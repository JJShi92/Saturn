diff -Naur sniper-6.1_old/common/misc/stats.cc sniper-6.1/common/misc/stats.cc
--- sniper-6.1_old/common/misc/stats.cc	2015-03-24 16:56:51.000000000 +0100
+++ sniper-6.1/common/misc/stats.cc	2017-08-01 14:34:53.232034000 +0200
@@ -12,11 +12,20 @@
 #include <cstring>
 #include <zlib.h>
 #include <sys/time.h>
+#include <fstream>
+#include <sstream>
 
 template <> UInt64 makeStatsValue<UInt64>(UInt64 t) { return t; }
 template <> UInt64 makeStatsValue<SubsecondTime>(SubsecondTime t) { return t.getFS(); }
 template <> UInt64 makeStatsValue<ComponentTime>(ComponentTime t) { return t.getElapsedTime().getFS(); }
 
+std::vector<double> applicationStartTime;
+std::vector<UInt64> applicationStartTimeId;
+std::vector<bool> applicationFinished;
+extern std::ofstream outputThroughputTrace;
+extern bool saveOutputThroughputTrace;
+
+
 const char* db_create_stmts[] = {
    // Statistics
    "CREATE TABLE `names` (nameid INTEGER, objectname TEXT, metricname TEXT);",
@@ -232,6 +241,61 @@
    int res = sqlite3_step(stmt);
    LOG_ASSERT_ERROR(res == SQLITE_DONE, "Error executing SQL statement: %s", sqlite3_errmsg(m_db));
    sqlite3_finalize(stmt);
+
+
+   // Instead of using the dumpstasts.py script to find out the total execution time of applications, we create our own log.
+   // The output file stream is outputThroughputTrace, and there we write the total execution time of applications
+   // (from beginning of first master thread, to the end of the very last thread, ignoring any ROI directives).
+   // Namely, in function StatsManager::logEvent, we track the event StatsManager::EVENT_APP_START and StatsManager::EVENT_APP_EXIT.
+   // We have a couple of vectors aiding in this. Vector applicationStartTimeId keeps track of the ID of executed
+   // applications, and we use the index of the vector with a specific ID to refer to the other auxiliary vectors.
+   // Vector applicationStartTime stores the actual start time of an application, and applicationFinished stores
+   // a boolean value stating whether the application has already finished or not (note that finished applications
+   // are not removed from Sniper's application list).
+   // With the use of these vectors, we can now compute the total execution time of an application when it finishes.
+   if(event == StatsManager::EVENT_APP_START){
+       // When we find event StatsManager::EVENT_APP_START, we search for this application ID inside vector applicationStartTimeId.
+	   int appIndex = -1;
+	   for(unsigned int appIndexAux = 0; appIndexAux < applicationStartTimeId.size(); appIndexAux++){
+		   if(applicationStartTimeId[appIndexAux] == value0){
+			   appIndex = appIndexAux;
+			   break;
+		   }
+	   }
+
+       // If the application ID didn't exist in the vector, then we add the application to all three auxiliary
+       // vectors, including the current time as the starting time of the application.
+	   if(appIndex < 0){
+		   applicationStartTimeId.push_back(value0);
+		   applicationStartTime.push_back(((double)time.getFS()) * 1e-15);
+		   applicationFinished.push_back(false);
+	   }
+       // We should not be receiving this event for an application that has already started, but in case we do,
+       // we simply update the start time of the application with the current time.
+	   else{
+		   applicationStartTime[appIndex] = ((double)time.getFS()) * 1e-15;
+	   }
+   }
+   else if(event == StatsManager::EVENT_APP_EXIT){
+       // When we find event StatsManager::EVENT_APP_EXIT, we search for this application ID inside vector applicationStartTimeId.
+	   int appIndex = -1;
+	   for(unsigned int appIndexAux = 0; appIndexAux < applicationStartTimeId.size(); appIndexAux++){
+		   if(applicationStartTimeId[appIndexAux] == value0){
+			   appIndex = appIndexAux;
+			   break;
+		   }
+	   }
+
+       // The application ID should normally already exist in the vector (otherwise we ignore the event), and
+       // we write to file stream outputThroughputTrace the application ID and the total execution time of the
+       // application as the different between the current time and the time at which the application started.
+	   if(appIndex >= 0){
+		   applicationFinished[appIndex] = true;
+		   if(saveOutputThroughputTrace){
+			   outputThroughputTrace << "Application:\t" << applicationStartTimeId[appIndex] << "\tExecutionTime:\t" << ((double)time.getFS()) * 1e-15 - applicationStartTime[appIndex] << std::endl;
+		   }
+	   }
+   }
 }
 
 StatHist &
diff -Naur sniper-6.1_old/common/scheduler/configurationParameters.cc sniper-6.1/common/scheduler/configurationParameters.cc
--- sniper-6.1_old/common/scheduler/configurationParameters.cc	1970-01-01 01:00:00.000000000 +0100
+++ sniper-6.1/common/scheduler/configurationParameters.cc	2017-08-01 14:34:53.612035000 +0200
@@ -0,0 +1,523 @@
+/**	\file	configurationParameters.cpp
+ *	\brief	Source file for general configuration parameters.
+ */
+
+#include "configurationParameters.h"
+
+
+
+
+ConfigurationParameters::ConfigurationParameters()
+{
+	// Set initial values for variables
+	runMcPAT = false;
+	Tamb = 45 + T_KELVIN;
+	Tinit = 60 + T_KELVIN;
+	Tdtm = 80 + T_KELVIN;
+	dtmEnabled = false;
+	Pmax = 250;
+	samplingInterval = 0.1e-3;
+	startTrace = 1;
+	simpleModel = false;
+	PinactiveCore = 0;
+	detailedSimulations = false;
+	inputApplicationTraceIsFile = true;
+	schedulingAlgorithm = 0;
+	coresPerIsland = 1;
+	schedulerAppRunning = false;
+}
+
+
+
+
+void ConfigurationParameters::readConfigurationFile(void)
+{
+	fileNameConfiguration = "/home/santiago/Documentos/Saturn/sniper/saturn.config";
+
+	if(fileNameConfiguration.size() > 0){
+		ifstream inputConfigFile(fileNameConfiguration.c_str());
+		if ( inputConfigFile.is_open() ){
+			if(inputConfigFile.good()){
+				// Read until the end of the file
+				while(inputConfigFile.good()){
+					// Read one line from the file
+					string line;
+					getline(inputConfigFile, line);
+
+					// If the line was successfully read
+					if(inputConfigFile.good()){
+						stringstream lineStream(line);
+						Parameter newParameter;
+						lineStream >> newParameter.name;
+
+						// If the line had a parameter
+						if(newParameter.name.size() > 0){
+							if(newParameter.name[0] == '-'){
+								newParameter.name.erase(0,1);
+								lineStream >> newParameter.value;
+
+								// If valid, add the configuration parameter to the list
+								if(addNewParameter(newParameter, false) == false){
+									inputConfigFile.close();
+									exit(1);
+								}
+							}
+						}
+					}
+				}
+			}
+			else{
+				cout << "Error: Configuration file could not be open for reading." << endl;
+				inputConfigFile.close();
+				exit(-1);
+			}
+			inputConfigFile.close();
+		}
+		else{
+			cout << "Error: Configuration file could not be open for reading." << endl;
+			exit(-1);
+		}
+	}
+}
+
+
+
+
+bool ConfigurationParameters::verify(void)
+{
+	if(Tamb < 0){
+		cout << "Error: The ambient temperature cannot be a negative value." << endl;
+		return false;
+	}
+
+	if(Tdtm < 0){
+		cout << "Error: The temperature for triggering DTM cannot be a negative value." << endl;
+		return false;
+	}
+
+	if(Pmax < 0){
+		cout << "Error: The maximum chip power cannot be a negative value." << endl;
+		return false;
+	}
+
+	if(fileNameConfigurationMatex.size() == 0){
+		cout << "Error: Required configuration file for MatEx missing." << endl;
+		exit(1);
+	}
+
+	if((fileNameFloorplan.size() == 0) && (fileNameEigenvaluesEigenvectorsIn.size() == 0)){
+		cout << "Error: Required floorplan or eigen data file missing." << endl;
+		exit(1);
+	}
+
+	return true;
+}
+
+
+
+
+
+
+void ConfigurationParameters::print(void)
+{
+	cout << "#Configuration Parameters:" << endl;
+	if(parameters.size() == 0){
+		cout << "\tNo configuration parameters" << endl;
+		return;
+	}
+	for(unsigned int i = 0; i < parameters.size(); i++){
+		cout << "\t" << parameters[i].name << ":\t" << parameters[i].value << endl;
+	}
+}
+
+
+
+void ConfigurationParameters::dumpToFile(const string &fileName)
+{
+	if(fileName.size() > 0){
+		ofstream dumpFile;
+		dumpFile.open (fileName.c_str());
+		if (dumpFile.is_open()){
+			for(unsigned int i = 0; i < parameters.size(); i++){
+				dumpFile << "\t-" << parameters[i].name << "\t\t" << parameters[i].value << endl;
+				if(dumpFile.good() == false){
+					cout << "Error: There was an error writing to the configuration dump file: \"" << fileName << "\"." << endl;
+					dumpFile.close();
+					exit(1);
+				}
+			}
+			dumpFile.close();
+		}
+		else{
+			cout << "Error: Configuration dump file: \"" << fileName << "\" could not be open for writing." << endl;
+			exit(1);
+		}
+	}
+}
+
+
+
+bool ConfigurationParameters::addNewParameter(const Parameter &newParameter, const bool &newHasPriority)
+{
+	if(newParameter.value.size() > 0){
+		// Check if the parameter is repeated.
+		int repeatedIndex = -1;
+		for(unsigned int existingParameter = 0; existingParameter < parameters.size(); existingParameter++){
+			if(newParameter.name == parameters[existingParameter].name)
+				repeatedIndex = existingParameter;
+		}
+
+		// If it is not repeated or the new one has priority, then we add the value to the configuration if it matches the type.
+		if((repeatedIndex < 0) || newHasPriority){
+
+			// Start with the configuration parameters that are names of files
+			if(newParameter.name == "appsIn"){
+				if(nullFileName(newParameter.value))
+					fileNameInputApplicationTrace = "";
+				else
+					fileNameInputApplicationTrace = newParameter.value;
+			}
+			else if(newParameter.name == "config"){
+				if(nullFileName(newParameter.value))
+					fileNameConfiguration = "";
+				else
+					fileNameConfiguration = newParameter.value;
+			}
+			else if(newParameter.name == "matexConfig"){
+				if(nullFileName(newParameter.value))
+					fileNameConfigurationMatex = "";
+				else
+					fileNameConfigurationMatex = newParameter.value;
+			}
+			else if(newParameter.name == "floorplan"){
+				if(nullFileName(newParameter.value))
+					fileNameFloorplan = "";
+				else
+					fileNameFloorplan = newParameter.value;
+			}
+			else if(newParameter.name == "eigen_in"){
+				if(nullFileName(newParameter.value))
+					fileNameEigenvaluesEigenvectorsIn = "";
+				else
+					fileNameEigenvaluesEigenvectorsIn = newParameter.value;
+			}
+			else if(newParameter.name == "eigen_out"){
+				if(nullFileName(newParameter.value))
+					fileNameEigenvaluesEigenvectorsOut = "";
+				else
+					fileNameEigenvaluesEigenvectorsOut = newParameter.value;
+			}
+			else if(newParameter.name == "coreTypes"){
+				if(nullFileName(newParameter.value))
+					fileNameCoreTypes = "";
+				else
+					fileNameCoreTypes = newParameter.value;
+			}
+			else if(newParameter.name == "dumpConf"){
+				if(nullFileName(newParameter.value))
+					fileNameDumpConfiguration = "";
+				else
+					fileNameDumpConfiguration = newParameter.value;
+			}
+			else if(newParameter.name == "dumpRawTraces"){
+				if(nullFileName(newParameter.value))
+					fileNameDumpCompressedRawTraces = "";
+				else
+					fileNameDumpCompressedRawTraces = newParameter.value;
+			}
+			else if(newParameter.name == "initTempFile"){
+				if(nullFileName(newParameter.value))
+					fileNameInputInitialTemperatures = "";
+				else
+					fileNameInputInitialTemperatures = newParameter.value;
+			}
+			else if(newParameter.name == "scheduleOut"){
+				if(nullFileName(newParameter.value))
+					fileNameOutputScheduleTrace = "";
+				else
+					fileNameOutputScheduleTrace = newParameter.value;
+			}
+			else if(newParameter.name == "frequencyOut"){
+				if(nullFileName(newParameter.value))
+					fileNameOutputFrequencyTrace = "";
+				else
+					fileNameOutputFrequencyTrace = newParameter.value;
+			}
+			else if(newParameter.name == "powerOut"){
+				if(nullFileName(newParameter.value))
+					fileNameOutputPowerTrace = "";
+				else
+					fileNameOutputPowerTrace = newParameter.value;
+			}
+			else if(newParameter.name == "energyOut"){
+				if(nullFileName(newParameter.value))
+					fileNameOutputEnergyTrace = "";
+				else
+					fileNameOutputEnergyTrace = newParameter.value;
+			}
+			else if(newParameter.name == "accEnergyOut"){
+				if(nullFileName(newParameter.value))
+					fileNameOutputAccumulatedEnergyTrace = "";
+				else
+					fileNameOutputAccumulatedEnergyTrace = newParameter.value;
+			}
+			else if(newParameter.name == "ipsOut"){
+				if(nullFileName(newParameter.value))
+					fileNameOutputIpsTrace = "";
+				else
+					fileNameOutputIpsTrace = newParameter.value;
+			}
+			else if(newParameter.name == "ipcOut"){
+				if(nullFileName(newParameter.value))
+					fileNameOutputIpcTrace = "";
+				else
+					fileNameOutputIpcTrace = newParameter.value;
+			}
+			else if(newParameter.name == "throughputOut"){
+				if(nullFileName(newParameter.value))
+					fileNameOutputThroughputTrace = "";
+				else
+					fileNameOutputThroughputTrace = newParameter.value;
+			}
+			else if(newParameter.name == "instOut"){
+				if(nullFileName(newParameter.value))
+					fileNameOutputInstructionsTrace = "";
+				else
+					fileNameOutputInstructionsTrace = newParameter.value;
+			}
+			else if(newParameter.name == "accInstOut"){
+				if(nullFileName(newParameter.value))
+					fileNameOutputAccumulatedInstructionsTrace = "";
+				else
+					fileNameOutputAccumulatedInstructionsTrace = newParameter.value;
+			}
+			else if(newParameter.name == "tempOut"){
+				if(nullFileName(newParameter.value))
+					fileNameOutputTransientTemperatures = "";
+				else
+					fileNameOutputTransientTemperatures = newParameter.value;
+			}
+			else if(newParameter.name == "maxTempOut"){
+				if(nullFileName(newParameter.value))
+					fileNameOutputMaximumTransientTemperatures = "";
+				else
+					fileNameOutputMaximumTransientTemperatures = newParameter.value;
+			}
+			else if(newParameter.name == "tracesTree"){
+				if(nullFileName(newParameter.value))
+					pathTracesMainTree = "";
+				else
+					pathTracesMainTree = newParameter.value;
+			}
+			else if(newParameter.name == "mcpatExecutable"){
+				if(nullFileName(newParameter.value))
+					mcpatExecutable = "";
+				else
+					mcpatExecutable = newParameter.value;
+			}
+			// Now we check for all the boolean variables
+			else if(newParameter.name == "detailedSimulations"){
+				if(newParameter.value == "0"){
+					detailedSimulations = false;
+				}
+				else if(newParameter.value == "1"){
+					detailedSimulations = true;
+				}
+				else{
+					cout << "Error: Value of parameter \"" << newParameter.name << "\" should be '0' or '1'" << endl;
+					return false;
+				}
+			}
+			else if(newParameter.name == "dtmEnabled"){
+				if(newParameter.value == "0"){
+					dtmEnabled = false;
+				}
+				else if(newParameter.value == "1"){
+					dtmEnabled = true;
+				}
+				else{
+					cout << "Error: Value of parameter \"" << newParameter.name << "\" should be '0' or '1'" << endl;
+					return false;
+				}
+			}
+			else if(newParameter.name == "inputApplicationTraceIsFile"){
+				if(newParameter.value == "0"){
+					inputApplicationTraceIsFile = false;
+				}
+				else if(newParameter.value == "1"){
+					inputApplicationTraceIsFile = true;
+				}
+				else{
+					cout << "Error: Value of parameter \"" << newParameter.name << "\" should be '0' or '1'" << endl;
+					return false;
+				}
+			}
+			else if(newParameter.name == "simpleModel"){
+				if(newParameter.value == "0"){
+					simpleModel = false;
+				}
+				else if(newParameter.value == "1"){
+					simpleModel = true;
+				}
+				else{
+					cout << "Error: Value of parameter \"" << newParameter.name << "\" should be '0' or '1'" << endl;
+					return false;
+				}
+			}
+			else if(newParameter.name == "runMcPAT"){
+				if(newParameter.value == "0"){
+					runMcPAT = false;
+				}
+				else if(newParameter.value == "1"){
+					runMcPAT = true;
+				}
+				else{
+					cout << "Error: Value of parameter \"" << newParameter.name << "\" should be '0' or '1'" << endl;
+					return false;
+				}
+			}
+			else if(newParameter.name == "schedulerAppRunning"){
+				if(newParameter.value == "0"){
+					schedulerAppRunning = false;
+				}
+				else if(newParameter.value == "1"){
+					schedulerAppRunning = true;
+				}
+				else{
+					cout << "Error: Value of parameter \"" << newParameter.name << "\" should be '0' or '1'" << endl;
+					return false;
+				}
+			}
+			// Now check the variables of type int
+			else if(newParameter.name == "startTrace"){
+				try{
+					int iValue;
+					stringstream streamValue(newParameter.value);
+					streamValue.exceptions(stringstream::goodbit);
+					streamValue >> iValue;
+					if((streamValue.rdstate() == stringstream::goodbit) || (streamValue.rdstate() == stringstream::eofbit)){
+						startTrace = iValue;
+					}
+					else{
+						cout << "Error: Value of parameter \"" << newParameter.name << "\" is invalid." << endl;
+						return false;
+					}
+				}
+				catch(...){
+					cout << "Error: Value of parameter \"" << newParameter.name << "\" is invalid." << endl;
+					return false;
+				}
+			}
+			else if(newParameter.name == "schedulingAlgorithm"){
+				try{
+					int iValue;
+					stringstream streamValue(newParameter.value);
+					streamValue.exceptions(stringstream::goodbit);
+					streamValue >> iValue;
+					if((streamValue.rdstate() == stringstream::goodbit) || (streamValue.rdstate() == stringstream::eofbit)){
+						schedulingAlgorithm = iValue;
+					}
+					else{
+						cout << "Error: Value of parameter \"" << newParameter.name << "\" is invalid." << endl;
+						return false;
+					}
+				}
+				catch(...){
+					cout << "Error: Value of parameter \"" << newParameter.name << "\" is invalid." << endl;
+					return false;
+				}
+			}
+			else if(newParameter.name == "coresPerIsland"){
+				try{
+					int iValue;
+					stringstream streamValue(newParameter.value);
+					streamValue.exceptions(stringstream::goodbit);
+					streamValue >> iValue;
+					if((streamValue.rdstate() == stringstream::goodbit) || (streamValue.rdstate() == stringstream::eofbit)){
+						coresPerIsland = iValue;
+					}
+					else{
+						cout << "Error: Value of parameter \"" << newParameter.name << "\" is invalid." << endl;
+						return false;
+					}
+				}
+				catch(...){
+					cout << "Error: Value of parameter \"" << newParameter.name << "\" is invalid." << endl;
+					return false;
+				}
+			}
+			else if(newParameter.name == "samplingInterval"){
+				try{
+					int iValue;
+					stringstream streamValue(newParameter.value);
+					streamValue.exceptions(stringstream::goodbit);
+					streamValue >> iValue;
+					if((streamValue.rdstate() == stringstream::goodbit) || (streamValue.rdstate() == stringstream::eofbit)){
+						samplingInterval = iValue;
+					}
+					else{
+						cout << "Error: Value of parameter \"" << newParameter.name << "\" is invalid." << endl;
+						return false;
+					}
+				}
+				catch(...){
+					cout << "Error: Value of parameter \"" << newParameter.name << "\" is invalid." << endl;
+					return false;
+				}
+			}
+			// Finally, we check all the variables of type double
+			else{
+				try{
+					double dValue;
+					stringstream streamValue(newParameter.value);
+					streamValue.exceptions(stringstream::goodbit);
+					streamValue >> dValue;
+					if(newParameter.name == "t_amb"){
+						Tamb = dValue + T_KELVIN;
+					}
+					else if(newParameter.name == "t_dtm"){
+						Tdtm = dValue + T_KELVIN;
+					}
+					else if(newParameter.name == "t_init"){
+						Tinit = dValue + T_KELVIN;
+					}
+					else if(newParameter.name == "p_max"){
+						Pmax = dValue;
+					}
+					else if(newParameter.name == "p_inactive"){
+						PinactiveCore = dValue;
+					}
+					else{
+						cout << "Error: \"" << newParameter.name << "\" is not a valid parameter. Please check usage." << endl;
+						return false;
+					}
+
+					if((streamValue.rdstate() != stringstream::goodbit) && (streamValue.rdstate() != stringstream::eofbit)){
+						cout << "Error: Value of parameter \"" << newParameter.name << "\" is invalid." << endl;
+						return false;
+					}
+				}
+				catch(...){
+					cout << "Error: Value of parameter \"" << newParameter.name << "\" is invalid." << endl;
+					return false;
+				}
+			}
+
+
+
+			// If it is not repeated, then we add it to the list
+			if(repeatedIndex < 0){
+				parameters.push_back(newParameter);
+			}
+			// If it is repeated and the first value has priority, then we replace it
+			else{
+				parameters[repeatedIndex] = newParameter;
+			}
+		}
+
+		return true;
+	}
+	else{
+		return false;
+	}
+}
diff -Naur sniper-6.1_old/common/scheduler/configurationParameters.h sniper-6.1/common/scheduler/configurationParameters.h
--- sniper-6.1_old/common/scheduler/configurationParameters.h	1970-01-01 01:00:00.000000000 +0100
+++ sniper-6.1/common/scheduler/configurationParameters.h	2017-08-01 14:34:53.612035000 +0200
@@ -0,0 +1,160 @@
+/**	\file	configurationParameters.h
+ *	\brief	Header file for general configuration parameters.
+ */
+#ifndef CONFIGURATIONPARAMETERS_H_
+#define CONFIGURATIONPARAMETERS_H_
+
+#include <iostream>
+#include <stdio.h>
+#include <stdlib.h>
+#include <algorithm>
+#include <unistd.h>
+#include <string.h>
+#include <vector>
+#include <string>
+#include <fstream>
+#include <sstream>
+#include <stdexcept>
+
+using namespace std;
+
+
+
+#ifndef T_KELVIN_H_
+#define T_KELVIN_H_
+const long double T_KELVIN = 273.15;
+#endif /* T_KELVIN_H_ */
+
+
+
+
+/**	\brief	Class that stores the configuration parameters.
+ *
+ *	Class that stores the configuration parameters from the configuration files or the command line. The command line has priority.
+ */
+class ConfigurationParameters{
+public:
+
+	/**	\brief	Structre with the definition pair of strings that forms a configuration parameter.	*/
+	struct Parameter {
+		string name;										/**< \brief Name of the configuration parameter.	*/
+		string value;										/**< \brief Value of the configuration parameter.	*/
+	};
+
+
+	/**	\brief	Vector containing all the configuration parameters.	*/
+	vector< Parameter > parameters;
+
+
+
+	/**	\brief	Method that parses the command line arguments.
+	 *
+	 *	\param[in]	argc	Number of command line arguments.
+	 *	\param[in]	argv	Strings with the command line arguments.
+	 */
+	void parseCommandLine(int argc, char *argv[]);
+
+
+
+	/**	\brief	Method that reads the configuration from the configuration file.
+	 *
+	 *	Method that reads the configuration from the configuration file. The configuration file must be passed as a command line argument.
+	 */
+	void readConfigurationFile(void);
+
+
+
+	/**	\brief	Method that verifies that the configuration parameters are valid.
+	 *
+	 */
+	bool verify(void);
+
+
+
+	/**	\brief	Method that prints the configuration parameters.
+	 */
+	void print(void);
+
+
+
+	/**	\brief	Method that saves the configuration parameters into a file.
+	 */
+	void dumpToFile(const string &fileName);
+
+
+
+
+	string fileNameFloorplan;								/**< \brief	Name of the floorplan file.	*/
+	string fileNameEigenvaluesEigenvectorsIn;				/**< \brief	Name of the input file with the eigenvalues and eigenvectors for the floorplan.	*/
+	string fileNameEigenvaluesEigenvectorsOut;				/**< \brief	Name of the output file with the eigenvalues and eigenvectors for the floorplan.	*/
+	string fileNameCoreTypes;								/**< \brief	Name of the core types file.	*/
+	string fileNameInputApplicationTrace;					/**< \brief	Name of the input application trace file.	*/
+	bool inputApplicationTraceIsFile;
+	string fileNameInputInitialTemperatures;				/**< \brief	Name of the input initial temperatures file.	*/
+	string fileNameOutputScheduleTrace;						/**< \brief	Name of the output schedule trace file.	*/
+	string fileNameOutputFrequencyTrace;					/**< \brief	Name of the output frequency trace file.	*/
+	string fileNameOutputPowerTrace;						/**< \brief	Name of the output power trace file.	*/
+	string fileNameOutputEnergyTrace;						/**< \brief	Name of the output energy trace file.	*/
+	string fileNameOutputAccumulatedEnergyTrace;			/**< \brief	Name of the output accumulated energy trace file.	*/
+	string fileNameOutputIpsTrace;							/**< \brief	Name of the output IPS trace file.	*/
+	string fileNameOutputIpcTrace;							/**< \brief	Name of the output IPS trace file.	*/
+	string fileNameOutputThroughputTrace;					/**< \brief	Name of the output Throughput trace file.	*/
+	string fileNameOutputInstructionsTrace;					/**< \brief	Name of the output instructions trace file.	*/
+	string fileNameOutputAccumulatedInstructionsTrace;		/**< \brief	Name of the output accumulated instructions trace file.	*/
+	string fileNameOutputTransientTemperatures;				/**< \brief	Name of the output file where the application stores the transient temperature results for the block model.	*/
+	string fileNameOutputMaximumTransientTemperatures;		/**< \brief	Name of the output file where the application stores the peaks in temperature for every change in power in the power trace file.	*/
+	string fileNameConfiguration;							/**< \brief	Name of the configuration file.	*/
+	string fileNameConfigurationMatex;						/**< \brief	Name of the configuration file for MatEx.	*/
+	string fileNameDumpConfiguration;						/**< \brief	Name of the dump configuration file.	*/
+	string fileNameDumpCompressedRawTraces;					/**< \brief	Name of the dump file with the compressed raw data information.	*/
+	string pathTracesMainTree;								/**< \brief	Path to the main tree of the traces (core types).	*/
+	string mcpatExecutable;									/**< \brief Path to the executable of McPAT, to run new McPAT simulations if necessary.	*/
+	bool runMcPAT;											/**< \brief	Indicates whether McPAT should be executed or not.	*/
+	double Tamb;											/**< \brief Ambient temperature [Kelvin].								*/
+	double Tdtm;											/**< \brief	Critical temperature in which DTM is triggered [Kelvin].	*/
+	bool dtmEnabled;
+	double Tinit;											/**< \brief	Initial temperature on all nodes [Kelvin].	*/
+	double Pmax;											/**< \brief	Maximum chip power [Watts].									*/
+	double PinactiveCore;									/**< \brief	Power consumption for an inactive core [Watts].				*/
+	unsigned long int samplingInterval;						/**< \brief Sampling interval for the output traces.					*/
+	int startTrace;											/**< \brief Number of trace from which to start parsing. Previous traces are ignored.	*/
+	bool simpleModel;										/**< \brief Type of model used in the traces.	*/
+	bool detailedSimulations;
+	int schedulingAlgorithm;
+	int coresPerIsland;
+	bool schedulerAppRunning;
+
+
+
+	/**	\brief	Constructor. Initializes all variables with the default values.	*/
+	ConfigurationParameters();
+
+private:
+	/**	\brief	Method that checks whether the value of the new parameter is valid.
+	 *
+	 *	\param[in]	newParameter		Name and value of the new parameter.
+	 *	\param[in]	newHasPriority		When the parameter name is repeated and variable is true, the new value replaces the old one. When this variable is false, the old value is preserved.
+	 *
+	 *	\return							True if the name is valid, false otherwise.
+	 */
+	bool addNewParameter(const Parameter &newParameter, const bool &newHasPriority);
+
+
+
+	/**	\brief	Return true if the string containing the file name is "(null)", "null", "(Null)", "Null", "(NULL)", or "NULL"	*/
+	inline bool nullFileName(const string &fileName) { return ((fileName == "(null)") || (fileName == "null") || (fileName == "(Null)") || (fileName == "Null") || (fileName == "(NULL)") || (fileName == "NULL")); }
+};
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif /* CONFIGURATIONPARAMETERS_H_ */
diff -Naur sniper-6.1_old/common/scheduler/floorplan.cc sniper-6.1/common/scheduler/floorplan.cc
--- sniper-6.1_old/common/scheduler/floorplan.cc	1970-01-01 01:00:00.000000000 +0100
+++ sniper-6.1/common/scheduler/floorplan.cc	2017-08-01 14:34:53.608035000 +0200
@@ -0,0 +1,505 @@
+/**	\file	floorplan.cpp
+ *	\brief	Source file for floorplan class.
+ */
+
+#include "floorplan.h"
+
+
+
+
+bool FunctionalUnit::load(const string &inputLine)
+{
+	try{
+		string unitName;
+		stringstream streamValue(inputLine);
+		streamValue.exceptions(stringstream::goodbit);
+
+		streamValue >> unitName;
+
+		if(unitName.size() > 0){
+			if(unitName[0] != '#'){
+				name = unitName;
+
+				streamValue >> width;
+				streamValue >> height;
+				streamValue >> left;
+				streamValue >> bottom;
+
+				// If the stream has no error, then the unit was properly read
+				if((streamValue.rdstate() == stringstream::goodbit) || (streamValue.rdstate() == stringstream::eofbit))
+					return true;
+				else
+					return false;
+			}
+		}
+
+		return false;
+	}
+	catch(...){
+		cout << "Error: Floorplan is invalid. Error found while reading line \"" << inputLine << "\"." << endl;
+		return false;
+	}
+}
+
+
+
+double FunctionalUnit::getArea(void)
+{
+	return width * height;
+}
+
+
+
+bool FunctionalUnit::isValid(void)
+{
+	if((width * height) > 0)
+		return true;
+	else
+		return false;
+}
+
+
+
+FunctionalUnit::FunctionalUnit()
+{
+	name = "";
+	width = 0;
+	height = 0;
+	left = 0;
+	bottom = 0;
+}
+
+
+
+
+
+
+
+
+
+bool WireDensityRaw::load(const string &inputLine)
+{
+	try{
+		string unitName;
+		double dValue;
+		stringstream streamValue(inputLine);
+		streamValue.exceptions(stringstream::goodbit);
+
+		streamValue >> unitName;
+
+		if(unitName.size() > 0){
+			if(unitName[0] != '#'){
+				nameFrom = unitName;
+
+				streamValue >> unitName;
+				nameTo = unitName;
+
+				streamValue >> dValue;
+				density = dValue;
+
+				// If the stream has no error, then the unit was properly read
+				if((streamValue.rdstate() == stringstream::goodbit) || (streamValue.rdstate() == stringstream::eofbit))
+					return true;
+				else
+					return false;
+			}
+		}
+
+		return false;
+	}
+	catch(...){
+		cout << "Error: Floorplan is invalid. Error found while reading line \"" << inputLine << "\"." << endl;
+		return false;
+	}
+}
+
+
+
+
+
+WireDensityRaw::WireDensityRaw()
+{
+	nameFrom = "";
+	nameTo = "";
+	density = 0;
+}
+
+
+
+
+
+
+
+
+
+bool Floorplan::readFloorplan(const string &floorplanFileName, bool const &readConnectivity)
+{
+	units.clear();
+
+	vector< WireDensityRaw > wireDensitiesRaw;
+
+	if(floorplanFileName.size() > 0){
+		ifstream inputFloorplanFile(floorplanFileName.c_str());
+		if ( inputFloorplanFile.is_open() ){
+			if(inputFloorplanFile.good()){
+
+				// Read until the end of the file
+				while(inputFloorplanFile.good()){
+					// Read one line from the file
+					string line;
+					getline(inputFloorplanFile, line);
+
+					// If the line was successfully read
+					if(inputFloorplanFile.good()){
+						// If the line is not a comment
+						if(line.size() > 0){
+							if(line[0] != '#'){
+								FunctionalUnit auxFunctionalUnit;
+								if(auxFunctionalUnit.load(line)){
+									units.push_back(auxFunctionalUnit);
+								}
+								else{
+									WireDensityRaw auxWireDensity;
+									if(auxWireDensity.load(line)){
+										if(readConnectivity)
+											wireDensitiesRaw.push_back(auxWireDensity);
+									}
+									else{
+										cout << "Error: Floorplan is invalid. Error found while reading line \"" << line << "\"." << endl;
+										exit(1);
+									}
+								}
+							}
+						}
+					}
+				}
+				// The floorplan file is read, so close it
+				inputFloorplanFile.close();
+
+
+				// Once the file was complete read, we fill the matrix with the wire densities
+				// If there was no wire density information in the floorplan, we take the default density of 1.
+				if((readConnectivity == true) && (wireDensitiesRaw.size() > 0)){
+					// We start with a zero wire density among every block
+
+					vector<double> emptyRow;
+					for(unsigned int i = 0; i < units.size(); i++)
+						emptyRow.push_back(0);
+					for(unsigned int i = 0; i < units.size(); i++)
+						wireDensities.push_back(emptyRow);
+
+					for(unsigned int i = 0; i < wireDensitiesRaw.size(); i++){
+						int indexFrom = getBlockIndex(wireDensitiesRaw[i].nameFrom);
+						int indexTo = getBlockIndex(wireDensitiesRaw[i].nameTo);
+
+						if((indexFrom >= 0) && ((indexTo >= 0))){
+							if(indexFrom == indexTo){
+								cout << "Error: Floorplan is invalid. Block \"" << wireDensitiesRaw[i].nameFrom << "\" is connected to itself." << endl;
+								exit(1);
+							}
+
+							// For the floorplan to be valid, the wire density from A->B has to be the same as for B->A. Therefore, the floorplan only needs wire densities from A->B to be specified.
+							// If wire densities from B->A are also specified, they must match the previous values, or the floorplan is considered as invalid.
+							if((wireDensities[indexFrom][indexTo] == 0) && (wireDensities[indexTo][indexFrom] == 0)){
+								wireDensities[indexFrom][indexTo] = wireDensitiesRaw[i].density;
+								wireDensities[indexTo][indexFrom] = wireDensitiesRaw[i].density;
+							}
+							else if((wireDensities[indexFrom][indexTo] != wireDensitiesRaw[i].density) || (wireDensities[indexTo][indexFrom] != wireDensitiesRaw[i].density)){
+								cout << "Error: Floorplan is invalid. Connectivity information from block \"" << wireDensitiesRaw[i].nameFrom << "\" to block \"" << wireDensitiesRaw[i].nameTo << "\" is different than from block \"" << wireDensitiesRaw[i].nameTo << "\" to block \"" << wireDensitiesRaw[i].nameFrom << "\"." << endl;
+								exit(1);
+							}
+						}
+						else{
+							if(indexFrom < 0)
+								cout << "Error: Floorplan is invalid. Block \"" << wireDensitiesRaw[i].nameFrom << "\" is not a valid block and it cannot be connected to block \"" << wireDensitiesRaw[i].nameTo << "\"." << endl;
+							if(indexTo < 0)
+								cout << "Error: Floorplan is invalid. Block \"" << wireDensitiesRaw[i].nameTo << "\" is not a valid block and it cannot be connected to block \"" << wireDensitiesRaw[i].nameFrom << "\"." << endl;
+							exit(1);
+						}
+					}
+				}
+				else{
+					vector<double> constantRow;
+					for(unsigned int i = 0; i < units.size(); i++)
+						constantRow.push_back(1.0);
+					for(unsigned int i = 0; i < units.size(); i++)
+						wireDensities.push_back(constantRow);
+				}
+
+				// Finally, we translate the floorplan to the origin (0,0), if it was not already the case
+				translate(0,0);
+
+				if(units.size() > 0)
+					return true;
+				else
+					return false;
+			}
+			else{
+				cout << "Error: Floorplan file could not be open for reading." << endl;
+				inputFloorplanFile.close();
+				exit(1);
+			}
+		}
+		else{
+			cout << "Error: Floorplan file could not be open for reading." << endl;
+			exit(1);
+		}
+	}
+	else{
+		cout << "Error: Required floorplan file missing." << endl;
+		exit(1);
+	}
+}
+
+
+
+
+
+
+
+
+int Floorplan::getBlockIndex(const string &blockName)
+{
+	for(unsigned int i = 0; i < units.size(); i++){
+		if(blockName == units[i].name)
+			return (int)i;
+	}
+
+	return -1;
+}
+
+
+
+
+
+
+
+void Floorplan::translate(const double &newLeftFloorplan, const double &newBottomFloorplan)
+{
+	if(units.size() > 0){
+		double leftMostCoordinate = units[0].left;
+		double bottomMostCoordinate = units[0].bottom;
+
+		for(unsigned int i = 1; i < units.size(); i++){
+			if(leftMostCoordinate > units[i].left)
+				leftMostCoordinate = units[i].left;
+			if(bottomMostCoordinate > units[i].bottom)
+				bottomMostCoordinate = units[i].bottom;
+		}
+
+		if(leftMostCoordinate != newLeftFloorplan){
+			for(unsigned int i = 0; i < units.size(); i++){
+				units[i].left +=  newLeftFloorplan - leftMostCoordinate;
+			}
+		}
+
+		if(bottomMostCoordinate != newBottomFloorplan){
+			for(unsigned int i = 0; i < units.size(); i++){
+				units[i].bottom +=  newBottomFloorplan - bottomMostCoordinate;
+			}
+		}
+	}
+}
+
+
+
+
+
+double Floorplan::getWidth(void)
+{
+	if(units.size() > 0){
+		double leftMostCoordinate = units[0].left;
+		double rightMostCoordinate = units[0].left + units[0].width;
+
+		for(unsigned int i = 1; i < units.size(); i++){
+			if(leftMostCoordinate > units[i].left)
+				leftMostCoordinate = units[i].left;
+			if(rightMostCoordinate < (units[i].left + units[i].width))
+				rightMostCoordinate = units[i].left + units[i].width;
+		}
+
+		return rightMostCoordinate - leftMostCoordinate;
+	}
+	else
+		return 0;
+}
+
+
+
+double Floorplan::getHeight(void)
+{
+	if(units.size() > 0){
+		double bottomMostCoordinate = units[0].bottom;
+		double topMostCoordinate = units[0].bottom + units[0].height;
+
+		for(unsigned int i = 1; i < units.size(); i++){
+			if(bottomMostCoordinate > units[i].bottom)
+				bottomMostCoordinate = units[i].bottom;
+			if(topMostCoordinate < (units[i].bottom + units[i].height))
+				topMostCoordinate = units[i].bottom + units[i].height;
+		}
+
+		return topMostCoordinate - bottomMostCoordinate;
+	}
+	else
+		return 0;
+}
+
+
+
+
+
+double Floorplan::getSharedLength(const int &unitA, const int &unitB)
+{
+	if( (unitA == unitB) ||
+		(unitA < 0) ||
+		(unitB < 0) ||
+		(unitA >= (int)units.size()) ||
+		(unitB >= (int)units.size())){
+		return 0;
+	}
+
+	double p11, p12, p21, p22;
+	p11 = p12 = p21 = p22 = 0.0;
+
+
+	if (isHorizontalAdjacent(unitA, unitB)) {
+		p11 = units[unitA].bottom;
+		p12 = p11 + units[unitA].height;
+		p21 = units[unitB].bottom;
+		p22 = p21 + units[unitB].height;
+	}
+
+	if (isVerticallyAdjacent(unitA, unitB)) {
+		p11 = units[unitA].left;
+		p12 = p11 + units[unitA].width;
+		p21 = units[unitB].left;
+		p22 = p21 + units[unitB].width;
+	}
+
+	return (minimum(p12, p22) - maximum(p11, p21));
+}
+
+
+
+
+
+
+
+
+
+
+bool Floorplan::isHorizontalAdjacent(const int &unitA, const int &unitB)
+{
+	if( (unitA == unitB) ||
+		(unitA < 0) ||
+		(unitB < 0) ||
+		(unitA >= (int)units.size()) ||
+		(unitB >= (int)units.size())){
+		return false;
+	}
+
+	double x1, x2, x3, x4;
+	double y1, y2, y3, y4;
+
+	x1 = units[unitA].left;
+	x2 = x1 + units[unitA].width;
+	x3 = units[unitB].left;
+	x4 = x3 + units[unitB].width;
+
+	y1 = units[unitA].bottom;
+	y2 = y1 + units[unitA].height;
+	y3 = units[unitB].bottom;
+	y4 = y3 + units[unitB].height;
+
+	/* diagonally adjacent => not adjacent */
+	if (equalTo(x2,x3) && equalTo(y2,y3))
+		return false;
+	if (equalTo(x1,x4) && equalTo(y1,y4))
+		return false;
+	if (equalTo(x2,x3) && equalTo(y1,y4))
+		return false;
+	if (equalTo(x1,x4) && equalTo(y2,y3))
+		return false;
+
+	if (equalTo(x1,x4) || equalTo(x2,x3))
+		if ((y3 >= y1 && y3 <= y2) || (y4 >= y1 && y4 <= y2) ||
+		    (y1 >= y3 && y1 <= y4) || (y2 >= y3 && y2 <= y4))
+			return true;
+
+	return false;
+}
+
+
+
+
+bool Floorplan::isVerticallyAdjacent(const int &unitA, const int &unitB)
+{
+	if( (unitA == unitB) ||
+		(unitA < 0) ||
+		(unitB < 0) ||
+		(unitA >= (int)units.size()) ||
+		(unitB >= (int)units.size())){
+		return false;
+	}
+
+	double x1, x2, x3, x4;
+	double y1, y2, y3, y4;
+
+	x1 = units[unitA].left;
+	x2 = x1 + units[unitA].width;
+	x3 = units[unitB].left;
+	x4 = x3 + units[unitB].width;
+
+	y1 = units[unitA].bottom;
+	y2 = y1 + units[unitA].height;
+	y3 = units[unitB].bottom;
+	y4 = y3 + units[unitB].height;
+
+	/* diagonally adjacent => not adjacent */
+	if (equalTo(x2,x3) && equalTo(y2,y3))
+		return false;
+	if (equalTo(x1,x4) && equalTo(y1,y4))
+		return false;
+	if (equalTo(x2,x3) && equalTo(y1,y4))
+		return false;
+	if (equalTo(x1,x4) && equalTo(y2,y3))
+		return false;
+
+	if (equalTo(y1,y4) || equalTo(y2,y3))
+		if ((x3 >= x1 && x3 <= x2) || (x4 >= x1 && x4 <= x2) ||
+		    (x1 >= x3 && x1 <= x4) || (x2 >= x3 && x2 <= x4))
+			return true;
+
+	return false;
+}
+
+
+
+
+
+void Floorplan::print(void)
+{
+	cout << "#Floorplan information:" << endl;
+	if(units.size() == 0){
+		cout << "\tNo functional units in the floorplan" << endl;
+	}
+	else{
+		cout << "#Functional Units:" << endl;
+		cout << "#Unit\tArea\tWidth\tHeight\tLeft\tBottom\tRight\tTop:" << endl;
+		for(unsigned int i = 0; i < units.size(); i++){
+			cout << "\t" << units[i].name << "\t\t" << units[i].width << "\t\t" << units[i].height << "\t\t" << units[i].left << "\t\t" << units[i].bottom << "\t\t" << units[i].left + units[i].width << "\t\t" << units[i].bottom + units[i].height << endl;
+		}
+
+		cout << "#Connectivity information:" << endl;
+		for(unsigned int i = 0; i < wireDensities.size(); i++){
+			for(unsigned int j = 0; j < wireDensities[i].size(); j++){
+				cout << "\tFrom:" << i+1 << "\tTo:" << j+1 << "\tDensity:" << wireDensities[i][j] << endl;
+			}
+		}
+	}
+}
+
+
+
+
diff -Naur sniper-6.1_old/common/scheduler/floorplan.h sniper-6.1/common/scheduler/floorplan.h
--- sniper-6.1_old/common/scheduler/floorplan.h	1970-01-01 01:00:00.000000000 +0100
+++ sniper-6.1/common/scheduler/floorplan.h	2017-08-01 14:34:53.612035000 +0200
@@ -0,0 +1,310 @@
+/**	\file	floorplan.h
+ *	\brief	Header file for floorplan class.
+ */
+#ifndef FLOORPLAN_H_
+#define FLOORPLAN_H_
+
+#include <iostream>
+#include <stdio.h>
+#include <stdlib.h>
+#include <algorithm>
+#include <unistd.h>
+#include <string.h>
+#include <vector>
+#include <string>
+#include <fstream>
+#include <sstream>
+#include <stdexcept>
+#include <Eigen/Dense>
+
+using namespace std;
+using namespace Eigen;
+
+
+/**	\brief	Number of functional block layers.	*/
+
+#define NUMBER_BLOCK_LAYERS		4
+/**	\brief	Silicon layer index.		*/
+#define SILICON		0
+/**	\brief	Interface layer index (silicon is always layer 0).		*/
+#define IFACE	1
+/**	\brief	Heat spreader layer index.	*/
+#define HSP	2
+/**	\brief	Heat sink layer index.		*/
+#define HSINK 3
+/**	\brief	Ambient nodes layer index.		*/
+#define AMBIENT_NODES 4
+
+/**	\brief	Number of extra nodes due to the model: 4 spreader nodes, 4 heat sink nodes under the spreader (center),
+ *			4 peripheral heat sink nodes (north, south, east and west) and a separate node for the ambient.
+ */
+#define EXTRA_NODES				12
+#define	SP_W		0						/**< \brief	Spreader nodes.		*/
+#define	SP_E		1						/**< \brief	Spreader nodes.		*/
+#define	SP_N		2						/**< \brief	Spreader nodes.		*/
+#define	SP_S		3						/**< \brief	Spreader nodes.		*/
+#define SINK_C_W	4						/**< \brief	Central sink nodes (directly under the spreader).		*/
+#define SINK_C_E	5						/**< \brief	Central sink nodes (directly under the spreader).		*/
+#define SINK_C_N	6						/**< \brief	Central sink nodes (directly under the spreader).		*/
+#define SINK_C_S	7						/**< \brief	Central sink nodes (directly under the spreader).		*/
+#define	SINK_W		8						/**< \brief	Peripheral sink nodes.		*/
+#define	SINK_E		9						/**< \brief	Peripheral sink nodes.		*/
+#define	SINK_N		10						/**< \brief	Peripheral sink nodes.		*/
+#define	SINK_S		11						/**< \brief	Peripheral sink nodes.		*/
+
+/**	\brief	Secondary extra nodes.		*/
+#define EXTRA_SECONDARY_NODES		16
+#define	SUB_W		12						/**< \brief	Package substrate nodes.		*/
+#define	SUB_E		13						/**< \brief	Package substrate nodes.		*/
+#define	SUB_N		14						/**< \brief	Package substrate nodes.		*/
+#define	SUB_S		15						/**< \brief	Package substrate nodes.		*/
+#define	SOLDER_W		16					/**< \brief	Solder ball nodes.		*/
+#define	SOLDER_E		17					/**< \brief	Solder ball nodes.		*/
+#define	SOLDER_N		18					/**< \brief	Solder ball nodes.		*/
+#define	SOLDER_S		19					/**< \brief	Solder ball nodes.		*/
+#define PCB_C_W	20							/**< \brief	Central PCB nodes (directly under the solder balls).		*/
+#define PCB_C_E	21							/**< \brief	Central PCB nodes (directly under the solder balls).		*/
+#define PCB_C_N	22							/**< \brief	Central PCB nodes (directly under the solder balls).		*/
+#define PCB_C_S	23							/**< \brief	Central PCB nodes (directly under the solder balls).		*/
+#define	PCB_W		24						/**< \brief	Peripheral PCB nodes.		*/
+#define	PCB_E		25						/**< \brief	Peripheral PCB nodes.		*/
+#define	PCB_N		26						/**< \brief	Peripheral PCB nodes.		*/
+#define	PCB_S		27						/**< \brief	Peripheral PCB nodes.		*/
+
+
+/**	\brief	Comparison margin to decide if two values are equal.		*/
+#define DELTA_EQUAL			1.0e-6
+
+
+
+
+
+
+
+/**	\brief	Class for a functional unit.
+ *
+ *	Class for a functional unit.
+ */
+class FunctionalUnit{
+public:
+	string name;							/**< \brief	Name of the functional unit.	*/
+	double width;							/**< \brief	Width of the functional unit [meters].	*/
+	double height;							/**< \brief	Height of the functional unit [meters].	*/
+	double left;							/**< \brief	Left (x) coordinate of the functional unit [meters].	*/
+	double bottom;							/**< \brief	Bottom (y) coordinate of the functional unit [meters].	*/
+
+
+	/**	\brief	Method that parses the line and loads the functional unit from the information in the line, if the line is valid
+	 *
+	 *	\param[in]	inputLine		String with the line read from the file with the information of a functional unit.
+	 *	\return						True if the line was successfully parsed.
+	 */
+	bool load(const string &inputLine);
+
+
+	/**	\brief	Method that returns the area of the functional unit.
+	 *
+	 *	\return						Area of the functional unit.
+	 */
+	double getArea(void);
+
+
+	/**	\brief	Method that returns whether the functional unit is valid or not.
+	 *
+	 *	\return						True if the area of the functional unit is larger than zero.
+	 */
+	bool isValid(void);
+
+
+
+	/**	\brief	Constructor. Initializes the unit with area zero.
+	 *
+	 */
+	FunctionalUnit();
+};
+
+
+
+
+
+
+
+
+
+/**	\brief	Class for the wire density between functional units.
+ *
+ *	Class for the wire density between functional units.
+ */
+class WireDensityRaw{
+public:
+	string nameFrom;						/**< \brief	Name of one of the functional units.	*/
+	string nameTo;							/**< \brief	Name of one of the functional units.	*/
+	double density;							/**< \brief	Wire density between functional unit.	*/
+
+
+	/**	\brief	Method that parses the line and loads the wire density unit from the information in the line, if the line is valid
+	 *
+	 *	\param[in]	inputLine		String with the line read from the file with the information of the wire density between functional units.
+	 *	\return						True if the line was successfully parsed.
+	 */
+	bool load(const string &inputLine);
+
+
+
+	/**	\brief	Constructor. Initializes the unit with wire density zero.
+	 *
+	 */
+	WireDensityRaw();
+};
+
+
+
+
+
+
+
+
+
+
+
+
+/**	\brief	Class that stores the floorplan.
+ *
+ *	Class that stores the floorplan.
+ */
+class Floorplan{
+public:
+	/**	\brief	Vector with the functional units.
+	 */
+	vector< FunctionalUnit > units;
+
+
+	/**	\brief	Matrix with the wire densities between functional units.
+	 */
+	vector< vector<double> > wireDensities;
+
+
+	/**	\brief	Method that reads the functional units from a file and loads this information into vector units.
+	 *
+	 *	\return						True if the floorplan was correctly read.
+	 */
+	bool readFloorplan(const string &floorplanFileName, bool const &readConnectivity);
+
+
+
+	/**	\brief	Get the total width of the floorplan.
+	 *
+	 *	\return		Total width of the floorplan.
+	 */
+	double getWidth(void);
+
+
+
+	/**	\brief	Get the total height of the floorplan.
+	 *
+	 *	\return		Total height of the floorplan.
+	 */
+	double getHeight(void);
+
+
+
+
+	/**	\brief	Method that prints the floorplan information.
+	 */
+	void print(void);
+
+
+
+	/**	\brief	Method that return the index of the block.
+	 *
+	 *	\param[in]	blockName			Name of the block.
+	 *	\return							Index of the block. -1 if the block does not exist.
+	 */
+	int getBlockIndex(const string &blockName);
+
+
+
+	/**	\brief	Method that returns the shared length between two functional units.
+	 *
+	 *	\return						Shared length between unitA and unitB.
+	 */
+	double getSharedLength(const int &unitA, const int &unitB);
+
+
+
+	/**	\brief	Method that returns true if two units are horizontally adjacent.
+	 *
+	 *	\return						True if unitA is horizontally adjacent to unitB.
+	 */
+	bool isHorizontalAdjacent(const int &unitA, const int &unitB);
+
+
+
+	/**	\brief	Method that returns true if two units are horizontally adjacent.
+	 *
+	 *	\return						True if unitA is horizontally adjacent to unitB.
+	 */
+	bool isVerticallyAdjacent(const int &unitA, const int &unitB);
+
+
+
+	/**	\brief	Method that returns the number of functional units in the floorplan.
+	 *
+	 */
+	inline unsigned int getNumberFunctionalUnits(void) { return units.size(); }
+
+
+
+	/**	\brief	Method that returns the number of thermal nodes resulting from the floorplan.
+	 *
+	 */
+	inline unsigned int getNumberThermalNodes(void) { return NUMBER_BLOCK_LAYERS*units.size() + EXTRA_NODES; }
+
+
+
+private:
+	/**	\brief	Method that translates the left-most and bottom-most coordinates of the entire floorplan.
+	 *
+	 *	\param[in]	newLeftFloorplan	New left-most coordinate.
+	 *	\param[in]	newBottomFloorplan	New bottom-most coordinate.
+	 */
+	void translate(const double &newLeftFloorplan, const double &newBottomFloorplan);
+
+	/**	\brief	Compares two values under a certain margin of error.
+	 *
+	 */
+	inline bool equalTo(const double &x, const double &y)
+	{
+		return (fabs(x-y) < DELTA_EQUAL);
+	}
+
+	/**	\brief	Compares two values and return the minimum value.
+	 *
+	 */
+	inline double minimum(const double &x, const double &y)
+	{
+		return ((x < y)? x:y);
+	}
+
+	/**	\brief	Compares two values and return the maximum value.
+	 *
+	 */
+	inline double maximum(const double &x, const double &y)
+	{
+		return ((x > y)? x:y);
+	}
+};
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif /* FLOORPLAN_H_ */
diff -Naur sniper-6.1_old/common/scheduler/Matex.cc sniper-6.1/common/scheduler/Matex.cc
--- sniper-6.1_old/common/scheduler/Matex.cc	1970-01-01 01:00:00.000000000 +0100
+++ sniper-6.1/common/scheduler/Matex.cc	2017-08-01 14:34:55.480037000 +0200
@@ -0,0 +1,1067 @@
+/**	\file	Matex.cpp
+ *	\brief	Source file for the Matex class implementation
+ */
+
+#include "Matex.h"
+
+
+
+
+Matex::Matex()
+{
+	// Set initial values for all variables
+	Binv = nullptr;
+	Gamb = nullptr;
+
+	Tamb = 45 + T_KELVIN;
+	numberThermalNodes = 0;
+	numberUnits = 0;
+	numberNodesAmbient = 0;
+	samplingInterval = 0.1e-3;
+
+	eigenValues = nullptr;
+	eigenVectors = nullptr;
+	eigenVectorsInv = nullptr;
+
+
+
+	multiplierH = nullptr;
+	HfunctionWithoutLambda = nullptr;
+	Hfunction = nullptr;
+	HfunctionSquaredLambda = nullptr;
+	auxHfunctionWithoutLambda = nullptr;
+
+	Tsteady = nullptr;
+	auxTsteady = nullptr;
+	Tdifference = nullptr;
+	exponentials = nullptr;
+	previousPower = nullptr;
+
+	heatContributionAmbient = nullptr;
+
+	previousTimePoint = 0;
+	preivousPointEqualPower = false;
+
+	firstPowerChange = true;
+}
+
+
+
+Matex::~Matex()
+{
+	// Delete dynamically assigned memory for the matrices and vectors
+	if(Binv != nullptr){
+		for(int i = 0; i < numberThermalNodes; i++){
+			if(Binv[i] != nullptr){
+				delete[] Binv[i];
+			}
+		}
+		delete[] Binv;
+	}
+
+
+	if(Gamb != nullptr){
+		delete[] Gamb;
+	}
+
+
+	if(eigenValues != nullptr){
+		delete[] eigenValues;
+	}
+
+
+	if(eigenVectors != nullptr){
+		for(int i = 0; i < numberThermalNodes; i++){
+			if(eigenVectors[i] != nullptr){
+				delete[] eigenVectors[i];
+			}
+		}
+		delete[] eigenVectors;
+	}
+
+	if(eigenVectorsInv != nullptr){
+		for(int i = 0; i < numberThermalNodes; i++){
+			if(eigenVectorsInv[i] != nullptr){
+				delete[] eigenVectorsInv[i];
+			}
+		}
+		delete[] eigenVectorsInv;
+	}
+
+
+	if(multiplierH != nullptr){
+		delete[] multiplierH;
+	}
+
+
+	if(HfunctionWithoutLambda != nullptr){
+		for(int i = 0; i < numberThermalNodes; i++){
+			if(HfunctionWithoutLambda[i] != nullptr){
+				delete[] HfunctionWithoutLambda[i];
+			}
+		}
+		delete[] HfunctionWithoutLambda;
+	}
+
+
+	if(Hfunction != nullptr){
+		for(int i = 0; i < numberThermalNodes; i++){
+			if(Hfunction[i] != nullptr){
+				delete[] Hfunction[i];
+			}
+		}
+		delete[] Hfunction;
+	}
+
+
+	if(HfunctionSquaredLambda != nullptr){
+		for(int i = 0; i < numberThermalNodes; i++){
+			if(HfunctionSquaredLambda[i] != nullptr){
+				delete[] HfunctionSquaredLambda[i];
+			}
+		}
+		delete[] HfunctionSquaredLambda;
+	}
+
+
+	if(auxHfunctionWithoutLambda != nullptr){
+		for(int i = 0; i < numberThermalNodes; i++){
+			if(auxHfunctionWithoutLambda[i] != nullptr){
+				delete[] auxHfunctionWithoutLambda[i];
+			}
+		}
+		delete[] auxHfunctionWithoutLambda;
+	}
+
+
+	if(Tsteady != nullptr){
+		delete[] Tsteady;
+	}
+
+	if(auxTsteady != nullptr){
+		delete[] auxTsteady;
+	}
+
+
+	if(Tdifference != nullptr){
+		delete[] Tdifference;
+	}
+
+
+	if(exponentials != nullptr){
+		delete[] exponentials;
+	}
+
+
+	if(previousPower != nullptr){
+		delete[] previousPower;
+	}
+
+
+	if(heatContributionAmbient != nullptr){
+		delete[] heatContributionAmbient;
+	}
+}
+
+
+
+
+bool Matex::load(ConfigurationParameters &generalConfigurationParameters)
+{
+	// Copy of the ambient temperature value in the configuration file
+	Tamb = generalConfigurationParameters.Tamb;
+
+	// Copy of the sampling interval value in the configuration file
+	samplingInterval = generalConfigurationParameters.samplingInterval;
+
+
+	cout << "SANTIAGO: Creating RC model object" << endl;
+
+	MatexConfigurationParameters matexConfigurationParameters;
+	RCmodel rcModel;
+
+	cout << "SANTIAGO: Reading MatEx configuration" << endl;
+	// Read the configuration
+	matexConfigurationParameters.readConfigurationFile(generalConfigurationParameters.fileNameConfigurationMatex);
+
+	cout << "SANTIAGO: Verifying MatEx configuration" << endl;
+	// Verify the configuration
+	if(matexConfigurationParameters.verify() == false){
+		cout << "Error: Matex's configuration file has some invalid parameters." << endl;
+		return false;
+	}
+
+	cout << "SANTIAGO: MatEx configuration ok" << endl;
+
+
+	// If there was an input file with the eigenvalues and eigenvectors, then we read it. In such a case, the floorplan is ignored and the data is directly read from the file.
+	// To speed up computation, this is a binary file.
+	if(generalConfigurationParameters.fileNameEigenvaluesEigenvectorsIn.size() > 0){
+		if(readEigenvaluesEigenvectorsFromFile(generalConfigurationParameters.fileNameEigenvaluesEigenvectorsIn) == false){
+			cout << "Error: There was an error reading the eigenvalues and eigenvectors information file." << endl;
+			return false;
+		}
+	}
+	else{
+		cout << "SANTIAGO: Reading floorplan" << endl;
+		// Read the floorplan from the floorplan file
+		if(floorplan.readFloorplan(generalConfigurationParameters.fileNameFloorplan, true) == false){
+			cout << "Error: There are no functional units in the floorplan." << endl;
+			return false;
+		}
+		numberUnits = floorplan.getNumberFunctionalUnits();
+		numberThermalNodes = floorplan.getNumberThermalNodes();
+
+		cout << "SANTIAGO: Floorplan ok with " << numberUnits << " units" << endl;
+
+
+		// Load the RC thermal network from the floorplan information
+		if(rcModel.load(matexConfigurationParameters, floorplan, true) == false){
+			cout << "Error: The RC thermal network could not be loaded." << endl;
+			return false;
+		}
+		numberNodesAmbient = rcModel.numberNodesAmbient;
+
+
+		cout << "SANTIAGO: RC model ok" << endl;
+
+
+		Binv = new double*[numberThermalNodes];
+		for(int i = 0; i < numberThermalNodes; i++){
+			Binv[i] = new double[numberThermalNodes];
+		}
+		for(int row = 0; row < numberThermalNodes; row++){
+			for(int column = 0; column < numberThermalNodes; column++){
+				Binv[row][column] = rcModel.Binv(row,column);
+			}
+		}
+
+		Gamb = new double[numberNodesAmbient];
+		for(int row = 0; row < numberNodesAmbient; row++){
+			Gamb[row] = rcModel.Gamb(row);
+		}
+
+
+
+
+		cout << "SANTIAGO: Computing eigenvalues" << endl;
+
+
+		/* Compute the eigenvalues and eigenvectors of matrix C in the RC thermal network.	*/
+		EigenSolver< Matrix<double, Dynamic, Dynamic> > es(rcModel.C);
+		Matrix<double, Dynamic, 1> eigenValuesAux = es.eigenvalues().real();
+		Matrix<double, Dynamic, Dynamic> eigenVectorsAux = es.eigenvectors().real();
+		Matrix<double, Dynamic, Dynamic> eigenVectorsInvAux = eigenVectorsAux.inverse();
+
+		cout << "SANTIAGO: Eigen values computed" << endl;
+
+		// Create eigenvalues and eigenvectors
+		eigenValues = new double[eigenValuesAux.rows()];
+		for(int i = 0; i < eigenValuesAux.rows(); i++){
+			eigenValues[i] = eigenValuesAux(i);
+		}
+
+		// Create eigenvalues and eigenvectors
+		eigenVectors = new double*[eigenVectorsAux.rows()];
+		for(int i = 0; i < eigenVectorsAux.rows(); i++){
+			eigenVectors[i] = new double[eigenVectorsAux.cols()];
+			for(int j = 0; j < eigenVectorsAux.cols(); j++){
+				eigenVectors[i][j] = eigenVectorsAux(i,j);
+			}
+		}
+
+		eigenVectorsInv = new double*[eigenVectorsAux.rows()];
+		for(int i = 0; i < eigenVectorsAux.rows(); i++){
+			eigenVectorsInv[i] = new double[eigenVectorsAux.cols()];
+			for(int j = 0; j < eigenVectorsAux.cols(); j++){
+				eigenVectorsInv[i][j] = eigenVectorsInvAux(i,j);
+			}
+		}
+
+
+		// Check that no eigenvalue is complex. If so, then the computation needs to be slightly changed. However, this should never happen for a valid RC thermal network.
+		for (int n = 0; n < es.eigenvalues().size(); n++){
+			if(abs(remainder(arg(es.eigenvalues()(n)),M_PI)) > 1e-12)
+				cout << "WARNING: Eigen value (" << n+1 << ") is complex: " << es.eigenvalues()(n) << endl;
+		}
+
+		cout << "SANTIAGO: Eigen values copied" << endl;
+	}
+
+
+	cout << "SANTIAGO: Saving Eigen file" << endl;
+
+	// If an output file for the eigenvalues and eigenvectors was specified, we save the information in the corresponding file
+	if(generalConfigurationParameters.fileNameEigenvaluesEigenvectorsOut.size() > 0){
+		if(saveEigenvaluesEigenvectorsToFile(generalConfigurationParameters.fileNameEigenvaluesEigenvectorsOut) == false){
+			cout << "Error: There was an error saving the eigenvalues and eigenvectors information file." << endl;
+			return false;
+		}
+	}
+
+
+	cout << "SANTIAGO: Eigen file saved" << endl;
+
+
+
+
+
+
+	// Reserve memory for the H functions that speed up the computation
+	multiplierH = new double[numberThermalNodes];
+	HfunctionWithoutLambda = new double*[numberThermalNodes];
+	Hfunction = new double*[numberThermalNodes];
+	HfunctionSquaredLambda = new double*[numberThermalNodes];
+	auxHfunctionWithoutLambda = new double*[numberThermalNodes];
+	for(int i = 0; i < numberThermalNodes; i++){
+		HfunctionWithoutLambda[i] = new double[numberThermalNodes];
+		Hfunction[i] = new double[numberThermalNodes];
+		HfunctionSquaredLambda[i] = new double[numberThermalNodes];
+		auxHfunctionWithoutLambda[i] = new double[numberThermalNodes];
+	}
+
+
+
+	// Reserve memory for the vectors used inside MatEx computation
+	Tsteady = new double[numberThermalNodes];
+	auxTsteady = new double[numberThermalNodes];
+	Tdifference = new double[numberThermalNodes];
+	exponentials = new double[numberThermalNodes];
+	previousPower = new double[numberUnits];
+	for(int i = 0; i < numberUnits; i++){
+		previousPower[i] = -1;
+	}
+
+
+
+
+
+
+	// Compute the heat contribution of the ambient temperature
+	heatContributionAmbient = new double[numberThermalNodes];
+	int offsetGamb = numberThermalNodes - numberNodesAmbient;
+	for(int i = 0; i < numberThermalNodes; i++){
+
+		heatContributionAmbient[i] = 0;
+		for(int j = 0; j < numberNodesAmbient; j++){
+			heatContributionAmbient[i] += Binv[i][j + offsetGamb]*Gamb[j];
+		}
+	}
+
+
+	cout << "SANTIAGO: Matex configuration read finished" << endl;
+
+	return true;
+}
+
+
+bool Matex::loadFloorplan(string &fileNameFloorplan)
+{
+	// Read the floorplan from the floorplan file
+	if(floorplan.readFloorplan(fileNameFloorplan, true) == false){
+		cout << "Error: There are no functional units in the floorplan." << endl;
+		return false;
+	}
+	numberUnits = floorplan.getNumberFunctionalUnits();
+	numberThermalNodes = floorplan.getNumberThermalNodes();
+
+	return true;
+}
+
+
+
+
+bool Matex::saveEigenvaluesEigenvectorsToFile(const string &fileName)
+{
+	if(fileName.size() > 0){
+		ofstream dumpFile;
+		dumpFile.open (fileName.c_str(), ios::out | ios::binary);
+		if (dumpFile.is_open()){
+
+			dumpFile.write((const char*)&numberUnits, sizeof(int));
+			dumpFile.write((const char*)&numberNodesAmbient, sizeof(int));
+			dumpFile.write((const char*)&numberThermalNodes, sizeof(int));
+
+			for(unsigned int unit = 0; unit < floorplan.getNumberFunctionalUnits(); unit++){
+				dumpFile << floorplan.units[unit].name << endl;
+				dumpFile.write((const char*)&floorplan.units[unit].width, sizeof(double));
+				dumpFile.write((const char*)&floorplan.units[unit].height, sizeof(double));
+			}
+
+			for(int row = 0; row < numberThermalNodes; row++){
+				for(int column = 0; column < numberThermalNodes; column++){
+					dumpFile.write((const char*)&Binv[row][column], sizeof(double));
+				}
+			}
+
+			for(int row = 0; row < numberNodesAmbient; row++){
+				dumpFile.write((const char*)&Gamb[row], sizeof(double));
+			}
+
+			for(int row = 0; row < numberThermalNodes; row++){
+				dumpFile.write((const char*)&eigenValues[row], sizeof(double));
+			}
+
+			for(int row = 0; row < numberThermalNodes; row++){
+				for(int column = 0; column < numberThermalNodes; column++){
+					dumpFile.write((const char*)&eigenVectors[row][column], sizeof(double));
+				}
+			}
+
+			for(int row = 0; row < numberThermalNodes; row++){
+				for(int column = 0; column < numberThermalNodes; column++){
+					dumpFile.write((const char*)&eigenVectorsInv[row][column], sizeof(double));
+				}
+			}
+
+			if(dumpFile.good() == false){
+				cout << "Error: There was an error writing to the eigenvalues and eigenvectors dump file: \"" << fileName << "\"." << endl;
+				dumpFile.close();
+				return false;
+			}
+
+			dumpFile.close();
+
+			return true;
+		}
+		else{
+			cout << "Error: Eigenvalues and eigenvectors dump file: \"" << fileName << "\" could not be open for writing." << endl;
+			return false;
+		}
+	}
+
+	return false;
+}
+
+
+
+
+
+bool Matex::readEigenvaluesEigenvectorsFromFile(const string &fileName)
+{
+	if(fileName.size() > 0){
+
+		FunctionalUnit auxFunctionalUnit;
+
+		ifstream inputEigenFile(fileName.c_str(), ios::in | ios::binary);
+		inputEigenFile.exceptions(stringstream::goodbit);
+		if ( inputEigenFile.is_open() ){
+			if(inputEigenFile.good()){
+				try{
+					inputEigenFile.read((char*)&numberUnits, sizeof(int));
+					if(numberUnits <= 0){
+						cout << "Error: file with the eigenvalues and eigenvectors information is invalid." << endl;
+						inputEigenFile.close();
+						return false;
+					}
+
+					inputEigenFile.read((char*)&numberNodesAmbient, sizeof(int));
+					if(numberNodesAmbient <= 0){
+						cout << "Error: file with the eigenvalues and eigenvectors information is invalid." << endl;
+						inputEigenFile.close();
+						return false;
+					}
+
+					inputEigenFile.read((char*)&numberThermalNodes, sizeof(int));
+					if(numberThermalNodes < numberUnits){
+						cout << "Error: file with the eigenvalues and eigenvectors information is invalid." << endl;
+						inputEigenFile.close();
+						return false;
+					}
+
+					for(int unit = 0; unit < numberUnits; unit++){
+						//inputEigenFile >> auxFunctionalUnit.name;
+						getline(inputEigenFile, auxFunctionalUnit.name);
+						if(inputEigenFile.rdstate() != stringstream::goodbit){
+							cout << "Error: file with the eigenvalues and eigenvectors information is invalid." << endl;
+							inputEigenFile.close();
+							return false;
+						}
+						inputEigenFile.read((char*)&auxFunctionalUnit.width, sizeof(auxFunctionalUnit.name));
+						if(auxFunctionalUnit.width <= 0){
+							cout << "Error: file with the eigenvalues and eigenvectors information is invalid." << endl;
+							inputEigenFile.close();
+							return false;
+						}
+						inputEigenFile.read((char*)&auxFunctionalUnit.height, sizeof(auxFunctionalUnit.name));
+						if(auxFunctionalUnit.height <= 0){
+							cout << "Error: file with the eigenvalues and eigenvectors information is invalid." << endl;
+							inputEigenFile.close();
+							return false;
+						}
+						floorplan.units.push_back(auxFunctionalUnit);
+					}
+
+					if((numberUnits != (int)floorplan.getNumberFunctionalUnits()) || (numberThermalNodes != (int)floorplan.getNumberThermalNodes())){
+						cout << "Error: file with the eigenvalues and eigenvectors information is invalid." << endl;
+						inputEigenFile.close();
+						return false;
+					}
+
+
+					Binv = new double*[numberThermalNodes];
+					for(int i = 0; i < numberThermalNodes; i++){
+						Binv[i] = new double[numberThermalNodes];
+					}
+					for(int row = 0; row < numberThermalNodes; row++){
+						for(int column = 0; column < numberThermalNodes; column++){
+							inputEigenFile.read((char*)&Binv[row][column], sizeof(double));
+						}
+					}
+
+					Gamb = new double[numberNodesAmbient];
+					for(int row = 0; row < numberNodesAmbient; row++){
+						inputEigenFile.read((char*)&Gamb[row], sizeof(double));
+					}
+
+					eigenValues = new double[numberThermalNodes];
+					for(int row = 0; row < numberThermalNodes; row++){
+						inputEigenFile.read((char*)&eigenValues[row], sizeof(double));
+					}
+
+					eigenVectors = new double*[numberThermalNodes];
+					for(int row = 0; row < numberThermalNodes; row++){
+						eigenVectors[row] = new double[numberThermalNodes];
+						for(int column = 0; column < numberThermalNodes; column++){
+							inputEigenFile.read((char*)&eigenVectors[row][column], sizeof(double));
+						}
+					}
+
+					eigenVectorsInv = new double*[numberThermalNodes];
+					for(int row = 0; row < numberThermalNodes; row++){
+						eigenVectorsInv[row] = new double[numberThermalNodes];
+						for(int column = 0; column < numberThermalNodes; column++){
+							inputEigenFile.read((char*)&eigenVectorsInv[row][column], sizeof(double));
+						}
+					}
+
+
+					// Verify that this and all previous values were successfully read
+					if(inputEigenFile.rdstate() != stringstream::goodbit){
+						cout << "Error: file with the eigenvalues and eigenvectors information is invalid." << endl;
+						inputEigenFile.close();
+						return false;
+					}
+
+
+					// Read one more byte to verify that the file ends here
+					char auxChar;
+					inputEigenFile.read((char*)&auxChar, sizeof(char));
+					if(inputEigenFile.rdstate() == stringstream::goodbit){
+						cout << "Error: file with the eigenvalues and eigenvectors information is invalid." << endl;
+						inputEigenFile.close();
+						return false;
+					}
+				}
+				catch(...){
+					cout << "Error: file with the eigenvalues and eigenvectors information is invalid." << endl;
+					inputEigenFile.close();
+					return false;
+				}
+			}
+			else{
+				cout << "Error: The file with the eigenvalues and eigenvectors information could not be open for reading." << endl;
+				inputEigenFile.close();
+				return false;
+			}
+		}
+		else{
+			cout << "Error: The file with the eigenvalues and eigenvectors information could not be open for reading." << endl;
+			return false;
+		}
+	}
+
+	return true;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+void Matex::computeTransientTemperatures(const double &newTimePoint, double* &Power, double* &Temperature)
+{
+	if(newTimePoint >= 0){
+		preivousPointEqualPower = true;
+		for(int i = 0; i < numberUnits; i++){
+			if(previousPower[i] != Power[i]){
+				preivousPointEqualPower = false;
+				break;
+			}
+		}
+
+		if(preivousPointEqualPower == false){
+
+
+			// For the first change in power, do nothing different
+			if(firstPowerChange){
+				firstPowerChange = false;
+			}
+			// For every change in power, first compute the new Tinit right before the power changed
+			else{
+				/* Compute all temperatures at the end of this trace. This is to later update Tinit		*/
+				double relativeTimePoint = newTimePoint - previousTimePoint;
+				for(int i = 0; i < numberThermalNodes; i++){
+					exponentials[i] = pow((double)M_E, eigenValues[i] * relativeTimePoint);
+				}
+
+				for(int k = 0; k < numberThermalNodes; k++){
+					double sumExponentials = 0;
+					for(int i = 0; i < numberThermalNodes; i++){
+						sumExponentials += exponentials[i] * HfunctionWithoutLambda[k][i];
+					}
+
+					Temperature[k] = Tsteady[k] + sumExponentials;
+				}
+			}
+			// No compute the new H for the change in power
+
+
+
+			// Compute the steady state temperature after the change in power
+			computeSteadyStateTemperatures(Power, Tsteady);
+
+			/* Compute the function H */
+			for(int j = 0; j < numberThermalNodes; j++){
+				Tdifference[j] = Temperature[j] - Tsteady[j];
+			}
+			//
+			for(int i = 0; i < numberThermalNodes; i++){
+				double multiplierAux = 0;
+				for(int j = 0; j < numberThermalNodes; j++){
+					multiplierAux += Tdifference[j] * eigenVectorsInv[i][j];
+				}
+				multiplierH[i] = multiplierAux;
+			}
+			//
+			for(int k = 0; k < numberThermalNodes; k++){
+				for(int i = 0; i < numberThermalNodes; i++){
+					double multiplierAux = multiplierH[i] * eigenVectors[k][i];
+					HfunctionWithoutLambda[k][i] = multiplierAux;
+					multiplierAux *= eigenValues[i];
+					Hfunction[k][i] = multiplierAux;
+					HfunctionSquaredLambda[k][i] = multiplierAux * eigenValues[i];
+				}
+			}
+
+			// The current time point is the previous time point for the next trace
+			previousTimePoint = newTimePoint;
+
+			for(int i = 0; i < numberUnits; i++){
+				previousPower[i] = Power[i];
+			}
+
+
+			// Compute all new temperatures
+			for(int k = 0; k < numberThermalNodes; k++){
+				double sumExponentials = 0;
+				for(int i = 0; i < numberThermalNodes; i++){
+					sumExponentials += HfunctionWithoutLambda[k][i];
+				}
+
+				Temperature[k] = Tsteady[k] + sumExponentials;
+			}
+		}
+		else{
+			// Compute all new temperatures
+			double relativeTimePoint = newTimePoint - previousTimePoint;
+			for(int i = 0; i < numberThermalNodes; i++){
+				exponentials[i] = pow((double)M_E, eigenValues[i] * relativeTimePoint);
+			}
+
+			for(int k = 0; k < numberThermalNodes; k++){
+				double sumExponentials = 0;
+				for(int i = 0; i < numberThermalNodes; i++){
+					sumExponentials += exponentials[i] * HfunctionWithoutLambda[k][i];
+				}
+
+				Temperature[k] = Tsteady[k] + sumExponentials;
+			}
+		}
+	}
+}
+
+
+
+
+
+
+
+
+
+
+void Matex::computeTransientTemperatures(const double &newTimePoint, double* &Power, double* &Tinit, double* &Temperature)
+{
+	// Compute the steady state temperature after the change in power
+	for(int i = 0; i < numberThermalNodes; i++){
+		double heatContributionPower = 0;
+		for(int j = 0; j < numberUnits; j++){
+			heatContributionPower += Binv[i][j]*Power[j];
+		}
+		auxTsteady[i] = heatContributionPower + Tamb*heatContributionAmbient[i];
+
+		Tdifference[i] = Tinit[i] - auxTsteady[i];
+	}
+
+	/* Compute the function H */
+	for(int i = 0; i < numberThermalNodes; i++){
+		double multiplierAux = 0;
+		for(int j = 0; j < numberThermalNodes; j++){
+			multiplierAux += Tdifference[j] * eigenVectorsInv[i][j];
+		}
+		multiplierH[i] = multiplierAux;
+	}
+	//
+	for(int k = 0; k < numberThermalNodes; k++){
+		for(int i = 0; i < numberThermalNodes; i++){
+			auxHfunctionWithoutLambda[k][i] = multiplierH[i] * eigenVectors[k][i];
+		}
+	}
+
+
+
+	/* Compute all temperatures at the end of this trace. This is to later update Tinit		*/
+	for(int i = 0; i < numberThermalNodes; i++){
+		exponentials[i] = pow((double)M_E, eigenValues[i] * newTimePoint);
+	}
+
+	for(int k = 0; k < numberThermalNodes; k++){
+		double sumExponentials = 0;
+		for(int i = 0; i < numberThermalNodes; i++){
+			sumExponentials += exponentials[i] * auxHfunctionWithoutLambda[k][i];
+		}
+
+		Temperature[k] = auxTsteady[k] + sumExponentials;
+	}
+}
+
+
+void Matex::computeTransientTemperatures(const double &newTimePoint, double* &Power, double* &Tinit, double* &Temperature, const int &numberUnitsWithPower)
+{
+	// Compute the steady state temperature after the change in power
+	for(int i = 0; i < numberThermalNodes; i++){
+		double heatContributionPower = 0;
+		for(int j = 0; j < numberUnitsWithPower; j++){
+			heatContributionPower += Binv[i][j]*Power[j];
+		}
+		auxTsteady[i] = heatContributionPower + Tamb*heatContributionAmbient[i];
+
+		Tdifference[i] = Tinit[i] - auxTsteady[i];
+	}
+
+	/* Compute the function H */
+	for(int i = 0; i < numberThermalNodes; i++){
+		double multiplierAux = 0;
+		for(int j = 0; j < numberThermalNodes; j++){
+			multiplierAux += Tdifference[j] * eigenVectorsInv[i][j];
+		}
+		multiplierH[i] = multiplierAux;
+	}
+	//
+	for(int k = 0; k < numberThermalNodes; k++){
+		for(int i = 0; i < numberThermalNodes; i++){
+			auxHfunctionWithoutLambda[k][i] = multiplierH[i] * eigenVectors[k][i];
+		}
+	}
+
+
+
+	/* Compute all temperatures at the end of this trace. This is to later update Tinit		*/
+	for(int i = 0; i < numberThermalNodes; i++){
+		exponentials[i] = pow((double)M_E, eigenValues[i] * newTimePoint);
+	}
+
+	for(int k = 0; k < numberThermalNodes; k++){
+		double sumExponentials = 0;
+		for(int i = 0; i < numberThermalNodes; i++){
+			sumExponentials += exponentials[i] * auxHfunctionWithoutLambda[k][i];
+		}
+
+		Temperature[k] = auxTsteady[k] + sumExponentials;
+	}
+}
+
+
+
+
+void Matex::computeTransientTemperaturesOnlyUnits(const double &newTimePoint, double* &Power, double* &Tinit, double* &Temperature)
+{
+	// Compute the steady state temperature after the change in power
+	for(int i = 0; i < numberThermalNodes; i++){
+		double heatContributionPower = 0;
+		for(int j = 0; j < numberUnits; j++){
+			heatContributionPower += Binv[i][j]*Power[j];
+		}
+		auxTsteady[i] = heatContributionPower + Tamb*heatContributionAmbient[i];
+
+		Tdifference[i] = Tinit[i] - auxTsteady[i];
+	}
+
+	/* Compute the function H */
+	for(int i = 0; i < numberThermalNodes; i++){
+		double multiplierAux = 0;
+		for(int j = 0; j < numberThermalNodes; j++){
+			multiplierAux += Tdifference[j] * eigenVectorsInv[i][j];
+		}
+		multiplierH[i] = multiplierAux;
+	}
+	//
+	for(int k = 0; k < numberUnits; k++){
+		for(int i = 0; i < numberThermalNodes; i++){
+			auxHfunctionWithoutLambda[k][i] = multiplierH[i] * eigenVectors[k][i];
+		}
+	}
+
+
+
+	/* Compute all temperatures at the end of this trace. This is to later update Tinit		*/
+	for(int i = 0; i < numberThermalNodes; i++){
+		exponentials[i] = pow((double)M_E, eigenValues[i] * newTimePoint);
+	}
+
+	for(int k = 0; k < numberUnits; k++){
+		double sumExponentials = 0;
+		for(int i = 0; i < numberThermalNodes; i++){
+			sumExponentials += exponentials[i] * auxHfunctionWithoutLambda[k][i];
+		}
+
+		Temperature[k] = auxTsteady[k] + sumExponentials;
+	}
+}
+
+
+void Matex::computeTransientTemperaturesOnlyUnits(const double &newTimePoint, double* &Power, double* &Tinit, double* &Temperature, const int &numberUnitsWithPower)
+{
+	// Compute the steady state temperature after the change in power
+	for(int i = 0; i < numberThermalNodes; i++){
+		double heatContributionPower = 0;
+		for(int j = 0; j < numberUnitsWithPower; j++){
+			heatContributionPower += Binv[i][j]*Power[j];
+		}
+		auxTsteady[i] = heatContributionPower + Tamb*heatContributionAmbient[i];
+
+		Tdifference[i] = Tinit[i] - auxTsteady[i];
+	}
+
+	/* Compute the function H */
+	for(int i = 0; i < numberThermalNodes; i++){
+		double multiplierAux = 0;
+		for(int j = 0; j < numberThermalNodes; j++){
+			multiplierAux += Tdifference[j] * eigenVectorsInv[i][j];
+		}
+		multiplierH[i] = multiplierAux;
+	}
+	//
+	for(int k = 0; k < numberUnits; k++){
+		for(int i = 0; i < numberThermalNodes; i++){
+			auxHfunctionWithoutLambda[k][i] = multiplierH[i] * eigenVectors[k][i];
+		}
+	}
+
+
+
+	/* Compute all temperatures at the end of this trace. This is to later update Tinit		*/
+	for(int i = 0; i < numberThermalNodes; i++){
+		exponentials[i] = pow((double)M_E, eigenValues[i] * newTimePoint);
+	}
+
+	for(int k = 0; k < numberUnits; k++){
+		double sumExponentials = 0;
+		for(int i = 0; i < numberThermalNodes; i++){
+			sumExponentials += exponentials[i] * auxHfunctionWithoutLambda[k][i];
+		}
+
+		Temperature[k] = auxTsteady[k] + sumExponentials;
+	}
+}
+
+
+
+
+
+
+
+
+
+void Matex::computeSteadyStateTemperatures(double* &Power, double* &Tsteady)
+{
+	for(int i = 0; i < numberThermalNodes; i++){
+
+		double heatContributionPower = 0;
+		for(int j = 0; j < numberUnits; j++){
+			heatContributionPower += Binv[i][j]*Power[j];
+		}
+
+		Tsteady[i] = heatContributionPower + Tamb*heatContributionAmbient[i];
+	}
+}
+
+
+
+
+
+
+
+
+bool Matex::readTemperaturesInitFile(ConfigurationParameters &generalConfigurationParameters, double* &Temperature)
+{
+	if(generalConfigurationParameters.fileNameInputInitialTemperatures.size() > 0){
+
+		// Initialize the result vector with -1. At the end, if the initial temperature file is correct, all temperatures must be positive values. If not, the temperature file was invalid.
+		for(int i = 0; i < numberThermalNodes; i++){
+			Temperature[i] = -1;
+		}
+
+		ifstream inputTemperatureFile(generalConfigurationParameters.fileNameInputInitialTemperatures.c_str());
+		if ( inputTemperatureFile.is_open() ){
+			if(inputTemperatureFile.good()){
+				// Read until the end of the file
+				while(inputTemperatureFile.good()){
+					// Read one line from the file
+					string line;
+					getline(inputTemperatureFile, line);
+
+					// If the line was successfully read
+					if(inputTemperatureFile.good()){
+						stringstream lineStream(line);
+						lineStream.exceptions(stringstream::goodbit);
+
+						string newThermalNodeName;
+						lineStream >> newThermalNodeName;
+
+						// If the line had a parameter
+						if((lineStream.rdstate() == stringstream::goodbit) && (newThermalNodeName.size() > 0)){
+							// Ignore comments
+							if(newThermalNodeName[0] != '#'){
+
+								// At this point, the string newThermalNodeName should hold a valid thermal node name according to the floorplan information
+								// First find the layer
+								int indexLayer = SILICON;
+								if (newThermalNodeName.substr(0, strlen("iface_")) == "iface_"){
+									indexLayer = IFACE;
+									newThermalNodeName.erase(0, strlen("iface_"));
+								}
+								else if (newThermalNodeName.substr(0, strlen("hsp_")) == "hsp_"){
+									indexLayer = HSP;
+									newThermalNodeName.erase(0, strlen("hsp_"));
+								}
+								else if (newThermalNodeName.substr(0, strlen("hsink_")) == "hsink_"){
+									indexLayer = HSINK;
+									newThermalNodeName.erase(0, strlen("hsink_"));
+								}
+								else if (newThermalNodeName.substr(0, strlen("inode_")) == "inode_"){
+									indexLayer = AMBIENT_NODES;
+									newThermalNodeName.erase(0, strlen("inode_"));
+								}
+
+
+								// Then find out the node in the layer
+								int indexUnit = -1;
+								if(indexLayer < AMBIENT_NODES){
+									for(int i = 0; i < numberUnits; i++){
+										if(newThermalNodeName == floorplan.units[i].name){
+											indexUnit = i;
+											break;
+										}
+									}
+								}
+								else{
+									stringstream numberStream(newThermalNodeName);
+									int iValue;
+									numberStream >> iValue;
+									if((numberStream.rdstate() == stringstream::goodbit) || (numberStream.rdstate() == stringstream::eofbit)){
+										if((iValue >= 0) && (iValue < EXTRA_NODES)){
+											indexUnit = iValue;
+										}
+									}
+								}
+
+
+								// If the unit is valid, only then we read the temperature and assign it to the node
+								if(indexUnit >= 0){
+									double newTemperature;
+									lineStream >> newTemperature;
+
+									if((lineStream.rdstate() == stringstream::goodbit) || (lineStream.rdstate() == stringstream::eofbit)){
+										int indexTemperature = numberUnits*indexLayer + indexUnit;
+										if((indexTemperature >= 0) && (indexTemperature < numberThermalNodes)){
+											Temperature[indexTemperature] = newTemperature;
+										}
+										else{
+											cout << "Error: The file with the initial temperature information does not match the floorplan information." << endl;
+											return false;
+										}
+									}
+									else{
+										cout << "Error: The file with the initial temperatures is invalid." << endl;
+										return false;
+									}
+								}
+								else{
+									cout << "Error: The file with the initial temperature information does not match the floorplan information." << endl;
+									return false;
+								}
+							}
+						}
+					}
+				}
+			}
+			else{
+				cout << "Error: The file with the initial temperature information could not be open for reading." << endl;
+				return false;
+			}
+		}
+		else{
+			cout << "Error: The file with the initial temperature information could not be open for reading." << endl;
+			return false;
+		}
+
+
+
+
+		// Finally, check that all the temperatures are valid
+		for(int i = 0; i < numberThermalNodes; i++){
+			if(Temperature[i] < 0){
+				cout << "Error: The file with the initial temperatures is invalid." << endl;
+				return false;
+			}
+		}
+
+	}
+	else{
+		/* If there was no initial temperature file, then use the initial temperature parameter	*/
+		if(generalConfigurationParameters.Tinit >= 0){
+			for(int i = 0; i < numberThermalNodes; i++){
+				Temperature[i] = generalConfigurationParameters.Tinit;
+			}
+		}
+		else{
+			cout << "Error: The initial temperature cannot be a negative value." << endl;
+			return false;
+		}
+	}
+
+
+
+	return true;
+}
+
+
+
+
+int Matex::getFunctionalUnitIndex(const string &unitName){
+	return floorplan.getBlockIndex(unitName);
+}
+
+string Matex::getFunctionalUnitName(const int &index){
+	return floorplan.units[index].name;
+}
+
+
diff -Naur sniper-6.1_old/common/scheduler/matexConfigurationParameters.cc sniper-6.1/common/scheduler/matexConfigurationParameters.cc
--- sniper-6.1_old/common/scheduler/matexConfigurationParameters.cc	1970-01-01 01:00:00.000000000 +0100
+++ sniper-6.1/common/scheduler/matexConfigurationParameters.cc	2017-08-01 14:34:53.612035000 +0200
@@ -0,0 +1,474 @@
+/**	\file	matexConfigurationParameters.cpp
+ *	\brief	Source file for general configuration parameters.
+ */
+
+#include "matexConfigurationParameters.h"
+
+
+
+
+MatexConfigurationParameters::MatexConfigurationParameters()
+{
+	/* Set defaults values for all configuration parameters	*/
+	/* Chip specs	*/
+	tChip= 0.15e-3;
+	kChip = 100.0;
+	pChip = 1.75e6;
+
+	/* Heat sink specs	*/
+	cConvec = 140.4;
+	rConvec = 0.1;
+	sSink = 60e-3;
+	tSink = 6.9e-3;
+	kSink = 400.0;
+	pSink = 3.55e6;
+
+	/* Heat spreader specs	*/
+	sSpreader = 30e-3;
+	tSpreader = 1e-3;
+	kSpreader = 400.0;
+	pSpreader = 3.55e6;
+
+	/* Interface material specs	*/
+	tInterface = 20e-6;
+	kInterface = 4.0;
+	pInterface = 4.0e6;
+
+	/* Secondary heat transfer path */
+	modelSecondary = false;
+	rConvecSec = 1.0;
+	cConvecSec = 140.4;						/**< \TODO Needs an updated value. */
+	nMetal = 8;
+	tMetal = 10.0e-6;
+	tC4 = 0.0001;
+	sC4 = 20.0e-6;
+	nC4 = 400;
+	sSub = 0.021;
+	tSub = 0.001;
+	sSolder = 0.021;
+	tSolder = 0.00094;
+	sPcb = 0.1;
+	tPcb = 0.002;
+
+	/* Others	*/
+	initTemp = 60 + T_KELVIN;
+
+	leakageUsed = false;
+	leakageMode = USER_LEAKAGE;
+
+	packageModelUsed = false;
+
+	modelType = BLOCK;
+
+	blockOmitLateral = false;
+
+	gridRows = 64;
+	gridCols = 64;
+
+	gridMapMode = CENTER;
+
+	iterations = 20;
+}
+
+
+
+
+void MatexConfigurationParameters::readConfigurationFile(const string &fileNameConfiguration)
+{
+	if(fileNameConfiguration.size() > 0){
+		ifstream inputConfigFile(fileNameConfiguration.c_str());
+		if ( inputConfigFile.is_open() ){
+			if(inputConfigFile.good()){
+				// Read until the end of the file
+				while(inputConfigFile.good()){
+					// Read one line from the file
+					string line;
+					getline(inputConfigFile, line);
+
+					// If the line was successfully read
+					if(inputConfigFile.good()){
+						stringstream lineStream(line);
+						Parameter newParameter;
+						lineStream >> newParameter.name;
+
+						// If the line had a parameter
+						if(newParameter.name.size() > 0){
+							if(newParameter.name[0] == '-'){
+								newParameter.name.erase(0,1);
+								lineStream >> newParameter.value;
+
+								// If valid, add the configuration parameter to the list
+								if(addNewParameter(newParameter, false) == false){
+									inputConfigFile.close();
+									exit(1);
+								}
+							}
+						}
+					}
+				}
+			}
+			else{
+				cout << "Error: Configuration file could not be open for reading." << endl;
+				inputConfigFile.close();
+				exit(1);
+			}
+			inputConfigFile.close();
+		}
+		else{
+			cout << "Error: Configuration file could not be open for reading." << endl;
+			exit(1);
+		}
+	}
+}
+
+
+
+
+bool MatexConfigurationParameters::verify(void)
+{
+	if(modelType == GRID){
+		if(gridRows < 1){
+			cout << "Error: Using the grid model with an invalid number of rows." << endl;
+			return false;
+		}
+
+		if(gridCols < 1){
+			cout << "Error: Using the grid model with an invalid number of columns." << endl;
+			return false;
+		}
+	}
+
+	if(iterations <= 0){
+		cout << "Error: The number of iterations for Newton's method has to be a positive integer." << endl;
+		return false;
+	}
+
+	return true;
+}
+
+
+
+
+
+
+void MatexConfigurationParameters::print(void)
+{
+	cout << "#Configuration Parameters:" << endl;
+	if(parameters.size() == 0){
+		cout << "\tNo configuration parameters" << endl;
+		return;
+	}
+	for(unsigned int i = 0; i < parameters.size(); i++){
+		cout << "\t" << parameters[i].name << ":\t" << parameters[i].value << endl;
+	}
+}
+
+
+
+bool MatexConfigurationParameters::addNewParameter(const Parameter &newParameter, const bool &newHasPriority)
+{
+	if(newParameter.value.size() > 0){
+		// Check if the parameter is repeated.
+		int repeatedIndex = -1;
+		for(unsigned int existingParameter = 0; existingParameter < parameters.size(); existingParameter++){
+			if(newParameter.name == parameters[existingParameter].name)
+				repeatedIndex = existingParameter;
+		}
+
+		// If it is not repeated or the new one has priority, then we add the value to the configuration if it matches the type.
+		if((repeatedIndex < 0) || newHasPriority){
+
+			// Start with the configuration parameters that are names of files
+			if(newParameter.name == "package_config_file"){
+				if(nullFileName(newParameter.value))
+					fileNamePackageConfig = "";
+				else
+					fileNamePackageConfig = newParameter.value;
+			}
+			else if(newParameter.name == "grid_layer_file"){
+				if(nullFileName(newParameter.value))
+					fileNameGridLayer = "";
+				else
+					fileNameGridLayer = newParameter.value;
+			}
+			// Then we check the configuration parameters that are enumerations
+			else if(newParameter.name == "model_type"){
+				if(newParameter.value == "block"){
+					modelType = BLOCK;
+				}
+				else if(newParameter.value == "grid"){
+					modelType = GRID;
+				}
+				else{
+					cout << "Error: Value of parameter \"" << newParameter.name << "\" should be 'block' or 'grid'" << endl;
+					return false;
+				}
+			}
+			else if(newParameter.name == "grid_map_mode"){
+				if((newParameter.value == "block") || (newParameter.value == "Block") || (newParameter.value == "BLOCK")){
+					gridMapMode = AVERAGE;
+				}
+				else if((newParameter.value == "min") || (newParameter.value == "Min") || (newParameter.value == "MIN")){
+					gridMapMode = MIN;
+				}
+				else if((newParameter.value == "max") || (newParameter.value == "Max") || (newParameter.value == "MAX")){
+					gridMapMode = MAX;
+				}
+				else if((newParameter.value == "center") || (newParameter.value == "Center") || (newParameter.value == "CENTER")){
+					gridMapMode = CENTER;
+				}
+				else{
+					cout << "Error: Value of parameter \"" << newParameter.name << "\" should be 'avg', 'min', 'max', or 'center'" << endl;
+					return false;
+				}
+			}
+			else if(newParameter.name == "leakage_mode"){
+				if(newParameter.value == "0"){
+					leakageMode = USER_LEAKAGE;
+				}
+				else if(newParameter.value == "1"){
+					leakageMode = HOTSPOT_LEAKAGE;
+				}
+				else{
+					cout << "Error: Value of parameter \"" << newParameter.name << "\" should be '0' or '1'" << endl;
+					return false;
+				}
+			}
+			// Now we check for all the boolean variables
+			else if(newParameter.name == "model_secondary"){
+				if(newParameter.value == "0"){
+					modelSecondary = false;
+				}
+				else if(newParameter.value == "1"){
+					modelSecondary = true;
+				}
+				else{
+					cout << "Error: Value of parameter \"" << newParameter.name << "\" should be '0' or '1'" << endl;
+					return false;
+				}
+			}
+			else if(newParameter.name == "leakage_used"){
+				if(newParameter.value == "0"){
+					leakageUsed = false;
+				}
+				else if(newParameter.value == "1"){
+					leakageUsed = true;
+				}
+				else{
+					cout << "Error: Value of parameter \"" << newParameter.name << "\" should be '0' or '1'" << endl;
+					return false;
+				}
+			}
+			else if(newParameter.name == "package_model_used"){
+				if(newParameter.value == "0"){
+					packageModelUsed = false;
+				}
+				else if(newParameter.value == "1"){
+					packageModelUsed = true;
+				}
+				else{
+					cout << "Error: Value of parameter \"" << newParameter.name << "\" should be '0' or '1'" << endl;
+					return false;
+				}
+			}
+			else if(newParameter.name == "block_omit_lateral"){
+				if(newParameter.value == "0"){
+					blockOmitLateral = false;
+				}
+				else if(newParameter.value == "1"){
+					blockOmitLateral = true;
+				}
+				else{
+					cout << "Error: Value of parameter \"" << newParameter.name << "\" should be '0' or '1'" << endl;
+					return false;
+				}
+			}
+			// Now check the variables of type int
+			else if(newParameter.name == "grid_rows"){
+				try{
+					int iValue;
+					stringstream streamValue(newParameter.value);
+					streamValue.exceptions(stringstream::goodbit);
+					streamValue >> iValue;
+					if((streamValue.rdstate() == stringstream::goodbit) || (streamValue.rdstate() == stringstream::eofbit)){
+						gridRows = iValue;
+					}
+					else{
+						cout << "Error: Value of parameter \"" << newParameter.name << "\" is invalid." << endl;
+						return false;
+					}
+				}
+				catch(...){
+					cout << "Error: Value of parameter \"" << newParameter.name << "\" is invalid." << endl;
+					return false;
+				}
+			}
+			else if(newParameter.name == "grid_cols"){
+				try{
+					int iValue;
+					stringstream streamValue(newParameter.value);
+					streamValue.exceptions(stringstream::goodbit);
+					streamValue >> iValue;
+					if((streamValue.rdstate() == stringstream::goodbit) || (streamValue.rdstate() == stringstream::eofbit)){
+						gridCols = iValue;
+					}
+					else{
+						cout << "Error: Value of parameter \"" << newParameter.name << "\" is invalid." << endl;
+						return false;
+					}
+				}
+				catch(...){
+					cout << "Error: Value of parameter \"" << newParameter.name << "\" is invalid." << endl;
+					return false;
+				}
+			}
+			else if(newParameter.name == "iterations"){
+				try{
+					int iValue;
+					stringstream streamValue(newParameter.value);
+					streamValue.exceptions(stringstream::goodbit);
+					streamValue >> iValue;
+					if((streamValue.rdstate() == stringstream::goodbit) || (streamValue.rdstate() == stringstream::eofbit)){
+						iterations = iValue;
+					}
+					else{
+						cout << "Error: Value of parameter \"" << newParameter.name << "\" is invalid." << endl;
+						return false;
+					}
+				}
+				catch(...){
+					cout << "Error: Value of parameter \"" << newParameter.name << "\" is invalid." << endl;
+					return false;
+				}
+			}
+			// Finally, we check all the variables of type double
+			else{
+				try{
+					double dValue;
+					stringstream streamValue(newParameter.value);
+					streamValue.exceptions(stringstream::goodbit);
+					streamValue >> dValue;
+					if(newParameter.name == "t_chip"){
+						tChip = dValue;
+					}
+					else if(newParameter.name == "k_chip"){
+						kChip = dValue;
+					}
+					else if(newParameter.name == "p_chip"){
+						pChip = dValue;
+					}
+					else if(newParameter.name == "c_convec"){
+						cConvec = dValue;
+					}
+					else if(newParameter.name == "r_convec"){
+						rConvec = dValue;
+					}
+					else if(newParameter.name == "s_sink"){
+						sSink = dValue;
+					}
+					else if(newParameter.name == "t_sink"){
+						tSink = dValue;
+					}
+					else if(newParameter.name == "k_sink"){
+						kSink = dValue;
+					}
+					else if(newParameter.name == "p_sink"){
+						pSink = dValue;
+					}
+					else if(newParameter.name == "s_spreader"){
+						sSpreader = dValue;
+					}
+					else if(newParameter.name == "t_spreader"){
+						tSpreader = dValue;
+					}
+					else if(newParameter.name == "k_spreader"){
+						kSpreader = dValue;
+					}
+					else if(newParameter.name == "p_spreader"){
+						pSpreader = dValue;
+					}
+					else if(newParameter.name == "t_interface"){
+						tInterface = dValue;
+					}
+					else if(newParameter.name == "k_interface"){
+						kInterface = dValue;
+					}
+					else if(newParameter.name == "p_interface"){
+						pInterface = dValue;
+					}
+					else if(newParameter.name == "r_convec_sec"){
+						rConvecSec = dValue;
+					}
+					else if(newParameter.name == "c_convec_sec"){
+						cConvecSec = dValue;
+					}
+					else if(newParameter.name == "n_metal"){
+						nMetal = dValue;
+					}
+					else if(newParameter.name == "t_metal"){
+						tMetal = dValue;
+					}
+					else if(newParameter.name == "t_c4"){
+						tC4 = dValue;
+					}
+					else if(newParameter.name == "s_c4"){
+						sC4 = dValue;
+					}
+					else if(newParameter.name == "n_c4"){
+						nC4 = dValue;
+					}
+					else if(newParameter.name == "s_sub"){
+						sSub = dValue;
+					}
+					else if(newParameter.name == "t_sub"){
+						tSub = dValue;
+					}
+					else if(newParameter.name == "s_solder"){
+						sSolder = dValue;
+					}
+					else if(newParameter.name == "t_solder"){
+						tSolder = dValue;
+					}
+					else if(newParameter.name == "s_pcb"){
+						sPcb = dValue;
+					}
+					else if(newParameter.name == "t_pcb"){
+						tPcb = dValue;
+					}
+					else if(newParameter.name == "init_temp"){
+						initTemp = dValue;
+					}
+					else{
+						cout << "Error: \"" << newParameter.name << "\" is not a valid parameter. Please check usage." << endl;
+						return false;
+					}
+
+					if((streamValue.rdstate() != stringstream::goodbit) && (streamValue.rdstate() != stringstream::eofbit)){
+						cout << "Error: Value of parameter \"" << newParameter.name << "\" is invalid." << endl;
+						return false;
+					}
+				}
+				catch(...){
+					cout << "Error: Value of parameter \"" << newParameter.name << "\" is invalid." << endl;
+					return false;
+				}
+			}
+
+
+
+			// If it is not repeated, then we add it to the list
+			if(repeatedIndex < 0){
+				parameters.push_back(newParameter);
+			}
+			// If it is repeated and the first value has priority, then we replace it
+			else{
+				parameters[repeatedIndex] = newParameter;
+			}
+		}
+
+		return true;
+	}
+	else{
+		return false;
+	}
+}
diff -Naur sniper-6.1_old/common/scheduler/matexConfigurationParameters.h sniper-6.1/common/scheduler/matexConfigurationParameters.h
--- sniper-6.1_old/common/scheduler/matexConfigurationParameters.h	1970-01-01 01:00:00.000000000 +0100
+++ sniper-6.1/common/scheduler/matexConfigurationParameters.h	2017-08-01 14:34:53.608035000 +0200
@@ -0,0 +1,169 @@
+/**	\file	matexConfigurationParameters.h
+ *	\brief	Header file for general configuration parameters.
+ */
+#ifndef MATEXCONFIGURATIONPARAMETERS_H_
+#define MATEXCONFIGURATIONPARAMETERS_H_
+
+#include <iostream>
+#include <stdio.h>
+#include <stdlib.h>
+#include <algorithm>
+#include <unistd.h>
+#include <string.h>
+#include <vector>
+#include <string>
+#include <fstream>
+#include <sstream>
+#include <stdexcept>
+
+using namespace std;
+
+
+
+#ifndef T_KELVIN_H_
+#define T_KELVIN_H_
+const long double T_KELVIN = 273.15;
+#endif /* T_KELVIN_H_ */
+
+
+
+
+/**	\brief	Class that stores the configuration parameters.
+ *
+ *	Class that stores the configuration parameters from the configuration files or the command line. The command line has priority.
+ */
+class MatexConfigurationParameters{
+public:
+
+	/**	\brief	Structre with the definition pair of strings that forms a configuration parameter.	*/
+	struct Parameter {
+		string name;										/**< \brief Name of the configuration parameter.	*/
+		string value;										/**< \brief Value of the configuration parameter.	*/
+	};
+
+
+	/**	\brief	Vector containing all the configuration parameters.	*/
+	vector< Parameter > parameters;
+
+
+
+	/**	\brief	Method that reads the configuration from the configuration file.
+	 *
+	 *	Method that reads the configuration from the configuration file. The configuration file must be passed as a command line argument.
+	 */
+	void readConfigurationFile(const string &fileNameConfiguration);
+
+
+
+	/**	\brief	Method that verifies that the configuration parameters are valid.
+	 *
+	 */
+	bool verify(void);
+
+
+
+	/**	\brief	Method that prints the configuration parameters.
+	 */
+	void print(void);
+
+
+
+	/**	\brief	Enumeration with the accepted types of models.	*/
+	typedef enum {
+		BLOCK=1,
+		GRID=2
+	} ModelTypes;
+
+	/**	\brief	Enumeration with the accepted grid map modes.	*/
+	typedef enum {
+		AVERAGE=1,
+		MIN=2,
+		MAX=3,
+		CENTER=4
+	} GridMapModes;
+
+	/**	\brief	Enumeration with the accepted leakage modes.	*/
+	typedef enum {
+		USER_LEAKAGE=1,
+		HOTSPOT_LEAKAGE=2
+	} LeakageModes;
+
+
+
+	string fileNamePackageConfig;							/**< \brief Name of the file with the package configuration.	*/
+	string fileNameGridLayer;								/**< \brief Name of the layer file for the grid model.	*/
+	ModelTypes modelType;									/**< \brief Model type: block or grid.	*/
+	GridMapModes gridMapMode;								/**< \brief Grid to block mapping mode - (avg|min|max|center), i.e., a block's temperature is the avg, min or max of all the grid cells in it or equal to that of the grid cell in its center.	*/
+	LeakageModes leakageMode;								/**< \brief Leakage mode (only valid when -leakage_used=1).	*/
+	bool modelSecondary;									/**< \brief Option to model the secondary path.	*/
+	bool leakageUsed;										/**< \brief Option to consider a temperature-leakage loop within the application.	*/
+	bool packageModelUsed;									/**< \brief Option to use the detailed package model.	*/
+	bool blockOmitLateral;									/**< \brief Option to omit lateral chip resistances.	*/
+	int gridRows;											/**< \brief Number of rows to use in the grid model.	*/
+	int gridCols;											/**< \brief Number of columns to use in the grid model.	*/
+	double tChip;											/**< \brief Chip thickness in meters.	*/
+	double kChip;											/**< \brief Silicon thermal conductivity [W/(meters * Kelvin)].	*/
+	double pChip;											/**< \brief Silicon specific heat [Joule/(meters^3 * Kelvin)].	*/
+	double cConvec;											/**< \brief Convection capacitance [Joule/Kelvin].	*/
+	double rConvec;											/**< \brief Convection resistance [Kelvin/Watt].	*/
+	double sSink;											/**< \brief Heatsink side [meters].	*/
+	double tSink;											/**< \brief Heatsink thickness [meters].	*/
+	double kSink;											/**< \brief Heatsink thermal conductivity [Watts/(meters * Kelvin].	*/
+	double pSink;											/**< \brief Heatsink specific heat [Joule/(meters^3 * Kelvin].	*/
+	double sSpreader;										/**< \brief Heat spreader side [meters].	*/
+	double tSpreader;										/**< \brief Heat spreader thickness [meters].	*/
+	double kSpreader;										/**< \brief Heat spreader thermal conductivity [Watts/(meters * Kelvin].	*/
+	double pSpreader;										/**< \brief Heat spreader specific heat [Joule/(meters^3 * Kelvin].	*/
+	double tInterface;										/**< \brief Interface material thickness [meters].	*/
+	double kInterface;										/**< \brief Interface material thermal conductivity [Watts/(meters * Kelvin].	*/
+	double pInterface;										/**< \brief Interface material specific heat [Joule/(meters^3 * Kelvin].	*/
+	double rConvecSec;										/**< \brief Convection resistance at the air/PCB interface [Kelvin/Watt].	*/
+	double cConvecSec;										/**< \brief Convection capacitance at the air/PCB interface [Jolue/Kelvin].	*/
+	double nMetal;											/**< \brief Number of on-chip metal layers.	*/
+	double tMetal;											/**< \brief One metal layer thickness [meters].	*/
+	double tC4;												/**< \brief C4/underfill thickness [meters].	*/
+	double sC4;												/**< \brief Side size of EACH C4 pad.	*/
+	double nC4;												/**< \brief Number of C4 pads.	*/
+	double sSub;											/**< \brief Package substrate side [meters].	*/
+	double tSub;											/**< \brief Package substrate thickness [meters].	*/
+	double sSolder;											/**< \brief Solder ball side [meters].	*/
+	double tSolder;											/**< \brief Solder ball thickness [meters].	*/
+	double sPcb;											/**< \brief PCB side [meters].	*/
+	double tPcb;											/**< \brief PCB thickness [meters].	*/
+	double initTemp;										/**< \brief Initial temperature [Kelvin], when not read from a file.	*/
+	int iterations;											/**< \brief Number of iterations used in Newton's method to compute the peaks in temperature.	*/
+
+
+
+	/**	\brief	Constructor. Initializes all variables with the default values.	*/
+	MatexConfigurationParameters();
+
+private:
+	/**	\brief	Method that checks whether the value of the new parameter is valid.
+	 *
+	 *	\param[in]	newParameter		Name and value of the new parameter.
+	 *	\param[in]	newHasPriority		When the parameter name is repeated and variable is true, the new value replaces the old one. When this variable is false, the old value is preserved.
+	 *
+	 *	\return							True if the name is valid, false otherwise.
+	 */
+	bool addNewParameter(const Parameter &newParameter, const bool &newHasPriority);
+
+
+
+	/**	\brief	Return true if the string containing the file name is "(null)", "null", "(Null)", "Null", "(NULL)", or "NULL"	*/
+	inline bool nullFileName(const string &fileName) { return ((fileName == "(null)") || (fileName == "null") || (fileName == "(Null)") || (fileName == "Null") || (fileName == "(NULL)") || (fileName == "NULL")); }
+};
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif /* MATEXCONFIGURATIONPARAMETERS_H_ */
diff -Naur sniper-6.1_old/common/scheduler/Matex.h sniper-6.1/common/scheduler/Matex.h
--- sniper-6.1_old/common/scheduler/Matex.h	1970-01-01 01:00:00.000000000 +0100
+++ sniper-6.1/common/scheduler/Matex.h	2017-08-01 14:34:53.608035000 +0200
@@ -0,0 +1,175 @@
+/**	\file	Matex.h
+ *	\brief	Header file for the Matex class implementation
+ */
+#ifndef MATEX_H_
+#define MATEX_H_
+
+#include <iostream>
+#include <stdio.h>
+#include <stdlib.h>
+#include <algorithm>
+#include <unistd.h>
+#include <string.h>
+#include <vector>
+#include <math.h>
+#include <string>
+#include <fstream>
+#include <sstream>
+#include <stdexcept>
+#include <Eigen/Dense>
+#include <Eigen/Eigenvalues>
+
+
+#include "configurationParameters.h"
+#include "matexConfigurationParameters.h"
+#include "floorplan.h"
+#include "rcModel.h"
+
+
+using namespace std;
+using namespace Eigen;
+
+
+#define nullptr NULL
+
+
+#ifndef T_KELVIN_H_
+#define T_KELVIN_H_
+const long double T_KELVIN = 273.15;
+#endif /* T_KELVIN_H_ */
+
+
+
+
+/**	\brief	Class that stores the configuration parameters.
+ *
+ *	Class that stores the configuration parameters from the configuration files or the command line. The command line has priority.
+ */
+class Matex{
+public:
+
+	/**	\brief	Constructor. Initializes all variables.	*/
+	Matex();
+
+
+	/**	\brief	Destructor.	*/
+	~Matex();
+
+
+	/**	\brief	Function loads the RC thermal network and computes the eigenvalues and eigenvectors for the MatEx computation.
+	 *
+	 *	Function loads the RC thermal network and computes the eigenvalues and eigenvectors for the MatEx computation.
+	 *
+	 *	\param[in]	generalConfigurationParameters			General configuration parameters
+	 *	\return												True if the files were successfully read and the models successfully computed. False otherwise.
+	 */
+	bool load(ConfigurationParameters &generalConfigurationParameters);
+
+	bool loadFloorplan(string &fileNameFloorplan);
+
+
+
+	void computeSteadyStateTemperatures(double* &Power, double* &Tsteady);
+
+
+	void computeTransientTemperatures(const double &newTimePoint, double* &Power, double* &Temperature);
+
+
+	void computeTransientTemperatures(const double &newTimePoint, double* &Power, double* &Tinit, double* &Temperature);
+
+
+	void computeTransientTemperatures(const double &newTimePoint, double* &Power, double* &Tinit, double* &Temperature, const int &numberUnitsWithPower);
+
+
+	void computeTransientTemperaturesOnlyUnits(const double &newTimePoint, double* &Power, double* &Tinit, double* &Temperature);
+
+
+	void computeTransientTemperaturesOnlyUnits(const double &newTimePoint, double* &Power, double* &Tinit, double* &Temperature, const int &numberUnitsWithPower);
+
+
+	bool readTemperaturesInitFile(ConfigurationParameters &generalConfigurationParameters, double* &Temperature);
+
+
+	inline int getNumberUnits(void) {return numberUnits;}
+
+
+	inline int getNumberThermalNodes(void) {return numberThermalNodes;}
+
+	inline int getNumberThermalNodesToAmbient(void) {return numberNodesAmbient;}
+
+	inline double getAreaNode(const unsigned int &nodeIndex) {	if(nodeIndex < floorplan.units.size())
+																	return floorplan.units[nodeIndex].getArea();
+																else
+																	return 0;}
+
+	inline double getTotalChipArea(void) {	double totalArea = 0;
+											for(unsigned int i = 0; i < floorplan.units.size(); i++)
+												totalArea += floorplan.units[i].getArea();
+											return totalArea; }
+
+
+	int getFunctionalUnitIndex(const string &unitName);
+
+	string getFunctionalUnitName(const int &index);
+
+
+	inline double getBinvValue(const int &row, const int &column){ return Binv[row][column]; }
+
+	inline double getGambValue(const int &row){ return Gamb[row]; }
+
+	inline double getHeatContributionAmbient(const int &index){ return heatContributionAmbient[index]; }
+
+
+	double previousTimePoint;
+	bool preivousPointEqualPower;
+
+	bool firstPowerChange;
+
+private:
+
+	double** Binv;											/**< \brief Matrix \f$\mathbf{B}^{-1}\f$.				*/
+	double* Gamb;											/**< \brief Vector \f$\mathbf{G}_\text{amb}\f$.			*/
+	double Tamb;											/**< \brief Ambient temperature.						*/
+	int numberThermalNodes;									/**< \brief Number of thermal nodes in the RC network.	*/
+	int numberUnits;										/**< \brief Number of blocks in the floorplan.			*/
+	int numberNodesAmbient;									/**< \brief Number of thermal nodes that connect to ambient.	*/
+
+	double samplingInterval;								/**< \brief Sampling interval for the output traces.					*/
+
+	double* eigenValues;
+	double** eigenVectors;
+	double** eigenVectorsInv;
+
+	double *multiplierH;
+	double **HfunctionWithoutLambda;
+	double **Hfunction;
+	double **HfunctionSquaredLambda;
+	double **auxHfunctionWithoutLambda;
+
+	double* Tsteady;
+	double* auxTsteady;
+	double *Tdifference;
+	double *exponentials;
+	double *previousPower;
+
+	double* heatContributionAmbient;
+
+	Floorplan floorplan;
+
+	bool readEigenvaluesEigenvectorsFromFile(const string &fileName);
+	bool saveEigenvaluesEigenvectorsToFile(const string &fileName);
+};
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif /* MATEX_H_ */
diff -Naur sniper-6.1_old/common/scheduler/rcModel.cc sniper-6.1/common/scheduler/rcModel.cc
--- sniper-6.1_old/common/scheduler/rcModel.cc	1970-01-01 01:00:00.000000000 +0100
+++ sniper-6.1/common/scheduler/rcModel.cc	2017-08-01 14:34:55.480037000 +0200
@@ -0,0 +1,1177 @@
+/**	\file	rcModel.cpp
+ *	\brief	Source file for RC thermal network class.
+ */
+
+#include "rcModel.h"
+
+
+
+
+
+
+
+
+
+void Package::loadR(const MatexConfigurationParameters &configuration, const double &floorplanWidth, const double &floorplanHeight)
+{
+	/* Lateral resistances of spreader and sink */
+	r_sp1_x = getThermalResistance(configuration.kSpreader, (configuration.sSpreader - floorplanWidth)/4.0, (configuration.sSpreader + 3*floorplanHeight)/4.0 * configuration.tSpreader);
+	r_sp1_y = getThermalResistance(configuration.kSpreader, (configuration.sSpreader - floorplanHeight)/4.0, (configuration.sSpreader + 3*floorplanWidth)/4.0 * configuration.tSpreader);
+	r_hs1_x = getThermalResistance(configuration.kSink, (configuration.sSpreader - floorplanWidth)/4.0, (configuration.sSpreader + 3*floorplanHeight)/4.0 * configuration.tSink);
+	r_hs1_y = getThermalResistance(configuration.kSink, (configuration.sSpreader - floorplanHeight)/4.0, (configuration.sSpreader + 3*floorplanWidth)/4.0 * configuration.tSink);
+	r_hs2_x = getThermalResistance(configuration.kSink, (configuration.sSpreader - floorplanWidth)/4.0, (3*configuration.sSpreader + floorplanHeight)/4.0 * configuration.tSink);
+	r_hs2_y = getThermalResistance(configuration.kSink, (configuration.sSpreader - floorplanHeight)/4.0, (3*configuration.sSpreader + floorplanWidth)/4.0 * configuration.tSink);
+	r_hs = getThermalResistance(configuration.kSink, (configuration.sSink - configuration.sSpreader)/4.0, (configuration.sSink+3*configuration.sSpreader)/4.0 * configuration.tSink);
+
+	/* Vertical resistances of spreader and sink */
+	r_sp_per_x = getThermalResistance(configuration.kSpreader, configuration.tSpreader, (configuration.sSpreader + floorplanHeight) * (configuration.sSpreader - floorplanWidth) / 4.0);
+	r_sp_per_y = getThermalResistance(configuration.kSpreader, configuration.tSpreader, (configuration.sSpreader + floorplanWidth) * (configuration.sSpreader - floorplanHeight) / 4.0);
+	r_hs_c_per_x = getThermalResistance(configuration.kSink, configuration.tSink, (configuration.sSpreader + floorplanHeight) * (configuration.sSpreader - floorplanWidth) / 4.0);
+	r_hs_c_per_y = getThermalResistance(configuration.kSink, configuration.tSink, (configuration.sSpreader + floorplanWidth) * (configuration.sSpreader - floorplanHeight) / 4.0);
+	r_hs_per = getThermalResistance(configuration.kSink, configuration.tSink, (configuration.sSink*configuration.sSink - configuration.sSpreader*configuration.sSpreader) / 4.0);
+
+	/* Vertical resistances to ambient (divide r_convec proportional to area) */
+	r_amb_c_per_x = configuration.rConvec * (configuration.sSink * configuration.sSink) / ((configuration.sSpreader + floorplanHeight) * (configuration.sSpreader - floorplanWidth) / 4.0);
+	r_amb_c_per_y = configuration.rConvec * (configuration.sSink * configuration.sSink) / ((configuration.sSpreader + floorplanWidth) * (configuration.sSpreader - floorplanHeight) / 4.0);
+	r_amb_per = configuration.rConvec * (configuration.sSink * configuration.sSink) / ((configuration.sSink*configuration.sSink - configuration.sSpreader*configuration.sSpreader) / 4.0);
+
+	/* Lateral resistances of package substrate, solder and PCB */
+	r_sub1_x = getThermalResistance(K_SUB, (configuration.sSub - floorplanWidth)/4.0, (configuration.sSub + 3*floorplanHeight)/4.0 * configuration.tSub);
+	r_sub1_y = getThermalResistance(K_SUB, (configuration.sSub - floorplanHeight)/4.0, (configuration.sSub + 3*floorplanWidth)/4.0 * configuration.tSub);
+	r_solder1_x = getThermalResistance(K_SOLDER, (configuration.sSolder - floorplanWidth)/4.0, (configuration.sSolder + 3*floorplanHeight)/4.0 * configuration.tSolder);
+	r_solder1_y = getThermalResistance(K_SOLDER, (configuration.sSolder - floorplanHeight)/4.0, (configuration.sSolder + 3*floorplanWidth)/4.0 * configuration.tSolder);
+	r_pcb1_x = getThermalResistance(K_PCB, (configuration.sSolder - floorplanWidth)/4.0, (configuration.sSolder + 3*floorplanHeight)/4.0 * configuration.tPcb);
+	r_pcb1_y = getThermalResistance(K_PCB, (configuration.sSolder - floorplanHeight)/4.0, (configuration.sSolder + 3*floorplanWidth)/4.0 * configuration.tPcb);
+	r_pcb2_x = getThermalResistance(K_PCB, (configuration.sSolder - floorplanWidth)/4.0, (3*configuration.sSolder + floorplanHeight)/4.0 * configuration.tPcb);
+	r_pcb2_y = getThermalResistance(K_PCB, (configuration.sSolder - floorplanHeight)/4.0, (3*configuration.sSolder + floorplanWidth)/4.0 * configuration.tPcb);
+	r_pcb = getThermalResistance(K_PCB, (configuration.sPcb - configuration.sSolder)/4.0, (configuration.sPcb + 3*configuration.sSolder)/4.0 * configuration.tPcb);
+
+	/* Vertical resistances of package substrate, solder balls and PCB */
+	r_sub_per_x = getThermalResistance(K_SUB, configuration.tSub, (configuration.sSub + floorplanHeight) * (configuration.sSub - floorplanWidth) / 4.0);
+	r_sub_per_y = getThermalResistance(K_SUB, configuration.tSub, (configuration.sSub + floorplanWidth) * (configuration.sSub - floorplanHeight) / 4.0);
+	r_solder_per_x = getThermalResistance(K_SOLDER, configuration.tSolder, (configuration.sSolder + floorplanHeight) * (configuration.sSolder - floorplanWidth) / 4.0);
+	r_solder_per_y = getThermalResistance(K_SOLDER, configuration.tSolder, (configuration.sSolder + floorplanWidth) * (configuration.sSolder - floorplanHeight) / 4.0);
+	r_pcb_c_per_x = getThermalResistance(K_PCB, configuration.tPcb, (configuration.sSolder + floorplanHeight) * (configuration.sSolder - floorplanWidth) / 4.0);
+	r_pcb_c_per_y = getThermalResistance(K_PCB, configuration.tPcb, (configuration.sSolder + floorplanWidth) * (configuration.sSolder - floorplanHeight) / 4.0);
+	r_pcb_per = getThermalResistance(K_PCB, configuration.tPcb, (configuration.sPcb*configuration.sPcb - configuration.sSolder*configuration.sSolder) / 4.0);
+
+	/* Vertical resistances to ambient at PCB (divide r_convec_sec proportional to area) */
+	r_amb_sec_c_per_x = configuration.rConvecSec * (configuration.sPcb * configuration.sPcb) / ((configuration.sSolder + floorplanHeight) * (configuration.sSolder - floorplanWidth) / 4.0);
+	r_amb_sec_c_per_y = configuration.rConvecSec * (configuration.sPcb * configuration.sPcb) / ((configuration.sSolder + floorplanWidth) * (configuration.sSolder - floorplanHeight) / 4.0);
+	r_amb_sec_per = configuration.rConvecSec * (configuration.sPcb * configuration.sPcb) / ((configuration.sPcb*configuration.sPcb - configuration.sSolder*configuration.sSolder) / 4.0);
+}
+
+
+
+
+void Package::loadC(const MatexConfigurationParameters &configuration, const double &floorplanWidth, const double &floorplanHeight)
+{
+	/* Vertical C's of spreader and sink */
+	c_sp_per_x = getThermalCapacitance(configuration.pSpreader, configuration.tSpreader, (configuration.sSpreader + floorplanHeight) * (configuration.sSpreader - floorplanWidth) / 4.0);
+	c_sp_per_y = getThermalCapacitance(configuration.pSpreader, configuration.tSpreader, (configuration.sSpreader + floorplanWidth) * (configuration.sSpreader - floorplanHeight) / 4.0);
+	c_hs_c_per_x = getThermalCapacitance(configuration.pSink, configuration.tSink, (configuration.sSpreader + floorplanHeight) * (configuration.sSpreader - floorplanWidth) / 4.0);
+	c_hs_c_per_y = getThermalCapacitance(configuration.pSink, configuration.tSink, (configuration.sSpreader + floorplanWidth) * (configuration.sSpreader - floorplanHeight) / 4.0);
+	c_hs_per = getThermalCapacitance(configuration.pSink, configuration.tSink, (configuration.sSink*configuration.sSink - configuration.sSpreader*configuration.sSpreader) / 4.0);
+
+	/* Vertical C's to ambient (divide configuration.cConvec proportional to area) */
+	c_amb_c_per_x = C_FACTOR * configuration.cConvec / (configuration.sSink * configuration.sSink) * ((configuration.sSpreader + floorplanHeight) * (configuration.sSpreader - floorplanWidth) / 4.0);
+	c_amb_c_per_y = C_FACTOR * configuration.cConvec / (configuration.sSink * configuration.sSink) * ((configuration.sSpreader + floorplanWidth) * (configuration.sSpreader - floorplanHeight) / 4.0);
+	c_amb_per = C_FACTOR * configuration.cConvec / (configuration.sSink * configuration.sSink) * ((configuration.sSink*configuration.sSink - configuration.sSpreader*configuration.sSpreader) / 4.0);
+
+	/* Vertical C's of package substrate, solder balls, and PCB */
+	c_sub_per_x = getThermalCapacitance(SPEC_HEAT_SUB, configuration.tSub, (configuration.sSub + floorplanHeight) * (configuration.sSub - floorplanWidth) / 4.0);
+	c_sub_per_y = getThermalCapacitance(SPEC_HEAT_SUB, configuration.tSub, (configuration.sSub + floorplanWidth) * (configuration.sSub - floorplanHeight) / 4.0);
+	c_solder_per_x = getThermalCapacitance(SPEC_HEAT_SOLDER, configuration.tSolder, (configuration.sSolder + floorplanHeight) * (configuration.sSolder - floorplanWidth) / 4.0);
+	c_solder_per_y = getThermalCapacitance(SPEC_HEAT_SOLDER, configuration.tSolder, (configuration.sSolder + floorplanWidth) * (configuration.sSolder - floorplanHeight) / 4.0);
+	c_pcb_c_per_x = getThermalCapacitance(SPEC_HEAT_PCB, configuration.tPcb, (configuration.sSolder + floorplanHeight) * (configuration.sSolder - floorplanWidth) / 4.0);
+	c_pcb_c_per_y = getThermalCapacitance(SPEC_HEAT_PCB, configuration.tPcb, (configuration.sSolder + floorplanWidth) * (configuration.sSolder - floorplanHeight) / 4.0);
+	c_pcb_per = getThermalCapacitance(SPEC_HEAT_PCB, configuration.tPcb, (configuration.sPcb*configuration.sPcb - configuration.sSolder*configuration.sSolder) / 4.0);
+
+	/* Vertical C's to ambient at PCB (divide configuration.cConvec_sec proportional to area) */
+	c_amb_sec_c_per_x = C_FACTOR * configuration.cConvecSec / (configuration.sPcb * configuration.sPcb) * ((configuration.sSolder + floorplanHeight) * (configuration.sSolder - floorplanWidth) / 4.0);
+	c_amb_sec_c_per_y = C_FACTOR * configuration.cConvecSec / (configuration.sPcb * configuration.sPcb) * ((configuration.sSolder + floorplanWidth) * (configuration.sSolder - floorplanHeight) / 4.0);
+	c_amb_sec_per = C_FACTOR * configuration.cConvecSec / (configuration.sPcb * configuration.sPcb) * ((configuration.sPcb*configuration.sPcb - configuration.sSolder*configuration.sSolder) / 4.0);
+}
+
+
+
+
+
+
+
+
+
+
+RCmodel::RCmodel()
+{
+	numberUnits = 0;
+	numberNodesAmbient = 0;
+	numberThermalNodes = 0;
+	numberGridLayers = 0;
+}
+
+
+
+bool RCmodel::load(const MatexConfigurationParameters &configuration, Floorplan &floorplan, const bool &doTransient)
+{
+	if(configuration.modelType == MatexConfigurationParameters::BLOCK){
+		if(loadRblock(configuration, floorplan)){
+			if(doTransient){
+				if(loadCblock(configuration, floorplan)){
+					return true;
+				}
+				else{
+					return false;
+				}
+			}
+			else{
+				return true;
+			}
+		}
+		else{
+			return false;
+		}
+	}
+	else if(configuration.modelType == MatexConfigurationParameters::GRID){
+		if(loadRgrid(configuration, floorplan)){
+			if(doTransient){
+				if(loadCgrid(configuration, floorplan)){
+					return true;
+				}
+				else{
+					return false;
+				}
+			}
+			else{
+				return true;
+			}
+		}
+		else{
+			return false;
+		}
+	}
+
+	return false;
+}
+
+
+
+
+bool RCmodel::loadRblock(const MatexConfigurationParameters &configuration, Floorplan &floorplan)
+{
+	if(floorplan.getNumberFunctionalUnits() <= 0){
+		return false;
+	}
+
+	numberUnits = floorplan.getNumberFunctionalUnits();
+	numberNodesAmbient = numberUnits + EXTRA_NODES;
+	numberThermalNodes = NUMBER_BLOCK_LAYERS*numberUnits + EXTRA_NODES;
+
+	double floorplanWidth = floorplan.getWidth();
+	double floorplanHeight = floorplan.getHeight();
+
+	/*	Sanity check on floorplan sizes	*/
+	if ( (floorplanWidth > configuration.sSink) ||
+		 (floorplanHeight > configuration.sSink) ||
+		 (floorplanWidth > configuration.sSpreader) ||
+		 (floorplanHeight > configuration.sSpreader)){
+
+		floorplan.print();
+		cout << "Error: Inordinate floorplan size." << endl;
+		exit(1);
+	}
+
+	Gx.resize(numberUnits);
+	Gy.resize(numberUnits);
+	GxInterface.resize(numberUnits);
+	GyInterface.resize(numberUnits);
+	GxSpreader.resize(numberUnits);
+	GySpreader.resize(numberUnits);
+	GxHeatSink.resize(numberUnits);
+	GyHeatSink.resize(numberUnits);
+	LenghtSharedEdge.resize(numberUnits,numberUnits);
+
+	B.resize(numberThermalNodes,numberThermalNodes);
+	C.resize(numberThermalNodes,numberThermalNodes);
+	G.resize(numberThermalNodes);
+	for(int i = 0; i < numberThermalNodes; i++)
+		G(i) = 0;
+	Gamb.resize(numberUnits + EXTRA_NODES);
+	for(int i = 0; i < numberUnits + EXTRA_NODES; i++)
+		Gamb(i) = 0;
+	conductances.resize(numberThermalNodes,numberThermalNodes);
+	for(int i = 0; i < numberThermalNodes; i++)
+		for(int j = 0; j < numberThermalNodes; j++)
+			conductances(i,j) = 0;
+	border.resize(numberUnits, 4);
+
+	/* Gx's and Gy's of blocks	*/
+	for (int i = 0; i < numberUnits; i++) {
+		/* At the silicon layer	*/
+		if (configuration.blockOmitLateral) {
+			Gx(i) = 0;
+			Gy(i) = 0;
+		}
+		else {
+			Gx(i) = 1.0/getThermalResistance(configuration.kChip, floorplan.units[i].width / 2.0, floorplan.units[i].height * configuration.tChip);
+			Gy(i) = 1.0/getThermalResistance(configuration.kChip, floorplan.units[i].height / 2.0, floorplan.units[i].width * configuration.tChip);
+		}
+
+		/* At the interface layer	*/
+		GxInterface(i) = 1.0/getThermalResistance(configuration.kInterface, floorplan.units[i].width / 2.0, floorplan.units[i].height * configuration.tInterface);
+		GyInterface(i) = 1.0/getThermalResistance(configuration.kInterface, floorplan.units[i].height / 2.0, floorplan.units[i].width * configuration.tInterface);
+
+		/* At the spreader layer	*/
+		GxSpreader(i) = 1.0/getThermalResistance(configuration.kSpreader, floorplan.units[i].width / 2.0, floorplan.units[i].height * configuration.tSpreader);
+		GySpreader(i) = 1.0/getThermalResistance(configuration.kSpreader, floorplan.units[i].height / 2.0, floorplan.units[i].width * configuration.tSpreader);
+
+		/* At the heat sink layer	*/
+		GxHeatSink(i) = 1.0/getThermalResistance(configuration.kSink, floorplan.units[i].width / 2.0, floorplan.units[i].height * configuration.tSink);
+		GyHeatSink(i) = 1.0/getThermalResistance(configuration.kSink, floorplan.units[i].height / 2.0, floorplan.units[i].width * configuration.tSink);
+	}
+
+	/* Shared lengths between blocks	*/
+	for (int i = 0; i < numberUnits; i++){
+		for (int j = i; j < numberUnits; j++){
+			LenghtSharedEdge(i,j) = floorplan.getSharedLength(i,j);
+			LenghtSharedEdge(j,i) = LenghtSharedEdge(i,j);
+		}
+	}
+
+
+	/* Load the information of the package	*/
+	package.loadR(configuration, floorplanWidth, floorplanHeight);
+
+
+
+
+
+
+	double gn_sp = 0, gs_sp = 0, ge_sp = 0, gw_sp = 0;
+	double gn_hs = 0, gs_hs = 0, ge_hs = 0, gw_hs = 0;
+
+
+
+
+	/* short the R's from block centers to a particular chip edge	*/
+	for (int i = 0; i < numberUnits; i++) {
+		if (equalTo(floorplan.units[i].bottom + floorplan.units[i].height, floorplanHeight)) {
+			gn_sp += GySpreader(i);
+			gn_hs += GyHeatSink(i);
+			border(i,2) = 1;	/* block is on northern border 	*/
+		} else
+			border(i,2) = 0;
+
+		if (equalTo(floorplan.units[i].bottom, 0)) {
+			gs_sp += GySpreader(i);
+			gs_hs += GyHeatSink(i);
+			border(i,3) = 1;	/* block is on southern border	*/
+		} else
+			border(i,3) = 0;
+
+		if (equalTo(floorplan.units[i].left + floorplan.units[i].width, floorplanWidth)) {
+			ge_sp += GxSpreader(i);
+			ge_hs += GxHeatSink(i);
+			border(i,1) = 1;	/* block is on eastern border	*/
+		} else
+			border(i,1) = 0;
+
+		if (equalTo(floorplan.units[i].left, 0)) {
+			gw_sp += GxSpreader(i);
+			gw_hs += GxHeatSink(i);
+			border(i,0) = 1;	/* block is on western border	*/
+		} else
+			border(i,0) = 0;
+	}
+
+	/* Overall Rs between nodes */
+	for (int i = 0; i < numberUnits; i++) {
+		double area = floorplan.units[i].getArea();
+		/* Amongst functional units	in the various layers	*/
+		for (int j = 0; j < numberUnits; j++) {
+			double part = 0, part_int = 0, part_sp = 0, part_hs = 0;
+			if (floorplan.isHorizontalAdjacent(i, j)) {
+				part = Gx(i) / floorplan.units[i].height;
+				part_int = GxInterface(i) / floorplan.units[i].height;
+				part_sp = GxSpreader(i) / floorplan.units[i].height;
+				part_hs = GxHeatSink(i) / floorplan.units[i].height;
+			}
+			else if (floorplan.isVerticallyAdjacent(i, j))  {
+				part = Gy(i) / floorplan.units[i].width;
+				part_int = GyInterface(i) / floorplan.units[i].width;
+				part_sp = GySpreader(i) / floorplan.units[i].width;
+				part_hs = GyHeatSink(i) / floorplan.units[i].width;
+			}
+			conductances(i, j) = part * LenghtSharedEdge(i, j);
+			conductances(IFACE*numberUnits + i, IFACE*numberUnits + j) = part_int * LenghtSharedEdge(i,j);
+			conductances(HSP*numberUnits + i, HSP*numberUnits + j) = part_sp * LenghtSharedEdge(i,j);
+			conductances(HSINK*numberUnits + i, HSINK*numberUnits + j) = part_hs * LenghtSharedEdge(i,j);
+		}
+		/* The 2.0 factor in the following equations is explained during the calculation of the B matrix	*/
+ 		/* Vertical g's in the silicon layer	*/
+		conductances(i, IFACE*numberUnits + i) = conductances(IFACE*numberUnits + i, i) = 2.0/getThermalResistance(configuration.kChip, configuration.tChip, area);
+ 		/* Vertical g's in the interface layer	*/
+		conductances(IFACE*numberUnits + i, HSP*numberUnits + i) = conductances(HSP*numberUnits + i, IFACE*numberUnits + i) = 2.0/getThermalResistance(configuration.kInterface, configuration.tInterface, area);
+		/* Vertical g's in the spreader layer	*/
+		conductances(HSP*numberUnits + i, HSINK*numberUnits + i) = conductances(HSINK*numberUnits + i, HSP*numberUnits + i) = 2.0/getThermalResistance(configuration.kSpreader, configuration.tSpreader, area);
+		/* Vertical g's in the heatsink core layer	*/
+		/* Vertical R to ambient: divide r_convec proportional to area	*/
+		double r_amb = configuration.rConvec * (configuration.sSink * configuration.sSink) / area;
+		Gamb(i) = 1.0 / (getThermalResistance(configuration.kSink, configuration.tSink, area) + r_amb);
+
+		/* lateral g's from block center (spreader layer) to peripheral (n,s,e,w) spreader nodes	*/
+		conductances(HSP*numberUnits + i, NUMBER_BLOCK_LAYERS*numberUnits + SP_N) = conductances(NUMBER_BLOCK_LAYERS*numberUnits + SP_N, HSP*numberUnits + i) = 2.0*border(i,2) / ((1.0/GySpreader(i)) + package.r_sp1_y*gn_sp/GySpreader(i));
+		conductances(HSP*numberUnits + i, NUMBER_BLOCK_LAYERS*numberUnits + SP_S) = conductances(NUMBER_BLOCK_LAYERS*numberUnits + SP_S, HSP*numberUnits + i) = 2.0*border(i,3) / ((1.0/GySpreader(i)) + package.r_sp1_y*gs_sp/GySpreader(i));
+		conductances(HSP*numberUnits + i, NUMBER_BLOCK_LAYERS*numberUnits + SP_E) = conductances(NUMBER_BLOCK_LAYERS*numberUnits + SP_E, HSP*numberUnits + i) = 2.0*border(i,1) / ((1.0/GxSpreader(i)) + package.r_sp1_x*ge_sp/GxSpreader(i));
+		conductances(HSP*numberUnits + i, NUMBER_BLOCK_LAYERS*numberUnits + SP_W) = conductances(NUMBER_BLOCK_LAYERS*numberUnits + SP_W, HSP*numberUnits + i) = 2.0*border(i,0) / ((1.0/GxSpreader(i)) + package.r_sp1_x*gw_sp/GxSpreader(i));
+
+		/* lateral g's from block center (heatsink layer) to peripheral (n,s,e,w) heatsink nodes	*/
+		conductances(HSINK*numberUnits + i, NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_N) = conductances(NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_N, HSINK*numberUnits + i) = 2.0*border(i,2) / ((1.0/GyHeatSink(i)) + package.r_hs1_y*gn_hs/GyHeatSink(i));
+		conductances(HSINK*numberUnits + i, NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_S) = conductances(NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_S, HSINK*numberUnits + i) = 2.0*border(i,3) / ((1.0/GyHeatSink(i)) + package.r_hs1_y*gs_hs/GyHeatSink(i));
+		conductances(HSINK*numberUnits + i, NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_E) = conductances(NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_E, HSINK*numberUnits + i) = 2.0*border(i,1) / ((1.0/GxHeatSink(i)) + package.r_hs1_x*ge_hs/GxHeatSink(i));
+		conductances(HSINK*numberUnits + i, NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_W) = conductances(NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_W, HSINK*numberUnits + i) = 2.0*border(i,0) / ((1.0/GxHeatSink(i)) + package.r_hs1_x*gw_hs/GxHeatSink(i));
+	}
+
+	/* g's from peripheral(n,s,e,w) nodes	*/
+	/* vertical g's between peripheral spreader nodes and center peripheral heatsink nodes */
+	conductances(NUMBER_BLOCK_LAYERS*numberUnits + SP_N, NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_N) = conductances(NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_N, NUMBER_BLOCK_LAYERS*numberUnits + SP_N) = 2.0/package.r_sp_per_y;
+	conductances(NUMBER_BLOCK_LAYERS*numberUnits + SP_S, NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_S) = conductances(NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_S, NUMBER_BLOCK_LAYERS*numberUnits + SP_S) = 2.0/package.r_sp_per_y;
+	conductances(NUMBER_BLOCK_LAYERS*numberUnits + SP_E, NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_E) = conductances(NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_E, NUMBER_BLOCK_LAYERS*numberUnits + SP_E) = 2.0/package.r_sp_per_x;
+	conductances(NUMBER_BLOCK_LAYERS*numberUnits + SP_W, NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_W) = conductances(NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_W, NUMBER_BLOCK_LAYERS*numberUnits + SP_W) = 2.0/package.r_sp_per_x;
+	/* lateral g's between peripheral outer sink nodes and center peripheral sink nodes	*/
+	conductances(NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_N, NUMBER_BLOCK_LAYERS*numberUnits + SINK_N) = conductances(NUMBER_BLOCK_LAYERS*numberUnits + SINK_N, NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_N) = 2.0/(package.r_hs + package.r_hs2_y);
+	conductances(NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_S, NUMBER_BLOCK_LAYERS*numberUnits + SINK_S) = conductances(NUMBER_BLOCK_LAYERS*numberUnits + SINK_S, NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_S) = 2.0/(package.r_hs + package.r_hs2_y);
+	conductances(NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_E, NUMBER_BLOCK_LAYERS*numberUnits + SINK_E) = conductances(NUMBER_BLOCK_LAYERS*numberUnits + SINK_E, NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_E) = 2.0/(package.r_hs + package.r_hs2_x);
+	conductances(NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_W, NUMBER_BLOCK_LAYERS*numberUnits + SINK_W) = conductances(NUMBER_BLOCK_LAYERS*numberUnits + SINK_W, NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_W) = 2.0/(package.r_hs + package.r_hs2_x);
+	/* vertical g's between inner peripheral sink nodes and ambient	*/
+	Gamb(numberUnits + SINK_C_N) = Gamb(numberUnits + SINK_C_S) = 1.0 / (package.r_hs_c_per_y + package.r_amb_c_per_y);
+	Gamb(numberUnits + SINK_C_E) = Gamb(numberUnits + SINK_C_W) = 1.0 / (package.r_hs_c_per_x + package.r_amb_c_per_x);
+	/* vertical g's between outer peripheral sink nodes and ambient	*/
+	Gamb(numberUnits + SINK_N) = Gamb(numberUnits + SINK_S) = Gamb(numberUnits + SINK_E) = Gamb(numberUnits + SINK_W) = 1.0 / (package.r_hs_per + package.r_amb_per);
+
+
+	/* Calculate matrix B such that BT = POWER in steady state */
+	/* Non-diagonal elements	*/
+	for (int i = 0; i < numberThermalNodes; i++)
+		for (int j = 0; j < i; j++)
+			if ((conductances(i,j) == 0.0) || (conductances(j,i) == 0.0))
+				B(i,j) = B(j,i) = 0.0;
+			else
+				/* Here is why the 2.0 factor comes when calculating conductances(,)	*/
+				B(i,j) = B(j,i) = -1.0/((1.0/conductances(i,j))+(1.0/conductances(j,i)));
+	/* Diagonal elements	*/
+	for (int i = 0; i < numberThermalNodes; i++) {
+		/* Functional blocks in the heat sink layer	*/
+		if (i >= HSINK*numberUnits && i < NUMBER_BLOCK_LAYERS*numberUnits)
+			B(i,i) = Gamb(i%numberUnits);
+		/* Heat sink peripheral nodes	*/
+		else if (i >= NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_W)
+			B(i,i) = Gamb(numberUnits + i - NUMBER_BLOCK_LAYERS*numberUnits);
+		/* All other nodes that are not connected to the ambient	*/
+		else
+			B(i,i) = 0.0;
+		/* Sum up the conductances	*/
+		for(int j = 0; j < numberThermalNodes; j++)
+			if (i != j)
+				B(i,i) -= B(i,j);
+	}
+
+	cout << "SANTIAGO: Inversing B" << endl;
+	/* Fill the inverse of matrix B	*/
+	Binv = B.inverse();
+
+	cout << "SANTIAGO: B inversed" << endl;
+
+	/* Fill the G vector from the Gamb vector	*/
+	for (int n = 0; n < Gamb.rows(); n++){
+		G(n + numberThermalNodes - Gamb.rows()) = Gamb(n);
+	}
+
+	cout << "SANTIAGO: Finished loadR" << endl;
+
+	/* vertical conductances to ambient	*/
+	//model->t_vector = dvector(m);/* scratch pad	*/
+	//model->p = ivector(m);		/* permutation vector for b's LUP decomposition	*/
+	/* Compute the LUP decomposition of B and store it too	*/
+	//Matrix<double, Dynamic, Dynamic> LU;
+	//LU = B;
+
+	/*
+	 * B is a symmetric positive definite matrix. It is
+	 * symmetric because if a node A is connected to B,
+	 * then B is also connected to A with the same R value.
+	 * It is positive definite because of the following
+	 * informal argument from Professor Lieven Vandenberghe's
+	 * lecture slides for the spring 2004-2005 EE 103 class
+	 * at UCLA: http://www.ee.ucla.edu/~vandenbe/103/chol.pdf
+	 * x^T*B*x = voltage^T * (B*x) = voltage^T * current
+	 * = total power dissipated in the resistors > 0
+	 * for x != 0.
+	 */
+	//lupdcmp(lu, NUMBER_BLOCK_LAYERS*numberUnits + EXTRA, p, 1);
+
+
+
+
+	return true;
+}
+
+
+
+
+
+
+
+
+
+bool RCmodel::loadCblock(const MatexConfigurationParameters &configuration, Floorplan &floorplan)
+{
+	double floorplanWidth = floorplan.getWidth();
+	double floorplanHeight = floorplan.getHeight();
+
+	/* Load the information of the package	*/
+	package.loadC(configuration, floorplanWidth, floorplanHeight);
+
+	A.resize(numberThermalNodes);
+	Ainv.resize(numberThermalNodes);
+
+	/* Functional block C's */
+	for (int i = 0; i < numberUnits; i++) {
+		double area = floorplan.units[i].getArea();
+		/* C's from functional units to ground	*/
+		A(i) = getThermalCapacitance(configuration.pChip, configuration.tChip, area);
+		/* C's from interface portion of the functional units to ground	*/
+		A(IFACE*numberUnits + i) = getThermalCapacitance(configuration.pInterface, configuration.tInterface, area);
+		/* C's from spreader portion of the functional units to ground	*/
+		A(HSP*numberUnits + i) = getThermalCapacitance(configuration.pSpreader, configuration.tSpreader, area);
+		/* C's from heatsink portion of the functional units to ground	*/
+		/* vertical C to ambient: divide configuration.cConvec proportional to area	*/
+		double c_amb = C_FACTOR * configuration.cConvec / (configuration.sSink * configuration.sSink) * area;
+		A(HSINK*numberUnits + i) = getThermalCapacitance(configuration.pSink, configuration.tSink, area) + c_amb;
+	}
+
+	/* C's from peripheral(n,s,e,w) nodes	*/
+ 	/* from peripheral spreader nodes to ground	*/
+	A(NUMBER_BLOCK_LAYERS*numberUnits + SP_N) = A(NUMBER_BLOCK_LAYERS*numberUnits + SP_S) = package.c_sp_per_y;
+	A(NUMBER_BLOCK_LAYERS*numberUnits + SP_E) = A(NUMBER_BLOCK_LAYERS*numberUnits + SP_W) = package.c_sp_per_x;
+ 	/* From center peripheral sink nodes to ground
+	 * NOTE: this treatment of capacitances (and the corresponding treatment of resistances in loadRblock) as parallel (series)
+	 * is only approximate and is done in order to avoid creating an extra layer of nodes.
+	 */
+	A(NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_N) = A(NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_S) = package.c_hs_c_per_y + package.c_amb_c_per_y;
+	A(NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_E) = A(NUMBER_BLOCK_LAYERS*numberUnits + SINK_C_W) = package.c_hs_c_per_x + package.c_amb_c_per_x;
+	/* From outer peripheral sink nodes to ground	*/
+	A(NUMBER_BLOCK_LAYERS*numberUnits + SINK_N)= A(NUMBER_BLOCK_LAYERS*numberUnits + SINK_S) = A(NUMBER_BLOCK_LAYERS*numberUnits + SINK_E) = A(NUMBER_BLOCK_LAYERS*numberUnits + SINK_W) = package.c_hs_per + package.c_amb_per;
+
+	/* Calculate A^-1 (for diagonal matrix A) such that A(dT) + BT = POWER */
+	for (int i = 0; i < numberThermalNodes; i++)
+		Ainv(i) = 1.0/A(i);
+
+	/* We are always going to use the eqn dT = - A^-1 * B T + A^-1 * POWER. so, store  C = - A^-1 * B	*/
+	C = Ainv.asDiagonal() * B;
+	for(int i = 0; i < numberThermalNodes; i++)
+		for(int j = 0; j < numberThermalNodes; j++)
+			if(C(i,j) != 0)
+				C(i,j) = - C(i,j);
+
+
+	return true;
+}
+
+
+
+
+
+void RCmodel::populateDefaultGridLayers(const MatexConfigurationParameters &configuration, Floorplan &floorplan)
+{
+	LayerInformation siliconLayer, interfaceMaterialLayer;
+
+	/* Silicon layer	*/
+	siliconLayer.has_lateral = true;
+	siliconLayer.has_power = false;
+	siliconLayer.k = configuration.kChip;
+	siliconLayer.thickness = configuration.tChip;
+	siliconLayer.sp = configuration.pChip;
+	siliconLayer.layerFloorplan = floorplan;
+	gridLayers.push_back(siliconLayer);
+
+
+	/* Interface material layer	*/
+	interfaceMaterialLayer.has_lateral = true;
+	interfaceMaterialLayer.has_power = false;
+	interfaceMaterialLayer.k = configuration.kInterface;
+	interfaceMaterialLayer.thickness = configuration.tInterface;
+	interfaceMaterialLayer.sp = configuration.pInterface;
+	interfaceMaterialLayer.layerFloorplan = floorplan;
+	gridLayers.push_back(interfaceMaterialLayer);
+
+	if (configuration.modelSecondary == true){
+		LayerInformation metalLayer, c4UnderfillLayer;
+
+		/* Metal layer	*/
+		metalLayer.has_lateral = true;
+		metalLayer.has_power = false;
+		metalLayer.k = K_METAL;
+		metalLayer.k1 = K_DIELECTRIC;
+		metalLayer.thickness = configuration.tMetal;
+		metalLayer.sp = SPEC_HEAT_METAL;
+		metalLayer.layerFloorplan = floorplan;
+		gridLayers.push_back(metalLayer);
+
+
+		/* C4/underfill layer*/
+		c4UnderfillLayer.has_lateral = true;
+		c4UnderfillLayer.has_power = false;
+		c4UnderfillLayer.k = K_C4;
+		c4UnderfillLayer.k1 = K_UNDERFILL;
+		c4UnderfillLayer.thickness = configuration.tC4;
+		c4UnderfillLayer.sp = SPEC_HEAT_C4;
+		c4UnderfillLayer.sp1 = SPEC_HEAT_UNDERFILL;
+		c4UnderfillLayer.layerFloorplan = floorplan;
+		gridLayers.push_back(c4UnderfillLayer);
+	}
+}
+
+
+
+
+
+void RCmodel::appendPackageLayers(const MatexConfigurationParameters &configuration)
+{
+	if(gridLayers.size() <= 0)
+		return;
+
+	LayerInformation spreaderLayer, heatsinkLayer;
+	Floorplan lastFloorplan = gridLayers[gridLayers.size() - 1].layerFloorplan;
+
+	/* Spreader layer	*/
+	spreaderLayer.has_lateral = true;
+	spreaderLayer.has_power = false;
+	spreaderLayer.k = configuration.kSpreader;
+	spreaderLayer.thickness = configuration.tSpreader;
+	spreaderLayer.sp = configuration.pSpreader;
+	spreaderLayer.layerFloorplan = lastFloorplan;
+	gridLayers.push_back(spreaderLayer);
+
+
+	/* Heatsink layer	*/
+	heatsinkLayer.has_lateral = true;
+	heatsinkLayer.has_power = false;
+	heatsinkLayer.k = configuration.kSink;
+	heatsinkLayer.thickness = configuration.tSink;
+	heatsinkLayer.sp = configuration.pSink;
+	heatsinkLayer.layerFloorplan = lastFloorplan;
+	gridLayers.push_back(heatsinkLayer);
+
+
+	if (configuration.modelSecondary) {
+		LayerInformation packagaeSubstrateLayer, solderBallsLayer, pcbLayer;
+
+		/* Package substrate layer	*/
+		packagaeSubstrateLayer.has_lateral = true;
+		packagaeSubstrateLayer.has_power = false;
+		packagaeSubstrateLayer.k = K_SUB;
+		packagaeSubstrateLayer.thickness = configuration.tSub;
+		packagaeSubstrateLayer.sp = SPEC_HEAT_SUB;
+		packagaeSubstrateLayer.layerFloorplan = lastFloorplan;
+		gridLayers.push_back(packagaeSubstrateLayer);
+
+
+		/* Solder balls layer	*/
+		solderBallsLayer.has_lateral = true;
+		solderBallsLayer.has_power = false;
+		solderBallsLayer.k = K_SOLDER;
+		solderBallsLayer.thickness = configuration.tSolder;
+		solderBallsLayer.sp = SPEC_HEAT_SOLDER;
+		solderBallsLayer.layerFloorplan = lastFloorplan;
+		gridLayers.push_back(solderBallsLayer);
+
+
+		/* PCB layer	*/
+		pcbLayer.has_lateral = true;
+		pcbLayer.has_power = false;
+		pcbLayer.k = K_PCB;
+		pcbLayer.thickness = configuration.tPcb;
+		pcbLayer.sp = SPEC_HEAT_PCB;
+		pcbLayer.layerFloorplan = lastFloorplan;
+		gridLayers.push_back(pcbLayer);
+	}
+}
+
+
+
+
+
+void RCmodel::parseLayerFile(const string &fileName)
+{
+	ifstream inputGridLayerFile;
+	if(fileName.size() > 0){
+		inputGridLayerFile.open(fileName.c_str());
+		if(inputGridLayerFile.is_open()){
+			if(inputGridLayerFile.good() == false){
+				cout << "Error: Input grid layer file: \"" << fileName << "\" could not be open for reading." << endl;
+				inputGridLayerFile.close();
+				exit(1);
+			}
+		}
+		else{
+			cout << "Error: Input grid layer file: \"" << fileName << "\" could not be open for reading." << endl;
+			exit(1);
+		}
+	}
+	else{
+		return;
+	}
+
+
+	int significantLinesInFile = 0;
+	int field = 0;
+	vector<int> layerOrder;
+	LayerInformation auxLayer;
+	double floorplanWidth = 0;
+	double floorplanHeight = 0;
+
+
+	// Read until the end of the file
+	while(inputGridLayerFile.good()){
+		// Read one line from the file
+		string line;
+		getline(inputGridLayerFile, line);
+
+		// If the line was successfully read
+		if(inputGridLayerFile.good()){
+			// If the line is not a comment
+			if(line.size() > 0){
+				if(line[0] != '#'){
+					switch (field){
+						case LCF_SNO:
+							//int layerNumber;
+							try{
+								int iValue;
+								stringstream streamValue(line);
+								streamValue.exceptions(stringstream::goodbit);
+								streamValue >> iValue;
+								if((streamValue.rdstate() == stringstream::goodbit) || (streamValue.rdstate() == stringstream::eofbit)){
+									for(unsigned int i = 0; layerOrder.size(); i++){
+										if(layerOrder[i] == iValue){
+											cout << "Error in layer configuration file: The layer number must be unique values." << endl;
+											inputGridLayerFile.close();
+											exit(1);
+										}
+									}
+									layerOrder.push_back(iValue);
+								}
+								else{
+									cout << "Error in layer configuration file: The layer number should be an integer value." << endl;
+									inputGridLayerFile.close();
+									exit(1);
+								}
+							}
+							catch(...){
+								cout << "Error in layer configuration file: The layer number should be an integer value." << endl;
+								inputGridLayerFile.close();
+								exit(1);
+							}
+							break;
+						case LCF_LATERAL:
+							if(line.size() == 1){
+								if((line[0] == 'Y') || (line[0] == 'y')){
+									auxLayer.has_lateral = true;
+								}
+								else if((line[0] == 'N') || (line[0] == 'n')){
+									auxLayer.has_lateral = false;
+								}
+								else{
+									cout << "Error in layer configuration file: Invalid layer heat flow indicator." << endl;
+									inputGridLayerFile.close();
+									exit(1);
+								}
+							}
+							else{
+								cout << "Error in layer configuration file: Invalid layer heat flow indicator." << endl;
+								inputGridLayerFile.close();
+								exit(1);
+							}
+							break;
+						case LCF_POWER:
+							if(line.size() == 1){
+								if((line[0] == 'Y') || (line[0] == 'y')){
+									auxLayer.has_power = true;
+								}
+								else if((line[0] == 'N') || (line[0] == 'n')){
+									auxLayer.has_power = false;
+								}
+								else{
+									cout << "Error in layer configuration file: Invalid layer power dissipation indicator." << endl;
+									inputGridLayerFile.close();
+									exit(1);
+								}
+							}
+							else{
+								cout << "Error in layer configuration file: Invalid layer power dissipation indicator." << endl;
+								inputGridLayerFile.close();
+								exit(1);
+							}
+							break;
+						case LCF_SP:
+							try{
+								double dValue;
+								stringstream streamValue(line);
+								streamValue.exceptions(stringstream::goodbit);
+								streamValue >> dValue;
+								if((streamValue.rdstate() == stringstream::goodbit) || (streamValue.rdstate() == stringstream::eofbit)){
+									auxLayer.sp = dValue;
+								}
+								else{
+									cout << "Error in layer configuration file: Invalid specific heat." << endl;
+									inputGridLayerFile.close();
+									exit(1);
+								}
+							}
+							catch(...){
+								cout << "Error in layer configuration file: Invalid specific heat." << endl;
+								inputGridLayerFile.close();
+								exit(1);
+							}
+							break;
+						case LCF_RHO:
+							try{
+								double dValue;
+								stringstream streamValue(line);
+								streamValue.exceptions(stringstream::goodbit);
+								streamValue >> dValue;
+								if((streamValue.rdstate() == stringstream::goodbit) || (streamValue.rdstate() == stringstream::eofbit)){
+									auxLayer.k = 1.0 / dValue;
+								}
+								else{
+									cout << "Error in layer configuration file: Invalid resistivity." << endl;
+									inputGridLayerFile.close();
+									exit(1);
+								}
+							}
+							catch(...){
+								cout << "Error in layer configuration file: Invalid resistivity." << endl;
+								inputGridLayerFile.close();
+								exit(1);
+							}
+							break;
+						case LCF_THICK:
+							try{
+								double dValue;
+								stringstream streamValue(line);
+								streamValue.exceptions(stringstream::goodbit);
+								streamValue >> dValue;
+								if((streamValue.rdstate() == stringstream::goodbit) || (streamValue.rdstate() == stringstream::eofbit)){
+									auxLayer.thickness = dValue;
+								}
+								else{
+									cout << "Error in layer configuration file: Invalid thickness." << endl;
+									inputGridLayerFile.close();
+									exit(1);
+								}
+							}
+							catch(...){
+								cout << "Error in layer configuration file: Invalid thickness." << endl;
+								inputGridLayerFile.close();
+								exit(1);
+							}
+							break;
+						case LCF_FLP:
+							if(auxLayer.layerFloorplan.readFloorplan(line, false) == false){
+								cout << "Error in layer configuration file: There are no functional units in the floorplan." << endl;
+								inputGridLayerFile.close();
+								exit(1);
+							}
+
+							/* First layer	*/
+							if (significantLinesInFile < LCF_NPARAMS) {
+								floorplanWidth = auxLayer.layerFloorplan.getWidth();
+								floorplanHeight = auxLayer.layerFloorplan.getHeight();
+							}
+							else if((equalTo(floorplanWidth, auxLayer.layerFloorplan.getWidth()) == false) || (equalTo(floorplanHeight, auxLayer.layerFloorplan.getHeight()) == false)){
+								cout << "Error in layer configuration file: Width and height differ across layers." << endl;
+								inputGridLayerFile.close();
+								exit(1);
+							}
+
+							gridLayers.push_back(auxLayer);
+
+							break;
+						default:
+							cout << "Error in layer configuration file: Invalid field number." << endl;
+							inputGridLayerFile.close();
+							exit(1);
+							break;
+					}
+					field = (field + 1) % LCF_NPARAMS;
+					significantLinesInFile++;
+				}
+			}
+		}
+	}
+	inputGridLayerFile.close();
+
+
+	if (significantLinesInFile % LCF_NPARAMS){
+		cout << "Error: Wrong number of lines in layer file." << endl;
+		exit(1);
+	}
+}
+
+
+
+
+/* setup the block and grid mapping data structures	*/
+void RCmodel::set_bgmap(const MatexConfigurationParameters &configuration, Floorplan &floorplan, LayerInformation &layer)
+{
+	/* i1, i2, j1 and j2 are indices of the boundary grid cells	*/
+	int i1, i2, j1, j2;
+
+
+	double floorplanWidth = floorplan.getWidth();
+	double floorplanHeight = floorplan.getHeight();
+	double cellWidth = floorplanWidth / configuration.gridCols;
+	double cellHeight = floorplanHeight / configuration.gridRows;
+
+	int numberUnitsFloorplan = layer.layerFloorplan.getNumberFunctionalUnits();
+
+
+	/* Initialize	*/
+	layer.b2gmap.resize(configuration.gridRows, configuration.gridCols);
+	for(int i = 0; i < configuration.gridRows; i++){
+		for(int j = 0; j < configuration.gridCols; j++){
+			layer.b2gmap(i,j).blocks.clear();
+		}
+	}
+	layer.g2bmap.resize(numberUnitsFloorplan);
+
+
+	/* For each functional unit	*/
+	for(unsigned int u = 0; u < (unsigned int)numberUnitsFloorplan; u++) {
+		/* Shortcuts for unit boundaries	*/
+		double lu = layer.layerFloorplan.units[u].left;
+		double ru = lu + layer.layerFloorplan.units[u].width;
+		double bu = layer.layerFloorplan.units[u].bottom;
+		double tu = bu + layer.layerFloorplan.units[u].height;
+
+		/* top index (lesser row) = rows - ceil (top / cell height)	*/
+		i1 = configuration.gridRows - tolerant_ceil(tu/cellHeight);
+		/* bottom index (greater row) = rows - floor (bottom / cell height)	*/
+		i2 = configuration.gridRows - tolerant_floor(bu/cellHeight);
+		/* left index = floor (left / cell width)	*/
+		j1 = tolerant_floor(lu/cellWidth);
+		/* right index = ceil (right / cell width)	*/
+		j2 = tolerant_ceil(ru/cellWidth);
+		/* sanity check	*/
+		if((i1 < 0) || (j1 < 0)){
+			cout << "Error: Negative grid cell start index!" << endl;
+			exit(1);
+		}
+		if((i2 > configuration.gridRows) || (j2 > configuration.gridCols)){
+			cout << "Error: Grid cell end index out of bounds!" << endl;
+			exit(1);
+		}
+		if((i1 >= i2) || (j1 >= j2)){
+			cout << "Error: Invalid floorplan spec or grid resolution" << endl;
+			exit(1);
+		}
+
+		/* Setup g2bmap	*/
+		layer.g2bmap(u).i1 = i1;
+		layer.g2bmap(u).i2 = i2;
+		layer.g2bmap(u).j1 = j1;
+		layer.g2bmap(u).j2 = j2;
+
+		/* Setup b2gmap	*/
+		/* For each grid cell in this unit	*/
+		for(int i = i1; i < i2; i++){
+			for(int j = j1; j < j2; j++){
+				/* Grid cells fully overlapped by this unit	*/
+				if ((i > i1) && (i < i2-1) && (j > j1) && (j < j2-1)) {
+
+					if (layer.b2gmap(i,j).blocks.size() != 0){
+						/* This should not occur since the grid cell is fully covered and hence, no other unit should be sharing it	*/
+						cout << "Warning: Overlap of functional blocks?" << endl;
+					}
+
+					layer.b2gmap(i,j).append(u, 1.0);
+				}
+				/* Boundary grid cells partially overlapped by this unit	*/
+				else {
+					/* Shortcuts for cell boundaries	*/
+					double lc = j * cellWidth, rc = (j+1) * cellWidth;
+					double tc = floorplanHeight - i * cellHeight;
+					double bc = floorplanHeight - (i+1) * cellHeight;
+
+					/* Shortcuts for overlap width and height	*/
+					double oh = (minimum(tu, tc) - maximum(bu, bc));
+					double ow = (minimum(ru, rc) - maximum(lu, lc));
+					double occupancy;
+
+					/* Overlap tolerance	*/
+					if (equalTo(oh/cellHeight, 0))
+						oh = 0;
+					else if (equalTo(oh/cellHeight, 1))
+						oh = cellHeight;
+
+					if (equalTo(ow/cellWidth, 0))
+						ow = 0;
+					else if (equalTo(ow/cellWidth, 1))
+						ow = cellWidth;
+
+					occupancy = (oh * ow) / (cellHeight * cellWidth);
+					if (oh < 0 || ow < 0){
+						cout << "Error: negative overlap!" << endl;
+						exit(1);
+					}
+
+
+					layer.b2gmap(i,j).append(u, occupancy);
+				}
+			}
+		}
+	}
+}
+
+
+
+
+
+void RCmodel::populateGridLayers(const MatexConfigurationParameters &configuration, Floorplan &floorplan)
+{
+	/* Read in values from the layer configuration file when specified	*/
+	if(configuration.fileNameGridLayer.size() > 0){
+		if (configuration.modelSecondary == true){
+			cout << "Error: Modeling secondary heat transfer path not supported when layer configuration file specified..." << endl;
+			exit(1);
+		}
+		else{
+			parseLayerFile(configuration.fileNameGridLayer);
+		}
+		cout << "Warning: Layer configuration file specified. Overriding default floorplan with those in the layer configuration file..." << endl;
+	}
+	else{
+		/* Populate default set of layers	*/
+		numberUnits = floorplan.getNumberFunctionalUnits();
+		populateDefaultGridLayers(configuration, floorplan);
+	}
+
+
+	/* Append the package layers	*/
+	appendPackageLayers(configuration);
+}
+
+
+
+
+
+
+
+
+bool RCmodel::loadRgrid(const MatexConfigurationParameters &configuration, Floorplan &floorplan)
+{
+	if ((configuration.gridRows & (configuration.gridRows-1)) ||
+		(configuration.gridCols & (configuration.gridCols-1))){
+		cout << "Error: The number of grid rows and grid columns should both be powers of two." << endl;
+		exit(1);
+	}
+
+	/* Check if there is a layer configuration file specified	*/
+	bool hasLayerConfigurationFile;
+	if(configuration.fileNameGridLayer.size() > 0){
+		hasLayerConfigurationFile = true;
+	}
+	else{
+		hasLayerConfigurationFile = false;
+		numberUnits = floorplan.getNumberFunctionalUnits();
+	}
+
+
+
+	/* Get layer information	*/
+	populateGridLayers(configuration, floorplan);
+
+
+	/* count the total no. of blocks */
+	//model->total_n_blocks = 0;
+	//for(unsigned int i = 0; i < gridLayer.size(); i++)
+	//	model->total_n_blocks += gridLayer[i].flp->n_units;
+
+
+
+
+	double floorplanWidth;
+	double floorplanHeight;
+	int inner_layers;
+
+
+	if (configuration.modelSecondary)
+		inner_layers = gridLayers.size() - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS;
+	else
+		inner_layers = gridLayers.size() - DEFAULT_PACK_LAYERS;
+
+
+
+	/* Setup the block-grid maps; flp parameter is ignored */
+	if (hasLayerConfigurationFile){
+		if(inner_layers > 0){
+			for(int i = 0; i < inner_layers; i++){
+				set_bgmap(configuration, floorplan, gridLayers[i]);
+			}
+			for(unsigned int i = inner_layers; i < gridLayers.size(); i++){
+				gridLayers[i].b2gmap = gridLayers[inner_layers - 1].b2gmap;
+				gridLayers[i].g2bmap = gridLayers[inner_layers - 1].g2bmap;
+			}
+		}
+	}
+	/* Only the silicon layer has allocated space for the maps. All the rest just point to it. so it is sufficient to setup the block-grid map for the silicon layer alone.
+	 * Further, for default layer configuration, the `flp' parameter should be the same as that of the silicon layer. Finally, the chip width and height information
+	 * need to be populated for default layer configuration.
+	 */
+	else {
+		floorplanWidth = floorplan.getWidth();
+		floorplanHeight = floorplan.getHeight();
+		if(gridLayers.size() > 0){
+			set_bgmap(configuration, floorplan, gridLayers[0]);
+			for(unsigned int i = 1; i < gridLayers.size(); i++){
+				gridLayers[i].b2gmap = gridLayers[0].b2gmap;
+				gridLayers[i].g2bmap = gridLayers[0].g2bmap;
+			}
+		}
+	}
+
+
+	/*	Sanity check on floorplan sizes	*/
+	if ( (floorplanWidth > configuration.sSink) ||
+		 (floorplanHeight > configuration.sSink) ||
+		 (floorplanWidth > configuration.sSpreader) ||
+		 (floorplanHeight > configuration.sSpreader)){
+
+		floorplan.print();
+		cout << "Error: Inordinate floorplan size." << endl;
+		exit(1);
+	}
+
+
+	double cellWidth = floorplanWidth / configuration.gridCols;
+	double cellHeight = floorplanHeight / configuration.gridRows;
+	double cellArea = cellWidth * cellHeight;
+
+
+
+	/* Load the information of the package	*/
+	package.loadR(configuration, floorplanWidth, floorplanHeight);
+
+
+
+	/* Layer specific resistances	*/
+	for(int i = 0; i < (int)gridLayers.size(); i++) {
+		if (gridLayers[i].has_lateral) {
+			gridLayers[i].rx =  getThermalResistance(gridLayers[i].k, cellWidth, cellHeight * gridLayers[i].thickness);
+			gridLayers[i].ry =  getThermalResistance(gridLayers[i].k, cellHeight, cellWidth * gridLayers[i].thickness);
+			if (configuration.modelSecondary && (i == inner_layers-SEC_CHIP_LAYERS+LAYER_C4)) {
+				gridLayers[i].rx1 =  getThermalResistance(gridLayers[i].k1, cellWidth, cellHeight * gridLayers[i].thickness);
+				gridLayers[i].ry1 =  getThermalResistance(gridLayers[i].k1, cellHeight, cellWidth * gridLayers[i].thickness);
+			}
+		}
+		else {
+			/* Positive infinity	*/
+			gridLayers[i].rx = DBL_MAX;
+			gridLayers[i].ry = DBL_MAX;
+			if (configuration.modelSecondary && (i == inner_layers - SEC_CHIP_LAYERS + LAYER_C4)) {
+				gridLayers[i].rx1 = DBL_MAX;
+				gridLayers[i].ry1 = DBL_MAX;
+			}
+		}
+		gridLayers[i].rz =  getThermalResistance(gridLayers[i].k, gridLayers[i].thickness, cellArea);
+		if (configuration.modelSecondary && (i == inner_layers - SEC_CHIP_LAYERS + LAYER_C4)) {
+			gridLayers[i].rz1 =  getThermalResistance(gridLayers[i].k1, gridLayers[i].thickness, cellArea);
+		}
+
+		if (configuration.modelSecondary == false) {
+			/* Heatsink	is connected to ambient. divide r_convec proportional to cell area */
+			if (i == (int)gridLayers.size() - DEFAULT_PACK_LAYERS + LAYER_SINK)
+				gridLayers[i].rz += configuration.rConvec * (configuration.sSink * configuration.sSink) / cellArea;
+		}
+		else {
+			/* Heatsink	is connected to ambient. divide r_convec proportional to cell area */
+			if (i == (int)gridLayers.size() - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SINK)
+				gridLayers[i].rz += configuration.rConvec * (configuration.sSink * configuration.sSink) / cellArea;
+		}
+	}
+
+
+	return true;
+}
+
+
+bool RCmodel::loadCgrid(const MatexConfigurationParameters &configuration, Floorplan &floorplan)
+{
+
+
+	return true;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+void RCmodel::print(void)
+{
+	if((B.rows() == 0) || (B.cols() == 0)){
+		cout << "Matrix B is empty." << endl;
+	}
+	else{
+		cout << "Matrix B(" << B.rows() << "," << B.cols() << "):" << endl;
+		cout << B << endl << endl;
+	}
+
+	if((Binv.rows() == 0) || (Binv.cols() == 0)){
+		cout << "Matrix B^-1 is empty." << endl;
+	}
+	else{
+		cout << "Matrix B^-1(" << Binv.rows() << "," << Binv.cols() << "):" << endl;
+		cout << Binv << endl << endl;
+	}
+
+	if((A.rows() == 0) || (A.cols() == 0)){
+		cout << "Matrix A is empty." << endl;
+	}
+	else{
+		Matrix<double, Dynamic, Dynamic> auxMatrix = A.asDiagonal();
+		cout << "Matrix A(" << auxMatrix.rows() << "," << auxMatrix.cols() << "):" << endl;
+		cout << auxMatrix << endl << endl;
+	}
+
+	if((Ainv.rows() == 0) || (Ainv.cols() == 0)){
+		cout << "Matrix A^-1 is empty." << endl;
+	}
+	else{
+		Matrix<double, Dynamic, Dynamic> auxMatrix = Ainv.asDiagonal();
+		cout << "Matrix A^-1(" << auxMatrix.rows() << "," << auxMatrix.cols() << "):" << endl;
+		cout << auxMatrix << endl << endl;
+	}
+
+	if((C.rows() > 0) && (C.cols() > 0)){
+		cout << "Matrix C(" << C.rows() << "," << C.cols() << "):" << endl;
+		cout << C << endl << endl;
+	}
+
+	if((G.rows() == 0) || (G.cols() == 0)){
+		cout << "Vector G is empty." << endl;
+	}
+	else{
+		cout << "Vector G:" << G.rows() << "):" << endl;
+		cout << G << endl << endl;
+	}
+}
diff -Naur sniper-6.1_old/common/scheduler/rcModel.h sniper-6.1/common/scheduler/rcModel.h
--- sniper-6.1_old/common/scheduler/rcModel.h	1970-01-01 01:00:00.000000000 +0100
+++ sniper-6.1/common/scheduler/rcModel.h	2017-08-01 14:34:55.480037000 +0200
@@ -0,0 +1,574 @@
+/**	\file	rcModel.h
+ *	\brief	Header file for RC thermal network class.
+ */
+#ifndef RCMODEL_H_
+#define RCMODEL_H_
+
+#include <iostream>
+#include <stdio.h>
+#include <stdlib.h>
+#include <algorithm>
+#include <unistd.h>
+#include <string.h>
+#include <vector>
+#include <string>
+#include <fstream>
+#include <sstream>
+#include <stdexcept>
+#include <Eigen/Dense>
+#include <float.h>
+
+#include "floorplan.h"
+#include "matexConfigurationParameters.h"
+
+using namespace std;
+using namespace Eigen;
+
+
+
+
+
+
+
+/**	\brief	Model specific constant: fitting factor to match floworks (due to lumping). Changed from 1/2 to 1/3 due to the difference from traditional Elmore Delay scenario.
+ */
+#define C_FACTOR	0.333
+
+
+/*	Typical thermal properties for secondary path layers	*/
+#define RHO_METAL	0.0025
+#define RHO_DIELECTRIC	1.0
+#define RHO_C4	0.8
+#define RHO_UNDERFILL 0.03
+#define	RHO_SUB	0.5
+#define RHO_SOLDER	0.06
+#define RHO_PCB	0.333
+#define K_METAL	(1.0/RHO_METAL)
+#define K_DIELECTRIC (1.0/RHO_DIELECTRIC)
+#define K_C4	(1.0/RHO_C4)
+#define K_UNDERFILL (1.0/RHO_UNDERFILL)
+#define K_SUB	(1.0/RHO_SUB)
+#define K_SOLDER	(1.0/RHO_SOLDER)
+#define K_PCB	(1.0/RHO_PCB)
+//FIXME! the following values need to be found
+#define SPEC_HEAT_METAL	3.55e6					/**< \brief	Specfic heat of silicon in [Joule/(meters^3 * Kelvin].					*/
+#define SPEC_HEAT_DIELECTRIC	2.2e6
+#define SPEC_HEAT_C4	1.65e6
+#define SPEC_HEAT_UNDERFILL	2.65e6
+#define SPEC_HEAT_SUB	1.6e6					/**< \brief	Specific heat of copper in [Joule/(meters^3 * Kelvin].					*/
+#define SPEC_HEAT_SOLDER	2.1e6				/**< \brief	Specific heat of the interface material in [Joule/(meters^3 * Kelvin].	*/
+#define SPEC_HEAT_PCB	1.32e6
+
+
+
+
+/* grid model differs from the block model in its use of
+ * a mesh of cells whose resolution is configurable. unlike
+ * the block model, it can also model a stacked 3-D chip,
+ * with each layer having a different floorplan. information
+ * about the floorplan and the properties of each layer is
+ * input in the form of a layer configuration file.
+ */
+
+/*  */
+#define LCF_NPARAMS			7	/**< \brief	Layer configuration file constant: Number of parameters per layer.	*/
+#define LCF_SNO				0	/**< \brief	Layer configuration file constant: Serial number.					*/
+#define LCF_LATERAL			1	/**< \brief	Layer configuration file constant: Has lateral heat flow?			*/
+#define LCF_POWER			2	/**< \brief	Layer configuration file constant: Dissipates power?				*/
+#define LCF_SP				3	/**< \brief	Layer configuration file constant: Specific heat capacity.			*/
+#define LCF_RHO				4	/**< \brief	Layer configuration file constant: Resistivity.						*/
+#define LCF_THICK			5	/**< \brief	Layer configuration file constant: Thickness.						*/
+#define LCF_FLP				6	/**< \brief	Layer configuration file constant: Floorplan file.					*/
+
+
+
+#define DEFAULT_CHIP_LAYERS	2	/**< \brief	Default number of chip layers (excluding spreader and sink). Used when LCF file is not specified.	*/
+#define LAYER_SI			0
+#define LAYER_INT			1
+
+#define SEC_CHIP_LAYERS	2		/**< \brief	Layers of secondary path with same area as die.		*/
+#define LAYER_METAL 0
+#define LAYER_C4	1
+
+#define DEFAULT_PACK_LAYERS	2	/**< \brief	Default number of package layers.					*/
+#define LAYER_SP			0
+#define LAYER_SINK			1
+
+#define SEC_PACK_LAYERS	3		/**< \brief	Additional package layers from secondary path.		*/
+#define LAYER_SUB	0
+#define LAYER_SOLDER	1
+#define LAYER_PCB	2
+
+
+
+
+
+/**	\brief	Class that stores the package parameters.
+ *
+ *	Class that stores the package parameters.
+ */
+class Package{
+public:
+	double r_sp1_x;								/**< \brief	Lateral resistance: Peripheral spreader nodes.		*/
+	double r_sp1_y;								/**< \brief	Lateral resistance: Peripheral spreader nodes.		*/
+	double r_hs1_x;								/**< \brief	Lateral resistance: Sink's inner periphery.			*/
+	double r_hs1_y;								/**< \brief	Lateral resistance: Sink's inner periphery.			*/
+	double r_hs2_x;								/**< \brief	Lateral resistance: Sink's inner periphery.			*/
+	double r_hs2_y;								/**< \brief	Lateral resistance: Sink's inner periphery.			*/
+	double r_hs;								/**< \brief	Lateral resistance: Sink's outer periphery.			*/
+
+	double r_sp_per_x;							/**< \brief	Vertical resistance: Peripheral spreader nodes.		*/
+	double r_sp_per_y;							/**< \brief	Vertical resistance: Peripheral spreader nodes.		*/
+	double r_hs_c_per_x;						/**< \brief	Vertical resistance: Sink's inner periphery.		*/
+	double r_hs_c_per_y;						/**< \brief	Vertical resistance: Sink's inner periphery.		*/
+	double r_hs_per;							/**< \brief	Vertical resistance: Sink's outer periphery.		*/
+
+	double c_sp_per_x;							/**< \brief	Vertical capacitance: Peripheral spreader nodes.	*/
+	double c_sp_per_y;							/**< \brief	Vertical capacitance: Peripheral spreader nodes.	*/
+	double c_hs_c_per_x;						/**< \brief	Vertical capacitance: Sink's inner periphery.		*/
+	double c_hs_c_per_y;						/**< \brief	Vertical capacitance: Sink's inner periphery.		*/
+	double c_hs_per;							/**< \brief	Vertical capacitance: Sink's outer periphery.		*/
+
+	double r_amb_c_per_x;						/**< \brief	Vertical resistance to ambient: Sink's inner periphery.		*/
+	double c_amb_c_per_x;						/**< \brief	Vertical capacitance to ambient: Sink's inner periphery.	*/
+	double r_amb_c_per_y;						/**< \brief	Vertical resistance to ambient: Sink's inner periphery.		*/
+	double c_amb_c_per_y;						/**< \brief	Vertical capacitance to ambient: Sink's inner periphery.	*/
+	double r_amb_per;							/**< \brief	Vertical resistance to ambient: Sink's outer periphery.		*/
+	double c_amb_per;							/**< \brief	Vertical capacitance to ambient: Sink's outer periphery.	*/
+
+	double r_sub1_x;							/**< \brief	Secondary path lateral resistance: Peripheral package substrate nodes.		*/
+	double r_sub1_y;							/**< \brief	Secondary path lateral resistance: Peripheral package substrate nodes.		*/
+	double r_solder1_x;							/**< \brief	Secondary path lateral resistance: Peripheral solder ball nodes.			*/
+	double r_solder1_y;							/**< \brief	Secondary path lateral resistance: Peripheral solder ball nodes.			*/
+	double r_pcb1_x;							/**< \brief	Secondary path lateral resistance: PCB's inner periphery.					*/
+	double r_pcb1_y;							/**< \brief	Secondary path lateral resistance: PCB's inner periphery.					*/
+	double r_pcb2_x;							/**< \brief	Secondary path lateral resistance: PCB's inner periphery.					*/
+	double r_pcb2_y;							/**< \brief	Secondary path lateral resistance: PCB's inner periphery.					*/
+	double r_pcb;								/**< \brief	Secondary path lateral resistance: PCB's outer periphery.					*/
+
+
+	double r_sub_per_x;							/**< \brief	Secondary path vertical resistance: Peripheral package substrate nodes.		*/
+	double r_sub_per_y;							/**< \brief	Secondary path vertical resistance: Peripheral package substrate nodes.		*/
+	double r_solder_per_x;						/**< \brief	Secondary path vertical resistance: Peripheral solder ball nodes.			*/
+	double r_solder_per_y;						/**< \brief	Secondary path vertical resistance: Peripheral solder ball nodes.			*/
+	double r_pcb_c_per_x;						/**< \brief	Secondary path vertical resistance: PCB's inner periphery.					*/
+	double r_pcb_c_per_y;						/**< \brief	Secondary path vertical resistance: PCB's inner periphery.					*/
+	double r_pcb_per;							/**< \brief	Secondary path vertical resistance: PCB's outer periphery.					*/
+
+	double c_sub_per_x;							/**< \brief	Secondary path vertical capacitances: Peripheral package substrate nodes.	*/
+	double c_sub_per_y;							/**< \brief	Secondary path vertical capacitances: Peripheral package substrate nodes.	*/
+	double c_solder_per_x;						/**< \brief	Secondary path vertical capacitances: Peripheral solder ball nodes.			*/
+	double c_solder_per_y;						/**< \brief	Secondary path vertical capacitances: Peripheral solder ball nodes.			*/
+	double c_pcb_c_per_x;						/**< \brief	Secondary path vertical capacitances: PCB's inner periphery.				*/
+	double c_pcb_c_per_y;						/**< \brief	Secondary path vertical capacitances: PCB's inner periphery.				*/
+	double c_pcb_per;							/**< \brief	Secondary path vertical capacitances: PCB's outer periphery.				*/
+
+	double r_amb_sec_c_per_x;					/**< \brief	Vertical resistance to ambient at PCB: PCB's inner periphery.		*/
+	double c_amb_sec_c_per_x;					/**< \brief	Vertical capacitances to ambient at PCB: PCB's inner periphery.		*/
+	double r_amb_sec_c_per_y;					/**< \brief	Vertical resistance to ambient at PCB: PCB's inner periphery.		*/
+	double c_amb_sec_c_per_y;					/**< \brief	Vertical capacitances to ambient at PCB: PCB's inner periphery.		*/
+	double r_amb_sec_per;						/**< \brief	Vertical resistance to ambient at PCB: PCB's outer periphery.		*/
+	double c_amb_sec_per;						/**< \brief	Vertical capacitances to ambient at PCB: PCB's outer periphery.		*/
+
+
+	/**	\brief	Method that loads all the R variables according to the configuration and floorplan size.
+	 *
+	 *	\param[in]	configuration		Configuration parameters.
+	 *	\param[in]	floorplanWidth		Width of the floorplan.
+	 *	\param[in]	floorplanHeight		Height of the floorplan.
+	 */
+	void loadR(const MatexConfigurationParameters &configuration, const double &floorplanWidth, const double &floorplanHeight);
+
+
+	/**	\brief	Method that loads all the C variables according to the configuration and floorplan size.
+	 *
+	 *	\param[in]	configuration		Configuration parameters.
+	 *	\param[in]	floorplanWidth		Width of the floorplan.
+	 *	\param[in]	floorplanHeight		Height of the floorplan.
+	 */
+	void loadC(const MatexConfigurationParameters &configuration, const double &floorplanWidth, const double &floorplanHeight);
+
+
+
+
+
+private:
+	/**	\brief	Compute the thermal resistance.
+	 *
+	 */
+	inline double getThermalResistance(const double &conductivity, const double &thickness, const double &area)
+	{
+		return thickness / (conductivity * area);
+	}
+
+
+	/**	\brief	Compute the thermal capacitance.
+	 *
+	 */
+	inline double getThermalCapacitance(const double &sp_heat, const double &thickness, const double &area)
+	{
+		/* Include lumped vs. distributed correction	*/
+		return C_FACTOR * sp_heat * thickness * area;
+	}
+};
+
+
+
+
+
+
+/**	\brief	Class that stores a list of blocks mapped to a grid cell.
+ *
+ *	Class that stores a list of blocks mapped to a grid cell.
+ */
+class BlockList{
+public:
+
+	/**	\brief	Block to grid mapping data structure.
+	 */
+	struct BlockListElement{
+		int blockIndex;			/**< \brief	Index of the mapped block.		*/
+		double occupancy;		/**< \brief	Ratio of this block's area within the grid cell to the total area of the grid cell.	*/
+	};
+
+
+	vector <BlockListElement> blocks;	/**< \brief	List of blocks mapped to a grid cell.	*/
+
+
+	inline void append(const int &newBlockIndex, const double &newOccupany)
+	{
+		BlockListElement newElement;
+		newElement.blockIndex = newBlockIndex;
+		newElement.occupancy = newOccupany;
+
+		blocks.push_back(newElement);
+	}
+};
+
+
+
+/**	\brief	Class that stores a the start and end indices of grid cells in a block (both in the x and y directions).
+ *
+ *	Class that stores a the start and end indices of grid cells in a block (both in the x and y directions).
+ */
+class GridList{
+public:
+
+	int i1;					/**< \brief	Start index in the y direction.		*/
+	int i2;					/**< \brief	End index in the y direction + 1.	*/
+	int j1;					/**< \brief	Start index in the x direction.		*/
+	int j2;					/**< \brief	End index in the x direction + 1.	*/
+};
+
+
+
+/**	\brief	Class that stores the layer information for the grid model.
+ *
+ *	Class that stores the layer information for the grid model.
+ */
+class LayerInformation{
+public:
+
+	bool has_lateral;					/**< \brief	Configuration parameter: Model lateral spreading of heat?		*/
+	bool has_power;						/**< \brief	Configuration parameter: Dissipates power?						*/
+	double k;							/**< \brief	Configuration parameter: Thermal conductivity.					*/
+	double k1;							/**< \brief	Configuration parameter: Thermal conductivity of the other material in some layers, such as C4/underfill.	*/
+	double thickness;					/**< \brief	Configuration parameter: Thickness.								*/
+	double sp;							/**< \brief	Configuration parameter: Specific heat capacity.				*/
+	double sp1;							/**< \brief	Configuration parameter: Specific heat of the other material in some layers, such as C4/underfill.			*/
+
+	double rx;							/**< \brief	Extracted information: x resistor.		*/
+	double ry;							/**< \brief	Extracted information: y resistor.		*/
+	double rz;							/**< \brief	Extracted information: z resistor.		*/
+	double rx1;							/**< \brief	Extracted information: Resistor of the other material in some layers, e.g. C4/underfill.				*/
+	double ry1;							/**< \brief	Extracted information: Resistor of the other material in some layers, e.g. C4/underfill.				*/
+	double rz1;							/**< \brief	Extracted information: Resistor of the other material in some layers, e.g. C4/underfill.				*/
+	double c;							/**< \brief	Extracted information: Capacitance.		*/
+	double c1;							/**< \brief	Extracted information: Capacitance.		*/
+
+	Floorplan layerFloorplan;			/**< \brief	Floorplan of the layer.					*/
+
+	Array<BlockList,Dynamic,Dynamic> b2gmap;		/**<\brief	Block-grid map: Every element in the array holds the information of which blocks are mapped to the corresponding grid cell.	*/
+
+	Array<GridList,Dynamic,1> g2bmap;		/**<\brief	Grid-block map: Every element in the array holds the information of which blocks are mapped to the corresponding grid cell.	*/
+};
+
+
+
+
+
+
+
+
+
+
+
+
+
+/**	\brief	Class that stores the RC thermal network.
+ *
+ *	Class that stores the RC thermal network.
+ */
+class RCmodel{
+public:
+	/**	\brief	Matrix B.
+	 */
+	Matrix<double, Dynamic, Dynamic> B;
+
+
+	/**	\brief	Inverse of matrix B.
+	 */
+	Matrix<double, Dynamic, Dynamic> Binv;
+
+	/**	\brief	Vector A (because A is a diagonal matrix).
+	 */
+	Matrix<double, Dynamic, 1> A;
+
+
+	/**	\brief	Inverse of vector A (because A is a diagonal matrix).
+	 */
+	Matrix<double, Dynamic, 1> Ainv;
+
+
+	/**	\brief	Matrix C.
+	 */
+	Matrix<double, Dynamic, Dynamic> C;
+
+
+	/**	\brief	Vector G.
+	 */
+	Matrix<double, Dynamic, 1> G;
+
+
+	/**	\brief	Vector Gamb. Is a partial copy of vector G.
+	 */
+	Matrix<double, Dynamic, 1> Gamb;
+
+
+
+	/**	\brief	Total number of functional units.
+	 */
+	int numberUnits;
+
+
+	/**	\brief	Total number of thermal nodes in contact with the ambient temperature.
+	 */
+	int numberNodesAmbient;
+
+
+	/**	\brief	Total number of thermal nodes.
+	 */
+	int numberThermalNodes;
+
+
+	/**	\brief	Total number of grid layers.
+	 */
+	int numberGridLayers;
+
+
+
+
+	/**	\brief	Method that loads the RC thermal network from the information in the floorplan.
+	 *
+	 *	\param[in]	configuration	Configuration parameters.
+	 *	\param[in]	floorplan		Floorplan information.
+	 *	\param[in]	doTransient		If true, load the entire RC thermal network. If false, matrix C is not needed so it is not loaded.
+	 *	\return						True if the RC thermal network was correctly loaded.
+	 */
+	bool load(const MatexConfigurationParameters &configuration, Floorplan &floorplan, const bool &doTransient);
+
+
+
+
+	/**	\brief	Method that prints the floorplan information.
+	 */
+	void print(void);
+
+
+
+
+	/**	\brief	Constructor. Initializes the variables.
+	 *
+	 */
+	RCmodel();
+
+
+
+
+private:
+
+	/**	\brief	Method that loads the RC thermal network for the steady-state computations from the information in the floorplan.
+	 *
+	 *	\param[in]	configuration	Configuration parameters.
+	 *	\param[in]	floorplan		Floorplan information.
+	 *	\return						True if the RC thermal network was correctly loaded.
+	 */
+	bool loadRblock(const MatexConfigurationParameters &configuration, Floorplan &floorplan);
+
+
+
+	/**	\brief	Method that loads the RC thermal network for the transient computations from the information in the floorplan.
+	 *
+	 *	\param[in]	configuration	Configuration parameters.
+	 *	\param[in]	floorplan		Floorplan information.
+	 *	\return						True if the RC thermal network was correctly loaded.
+	 */
+	bool loadCblock(const MatexConfigurationParameters &configuration, Floorplan &floorplan);
+
+
+
+	/**	\brief	Method that loads the RC thermal network for the steady-state computations from the information in the floorplan.
+	 *
+	 *	\param[in]	configuration	Configuration parameters.
+	 *	\param[in]	floorplan		Floorplan information.
+	 *	\return						True if the RC thermal network was correctly loaded.
+	 */
+	bool loadRgrid(const MatexConfigurationParameters &configuration, Floorplan &floorplan);
+
+
+
+	/**	\brief	Method that loads the RC thermal network for the transient computations from the information in the floorplan.
+	 *
+	 *	\param[in]	configuration	Configuration parameters.
+	 *	\param[in]	floorplan		Floorplan information.
+	 *	\return						True if the RC thermal network was correctly loaded.
+	 */
+	bool loadCgrid(const MatexConfigurationParameters &configuration, Floorplan &floorplan);
+
+
+
+	/**	\brief	Method that populates the grid layer information either from the default floorplan or from the layer configuration file.
+	 *
+	 *	\param[in]	configuration	Configuration parameters.
+	 *	\param[in]	floorplan		Floorplan information.
+	 */
+	void populateGridLayers(const MatexConfigurationParameters &configuration, Floorplan &floorplan);
+
+	/**	\brief	Method that populates the default grid layer information.
+	 *
+	 *	\param[in]	configuration	Configuration parameters.
+	 *	\param[in]	floorplan		Floorplan information.
+	 */
+	void populateDefaultGridLayers(const MatexConfigurationParameters &configuration, Floorplan &floorplan);
+
+	/**	\brief	Method that appends the layer information of the package.
+	 *
+	 *	\param[in]	configuration	Configuration parameters.
+	 */
+	void appendPackageLayers(const MatexConfigurationParameters &configuration);
+
+
+	/**	\brief	Method that parses the layer configuration file.
+	 *
+	 *	\param[in]	fileName			Name of the layer file to parse.
+	 */
+	void parseLayerFile(const string &fileName);
+
+	/**	\brief	Method that sets the block and grid mapping data of the layer.
+	 *
+	 *	\param[in]	configuration	Configuration parameters.
+	 *	\param[in]	floorplan		Floorplan information.
+	 *	\param[inout]	layer			Layer.
+	 */
+	void set_bgmap(const MatexConfigurationParameters &configuration, Floorplan &floorplan, LayerInformation &layer);
+
+	/**	\brief	Compute the thermal resistance.
+	 *
+	 */
+	inline double getThermalResistance(const double &conductivity, const double &thickness, const double &area)
+	{
+		return thickness / (conductivity * area);
+	}
+
+
+	/**	\brief	Compute the thermal capacitance.
+	 *
+	 */
+	inline double getThermalCapacitance(const double &sp_heat, const double &thickness, const double &area)
+	{
+		/* Include lumped vs. distributed correction	*/
+		return C_FACTOR * sp_heat * thickness * area;
+	}
+
+	/**	\brief	Compares two values under a certain margin of error.
+	 *
+	 */
+	inline bool equalTo(const double &x, const double &y)
+	{
+		return (fabs(x-y) < DELTA_EQUAL);
+	}
+
+	/**	\brief	Compares two values and return the minimum value.
+	 *
+	 */
+	inline double minimum(const double &x, const double &y)
+	{
+		return ((x < y)? x:y);
+	}
+
+	/**	\brief	Compares two values and return the maximum value.
+	 *
+	 */
+	inline double maximum(const double &x, const double &y)
+	{
+		return ((x > y)? x:y);
+	}
+
+	/**	\brief	Returns the ceiling function of the value, unless it is really close to an integer, case in which returns the integer.
+	 *
+	 */
+	inline int tolerant_ceil(double val)
+	{
+		double nearest = floor(val+0.5);
+		/* Numbers close to integers	*/
+		if (equalTo(val, nearest))
+			return ((int) nearest);
+		/* All others	*/
+		else
+			return ((int) ceil(val));
+	}
+
+	/**	\brief	Returns the floor function of the value, unless it is really close to an integer, case in which returns the integer.
+	 *
+	 */
+	inline int tolerant_floor(double val)
+	{
+		double nearest = floor(val+0.5);
+		if (equalTo(val, nearest))
+			return ((int) nearest);
+		else
+			return ((int) floor(val));
+	}
+
+
+
+	Matrix<double, Dynamic, 1> Gx;							/**< \brief	Lumped conductances in x direction.	*/
+	Matrix<double, Dynamic, 1> Gy;							/**< \brief	Lumped conductances in x direction.	*/
+	Matrix<double, Dynamic, 1> GxInterface;				/**< \brief	Lateral conductances in the interface layer.	*/
+	Matrix<double, Dynamic, 1> GyInterface;				/**< \brief	Lateral conductances in the interface layer.	*/
+	Matrix<double, Dynamic, 1> GxSpreader;					/**< \brief	Lateral conductances in the spreader layer.	*/
+	Matrix<double, Dynamic, 1> GySpreader;					/**< \brief	Lateral conductances in the spreader layer.	*/
+	Matrix<double, Dynamic, 1> GxHeatSink;					/**< \brief	Lateral conductances in the heat sink layer.	*/
+	Matrix<double, Dynamic, 1> GyHeatSink;					/**< \brief	Lateral conductances in the heat sink layer.	*/
+	Matrix<double, Dynamic, Dynamic> LenghtSharedEdge;		/**< \brief Length of shared edge between functional units.	*/
+	Matrix<double, Dynamic, Dynamic> conductances;			/**< \brief	Matrix with conductances: conductances(i,j) = conductance between thermal nodes i and j */
+
+	Matrix<int, Dynamic, Dynamic> border;
+
+	Package package;											/**< \brief	Package parameters.						*/
+	vector<LayerInformation> gridLayers;							/**< \brief	Vector with the layer information for the grid model.	*/
+};
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif /* RCMODEL_H_ */
diff -Naur sniper-6.1_old/common/scheduler/scheduler.h sniper-6.1/common/scheduler/scheduler.h
--- sniper-6.1_old/common/scheduler/scheduler.h	2015-03-24 16:56:51.000000000 +0100
+++ sniper-6.1/common/scheduler/scheduler.h	2017-08-01 14:34:53.608035000 +0200
@@ -17,6 +17,12 @@
       virtual bool threadSetAffinity(thread_id_t calling_thread_id, thread_id_t thread_id, size_t cpusetsize, const cpu_set_t *mask) { return false; }
       virtual bool threadGetAffinity(thread_id_t thread_id, size_t cpusetsize, cpu_set_t *mask) { return false; }
 
+	  /** Method to set the affinity of a thread ID to the specified core ID.
+          Particularly, method setAffinitySingle() of the thread_id element in vector
+		  m_thread_info is called by passing argument core_id.
+	   */
+      virtual void setAffinitySingle(thread_id_t thread_id, core_id_t core_id) { }
+
    protected:
       ThreadManager *m_thread_manager;
 
diff -Naur sniper-6.1_old/common/scheduler/scheduler_pinned_base.cc sniper-6.1/common/scheduler/scheduler_pinned_base.cc
--- sniper-6.1_old/common/scheduler/scheduler_pinned_base.cc	2015-03-24 16:56:51.000000000 +0100
+++ sniper-6.1/common/scheduler/scheduler_pinned_base.cc	2017-08-01 14:34:53.608035000 +0200
@@ -1,10 +1,70 @@
 #include "scheduler_pinned_base.h"
-#include "simulator.h"
-#include "core_manager.h"
-#include "performance_model.h"
-#include "os_compat.h"
+#include <math.h>
+
+#define OUTPUT_FILE_PRECISION	12
+
+
+#include "HotSpot/temperature.h"
+#include "HotSpot/temperature_grid.h"	/* for dump_steady_temp_grid	*/
+#include "HotSpot/flp.h"
+#include "HotSpot/util.h"
+
+static flp_t *flp;
+/* hotspot temperature model	*/
+static RC_model_t *model;
+/* instantaneous temperature and power values	*/
+//static double *temp, *power;
+/* steady state temperature and power values	*/
+static double *overall_power, *steady_temp;
+
+
+
+#define MAX_FREQUENCY	4000
+#define MIN_FREQUENCY	200
+#define FREQUENCY_STEP	200
+#define NOMINAL_FREQUENCY	2600
+
+#define THERMAL_HISTERESIS_BOOST_UP	0.5
+#define TURBO_BOOST_INTERVAL_NS	1000000
+
+#define CORE_INITIAL_POWER		1.167819
+#define CACHE_POWER_CONSUMPTION	0.72
+#define WINDOW_SIZE		10
+
+ConfigurationParameters configurationParameters;
+Matex matex;
+double* Temperature;
+double* Power;
+UInt64* currentIps;
+int numberUnitsInFloorplan;
+int numberThermalNodes;
+vector<bool> islandTurboBoostEnabled;
+vector<int> coresReservedForApplication;
+
+UInt64 lastTimeTurboBoostChange;
+
+UInt64 lastTimeHotSpotAndMyStatistics;
+
+bool firstTemperatureComputed;
+
+UInt64* accumulatedExecutedInstructions;
+double totalAccumulatedExecutedInstructions;
+double totalFinishedApplicationInstances;
+vector<double> accumulatedConsumedEnergy;
+double totalAccumulatedConsumedEnergy;
+
+ofstream outputScheduleTrace, outputFrequencyTrace, outputPowerTrace, outputEnergyTrace, outputAccumulatedEnergyTrace, outputIpsTrace, outputIpcTrace, outputThroughputTrace, outputInstructionsTrace, outputAccumulatedInstructionsTrace, outputTransientTemperatures, outputMaximumTransientTemperatures;
+bool saveOutputScheduleTrace, saveOutputFrequencyTrace, saveOutputPowerTrace, saveOutputEnergyTrace, saveOutputAccumulatedEnergyTrace, saveOutputIpsTrace, saveOutputIpcTrace, saveOutputThroughputTrace, saveOutputInstructionsTrace, saveOutputAccumulatedInstructionsTrace, saveOutputTransientTemperatures, saveOutputMaximumTransientTemperatures;
+
+
+vector< vector<UInt64> > accumulatedExecutedInstructionLastWindow;
+vector< vector<double> > cyclesExecutedLastWindow;
+vector< UInt64 > averageIPCinWindow;
+vector< vector<double> > temperatureWindow;
+vector< double > averageTemperatureInWindow;
+
+
 
-#include <sstream>
 
 // Pinned scheduler.
 // Each thread has is pinned to a specific core (m_thread_affinity).
@@ -18,8 +78,364 @@
    , m_core_thread_running(Sim()->getConfig()->getApplicationCores(), INVALID_THREAD_ID)
    , m_quantum_left(Sim()->getConfig()->getApplicationCores(), SubsecondTime::Zero())
 {
+	// We initialize the new variables created for log the new statistics, and compute
+    // the transient power consumption and temperature throughtout the chip.
+	Temperature = nullptr;
+	Power = nullptr;
+	currentIps = nullptr;
+	accumulatedExecutedInstructions = nullptr;
+	numberUnitsInFloorplan = 0;
+	numberThermalNodes = 0;
+
+	firstTemperatureComputed = true;
+
+	totalAccumulatedExecutedInstructions = 0;
+	totalFinishedApplicationInstances = 0;
+	totalAccumulatedConsumedEnergy = 0;
+	lastTimeHotSpotAndMyStatistics = 0;
+
+
+	// Read the configuration file for the new integration of Sniper.
+	// Note that the location of the configuration file is now hardcoded inside the 
+    // readConfigurationFile() method.
+	configurationParameters.readConfigurationFile();
+
+	// Verify the configuration
+	if(configurationParameters.verify() == false){
+		cout << "Error: The configuration has some invalid parameters." << endl;
+		exit(-1);
+	}
+	cout << "Configuration verified" << endl;
+
+
+
+	// Read the name of the floorplan file from the configuration file,
+	// initialize flp, and get the adjacency matrix
+	flp = read_flp(configurationParameters.fileNameFloorplan.c_str(), FALSE);
+	// Also load the floorplan to the Matex object
+	matex.loadFloorplan(configurationParameters.fileNameFloorplan);
+
+	// Configure thermal model parameters. default_thermal_config
+	// returns a set of default parameters. only those configuration
+	// parameters (config.*) that need to be changed are set explicitly.
+	thermal_config_t config = default_thermal_config();
+	strcpy(config.init_file, configurationParameters.fileNameInputInitialTemperatures.c_str());
+
+	// Read the configuration file from HotSpot used to derive the thermal model
+	MatexConfigurationParameters matexConfigurationParameters;
+	matexConfigurationParameters.readConfigurationFile(configurationParameters.fileNameConfigurationMatex);
+	if(matexConfigurationParameters.verify() == false){
+		cout << "Error: Matex's configuration file has some invalid parameters." << endl;
+		exit(-1);
+	}
+
+	// Load the thermal configuration from the parameters read in HotSpot's configuration file
+	config.t_chip = matexConfigurationParameters.tChip;
+	config.k_chip = matexConfigurationParameters.kChip;
+	config.p_chip = matexConfigurationParameters.pChip;
+
+	config.c_convec = matexConfigurationParameters.cConvec;
+	config.r_convec = matexConfigurationParameters.rConvec;
+	config.s_sink = matexConfigurationParameters.sSink;
+	config.t_sink = matexConfigurationParameters.tSink;
+	config.k_sink = matexConfigurationParameters.kSink;
+	config.p_sink = matexConfigurationParameters.pSink;
+
+	config.s_spreader = matexConfigurationParameters.sSpreader;
+	config.t_spreader = matexConfigurationParameters.tSpreader;
+	config.k_spreader = matexConfigurationParameters.kSpreader;
+	config.p_spreader = matexConfigurationParameters.pSpreader;
+
+	config.t_interface = matexConfigurationParameters.tInterface;
+	config.k_interface = matexConfigurationParameters.kInterface;
+	config.p_interface = matexConfigurationParameters.pInterface;
+
+	config.model_secondary = matexConfigurationParameters.modelSecondary;
+	config.r_convec_sec = matexConfigurationParameters.rConvecSec;
+	config.c_convec_sec = matexConfigurationParameters.cConvecSec;
+	config.n_metal = matexConfigurationParameters.nMetal;
+	config.t_metal = matexConfigurationParameters.tMetal;
+	config.t_c4 = matexConfigurationParameters.tC4;
+	config.s_c4 = matexConfigurationParameters.sC4;
+	config.n_c4 = matexConfigurationParameters.nC4;
+	config.s_sub = matexConfigurationParameters.sSub;
+	config.t_sub = matexConfigurationParameters.tSub;
+	config.s_solder = matexConfigurationParameters.sSolder;
+	config.t_solder = matexConfigurationParameters.tSolder;
+	config.s_pcb = matexConfigurationParameters.sPcb;
+	config.t_pcb = matexConfigurationParameters.tPcb;
+
+	config.ambient = configurationParameters.Tamb;
+	config.init_temp = matexConfigurationParameters.initTemp;
+	config.sampling_intvl = configurationParameters.samplingInterval;
+	config.base_proc_freq = 1 / configurationParameters.samplingInterval;
+	config.dtm_used = FALSE;
+	if(matexConfigurationParameters.modelType == MatexConfigurationParameters::GRID)
+		strcpy(config.model_type, "grid");
+	else
+		strcpy(config.model_type, "block");
+	config.leakage_used = matexConfigurationParameters.leakageUsed;
+	config.leakage_mode = (int)matexConfigurationParameters.leakageMode;
+	config.package_model_used = matexConfigurationParameters.packageModelUsed;
+	strcpy(config.package_config_file, matexConfigurationParameters.fileNamePackageConfig.c_str());
+	config.block_omit_lateral = matexConfigurationParameters.blockOmitLateral;
+
+	config.grid_rows = matexConfigurationParameters.gridRows;
+	config.grid_cols = matexConfigurationParameters.gridCols;
+	strcpy(config.grid_layer_file, matexConfigurationParameters.fileNameGridLayer.c_str());
+	if(matexConfigurationParameters.gridMapMode == MatexConfigurationParameters::AVERAGE)
+		strcpy(config.grid_map_mode, "avg");
+	else if(matexConfigurationParameters.gridMapMode == MatexConfigurationParameters::MIN)
+		strcpy(config.grid_map_mode, "min");
+	else if(matexConfigurationParameters.gridMapMode == MatexConfigurationParameters::MAX)
+		strcpy(config.grid_map_mode, "max");
+	else
+		strcpy(config.grid_map_mode, "center");
+
+	// Allocate and initialize the RC model
+	model = alloc_RC_model(&config, flp);
+	populate_R_model(model, flp);
+	populate_C_model(model, flp);
+
+	// Allocate the temperature and power arrays
+	// Using hotspot_vector to internally allocate any extra nodes needed
+	Temperature = hotspot_vector(model);
+	Power = hotspot_vector(model);
+	steady_temp = hotspot_vector(model);
+	overall_power = hotspot_vector(model);
+
+
+	// Set up initial instantaneous temperatures
+	if ((strlen(model->config->init_file) > 0) && strcmp(model->config->init_file, NULLFILE)) {
+		if (!model->config->dtm_used)
+			// Initial T = steady T for no DTM
+			read_temp(model, Temperature, model->config->init_file, FALSE);
+		else
+			// Initial T = clipped steady T with DTM
+			read_temp(model, Temperature, model->config->init_file, TRUE);
+	}
+	else
+		// No input file - use init_temp as the common temperature
+		set_temp(model, Temperature, model->config->init_temp);
+
+
+	numberUnitsInFloorplan = flp->n_units;
+
+	// Allocate memory for the auxiliary variables used for the new output logs
+	currentIps = new UInt64[numberUnitsInFloorplan];
+	if(currentIps == nullptr){
+		cout << "Error: Allocating memory for the power vector." << endl;
+		exit(-1);
+	}
+
+	accumulatedExecutedInstructions = new UInt64[numberUnitsInFloorplan];
+	if(accumulatedExecutedInstructions == nullptr){
+		delete[] currentIps;
+		cout << "Error: Allocating memory for the accumulatedExecutedInstructions vector." << endl;
+		exit(-1);
+	}
+
+	vector<UInt64> auxUIntVectorWindowSize;
+	vector<double> auxDoubleVectorWindowSize;
+	for(int i = 0; i < WINDOW_SIZE; i++){
+		auxUIntVectorWindowSize.push_back(0);
+		auxDoubleVectorWindowSize.push_back(0);
+	}
+	for(int i = 0; i < numberUnitsInFloorplan; i++){
+		Power[i] = 0;
+		currentIps[i] = 0;
+		accumulatedExecutedInstructions[i] = 0;
+		accumulatedConsumedEnergy.push_back(0);
+
+		accumulatedExecutedInstructionLastWindow.push_back(auxUIntVectorWindowSize);
+		cyclesExecutedLastWindow.push_back(auxDoubleVectorWindowSize);
+		averageIPCinWindow.push_back(0);
+		temperatureWindow.push_back(auxDoubleVectorWindowSize);
+		averageTemperatureInWindow.push_back(0);
+	}
+
+
+	totalAccumulatedExecutedInstructions = 0;
+	totalFinishedApplicationInstances = 0;
+
+	totalAccumulatedConsumedEnergy = 0;
+
+	lastTimeTurboBoostChange = 0;
+
+	core_id_t totalNumberCores = (core_id_t)Sim()->getConfig()->getApplicationCores();
+	cout << "There are " << totalNumberCores << " cores" << endl;
+
+	for(int coreNumber = 0; coreNumber < totalNumberCores; coreNumber++){
+		coresReservedForApplication.push_back(-1);
+	}
+
+
+
+
+
+	// Open and, if successfully opened, write the headers of each output log file
+	if(openOutputFile(configurationParameters.fileNameOutputScheduleTrace, outputScheduleTrace, saveOutputScheduleTrace) == true){
+		outputScheduleTrace << "time";
+		for(int i = 0; i < totalNumberCores; i++){
+			outputScheduleTrace << "\t" << matex.getFunctionalUnitName(i);
+		}
+		outputScheduleTrace << endl;
+	}
+	if(openOutputFile(configurationParameters.fileNameOutputFrequencyTrace, outputFrequencyTrace, saveOutputFrequencyTrace) == true){
+		outputFrequencyTrace << "time";
+		for(int i = 0; i < totalNumberCores; i++){
+			outputFrequencyTrace << "\t" << matex.getFunctionalUnitName(i);
+		}
+		outputFrequencyTrace << endl;
+	}
+	if(openOutputFile(configurationParameters.fileNameOutputPowerTrace, outputPowerTrace, saveOutputPowerTrace) == true){
+		outputPowerTrace << "time\tTotalPower";
+		for(int i = 0; i < numberUnitsInFloorplan; i++){
+			outputPowerTrace << "\t" << matex.getFunctionalUnitName(i);
+		}
+		outputPowerTrace << endl;
+	}
+	if(openOutputFile(configurationParameters.fileNameOutputEnergyTrace, outputEnergyTrace, saveOutputEnergyTrace) == true){
+		outputEnergyTrace << "time\tTotalEnergy";
+		for(int i = 0; i < numberUnitsInFloorplan; i++){
+			outputEnergyTrace << "\t" << matex.getFunctionalUnitName(i);
+		}
+		outputEnergyTrace << endl;
+	}
+	if(openOutputFile(configurationParameters.fileNameOutputAccumulatedEnergyTrace, outputAccumulatedEnergyTrace, saveOutputAccumulatedEnergyTrace) == true){
+		outputAccumulatedEnergyTrace << "time\tTotalEnergy";
+		for(int i = 0; i < numberUnitsInFloorplan; i++){
+			outputAccumulatedEnergyTrace << "\t" << matex.getFunctionalUnitName(i);
+		}
+		outputAccumulatedEnergyTrace << endl;
+	}
+	if(openOutputFile(configurationParameters.fileNameOutputIpsTrace, outputIpsTrace, saveOutputIpsTrace) == true){
+		outputIpsTrace << "time\tTotalIPS";
+		for(int i = 0; i < totalNumberCores; i++){
+			outputIpsTrace << "\t" << matex.getFunctionalUnitName(i);
+		}
+		outputIpsTrace << endl;
+	}
+	if(openOutputFile(configurationParameters.fileNameOutputIpcTrace, outputIpcTrace, saveOutputIpcTrace) == true){
+		outputIpcTrace << "time\tTotalIPC";
+		for(int i = 0; i < totalNumberCores; i++){
+			outputIpcTrace << "\t" << matex.getFunctionalUnitName(i);
+		}
+		outputIpcTrace << endl;
+	}
+	if(openOutputFile(configurationParameters.fileNameOutputThroughputTrace, outputThroughputTrace, saveOutputThroughputTrace) == true){
+		// This log file does not use headers, but it still needs to be opened
+	}
+	if(openOutputFile(configurationParameters.fileNameOutputInstructionsTrace, outputInstructionsTrace, saveOutputInstructionsTrace) == true){
+		outputInstructionsTrace << "time\tTotalInst";
+		for(int i = 0; i < totalNumberCores; i++){
+			outputInstructionsTrace << "\t" << matex.getFunctionalUnitName(i);
+		}
+		outputInstructionsTrace << endl;
+	}
+	if(openOutputFile(configurationParameters.fileNameOutputAccumulatedInstructionsTrace, outputAccumulatedInstructionsTrace, saveOutputAccumulatedInstructionsTrace) == true){
+		outputAccumulatedInstructionsTrace << "time\tTotalInst";
+		for(int i = 0; i < totalNumberCores; i++){
+			outputAccumulatedInstructionsTrace << "\t" << matex.getFunctionalUnitName(i);
+		}
+		outputAccumulatedInstructionsTrace << endl;
+	}
+	if(openOutputFile(configurationParameters.fileNameOutputTransientTemperatures, outputTransientTemperatures, saveOutputTransientTemperatures) == true){
+		outputTransientTemperatures << "time";
+		for(int i = 0; i < numberUnitsInFloorplan; i++){
+			outputTransientTemperatures << "\t" << matex.getFunctionalUnitName(i);
+		}
+		outputTransientTemperatures << endl;
+	}
+	if(openOutputFile(configurationParameters.fileNameOutputMaximumTransientTemperatures, outputMaximumTransientTemperatures, saveOutputMaximumTransientTemperatures) == true){
+		outputMaximumTransientTemperatures << "time\tmaxTemp" << endl;
+	}
+
+
+	// Set the initial temperature for all cores and other units in the floorplan
+	// FIXME: Note that at this point we still haven't called McPAT, so we cannot read
+	// these values from it. Please make sure that all these power consumptions are later
+	// filled with proper values once that McPAT is executed. For the cores this is already
+	// done, however, it is not yet done for the other blocks in the floorplan.
+	for(int i = 0; i < totalNumberCores; i++){
+		Power[i] = CORE_INITIAL_POWER;
+	}
+	for(int i = totalNumberCores; i < numberUnitsInFloorplan; i++){
+		Power[i] = CACHE_POWER_CONSUMPTION;
+	}
+
+
+	// Compute the steady state temperatures for the initial power vector
+	steady_state_temp(model, Power, Temperature);
+
+	for(int i = 0; i < numberUnitsInFloorplan; i++){
+		for(int j = 0; j < WINDOW_SIZE; j++){
+			temperatureWindow[i][j] = Temperature[i];
+		}
+		averageTemperatureInWindow[i] = Temperature[i];
+	}
+
+	// Make sure that Turbo Boost is disabled on start up.
+	cout << "There are " << Sim()->getDvfsManager()->getNumberCoreDomains() << " voltage/frequency islands" << endl;
+	for(unsigned int islandIndex = 0; islandIndex < Sim()->getDvfsManager()->getNumberCoreDomains(); islandIndex++)
+		islandTurboBoostEnabled.push_back(false);
+}
+
+
+SchedulerPinnedBase::~SchedulerPinnedBase()
+{
+
+	// Close all output log files and delete all dynamicly allocated memory
+	closeOutputFilesAndDeleteDynamicMemory(	outputScheduleTrace, outputFrequencyTrace, outputPowerTrace, outputEnergyTrace, outputAccumulatedEnergyTrace, outputIpsTrace, outputIpcTrace, outputThroughputTrace, outputInstructionsTrace, outputAccumulatedInstructionsTrace, outputTransientTemperatures, outputMaximumTransientTemperatures,
+											saveOutputScheduleTrace, saveOutputFrequencyTrace, saveOutputPowerTrace, saveOutputEnergyTrace, saveOutputAccumulatedEnergyTrace, saveOutputIpsTrace, saveOutputIpcTrace, saveOutputThroughputTrace, saveOutputInstructionsTrace, saveOutputAccumulatedInstructionsTrace, saveOutputTransientTemperatures, saveOutputMaximumTransientTemperatures);
+
+
+	double total_elapsed_cycles = 0; 	// Set this to be the correct time elapsed  (in cycles)
+	int i, j, base;
+
+	// Find the average power dissipated in the elapsed time
+	if (model->type == BLOCK_MODEL)
+		for (i = 0; i < flp->n_units; i++)
+			overall_power[i] /= total_elapsed_cycles;
+	else
+		for(i=0, base=0; i < model->grid->n_layers; i++) {
+			if(model->grid->layers[i].has_power)
+				for(j=0; j < model->grid->layers[i].flp->n_units; j++)
+					overall_power[base+j] /= total_elapsed_cycles;
+			base += model->grid->layers[i].flp->n_units;
+		}
+
+	// Compute the final steady state temperatures for the average power consumption
+	steady_state_temp(model, overall_power, steady_temp);
+
+	// Dump temperatures if needed
+	if ((strlen(model->config->steady_file) > 0) && strcmp(model->config->steady_file, NULLFILE))
+		dump_temp(model, steady_temp, model->config->steady_file);
+
+	// for the grid model, optionally dump the internal temperatures of the grid cells
+	if ((model->type == GRID_MODEL) && (strlen(model->config->grid_steady_file) > 0) && strcmp(model->config->grid_steady_file, NULLFILE))
+		dump_steady_temp_grid(model->grid, model->config->grid_steady_file);
+
+	// Cleanup the vectors used by HotSpot
+	delete_RC_model(model);
+	free_flp(flp, FALSE);
+	free_dvector(Temperature);
+	free_dvector(Power);
+	free_dvector(steady_temp);
+	free_dvector(overall_power);
+
+	if(currentIps != nullptr){
+		delete[] currentIps;
+	}
+
+	if(accumulatedExecutedInstructions != nullptr){
+		delete[] accumulatedExecutedInstructions;
+	}
 }
 
+
+
+
 core_id_t SchedulerPinnedBase::findFreeCoreForThread(thread_id_t thread_id)
 {
    for(core_id_t core_id = 0; core_id < (core_id_t)Sim()->getConfig()->getApplicationCores(); ++core_id)
@@ -43,7 +459,55 @@
    }
    else
    {
-      threadSetInitialAffinity(thread_id);
+	   // Check if there were cores reserved for the application creating the new thread
+	   // First get the application ID of the thread
+	   int appId = Sim()->getThreadManager()->getThreadFromID(thread_id)->getAppId();
+	   // Then iterate the coresReservedForApplication and check if there is a core that
+	   // has been reserved for appId
+	   vector<int> coresReservedForThisAppllication;
+	   for(core_id_t core_id = 0; core_id < (core_id_t)Sim()->getConfig()->getApplicationCores(); core_id++){
+		   if(coresReservedForApplication[core_id] == appId){
+			   // If there are cores reserved for this application, add them to the
+			   // coresReservedForThisAppllication, which will be checked later
+			   coresReservedForThisAppllication.push_back(core_id);
+		   }
+	   }
+
+	   // If there are no cores reserved for this application, continue normally by using
+	   // Sniper's default thread affinity assignment of new threads (i.e., call function
+	   // threadSetInitialAffinity() passing thread_id as parameter).
+	   if(coresReservedForThisAppllication.size() == 0){
+		   threadSetInitialAffinity(thread_id);
+	   }
+	   // If there are cores reserved for this application, then set the affinity of
+	   // the thread to one of those cores
+	   else{
+		   // Search for a free core among the cores reserved for the application
+		   core_id_t core_id = -1;
+		   // Iterate through the coresReservedForThisAppllication vector
+		   for(unsigned int reservedCoreIndex = 0; reservedCoreIndex < coresReservedForThisAppllication.size(); reservedCoreIndex++){
+			   // For each core in the vector, check the thread status in the m_core_thread_running vector.
+			   // In case the thread status is INVALID_THREAD_ID, then the core is free
+			   if (m_core_thread_running[ coresReservedForThisAppllication[reservedCoreIndex] ] == INVALID_THREAD_ID){
+				   core_id = coresReservedForThisAppllication[reservedCoreIndex];
+				   break;
+			   }
+		   }
+
+		   // If there was a free core reserved for this application, set the affinity
+		   // of the thread to that core by calling setAffinitySingle(core_id)
+		   if(core_id >= 0){
+			   m_thread_info[thread_id].setAffinitySingle(core_id);
+		   }
+		   // If there was no free core reserved for this application, set the affinity
+		   // of the thread normally by using Sniper's default policy.
+		   // FIXME: This could probably be improved by setting the affinity to the
+		   // reserved core for this application that has less threads with affinity
+		   // to it, using preemption on the cores reserved for the application.
+		   else{
+			   threadSetInitialAffinity(thread_id);
+		   }
+	   }
    }
 
    // The first thread scheduled on this core can start immediately, the others have to wait
@@ -86,6 +550,11 @@
    }
 }
 
+void SchedulerPinnedBase::setAffinitySingle(thread_id_t thread_id, core_id_t core_id)
+{
+	m_thread_info[thread_id].setAffinitySingle(core_id);
+}
+
 bool SchedulerPinnedBase::threadSetAffinity(thread_id_t calling_thread_id, thread_id_t thread_id, size_t cpusetsize, const cpu_set_t *mask)
 {
    if (m_thread_info.size() <= (size_t)thread_id)
@@ -201,7 +670,218 @@
 
 void SchedulerPinnedBase::periodic(SubsecondTime time)
 {
-   SubsecondTime delta = time - m_last_periodic;
+	SubsecondTime delta = time - m_last_periodic;
+	// Get the current time in femtoSeconds and convert it to seconds, used later for
+	// printing the statistics
+	double currentTime = ((double)time.getFS()) * 1e-15;
+
+
+	// Chech if enough time has passed between the last time the statistics were printed
+	if((time.getNS() - lastTimeHotSpotAndMyStatistics) >= configurationParameters.samplingInterval){
+		// Compute the elapsed time since the last HotSpot computation, in seconds
+		double elapsedTime = ((double)(time.getNS() - lastTimeHotSpotAndMyStatistics)) * 1e-9;
+
+		// Update the value of the last time HotSpot computed temperature and the statistics
+		// were outputed
+		lastTimeHotSpotAndMyStatistics = time.getNS();
+
+		// Compute the transient temperatures for the current power vectors.
+		// Calculate the current temp given the previous temp, time
+		// elapsed since then, and the average power dissipated during
+		// that interval. for the grid model, only the first call to
+		// compute_temp passes a non-null 'temp' array. if 'temp' is  NULL,
+		// compute_temp remembers it from the last non-null call.
+		// this is used to maintain the internal grid temperatures
+		// across multiple calls of compute_temp.
+		if ((model->type == BLOCK_MODEL) || (firstTemperatureComputed == true))
+			compute_temp(model, Power, Temperature, elapsedTime);
+		else
+			compute_temp(model, Power, NULL, elapsedTime);
+		firstTemperatureComputed = false;
+
+		// Update the power vector with the data parsed by the Python script from the
+		// McPAT results
+		// FIXME: Here is were we could also read and update the power consumption
+		// of other blocks in the floorplan, like the caches.
+		core_id_t totalNumberCores = (core_id_t)Sim()->getConfig()->getApplicationCores();
+		for(core_id_t core_id = 0; core_id < totalNumberCores; ++core_id){
+			Power[core_id] = ((double)(Sim()->getStatsManager()->getMetricObject("core", core_id, "energy-dynamic")->recordMetric() + Sim()->getStatsManager()->getMetricObject("core", core_id, "energy-static")->recordMetric()))*1e-6;
+		}
+
+
+
+
+		// Save the output data into the corresponding output log files
+		if(saveOutputScheduleTrace)
+			addNewScheduleToFile(outputScheduleTrace, currentTime, totalNumberCores, m_core_thread_running);
+
+		if(saveOutputFrequencyTrace)
+			addNewFrequencyToFile(outputFrequencyTrace, currentTime, totalNumberCores, m_core_thread_running);
+
+		if(saveOutputPowerTrace)
+			addNewPowerToFile(outputPowerTrace, currentTime, Power, numberUnitsInFloorplan);
+
+		if(saveOutputEnergyTrace)
+			addNewEnergyToFile(outputEnergyTrace, currentTime, elapsedTime, Power, numberUnitsInFloorplan);
+
+		if(saveOutputAccumulatedEnergyTrace)
+			addNewAccumulatedEnergyToFile(outputAccumulatedEnergyTrace, currentTime, elapsedTime, Power, accumulatedConsumedEnergy, totalAccumulatedConsumedEnergy);
+		else
+			// Even if the output log file is not being generated now, we still need to
+			// compute the total energy
+			computeTotalEnergy(elapsedTime, Power, accumulatedConsumedEnergy, totalAccumulatedConsumedEnergy);
+
+		if(saveOutputIpsTrace)
+			addNewIpsToFile(outputIpsTrace, currentTime, elapsedTime, totalNumberCores);
+		else
+			// Even if the output log file is not being generated now, we still need to
+			// compute the IPS
+			computeIps(elapsedTime, totalNumberCores);
+
+		if(saveOutputIpcTrace)
+			addNewIpcToFile(outputIpcTrace, currentTime, elapsedTime, totalNumberCores, m_core_thread_running);
+
+		if(saveOutputInstructionsTrace)
+			addNewInstructionsToFile(outputInstructionsTrace, currentTime, totalNumberCores, accumulatedExecutedInstructions);
+
+		if(saveOutputAccumulatedInstructionsTrace)
+			addNewAccumulatedInstructionsToFile(outputAccumulatedInstructionsTrace, currentTime, totalNumberCores, accumulatedExecutedInstructions, totalAccumulatedExecutedInstructions);
+		else
+			// Even if the output log file is not being generated now, we still need to
+			// compute the total number of executed instructions
+			computeTotalInstructions(totalNumberCores, accumulatedExecutedInstructions, totalAccumulatedExecutedInstructions);
+
+		if(saveOutputTransientTemperatures)
+			addNewTemperaturesToFile(outputTransientTemperatures, currentTime, Temperature, numberUnitsInFloorplan);
+
+		if(saveOutputMaximumTransientTemperatures)
+			addNewMaximumTemperatureToFile(outputMaximumTransientTemperatures, currentTime, Temperature, numberUnitsInFloorplan);
+
+
+
+		// Update the accumulated number of instructions for each core.
+		// Also update the window with the accumulated executed instructions and the
+		// executed cycles.
+		// Also compute the average IPC based on the window values.
+		for(int i = 0; i < totalNumberCores; i++){
+			accumulatedExecutedInstructions[i] = Sim()->getCoreManager()->getCoreFromID(i)->getInstructionCount();
+
+			// Delete the first value of each window vector
+			accumulatedExecutedInstructionLastWindow[i].erase(accumulatedExecutedInstructionLastWindow[i].begin() + 0);
+			cyclesExecutedLastWindow[i].erase(cyclesExecutedLastWindow[i].begin() + 0);
+
+			// Add the new values at the end of each window
+			// The number of executed cycles is computed according to the execution frequency and the elapsed time
+			accumulatedExecutedInstructionLastWindow[i].push_back(accumulatedExecutedInstructions[i]);
+			cyclesExecutedLastWindow[i].push_back(Sim()->getMagicServer()->getFrequency(i) * 1e6 * elapsedTime);
+
+			// Compute the average IPC for the window
+			double totalCyclesInWindow = 0;
+			for(int j = 0; j < WINDOW_SIZE; j++){
+				totalCyclesInWindow += cyclesExecutedLastWindow[i][j];
+			}
+			averageIPCinWindow[i] = (accumulatedExecutedInstructionLastWindow[i][accumulatedExecutedInstructionLastWindow[i].size() - 1] - accumulatedExecutedInstructionLastWindow[i][0])/totalCyclesInWindow;
+		}
+
+		// Update the window with the last temperatures.
+		// Also compute the average temperature based on the window values.
+		for(int i = 0; i < numberUnitsInFloorplan; i++){
+
+			// Delete the first value of each window vector
+			temperatureWindow[i].erase(temperatureWindow[i].begin() + 0);
+
+			// Add the new values at the end of each window
+			temperatureWindow[i].push_back(Temperature[i]);
+
+			// Compute the average value
+			double summationTemperatureUnit = 0;
+			for(int j = 0; j < WINDOW_SIZE; j++){
+				summationTemperatureUnit += temperatureWindow[i][j];
+			}
+			averageTemperatureInWindow[i] = summationTemperatureUnit/WINDOW_SIZE;
+		}
+	}
+
+
+	// Apply Turbo Boost in case required. First check if enough time has passed since
+	// the last control period of Turbo Boost.
+	if((time.getNS() - lastTimeTurboBoostChange) >= TURBO_BOOST_INTERVAL_NS){
+		// Update the last time of Turbo Boost's control period
+		lastTimeTurboBoostChange = time.getNS();
+		// Get the total number of voltage islands and number of cores per island
+		unsigned int totalNumberIslands = Sim()->getDvfsManager()->getNumberCoreDomains();
+		unsigned int coresPerIsland = Sim()->getDvfsManager()->getNumberCoresPerDomain();
+		// Iterate through all voltage islands
+		for(unsigned int islandIndex = 0; islandIndex < totalNumberIslands; islandIndex++){
+			// If Turbo Boost should be applied to a specific island
+			if(islandTurboBoostEnabled[islandIndex] == true){
+
+				// First check if there are threads running on the island. If there are none, then set the frequency to nominal
+				bool islandActive = false;
+				// Iterate through all the cores in the island
+				for(unsigned int coreIndex = 0; coreIndex < coresPerIsland; coreIndex++){
+					// Compute the absolute core ID
+					int absoluteCoreNumber = coreIndex + islandIndex * coresPerIsland;
+					// Check if there is a valid thread running on the core
+					if(m_core_thread_running[absoluteCoreNumber] >= 0){
+						// If there is a thread running on the core and no scheduler app
+						// was running, then the island is active (i.e., there are application
+						// threads being executed. If there is a scheduler app running,
+						// check that the scheduler is not running a thread on this core
+						// as Turbo Boost should not be applied in case only scheduler
+						// threads are running on the island.
+						if( ((configurationParameters.schedulerAppRunning == true) && (Sim()->getThreadManager()->getThreadFromID(m_core_thread_running[absoluteCoreNumber])->getAppId() != 0)) ||
+							(configurationParameters.schedulerAppRunning == false)){
+							islandActive = true;
+							break;
+						}
+					}
+				}
+
+
+				// If the island was active (running an application thread not belonging
+				// to the scheduler) then apply Turbo Boost
+				if(islandActive){
+					// First verify whether a thermal violation is present in this
+					// voltage island
+					bool thermalViolation = false;
+					for(unsigned int coreIndex = 0; coreIndex < coresPerIsland; coreIndex++){
+						if(Temperature[coreIndex + islandIndex * coresPerIsland] > configurationParameters.Tdtm){
+							thermalViolation = true;
+							break;
+						}
+					}
+
+					// Get the current frequency of the island
+					unsigned int currentIslandFrequency = Sim()->getMagicServer()->getFrequency(islandIndex * coresPerIsland);
+
+					if(thermalViolation == true){
+						// If there was a thermal violation, reduce the frequency of the island
+						if(currentIslandFrequency > MIN_FREQUENCY){
+							Sim()->getMagicServer()->setFrequency(islandIndex * coresPerIsland, currentIslandFrequency - FREQUENCY_STEP);
+						}
+					}
+					else{
+						// If there was no thermal violation, increase the frequency of the island
+						if(currentIslandFrequency < MAX_FREQUENCY){
+							Sim()->getMagicServer()->setFrequency(islandIndex * coresPerIsland, currentIslandFrequency + FREQUENCY_STEP);
+						}
+					}
+				}
+				// If the island wasn't active, then execute at nominal frequency
+				else{
+					Sim()->getMagicServer()->setFrequency(islandIndex * coresPerIsland, NOMINAL_FREQUENCY);
+				}
+			}
+		}
+	}
+
+
+
+
+
+
+
 
    for(core_id_t core_id = 0; core_id < (core_id_t)Sim()->getConfig()->getApplicationCores(); ++core_id)
    {
@@ -358,3 +1038,381 @@
    }
    printf("\n");
 }
+
+
+
+
+
+
+
+
+
+bool openOutputFile(const string &fileName, ofstream &outputStream, bool &outputStreamReadyForWriting)
+{
+	// First indicate that the file is not ready for writing
+	outputStreamReadyForWriting = false;
+	// Check that the file name is not empty
+	if(fileName.size() > 0){
+		// Try to open the output file stream
+		outputStream.open (fileName.c_str());
+		// Check that the file stream is opened and in the good state.
+		if (outputStream.is_open()){
+			if (outputStream.good()){
+				// If all went well, set the precision of the output file stream (for
+				// streaming double variables) and indicate that the file is ready for
+				// writing
+				outputStream.precision(OUTPUT_FILE_PRECISION);
+				outputStreamReadyForWriting = true;
+				return true;
+			}
+			else{
+				cout << "Error: Output file: \"" << fileName << "\" could not be open for writing." << endl;
+				outputStream.close();
+				return false;
+			}
+		}
+		else{
+			cout << "Error: Output file: \"" << fileName << "\" could not be open for writing." << endl;
+			return false;
+		}
+	}
+	else{
+		return false;
+	}
+}
+
+
+
+void closeOutputFilesAndDeleteDynamicMemory(	ofstream &outputScheduleTrace,
+												ofstream &outputFrequencyTrace,
+												ofstream &outputPowerTrace,
+												ofstream &outputEnergyTrace,
+												ofstream &outputAccumulatedEnergyTrace,
+												ofstream &outputIpsTrace,
+												ofstream &outputIpcTrace,
+												ofstream &outputThroughputTrace,
+												ofstream &outputInstructionsTrace,
+												ofstream &outputAccumulatedInstructionsTrace,
+												ofstream &outputTransientTemperatures,
+												ofstream &outputMaximumTransientTemperatures,
+												const bool &saveOutputScheduleTrace,
+												const bool &saveOutputFrequencyTrace,
+												const bool &saveOutputPowerTrace,
+												const bool &saveOutputEnergyTrace,
+												const bool &saveOutputAccumulatedEnergyTrace,
+												const bool &saveOutputIpsTrace,
+												const bool &saveOutputIpcTrace,
+												const bool &saveOutputThroughputTrace,
+												const bool &saveOutputInstructionsTrace,
+												const bool &saveOutputAccumulatedInstructionsTrace,
+												const bool &saveOutputTransientTemperatures,
+												const bool &saveOutputMaximumTransientTemperatures)
+{
+	// If a file was ready to be written it means it was opened, and therefore it should
+	// be closed.
+	if(saveOutputScheduleTrace)
+		outputScheduleTrace.close();
+	if(saveOutputFrequencyTrace)
+		outputFrequencyTrace.close();
+	if(saveOutputPowerTrace)
+		outputPowerTrace.close();
+	if(saveOutputEnergyTrace)
+		outputEnergyTrace.close();
+	if(saveOutputAccumulatedEnergyTrace)
+		outputAccumulatedEnergyTrace.close();
+	if(saveOutputIpsTrace)
+		outputIpsTrace.close();
+	if(saveOutputIpcTrace)
+		outputIpcTrace.close();
+	if(saveOutputThroughputTrace)
+		outputThroughputTrace.close();
+	if(saveOutputInstructionsTrace)
+		outputInstructionsTrace.close();
+	if(saveOutputAccumulatedInstructionsTrace)
+		outputAccumulatedInstructionsTrace.close();
+	if(saveOutputTransientTemperatures)
+		outputTransientTemperatures.close();
+	if(saveOutputMaximumTransientTemperatures)
+		outputMaximumTransientTemperatures.close();
+}
+
+
+
+
+void addNewScheduleToFile(ofstream &outputScheduleTrace, const double &time, const int &totalNumberCores, vector<thread_id_t> &m_core_thread_running)
+{
+	outputScheduleTrace << time;
+	for(int k = 0; k < totalNumberCores; k++){
+		// If there is a valid thread running on the core and the frequency of the core
+		// is larger than zero (a frequency of zero means that the core is in low-power
+		// mode), then we write the appID/threadID.
+		// Note that since the time granularity at which the output logs are written
+		// is less frequent than the time steps at which the scheduler reacts, some
+		// statistics for very fast executing threads might occur.
+		if((m_core_thread_running[k] >= 0) && (Sim()->getMagicServer()->getFrequency(k) > 0))
+			outputScheduleTrace << "\t" << Sim()->getThreadManager()->getThreadFromID(m_core_thread_running[k])->getAppId() << "/" << m_core_thread_running[k];
+		else
+		// If there is no thread running or if the core is in low-power mode, then we
+		// write - to the output file.
+			outputScheduleTrace << "\t-";
+	}
+	outputScheduleTrace << endl;
+}
+
+
+
+
+void addNewFrequencyToFile(ofstream &outputFrequencyTrace, const double &time, const int &totalNumberCores, vector<thread_id_t> &m_core_thread_running)
+{
+	outputFrequencyTrace << time;
+	for(int k = 0; k < totalNumberCores; k++){
+		// If there is a valid thread running on the core and the frequency of the core
+		// is larger than zero (a frequency of zero means that the core is in low-power
+		// mode), then we write the frequency of execution of the core.
+		if((m_core_thread_running[k] >= 0) && (Sim()->getMagicServer()->getFrequency(k) > 0))
+			outputFrequencyTrace << "\t" << Sim()->getMagicServer()->getFrequency(k);
+		else
+		// If there is no thread running or if the core is in low-power mode, then we
+		// write 0 to the output file.
+			outputFrequencyTrace << "\t" << 0;
+	}
+	outputFrequencyTrace << endl;
+}
+
+
+
+
+void addNewPowerToFile(ofstream &outputPowerTrace, const double &time, double* &Power, const int &numberUnits)
+{
+	// Compute the total power consumption of the chip by adding the entire power vector
+	double totalPowerConsumption = 0;
+	for(int k = 0; k < numberUnits; k++){
+		totalPowerConsumption += Power[k];
+	}
+
+	// Write the current time and total power consumption
+	outputPowerTrace << time << "\t" << totalPowerConsumption;
+	// Then write the individual power consumption of every unit on the floorplan
+	for(int k = 0; k < numberUnits; k++){
+		outputPowerTrace << "\t" << Power[k];
+	}
+	outputPowerTrace << endl;
+}
+
+
+
+
+void addNewEnergyToFile(ofstream &outputEnergyTrace, const double &time, const double &samplingTime, double* &Power, const int &numberUnits)
+{
+	// Compute the total energy consumed during between now and the last time the output
+	// statistics were printed.
+	double totalEnergyTrace =0;
+	for(int k = 0; k < numberUnits; k++){
+		totalEnergyTrace += Power[k] * samplingTime;
+	}
+
+	// Write the current time and total energy consumption
+	outputEnergyTrace << time << "\t" << totalEnergyTrace;
+	// Then write the individual energy consumption of every unit on the floorplan
+	for(int k = 0; k < numberUnits; k++){
+		outputEnergyTrace << "\t" << Power[k] * samplingTime;
+	}
+	outputEnergyTrace << endl;
+}
+
+
+
+
+void addNewAccumulatedEnergyToFile(ofstream &outputAccumulatedEnergyTrace, const double &time, const double &samplingTime, double* &Power, vector<double> &accumulatedConsumedEnergy, double &totalAccumulatedConsumedEnergy)
+{
+	// Compute the energy consumed by every floorplan unit between now and the last time
+	// that the statistics were printed, and then add these values to the accumulated
+	// statistics
+	unsigned int numberUnits = accumulatedConsumedEnergy.size();
+	for(unsigned int k = 0; k < numberUnits; k++){
+		double coreEnergyTrace = Power[k] * samplingTime;
+		accumulatedConsumedEnergy[k] += coreEnergyTrace;
+		totalAccumulatedConsumedEnergy += coreEnergyTrace;
+	}
+
+	// Write the new accumulated statistics to the file
+	outputAccumulatedEnergyTrace << time << "\t" << totalAccumulatedConsumedEnergy;
+	for(unsigned int k = 0; k < numberUnits; k++){
+		outputAccumulatedEnergyTrace << "\t" << accumulatedConsumedEnergy[k];
+	}
+	outputAccumulatedEnergyTrace << endl;
+}
+
+
+void computeTotalEnergy(const double &samplingTime, double* &Power, vector<double> &accumulatedConsumedEnergy, double &totalAccumulatedConsumedEnergy)
+{
+	// Compute the energy consumed by every floorplan unit between now and the last time
+	// that the statistics were printed, and then add these values to the accumulated
+	// statistics
+	unsigned int numberUnits = accumulatedConsumedEnergy.size();
+	for(unsigned int k = 0; k < numberUnits; k++){
+		double coreEnergyTrace = Power[k] * samplingTime;
+		accumulatedConsumedEnergy[k] += coreEnergyTrace;
+		totalAccumulatedConsumedEnergy += coreEnergyTrace;
+	}
+}
+
+
+
+
+void addNewIpsToFile(ofstream &outputIpsTrace, const double &time, const double &elapsedTime, const int &totalNumberCores)
+{
+	// The current IPS of a core (i.e., the average IPS between now and the last time
+	// that the statistics were printed) is computed by reading the total number of
+	// instructions executed by a core since start up until now (i.e., the value from
+	// Sim()->getCoreManager()->getCoreFromID(k)->getInstructionCount()), substracting
+	// the total number of instructions executed until the last time that the statistics
+	// were printed (i.e., the value in accumulatedExecutedInstructions[k]), and dividing
+	// this number by the time elapsed between the two points (i.e., elapsedTime).
+	// We also compute the total IPS of all cores together.
+	double totalIPStrace = 0;
+	for(int k = 0; k < totalNumberCores; k++){
+		double ipsCore = (Sim()->getCoreManager()->getCoreFromID(k)->getInstructionCount() - accumulatedExecutedInstructions[k])/elapsedTime;
+		currentIps[k] = ipsCore;
+		totalIPStrace += ipsCore;
+	}
+
+	// Write the new statistics to the file
+	outputIpsTrace << time << "\t" << totalIPStrace;
+	for(int k = 0; k < totalNumberCores; k++){
+		outputIpsTrace << "\t" << currentIps[k];
+	}
+	outputIpsTrace << endl;
+}
+
+void computeIps(const double &elapsedTime, const int &totalNumberCores)
+{
+	// The current IPS of a core (i.e., the average IPS between now and the last time
+	// that the statistics were printed) is computed by reading the total number of
+	// instructions executed by a core since start up until now (i.e., the value from
+	// Sim()->getCoreManager()->getCoreFromID(k)->getInstructionCount()), substracting
+	// the total number of instructions executed until the last time that the statistics
+	// were printed (i.e., the value in accumulatedExecutedInstructions[k]), and dividing
+	// this number by the time elapsed between the two points (i.e., elapsedTime).
+	for(int k = 0; k < totalNumberCores; k++){
+		currentIps[k] = (Sim()->getCoreManager()->getCoreFromID(k)->getInstructionCount() - accumulatedExecutedInstructions[k])/elapsedTime;
+	}
+}
+
+void addNewIpcToFile(ofstream &outputIpcTrace, const double &time, const double &elapsedTime, const int &totalNumberCores, vector<thread_id_t> &m_core_thread_running)
+{
+	// The current IPC of a core (i.e., the average IPC between now and the last time
+	// that the statistics were printed) is computed by reading the total number of
+	// instructions executed by a core since start up until now (i.e., the value from
+	// Sim()->getCoreManager()->getCoreFromID(k)->getInstructionCount()), substracting
+	// the total number of instructions executed until the last time that the statistics
+	// were printed (i.e., the value in accumulatedExecutedInstructions[k]), and dividing
+	// this number by the total cycles executed between the two points (i.e., the execution
+	// frequency of the core multiplied by the elapsedTime).
+	// We keep track of the total IPC of all cores.
+	double totalIPCtrace = 0;
+	for(int k = 0; k < totalNumberCores; k++){
+		if((m_core_thread_running[k] >= 0) && (Sim()->getMagicServer()->getFrequency(k) > 0))
+			totalIPCtrace += (Sim()->getCoreManager()->getCoreFromID(k)->getInstructionCount() - accumulatedExecutedInstructions[k])/(Sim()->getMagicServer()->getFrequency(k) * 1e6 * elapsedTime);
+	}
+
+	// Write to the file the current time and total IPC, as well as the individual IPC
+	// of each core.
+	outputIpcTrace << time << "\t" << totalIPCtrace;
+	for(int k = 0; k < totalNumberCores; k++){
+		if((m_core_thread_running[k] >= 0) && (Sim()->getMagicServer()->getFrequency(k) > 0)){
+			double ipcCore = (Sim()->getCoreManager()->getCoreFromID(k)->getInstructionCount() - accumulatedExecutedInstructions[k])/(Sim()->getMagicServer()->getFrequency(k) * 1e6 * elapsedTime);
+			outputIpcTrace << "\t" << ipcCore;
+		}
+		else{
+			outputIpcTrace << "\t" << 0;
+		}
+	}
+	outputIpcTrace << endl;
+}
+
+
+void addNewInstructionsToFile(ofstream &outputInstructionsTrace, const double &time, const int &totalNumberCores, UInt64* &accumulatedExecutedInstructions)
+{
+	// Compute the total number of instructions executed by all cores between now and the
+	// last time that the statistics were printed.
+	double totalInstructionsTrace = 0;
+	for(int k = 0; k < totalNumberCores; k++){
+		UInt64 coreInstructionsTrace = Sim()->getCoreManager()->getCoreFromID(k)->getInstructionCount();
+		totalInstructionsTrace += coreInstructionsTrace - accumulatedExecutedInstructions[k];
+	}
+
+	// Write the current time and the total number of instructions, as well as the number
+	// of instructions executed by each individual core between now and the last time that
+	// the statistics were printed.
+	outputInstructionsTrace << time << "\t" << totalInstructionsTrace;
+	for(int k = 0; k < totalNumberCores; k++){
+		UInt64 coreInstructionsTrace = Sim()->getCoreManager()->getCoreFromID(k)->getInstructionCount();
+		outputInstructionsTrace << "\t" << coreInstructionsTrace - accumulatedExecutedInstructions[k];
+	}
+	outputInstructionsTrace << endl;
+}
+
+
+
+
+void addNewAccumulatedInstructionsToFile(ofstream &outputAccumulatedInstructionsTrace, const double &time, const int &totalNumberCores, UInt64* &accumulatedExecutedInstructions, double &totalAccumulatedExecutedInstructions)
+{
+	// Compute the total number of accumulated instructions executed by all cores since start up
+	totalAccumulatedExecutedInstructions = 0;
+	for(int k = 0; k < totalNumberCores; k++){
+		totalAccumulatedExecutedInstructions += Sim()->getCoreManager()->getCoreFromID(k)->getInstructionCount();
+	}
+
+	// Write the current time, the total number of accumulataed instructions executed by all cores
+	// since start up, as well as the number of accumulated instructions executed by each
+	// individual core.
+	outputAccumulatedInstructionsTrace << time << "\t" << totalAccumulatedExecutedInstructions;
+	for(int k = 0; k < totalNumberCores; k++){
+		outputAccumulatedInstructionsTrace << "\t" << Sim()->getCoreManager()->getCoreFromID(k)->getInstructionCount();
+	}
+	outputAccumulatedInstructionsTrace << endl;
+}
+
+
+void computeTotalInstructions(const int &totalNumberCores, UInt64* &accumulatedExecutedInstructions, double &totalAccumulatedExecutedInstructions)
+{
+	// Compute the total number of accumulated instructions executed by all cores since start up
+	totalAccumulatedExecutedInstructions = 0;
+	for(int k = 0; k < totalNumberCores; k++){
+		totalAccumulatedExecutedInstructions += Sim()->getCoreManager()->getCoreFromID(k)->getInstructionCount();
+	}
+}
+
+
+
+
+void addNewTemperaturesToFile(ofstream &outputTransientTemperatures, const double &time, double* &Temperature, const int &numberUnits)
+{
+	// Write the current time and the current transient temperature (in degrees
+	// centigrades, not Kelvin) of every unit in the floorplan.
+	outputTransientTemperatures << time;
+	for(int k = 0; k < numberUnits; k++){
+		outputTransientTemperatures << "\t" << Temperature[k] - T_KELVIN;
+	}
+	outputTransientTemperatures << endl;
+}
+
+
+
+
+void addNewMaximumTemperatureToFile(ofstream &outputMaximumTransientTemperatures, const double &time, double* &Temperature, const int &numberUnits)
+{
+	// Write the current time and the current maximum transient temperature (in degrees
+	// centigrades, not Kelvin) among all units of the floorplan.
+	double maxTemperature = 0;
+	for(int k = 0; k < numberUnits; k++){
+		if(maxTemperature < Temperature[k])
+			maxTemperature = Temperature[k];
+	}
+	outputMaximumTransientTemperatures << time << "\t" << maxTemperature - T_KELVIN << endl;
+}
+
+
+
+
diff -Naur sniper-6.1_old/common/scheduler/scheduler_pinned_base.h sniper-6.1/common/scheduler/scheduler_pinned_base.h
--- sniper-6.1_old/common/scheduler/scheduler_pinned_base.h	2015-03-24 16:56:51.000000000 +0100
+++ sniper-6.1/common/scheduler/scheduler_pinned_base.h	2017-08-01 14:34:53.608035000 +0200
@@ -1,25 +1,85 @@
 #ifndef __SCHEDULER_PINNED_BASE_H
 #define __SCHEDULER_PINNED_BASE_H
 
+#include <iostream>
+#include <iomanip>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <fstream>
+#include <sstream>
+#include <vector>
+#include <algorithm>
+#include <complex>
+#include <string>
+#include <math.h>
+#include <cfloat>
+#include <stdexcept>
+
+using namespace std;
+
+
 #include "scheduler_dynamic.h"
 #include "simulator.h"
+#include "magic_server.h"
+#include "thread_manager.h"
+#include "thread.h"
+
+#include "simulator.h"
+#include "core_manager.h"
+#include "performance_model.h"
+#include "os_compat.h"
+#include "stats.h"
+#include "dvfs_manager.h"
+#include "configurationParameters.h"
+#include "Matex.h"
+
+
 
 class SchedulerPinnedBase : public SchedulerDynamic
 {
    public:
+	  /** In the constructor, we initiallize the new variables for the statistics,
+	      we read and verifiy the new configuration files (the saturn configuration
+	      file and the HotSpot configuration file), we read and verify the floorplan
+	      file, the thermal model is computed and populated based on the configuration
+	      parameters and the floorplan, and we open all the output log files to generate
+		  as specified in the configuration file.
+	   */
       SchedulerPinnedBase(ThreadManager *thread_manager, SubsecondTime quantum);
 
+	  /** In the destructor, we close all the output log files and clean up the thermal
+	      model and auxiliary variables.
+	   */
+      ~SchedulerPinnedBase();
+
       virtual core_id_t threadCreate(thread_id_t);
       virtual void threadYield(thread_id_t thread_id);
       virtual bool threadSetAffinity(thread_id_t calling_thread_id, thread_id_t thread_id, size_t cpusetsize, const cpu_set_t *mask);
       virtual bool threadGetAffinity(thread_id_t thread_id, size_t cpusetsize, cpu_set_t *mask);
 
+	  /** The most important part of the entire Sniper + McPAT + HotSpot integration
+	      takes place in this method. Namely, in this method we use HotSpot to compute
+	      the new transient temperatures for the current power vector, we then update
+	      the power vector with the data parsed by the Python script from the McPAT
+	      results, we then write all the output logs, and finally we update the values
+	      of the statistics holding average values for a last (fixed-time) window.
+	      Furthermore, the DVFS settings of the voltage islands that are applying
+	      Turbo Boost are also computed at the end of this method.
+	   */
       virtual void periodic(SubsecondTime time);
       virtual void threadStart(thread_id_t thread_id, SubsecondTime time);
       virtual void threadStall(thread_id_t thread_id, ThreadManager::stall_type_t reason, SubsecondTime time);
       virtual void threadResume(thread_id_t thread_id, thread_id_t thread_by, SubsecondTime time);
       virtual void threadExit(thread_id_t thread_id, SubsecondTime time);
 
+	  /** Method to set the affinity of a thread ID to the specified core ID.
+          Particularly, method setAffinitySingle() of the thread_id element in vector
+		  m_thread_info is called by passing argument core_id.
+	   */
+      virtual void setAffinitySingle(thread_id_t thread_id, core_id_t core_id);
+
    protected:
       class ThreadInfo
       {
@@ -84,4 +144,148 @@
       void printState();
 };
 
+
+
+
+/**	Open the output file stream (outputStream) stated in fileName. In case the file
+	is ready for writing, then set outputStreamReadyForWriting to true.
+ */
+bool openOutputFile(const string &fileName, ofstream &outputStream, bool &outputStreamReadyForWriting);
+
+/** If there is a valid thread running on the core and the frequency of the core is
+	larger than zero (a frequency of zero means that the core is in low-power mode),
+	then we write the appID/threadID. If there is no thread running or if the core is
+	in low-power mode, then we write - to the output file.
+	Note that since the time granularity at which the output logs are written is less
+	frequent than the time steps at which the scheduler reacts, some statistics for
+	very fast executing threads might occur.
+ */
+void addNewScheduleToFile(ofstream &outputScheduleTrace, const double &time, const int &totalNumberCores, vector<thread_id_t> &m_core_thread_running);
+
+/** If there is a valid thread running on the core and the frequency of the core is
+	larger than zero (a frequency of zero means that the core is in low-power mode),
+	then we write the frequency of execution of the core. If there is no thread running
+	or if the core is in low-power mode, then we write 0 to the output file.
+ */
+void addNewFrequencyToFile(ofstream &outputFrequencyTrace, const double &time, const int &totalNumberCores, vector<thread_id_t> &m_core_thread_running);
+
+/**	Compute the total power consumption of the chip by adding the entire power vector.
+	Write the current time and total power consumption. Then write the individual power
+	consumption of every unit on the floorplan.
+ */
+void addNewPowerToFile(ofstream &outputPowerTrace, const double &time, double* &Power, const int &numberUnits);
+
+/**	Compute the total energy consumed during between now and the last time the output
+	statistics were printed. Write the current time and total energy consumption. Then
+	write the individual energy consumption of every unit on the floorplan.
+ */
+void addNewEnergyToFile(ofstream &outputEnergyTrace, const double &time, const double &samplingTime, double* &Power, const int &numberUnits);
+
+/**	Compute the energy consumed by every floorplan unit between now and the last time
+	that the statistics were printed, and then add these values to the accumulated
+	statistics. Write the new accumulated statistics to the file.
+ */
+void addNewAccumulatedEnergyToFile(ofstream &outputAccumulatedEnergyTrace, const double &time, const double &samplingTime, double* &Power, vector<double> &accumulatedConsumedEnergy, double &totalAccumulatedConsumedEnergy);
+
+/**	Compute the energy consumed by every floorplan unit between now and the last time
+	that the statistics were printed, and then add these values to the accumulated
+	statistics.
+ */
+void computeTotalEnergy(const double &samplingTime, double* &Power, vector<double> &accumulatedConsumedEnergy, double &totalAccumulatedConsumedEnergy);
+
+/**	The current IPS of a core (i.e., the average IPS between now and the last time that
+	the statistics were printed) is computed by reading the total number of instructions
+	executed by a core since start up until now (i.e., the value from
+	Sim()->getCoreManager()->getCoreFromID(k)->getInstructionCount()), substracting the
+	total number of instructions executed until the last time that the statistics were
+	printed (i.e., the value in accumulatedExecutedInstructions[k]), and dividing this
+	number by the time elapsed between the two points (i.e., elapsedTime).
+	We also compute the total IPS of all cores together. Write the new statistics to
+	the file.
+ */
+void addNewIpsToFile(ofstream &outputIpsTrace, const double &time, const double &elapsedTime, const int &totalNumberCores);
+
+/**	The current IPS of a core (i.e., the average IPS between now and the last time that
+	the statistics were printed) is computed by reading the total number of instructions
+	executed by a core since start up until now (i.e., the value from
+	Sim()->getCoreManager()->getCoreFromID(k)->getInstructionCount()), substracting the
+	total number of instructions executed until the last time that the statistics were
+	printed (i.e., the value in accumulatedExecutedInstructions[k]), and dividing this
+	number by the time elapsed between the two points (i.e., elapsedTime).
+ */
+void computeIps(const double &elapsedTime, const int &totalNumberCores);
+
+/**	The current IPC of a core (i.e., the average IPC between now and the last time that
+	the statistics were printed) is computed by reading the total number of instructions
+	executed by a core since start up until now (i.e., the value from
+	Sim()->getCoreManager()->getCoreFromID(k)->getInstructionCount()), substracting the
+	total number of instructions executed until the last time that the statistics were
+	printed (i.e., the value in accumulatedExecutedInstructions[k]), and dividing this
+	number by the total cycles executed between the two points (i.e., the execution
+	frequency of the core multiplied by the elapsedTime). We keep track of the total
+	IPC of all cores. Write to the file the current time and total IPC, as well as the
+	individual IPC of each core.
+ */
+void addNewIpcToFile(ofstream &outputIpcTrace, const double &time, const double &elapsedTime, const int &totalNumberCores, vector<thread_id_t> &m_core_thread_running);
+
+/**	Compute the total number of instructions executed by all cores between now and the
+	last time that the statistics were printed. Then write the current time and the
+	total number of instructions, as well as the number of instructions executed by
+	each individual core between now and the last time that the statistics were printed.
+ */
+void addNewInstructionsToFile(ofstream &outputInstructionsTrace, const double &time, const int &totalNumberCores, UInt64* &accumulatedExecutedInstructions);
+
+/**	Compute the total number of accumulated instructions executed by all cores since
+	start up. Write the current time, the total number of accumulataed instructions
+	executed by all cores since start up, as well as the number of accumulated
+	instructions executed by each individual core.
+ */
+void addNewAccumulatedInstructionsToFile(ofstream &outputAccumulatedInstructionsTrace, const double &time, const int &totalNumberCores, UInt64* &accumulatedExecutedInstructions, double &totalAccumulatedExecutedInstructions);
+
+/**	Compute the total number of accumulated instructions executed by all cores since
+	start up.
+ */
+void computeTotalInstructions(const int &totalNumberCores, UInt64* &accumulatedExecutedInstructions, double &totalAccumulatedExecutedInstructions);
+
+/**	Write the current time and the current transient temperature (in degrees
+	centigrades, not Kelvin) of every unit in the floorplan.
+ */
+void addNewTemperaturesToFile(ofstream &outputTransientTemperatures, const double &time, double* &Temperature, const int &numberUnits);
+
+/**	Write the current time and the current maximum transient temperature (in degrees
+	centigrades, not Kelvin) among all units of the floorplan.
+ */
+void addNewMaximumTemperatureToFile(ofstream &outputMaximumTransientTemperatures, const double &time, double* &Temperature, const int &numberUnits);
+
+
+
+/**	Close all files that were ready to be written, as this means that they were opened.
+ */
+void closeOutputFilesAndDeleteDynamicMemory(	ofstream &outputScheduleTrace,
+												ofstream &outputFrequencyTrace,
+												ofstream &outputPowerTrace,
+												ofstream &outputEnergyTrace,
+												ofstream &outputAccumulatedEnergyTrace,
+												ofstream &outputIpsTrace,
+												ofstream &outputIpcTrace,
+												ofstream &outputThroughputTrace,
+												ofstream &outputInstructionsTrace,
+												ofstream &outputAccumulatedInstructionsTrace,
+												ofstream &outputTransientTemperatures,
+												ofstream &outputMaximumTransientTemperatures,
+												const bool &saveOutputScheduleTrace,
+												const bool &saveOutputFrequencyTrace,
+												const bool &saveOutputPowerTrace,
+												const bool &saveOutputEnergyTrace,
+												const bool &saveOutputAccumulatedEnergyTrace,
+												const bool &saveOutputIpsTrace,
+												const bool &saveOutputIpcTrace,
+												const bool &saveOutputThroughputTrace,
+												const bool &saveOutputInstructionsTrace,
+												const bool &saveOutputAccumulatedInstructionsTrace,
+												const bool &saveOutputTransientTemperatures,
+												const bool &saveOutputMaximumTransientTemperatures);
+
+
+
 #endif // __SCHEDULER_PINNED_BASE_H
diff -Naur sniper-6.1_old/common/system/dvfs_manager.cc sniper-6.1/common/system/dvfs_manager.cc
--- sniper-6.1_old/common/system/dvfs_manager.cc	2015-03-24 16:56:51.000000000 +0100
+++ sniper-6.1/common/system/dvfs_manager.cc	2017-08-01 14:34:51.128031000 +0200
@@ -96,3 +96,15 @@
       LOG_PRINT_ERROR("Cannot change non-core frequency");
    }
 }
+
+
+UInt32 DvfsManager::getNumberCoreDomains(void)
+{
+	return m_num_proc_domains;
+}
+
+UInt32 DvfsManager::getNumberCoresPerDomain(void)
+{
+	return m_cores_per_socket;
+}
+
diff -Naur sniper-6.1_old/common/system/dvfs_manager.h sniper-6.1/common/system/dvfs_manager.h
--- sniper-6.1_old/common/system/dvfs_manager.h	2015-03-24 16:56:51.000000000 +0100
+++ sniper-6.1/common/system/dvfs_manager.h	2017-08-01 14:34:51.120031000 +0200
@@ -17,6 +17,15 @@
       DOMAIN_GLOBAL_MAX
    };
    DvfsManager();
+
+   /** Function that returns the total number of core domains, i.e., the number of voltage islands
+    */
+   UInt32 getNumberCoreDomains(void);
+
+   /** Function that returns the total number of cores per domains, i.e., the number of cores per voltage islands
+    */
+   UInt32 getNumberCoresPerDomain(void);
+
    UInt32 getCoreDomainId(UInt32 core_id);
    const ComponentPeriod* getCoreDomain(UInt32 core_id);
    const ComponentPeriod* getGlobalDomain(DvfsGlobalDomain domain_id = DOMAIN_GLOBAL_DEFAULT);
diff -Naur sniper-6.1_old/common/system/magic_client.cc sniper-6.1/common/system/magic_client.cc
--- sniper-6.1_old/common/system/magic_client.cc	2015-03-24 16:56:51.000000000 +0100
+++ sniper-6.1/common/system/magic_client.cc	2017-08-01 14:34:51.136031000 +0200
@@ -1,54 +1,154 @@
-#include "magic_client.h"
-#include "magic_server.h"
-#include "sim_api.h"
-#include "simulator.h"
-#include "core.h"
-#include "core_manager.h"
-#include "thread.h"
-#include "thread_manager.h"
-
-static UInt64 handleMagic(thread_id_t thread_id, UInt64 cmd, UInt64 arg0 = 0, UInt64 arg1 = 0)
-{
-   Thread *thread = (thread_id == INVALID_THREAD_ID) ? NULL : Sim()->getThreadManager()->getThreadFromID(thread_id);
-   Core *core = thread == NULL ? NULL : thread->getCore();
-   return Sim()->getMagicServer()->Magic(thread_id, core ? core->getId() : INVALID_CORE_ID, cmd, arg0, arg1);
-}
-
-void setInstrumentationMode(UInt64 opt)
-{
-   handleMagic(INVALID_THREAD_ID, SIM_CMD_INSTRUMENT_MODE, opt);
-}
-
-UInt64 handleMagicInstruction(thread_id_t thread_id, UInt64 cmd, UInt64 arg0, UInt64 arg1)
-{
-   switch(cmd)
-   {
-   case SIM_CMD_ROI_TOGGLE:
-   case SIM_CMD_ROI_START:
-   case SIM_CMD_ROI_END:
-   case SIM_CMD_MHZ_SET:
-   case SIM_CMD_MARKER:
-   case SIM_CMD_NAMED_MARKER:
-   case SIM_CMD_USER:
-   case SIM_CMD_INSTRUMENT_MODE:
-   case SIM_CMD_MHZ_GET:
-   case SIM_CMD_SET_THREAD_NAME:
-      return handleMagic(thread_id, cmd, arg0, arg1);
-   case SIM_CMD_PROC_ID:
-   {
-      Core *core = Sim()->getCoreManager()->getCurrentCore();
-      return core->getId();
-   }
-   case SIM_CMD_THREAD_ID:
-      return thread_id;
-   case SIM_CMD_NUM_PROCS:
-      return Sim()->getConfig()->getApplicationCores();
-   case SIM_CMD_NUM_THREADS:
-      return Sim()->getThreadManager()->getNumThreads();
-   case SIM_CMD_IN_SIMULATOR:
-      return 0;
-   default:
-      LOG_PRINT_WARNING_ONCE("Encountered unknown magic instruction cmd(%u)", cmd);
-      return 1;
-   }
-}
+#include "magic_client.h"
+#include "magic_server.h"
+#include "sim_api.h"
+#include "simulator.h"
+#include "core.h"
+#include "core_manager.h"
+#include "thread.h"
+#include "thread_manager.h"
+#include "dvfs_manager.h"
+
+extern double* Temperature;
+extern double* Power;
+extern UInt64* currentIps;
+extern UInt64* accumulatedExecutedInstructions;
+extern std::vector<bool> islandTurboBoostEnabled;
+extern std::vector<int> coresReservedForApplication;
+extern std::vector<bool> applicationFinished;
+extern std::vector< UInt64 > averageIPCinWindow;
+extern std::vector< double > averageTemperatureInWindow;
+
+static UInt64 handleMagic(thread_id_t thread_id, UInt64 cmd, UInt64 arg0 = 0, UInt64 arg1 = 0)
+{
+   Thread *thread = (thread_id == INVALID_THREAD_ID) ? NULL : Sim()->getThreadManager()->getThreadFromID(thread_id);
+   Core *core = thread == NULL ? NULL : thread->getCore();
+   return Sim()->getMagicServer()->Magic(thread_id, core ? core->getId() : INVALID_CORE_ID, cmd, arg0, arg1);
+}
+
+void setInstrumentationMode(UInt64 opt)
+{
+   handleMagic(INVALID_THREAD_ID, SIM_CMD_INSTRUMENT_MODE, opt);
+}
+
+UInt64 handleMagicInstruction(thread_id_t thread_id, UInt64 cmd, UInt64 arg0, UInt64 arg1)
+{
+   switch(cmd)
+   {
+   case SIM_CMD_ROI_TOGGLE:
+   case SIM_CMD_ROI_START:
+   case SIM_CMD_ROI_END:
+   case SIM_CMD_MHZ_SET:
+   case SIM_CMD_MARKER:
+   case SIM_CMD_NAMED_MARKER:
+   case SIM_CMD_USER:
+   case SIM_CMD_INSTRUMENT_MODE:
+   case SIM_CMD_MHZ_GET:
+   case SIM_CMD_SET_THREAD_NAME:
+   // These new three API functions below simply call the handleMagic(thread_id, cmd, arg0, arg1) function
+   // and they are handled there.
+   case SIM_CMD_SET_THREAD_AFFINITY:
+   case SIM_CMD_GET_THREAD_APP_ID:
+   case SIM_CMD_IS_THREAD_FINISHED:
+      return handleMagic(thread_id, cmd, arg0, arg1);
+   case SIM_CMD_PROC_ID:
+   {
+      Core *core = Sim()->getCoreManager()->getCurrentCore();
+      return core->getId();
+   }
+   case SIM_CMD_THREAD_ID:
+      return thread_id;
+   case SIM_CMD_NUM_PROCS:
+      return Sim()->getConfig()->getApplicationCores();
+   case SIM_CMD_NUM_THREADS:
+      return Sim()->getThreadManager()->getNumThreads();
+   case SIM_CMD_IN_SIMULATOR:
+      return 0;
+   case SIM_CMD_GET_TEMPERATURE:
+      // Return the current temperature of the specified core ID (i.e., arg0) from the Temperature vector.
+      // Note that the temperature vector is an integer that holds the value in microKelvin, and hence the
+      // temperature value is multiplied by 1000000.0 before returning it.
+ 	  if(arg0 < Sim()->getConfig()->getApplicationCores())
+ 		  return (UInt64)(Temperature[arg0]*1000000.0);
+ 	  else
+ 		  return 0;
+   case SIM_CMD_GET_POWER:
+      // Return the current power consumption of the specified core ID (i.e., arg0) from the Power vector.
+      // Note that the power vector is an integer that holds the value in microWatts, and hence the
+      // power value is multiplied by 1000000.0.
+ 	  if(arg0 < Sim()->getConfig()->getApplicationCores())
+ 		  return (UInt64)(Power[arg0]*1000000.0);
+ 	  else
+ 		  return 0;
+   case SIM_CMD_GET_IPS:
+      // Return the current IPS of the specified core ID (i.e., arg0) from the currentIps vector.
+	  if(arg0 < Sim()->getConfig()->getApplicationCores())
+		  return currentIps[arg0];
+	  else
+		  return 0;
+   case SIM_CMD_GET_ACCUMULATED_INSTRUCTIONS:
+      // Return the accumulated executed instructions of the specified core ID (i.e., arg0) from the
+      // accumulatedExecutedInstructions vector.
+	  if(arg0 < Sim()->getConfig()->getApplicationCores())
+		  return accumulatedExecutedInstructions[arg0];
+	  else
+		  return 0;
+   case SIM_CMD_SET_ISLAND_BOOSTING:
+       // Set the status of Turbo Boost (similar to Intel's Turbo Boost) for the specified voltage island
+       // (i.e., arg0) to the specified value (\i.e., arg1), by modifying the islandTurboBoostEnabled vector.
+   	   if(arg0 < Sim()->getDvfsManager()->getNumberCoreDomains()){
+   		   if(arg0 < islandTurboBoostEnabled.size()){
+   			   if(arg1 == false){
+   				   islandTurboBoostEnabled[arg0] = false;
+   			   }
+   			   else{
+   				   islandTurboBoostEnabled[arg0] = true;
+   			   }
+   		   }
+   		   else{
+   			LOG_PRINT_WARNING_ONCE("The size of the vector with the Turbo Boost state is only %u", islandTurboBoostEnabled.size());
+   		   }
+   	   }
+   	   else{
+   		LOG_PRINT_WARNING_ONCE("There are only %u voltage/frequency islands in the system", Sim()->getDvfsManager()->getNumberCoreDomains());
+   	   }
+   	   return 0;
+   case SIM_CMD_RESERVE_CORES_FOR_APPLICATION:
+       // Reserve a core ID (i.e., arg0) for a certain application (i.e., arg1) for newly created threads.
+       // That is, threads that were already spawned before this command was issued should be migrated
+       // with SimSetThreadAffinity(). However, when one or more cores are reserved for a certain
+       // application, then newly created threads will have their affinities automatically set to one of
+       // the reserved cores, saving an additional thread migration. In case that an application has no
+       // cores reserved for it, then the default affinity selection of Sniper is used.
+	   if(arg0 < coresReservedForApplication.size()){
+		   coresReservedForApplication[arg0] = arg1;
+	   }
+	   return 0;
+   case SIM_CM_IS_APPLICATION_FINISHED:
+       // Returns whether the application ID (i.e., arg0) has finished execution. Note that Sniper
+       // does not delete application IDs from its application list (similar to processes IDs in Linux).
+	   if(arg0 < applicationFinished.size()){
+		   return applicationFinished[arg0];
+	   }
+	   else{
+		   return false;
+	   }
+   case SIM_CMD_GET_AVERAGE_TEMPERATURE_LAST_WINDOW:
+      // Return the average temperature of a core (or floorplan unit if the index corresponds to a block in
+      // the floorplan that is not a core) during the last (fixed-time and hardcoded) time window.
+	  // The average temperature is returned in microKelvin.
+ 	  if(arg0 < Sim()->getConfig()->getApplicationCores())
+ 		  return (UInt64)(averageTemperatureInWindow[arg0]*1000000.0);
+ 	  else
+ 		  return 0;
+   case SIM_CMD_GET_AVERAGE_IPC_LAST_WINDOW:
+      // Return the average instructions per cycle (IPC) of the specified core during the
+	  // last (fixed-time and hardcoded) time window.
+ 	  if(arg0 < Sim()->getConfig()->getApplicationCores())
+ 		  return (UInt64)(averageIPCinWindow[arg0]*1000000.0);
+ 	  else
+ 		  return 0;
+   default:
+      LOG_PRINT_WARNING_ONCE("Encountered unknown magic instruction cmd(%u)", cmd);
+      return 1;
+   }
+}
diff -Naur sniper-6.1_old/common/system/magic_server.cc sniper-6.1/common/system/magic_server.cc
--- sniper-6.1_old/common/system/magic_server.cc	2015-03-24 16:56:51.000000000 +0100
+++ sniper-6.1/common/system/magic_server.cc	2017-08-01 14:34:51.124031000 +0200
@@ -11,6 +11,8 @@
 #include "stats.h"
 #include "timer.h"
 #include "thread.h"
+#include "scheduler_pinned_base.h"
+
 
 MagicServer::MagicServer()
       : m_performance_enabled(false)
@@ -99,6 +101,30 @@
          return setInstrumentationMode(arg0);
       case SIM_CMD_MHZ_GET:
          return getFrequency(arg0);
+      case SIM_CMD_SET_THREAD_AFFINITY:
+          // Set the affinity of the thread ID (i.e., arg0) to a certain core ID (\i.e., arg1).
+          // Sniper will then migrate the thread to the specified core in the next appropriate time epoch.
+    	  if(arg0 < Sim()->getThreadManager()->getNumThreads())
+    		  Sim()->getThreadManager()->getScheduler()->setAffinitySingle(arg0, arg1);
+    	  return 0;
+      case SIM_CMD_GET_THREAD_APP_ID:
+          //  Return the application ID to which the specified thread ID (i.e., arg0) belongs to.
+    	  if(arg0 < Sim()->getThreadManager()->getNumThreads())
+			  return Sim()->getThreadManager()->getThreadFromID(arg0)->getAppId();
+		  return 0;
+      case SIM_CMD_IS_THREAD_FINISHED:
+          // Return whether the thread ID (i.e., arg0) has finished execution. Note that Sniper does
+          // not delete thread IDs from its thread list (similar to processes IDs in Linux).
+    	  if(arg0 < Sim()->getThreadManager()->getNumThreads()){
+    		  Core::State threadState = Sim()->getThreadManager()->getThreadState(arg0);
+    		  if((threadState == Core::IDLE) || (threadState == Core::BROKEN))
+    			  return 1;
+    		  else
+    			  return 0;
+    	  }
+    	  else{
+    		  return 1;
+    	  }
       default:
          LOG_ASSERT_ERROR(false, "Got invalid Magic %lu, arg0(%lu) arg1(%lu)", cmd, arg0, arg1);
    }
diff -Naur sniper-6.1_old/common/trace_frontend/trace_manager.cc sniper-6.1/common/trace_frontend/trace_manager.cc
--- sniper-6.1_old/common/trace_frontend/trace_manager.cc	2015-03-24 16:56:51.000000000 +0100
+++ sniper-6.1/common/trace_frontend/trace_manager.cc	2017-08-01 14:34:53.304034000 +0200
@@ -11,6 +11,9 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 
+#include "configurationParameters.h"
+extern ConfigurationParameters configurationParameters;
+
 TraceManager::TraceManager()
    : m_monitor(new Monitor(this))
    , m_threads(0)
@@ -179,6 +182,19 @@
          Sim()->getHooksManager()->callHooks(HookType::HOOK_APPLICATION_EXIT, (UInt64)app_id);
          Sim()->getStatsManager()->logEvent(StatsManager::EVENT_APP_EXIT, SubsecondTime::MaxTime(), INVALID_CORE_ID, INVALID_THREAD_ID, (UInt64)app_id, 0, "");
 
+         // When an application finishes, depending on the value of the --sim-end configuration variable,
+         // it may be re-executed by Sniper. Particularly, in case --sim-end=first or --sim-end=last, then
+         // applications are not re-executed. However, in case --sim-end=last-restart, then applications are
+         // re-executed automatically by Sniper when they finished.
+         // Either way, variable m_num_apps_nonfinish keeps track of the number of applications that have yet
+         // to finish at least one time. Therefore, the value of m_num_apps_nonfinish is used in combination
+         // with --sim-end for the cases in which --sim-end=last or --sim-end=last-restart.
+         // In other words, when --sim-end=first Sniper finishes execution when the first application finishes.
+         // However, when --sim-end=last or --sim-end=last-restart, Sniper finishes execution when all applications
+         // have finished at least one time (in case --sim-end=last-restart they might have finished more than
+         // once).
+         // Because of this, the value of m_num_apps_nonfinish is only decreased the first time each
+         // application finishes.
          if (m_app_info[app_id].num_runs == 1)
             m_num_apps_nonfinish--;
 
@@ -187,7 +203,14 @@
             // First app has ended: stop
             stop();
          }
-         else if (m_num_apps_nonfinish == 0)
+         // Depending on the value of parameter -schedulerAppRunning in the configuration file, then Sniper
+         // will finish either when (m_num_apps_nonfinish == 0) or when (m_num_apps_nonfinish == 1).
+         // That is, if there is no scheduler running at the user level, then Sniper will finish normally when
+         // (m_num_apps_nonfinish == 0). However, if there is a scheduler running at the user level, then this
+         // application is not expected to ever finish, and therefore Sniper should finish running when
+         // (m_num_apps_nonfinish == 1), as the scheduler app is the last application still running.
+         else if (((configurationParameters.schedulerAppRunning == false)&&(m_num_apps_nonfinish == 0)) ||
+        		 ((configurationParameters.schedulerAppRunning == true)&&(m_num_apps_nonfinish == 1)))
          {
             // All apps have completed at least once: stop
             stop();
diff -Naur sniper-6.1_old/config/base.cfg sniper-6.1/config/base.cfg
--- sniper-6.1_old/config/base.cfg	2015-03-24 16:56:51.000000000 +0100
+++ sniper-6.1/config/base.cfg	2017-08-01 14:34:57.176040000 +0200
@@ -51,7 +51,7 @@
 report = false
 
 [clock_skew_minimization/barrier]
-quantum = 100                         # Synchronize after every quantum (ns)
+quantum = 10000                       # Synchronize after every quantum (ns)
 
 # This section describes parameters for the core model
 [perf_model/core]
diff -Naur sniper-6.1_old/config/buildconf.makefile sniper-6.1/config/buildconf.makefile
--- sniper-6.1_old/config/buildconf.makefile	1970-01-01 01:00:00.000000000 +0100
+++ sniper-6.1/config/buildconf.makefile	2017-08-01 14:34:57.172040000 +0200
@@ -0,0 +1,22 @@
+# This file is auto-generated, changes made to it will be lost. Please edit makebuildscripts.py instead.
+
+SELF_DIR := $(dir $(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST)))
+SNIPER_ROOT ?= $(shell readlink -f $(SELF_DIR)/..)
+
+GRAPHITE_CC:=cc
+GRAPHITE_CFLAGS:=-mno-sse4 -mno-sse4.1 -mno-sse4.2 -mno-sse4a -mno-avx -mno-avx2 -I${SNIPER_ROOT}/include 
+GRAPHITE_CXX:=g++
+GRAPHITE_CXXFLAGS:=-mno-sse4 -mno-sse4.1 -mno-sse4.2 -mno-sse4a -mno-avx -mno-avx2 -I${SNIPER_ROOT}/include 
+GRAPHITE_LD:=g++
+GRAPHITE_LDFLAGS:=-static -L${SNIPER_ROOT}/lib -pthread 
+GRAPHITE_LD_LIBRARY_PATH:=
+GRAPHITE_UPCCFLAGS:=-I${SNIPER_ROOT}/include  -link-with='g++ -static -L${SNIPER_ROOT}/lib -pthread'
+PIN_HOME:=/home/santiago/Documentos/Saturn/sniper/sniper-6.1/pin_kit
+SNIPER_CC:=cc
+SNIPER_CFLAGS:=-mno-sse4 -mno-sse4.1 -mno-sse4.2 -mno-sse4a -mno-avx -mno-avx2 -I${SNIPER_ROOT}/include 
+SNIPER_CXX:=g++
+SNIPER_CXXFLAGS:=-mno-sse4 -mno-sse4.1 -mno-sse4.2 -mno-sse4a -mno-avx -mno-avx2 -I${SNIPER_ROOT}/include 
+SNIPER_LD:=g++
+SNIPER_LDFLAGS:=-static -L${SNIPER_ROOT}/lib -pthread 
+SNIPER_LD_LIBRARY_PATH:=
+SNIPER_UPCCFLAGS:=-I${SNIPER_ROOT}/include  -link-with='g++ -static -L${SNIPER_ROOT}/lib -pthread'
diff -Naur sniper-6.1_old/config/buildconf.sh sniper-6.1/config/buildconf.sh
--- sniper-6.1_old/config/buildconf.sh	1970-01-01 01:00:00.000000000 +0100
+++ sniper-6.1/config/buildconf.sh	2017-08-01 14:34:57.180040000 +0200
@@ -0,0 +1,21 @@
+# This file is auto-generated, changes made to it will be lost. Please edit makebuildscripts.py instead.
+
+if [ -z "${SNIPER_ROOT}" ] ; then SNIPER_ROOT=$(readlink -f "$(dirname "${BASH_SOURCE[0]}")/..") ; fi
+
+GRAPHITE_CC="cc"
+GRAPHITE_CFLAGS="-mno-sse4 -mno-sse4.1 -mno-sse4.2 -mno-sse4a -mno-avx -mno-avx2 -I${SNIPER_ROOT}/include "
+GRAPHITE_CXX="g++"
+GRAPHITE_CXXFLAGS="-mno-sse4 -mno-sse4.1 -mno-sse4.2 -mno-sse4a -mno-avx -mno-avx2 -I${SNIPER_ROOT}/include "
+GRAPHITE_LD="g++"
+GRAPHITE_LDFLAGS="-static -L${SNIPER_ROOT}/lib -pthread "
+GRAPHITE_LD_LIBRARY_PATH=""
+GRAPHITE_UPCCFLAGS="-I${SNIPER_ROOT}/include  -link-with='g++ -static -L${SNIPER_ROOT}/lib -pthread'"
+PIN_HOME="/home/santiago/Documentos/Saturn/sniper/sniper-6.1/pin_kit"
+SNIPER_CC="cc"
+SNIPER_CFLAGS="-mno-sse4 -mno-sse4.1 -mno-sse4.2 -mno-sse4a -mno-avx -mno-avx2 -I${SNIPER_ROOT}/include "
+SNIPER_CXX="g++"
+SNIPER_CXXFLAGS="-mno-sse4 -mno-sse4.1 -mno-sse4.2 -mno-sse4a -mno-avx -mno-avx2 -I${SNIPER_ROOT}/include "
+SNIPER_LD="g++"
+SNIPER_LDFLAGS="-static -L${SNIPER_ROOT}/lib -pthread "
+SNIPER_LD_LIBRARY_PATH=""
+SNIPER_UPCCFLAGS="-I${SNIPER_ROOT}/include  -link-with='g++ -static -L${SNIPER_ROOT}/lib -pthread'"
diff -Naur sniper-6.1_old/config/gainestown.cfg sniper-6.1/config/gainestown.cfg
--- sniper-6.1_old/config/gainestown.cfg	2015-03-24 16:56:51.000000000 +0100
+++ sniper-6.1/config/gainestown.cfg	2017-08-01 14:34:57.180040000 +0200
@@ -5,12 +5,12 @@
 #include nehalem
 
 [perf_model/core]
-frequency = 2.66
+frequency = 2.60
 
 [perf_model/l3_cache]
 perfect = false
 cache_block_size = 64
-cache_size = 8192
+cache_size = 4096
 associativity = 16
 address_hash = mask
 replacement_policy = lru
@@ -46,3 +46,5 @@
 bandwidth = 25.6 # in GB/s. Actually, it's 12.8 GB/s per direction and per connected chip pair
 ignore_local_traffic = true # Memory controllers are on-chip, so traffic from core0 to dram0 does not use the QPI links
 
+[power]
+technology_node = 22 # nm
diff -Naur sniper-6.1_old/config/nehalem.cfg sniper-6.1/config/nehalem.cfg
--- sniper-6.1_old/config/nehalem.cfg	2015-03-24 16:56:51.000000000 +0100
+++ sniper-6.1/config/nehalem.cfg	2017-08-01 14:34:57.176040000 +0200
@@ -97,8 +97,8 @@
 transition_latency = 2000 # In ns, "under 2 microseconds" according to http://download.intel.com/design/intarch/papers/323671.pdf (page 8)
 
 [dvfs/simple]
-cores_per_socket = 1
+cores_per_socket = 4
 
 [power]
 vdd = 1.2 # Volts
-technology_node = 45 # nm
+technology_node = 22 # nm
diff -Naur sniper-6.1_old/config/noc.cfg sniper-6.1/config/noc.cfg
--- sniper-6.1_old/config/noc.cfg	2015-03-24 16:56:51.000000000 +0100
+++ sniper-6.1/config/noc.cfg	2017-08-01 14:34:57.180040000 +0200
@@ -2,8 +2,8 @@
 memory_model_1 = emesh_hop_by_hop
 
 [network/emesh_hop_by_hop]
-hop_latency = 2            # Per-hop latency in core cycles
+hop_latency = 3            # Per-hop latency in core cycles
 link_bandwidth = 64        # Per-link, per-direction bandwidth in bits/cycle
-dimensions = 1             # Mesh dimensions (1 for line/ring, 2 for mesh/torus)
-wrap_around = true         # Has wrap-around links? (false for line/mesh, true for ring/torus)
-concentration = 1          # Number of cores per network interface (must be >= last-level-cache/shared_cores)
+dimensions = 2             # Mesh dimensions (1 for line/ring, 2 for mesh/torus)
+wrap_around = false         # Has wrap-around links? (false for line/mesh, true for ring/torus)
+concentration = 4          # Number of cores per network interface (must be >= last-level-cache/shared_cores)
diff -Naur sniper-6.1_old/config/sniper.py sniper-6.1/config/sniper.py
--- sniper-6.1_old/config/sniper.py	1970-01-01 01:00:00.000000000 +0100
+++ sniper-6.1/config/sniper.py	2017-08-01 14:34:57.176040000 +0200
@@ -0,0 +1,3 @@
+# This file is auto-generated, changes made to it will be lost. Please edit Makefile instead.
+target="intel64"
+pin_home="pin_kit"
diff -Naur sniper-6.1_old/.gitignore sniper-6.1/.gitignore
--- sniper-6.1_old/.gitignore	2015-03-24 16:56:51.000000000 +0100
+++ sniper-6.1/.gitignore	1970-01-01 01:00:00.000000000 +0100
@@ -1,53 +0,0 @@
-# object files
-*.d
-*.o
-*.pyc
-
-# emacs temp files
-*~
-
-# vi temp files
-*.swp
-
-# test output
-*.log
-sim.out
-sim.cfg
-sim.info
-sim.stats
-sim.stats.base
-sim.stats.delta
-sim.stats.db
-sim.stats.sqlite3
-appdebug_port.out
-debug_offset.out
-graphite.out
-cpi-stack.jpg
-output_files
-tools/cpistack-collect/cpistack-*
-
-# compiled libraries
-lib/libcarbon_sim.a
-lib/pin_sim.so
-lib/libgraphite_user.a
-lib/sniper
-config/buildconf.*
-config/sniper.py
-docs
-.build_os
-include/linux/perf_event.h
-sift/libsift.a
-sift/siftdump
-sift/recorder/sift_recorder
-tools/pinversion
-
-# result files
-results/
-!results/.DO_NOT_DELETE
-
-# dependencies
-boost_1_38_0
-pin_kit
-linux_2_6_32
-mcpat
-python_kit
diff -Naur sniper-6.1_old/include/linux/perf_event.h sniper-6.1/include/linux/perf_event.h
--- sniper-6.1_old/include/linux/perf_event.h	1970-01-01 01:00:00.000000000 +0100
+++ sniper-6.1/include/linux/perf_event.h	2017-08-01 14:34:47.048025000 +0200
@@ -0,0 +1,816 @@
+/*
+ * Performance events:
+ *
+ *    Copyright (C) 2008-2009, Thomas Gleixner <tglx@linutronix.de>
+ *    Copyright (C) 2008-2011, Red Hat, Inc., Ingo Molnar
+ *    Copyright (C) 2008-2011, Red Hat, Inc., Peter Zijlstra
+ *
+ * Data type definitions, declarations, prototypes.
+ *
+ *    Started by: Thomas Gleixner and Ingo Molnar
+ *
+ * For licencing details see kernel-base/COPYING
+ */
+#ifndef _LINUX_PERF_EVENT_H
+#define _LINUX_PERF_EVENT_H
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+#include <asm/byteorder.h>
+
+/*
+ * User-space ABI bits:
+ */
+
+/*
+ * attr.type
+ */
+enum perf_type_id {
+	PERF_TYPE_HARDWARE			= 0,
+	PERF_TYPE_SOFTWARE			= 1,
+	PERF_TYPE_TRACEPOINT			= 2,
+	PERF_TYPE_HW_CACHE			= 3,
+	PERF_TYPE_RAW				= 4,
+	PERF_TYPE_BREAKPOINT			= 5,
+
+	PERF_TYPE_MAX,				/* non-ABI */
+};
+
+/*
+ * Generalized performance event event_id types, used by the
+ * attr.event_id parameter of the sys_perf_event_open()
+ * syscall:
+ */
+enum perf_hw_id {
+	/*
+	 * Common hardware events, generalized by the kernel:
+	 */
+	PERF_COUNT_HW_CPU_CYCLES		= 0,
+	PERF_COUNT_HW_INSTRUCTIONS		= 1,
+	PERF_COUNT_HW_CACHE_REFERENCES		= 2,
+	PERF_COUNT_HW_CACHE_MISSES		= 3,
+	PERF_COUNT_HW_BRANCH_INSTRUCTIONS	= 4,
+	PERF_COUNT_HW_BRANCH_MISSES		= 5,
+	PERF_COUNT_HW_BUS_CYCLES		= 6,
+	PERF_COUNT_HW_STALLED_CYCLES_FRONTEND	= 7,
+	PERF_COUNT_HW_STALLED_CYCLES_BACKEND	= 8,
+	PERF_COUNT_HW_REF_CPU_CYCLES		= 9,
+
+	PERF_COUNT_HW_MAX,			/* non-ABI */
+};
+
+/*
+ * Generalized hardware cache events:
+ *
+ *       { L1-D, L1-I, LLC, ITLB, DTLB, BPU, NODE } x
+ *       { read, write, prefetch } x
+ *       { accesses, misses }
+ */
+enum perf_hw_cache_id {
+	PERF_COUNT_HW_CACHE_L1D			= 0,
+	PERF_COUNT_HW_CACHE_L1I			= 1,
+	PERF_COUNT_HW_CACHE_LL			= 2,
+	PERF_COUNT_HW_CACHE_DTLB		= 3,
+	PERF_COUNT_HW_CACHE_ITLB		= 4,
+	PERF_COUNT_HW_CACHE_BPU			= 5,
+	PERF_COUNT_HW_CACHE_NODE		= 6,
+
+	PERF_COUNT_HW_CACHE_MAX,		/* non-ABI */
+};
+
+enum perf_hw_cache_op_id {
+	PERF_COUNT_HW_CACHE_OP_READ		= 0,
+	PERF_COUNT_HW_CACHE_OP_WRITE		= 1,
+	PERF_COUNT_HW_CACHE_OP_PREFETCH		= 2,
+
+	PERF_COUNT_HW_CACHE_OP_MAX,		/* non-ABI */
+};
+
+enum perf_hw_cache_op_result_id {
+	PERF_COUNT_HW_CACHE_RESULT_ACCESS	= 0,
+	PERF_COUNT_HW_CACHE_RESULT_MISS		= 1,
+
+	PERF_COUNT_HW_CACHE_RESULT_MAX,		/* non-ABI */
+};
+
+/*
+ * Special "software" events provided by the kernel, even if the hardware
+ * does not support performance events. These events measure various
+ * physical and sw events of the kernel (and allow the profiling of them as
+ * well):
+ */
+enum perf_sw_ids {
+	PERF_COUNT_SW_CPU_CLOCK			= 0,
+	PERF_COUNT_SW_TASK_CLOCK		= 1,
+	PERF_COUNT_SW_PAGE_FAULTS		= 2,
+	PERF_COUNT_SW_CONTEXT_SWITCHES		= 3,
+	PERF_COUNT_SW_CPU_MIGRATIONS		= 4,
+	PERF_COUNT_SW_PAGE_FAULTS_MIN		= 5,
+	PERF_COUNT_SW_PAGE_FAULTS_MAJ		= 6,
+	PERF_COUNT_SW_ALIGNMENT_FAULTS		= 7,
+	PERF_COUNT_SW_EMULATION_FAULTS		= 8,
+	PERF_COUNT_SW_DUMMY			= 9,
+
+	PERF_COUNT_SW_MAX,			/* non-ABI */
+};
+
+/*
+ * Bits that can be set in attr.sample_type to request information
+ * in the overflow packets.
+ */
+enum perf_event_sample_format {
+	PERF_SAMPLE_IP				= 1U << 0,
+	PERF_SAMPLE_TID				= 1U << 1,
+	PERF_SAMPLE_TIME			= 1U << 2,
+	PERF_SAMPLE_ADDR			= 1U << 3,
+	PERF_SAMPLE_READ			= 1U << 4,
+	PERF_SAMPLE_CALLCHAIN			= 1U << 5,
+	PERF_SAMPLE_ID				= 1U << 6,
+	PERF_SAMPLE_CPU				= 1U << 7,
+	PERF_SAMPLE_PERIOD			= 1U << 8,
+	PERF_SAMPLE_STREAM_ID			= 1U << 9,
+	PERF_SAMPLE_RAW				= 1U << 10,
+	PERF_SAMPLE_BRANCH_STACK		= 1U << 11,
+	PERF_SAMPLE_REGS_USER			= 1U << 12,
+	PERF_SAMPLE_STACK_USER			= 1U << 13,
+	PERF_SAMPLE_WEIGHT			= 1U << 14,
+	PERF_SAMPLE_DATA_SRC			= 1U << 15,
+	PERF_SAMPLE_IDENTIFIER			= 1U << 16,
+	PERF_SAMPLE_TRANSACTION			= 1U << 17,
+
+	PERF_SAMPLE_MAX = 1U << 18,		/* non-ABI */
+};
+
+/*
+ * values to program into branch_sample_type when PERF_SAMPLE_BRANCH is set
+ *
+ * If the user does not pass priv level information via branch_sample_type,
+ * the kernel uses the event's priv level. Branch and event priv levels do
+ * not have to match. Branch priv level is checked for permissions.
+ *
+ * The branch types can be combined, however BRANCH_ANY covers all types
+ * of branches and therefore it supersedes all the other types.
+ */
+enum perf_branch_sample_type {
+	PERF_SAMPLE_BRANCH_USER		= 1U << 0, /* user branches */
+	PERF_SAMPLE_BRANCH_KERNEL	= 1U << 1, /* kernel branches */
+	PERF_SAMPLE_BRANCH_HV		= 1U << 2, /* hypervisor branches */
+
+	PERF_SAMPLE_BRANCH_ANY		= 1U << 3, /* any branch types */
+	PERF_SAMPLE_BRANCH_ANY_CALL	= 1U << 4, /* any call branch */
+	PERF_SAMPLE_BRANCH_ANY_RETURN	= 1U << 5, /* any return branch */
+	PERF_SAMPLE_BRANCH_IND_CALL	= 1U << 6, /* indirect calls */
+	PERF_SAMPLE_BRANCH_ABORT_TX	= 1U << 7, /* transaction aborts */
+	PERF_SAMPLE_BRANCH_IN_TX	= 1U << 8, /* in transaction */
+	PERF_SAMPLE_BRANCH_NO_TX	= 1U << 9, /* not in transaction */
+
+	PERF_SAMPLE_BRANCH_MAX		= 1U << 10, /* non-ABI */
+};
+
+#define PERF_SAMPLE_BRANCH_PLM_ALL \
+	(PERF_SAMPLE_BRANCH_USER|\
+	 PERF_SAMPLE_BRANCH_KERNEL|\
+	 PERF_SAMPLE_BRANCH_HV)
+
+/*
+ * Values to determine ABI of the registers dump.
+ */
+enum perf_sample_regs_abi {
+	PERF_SAMPLE_REGS_ABI_NONE	= 0,
+	PERF_SAMPLE_REGS_ABI_32		= 1,
+	PERF_SAMPLE_REGS_ABI_64		= 2,
+};
+
+/*
+ * Values for the memory transaction event qualifier, mostly for
+ * abort events. Multiple bits can be set.
+ */
+enum {
+	PERF_TXN_ELISION        = (1 << 0), /* From elision */
+	PERF_TXN_TRANSACTION    = (1 << 1), /* From transaction */
+	PERF_TXN_SYNC           = (1 << 2), /* Instruction is related */
+	PERF_TXN_ASYNC          = (1 << 3), /* Instruction not related */
+	PERF_TXN_RETRY          = (1 << 4), /* Retry possible */
+	PERF_TXN_CONFLICT       = (1 << 5), /* Conflict abort */
+	PERF_TXN_CAPACITY_WRITE = (1 << 6), /* Capacity write abort */
+	PERF_TXN_CAPACITY_READ  = (1 << 7), /* Capacity read abort */
+
+	PERF_TXN_MAX	        = (1 << 8), /* non-ABI */
+
+	/* bits 32..63 are reserved for the abort code */
+
+	PERF_TXN_ABORT_MASK  = (0xffffffffULL << 32),
+	PERF_TXN_ABORT_SHIFT = 32,
+};
+
+/*
+ * The format of the data returned by read() on a perf event fd,
+ * as specified by attr.read_format:
+ *
+ * struct read_format {
+ *	{ u64		value;
+ *	  { u64		time_enabled; } && PERF_FORMAT_TOTAL_TIME_ENABLED
+ *	  { u64		time_running; } && PERF_FORMAT_TOTAL_TIME_RUNNING
+ *	  { u64		id;           } && PERF_FORMAT_ID
+ *	} && !PERF_FORMAT_GROUP
+ *
+ *	{ u64		nr;
+ *	  { u64		time_enabled; } && PERF_FORMAT_TOTAL_TIME_ENABLED
+ *	  { u64		time_running; } && PERF_FORMAT_TOTAL_TIME_RUNNING
+ *	  { u64		value;
+ *	    { u64	id;           } && PERF_FORMAT_ID
+ *	  }		cntr[nr];
+ *	} && PERF_FORMAT_GROUP
+ * };
+ */
+enum perf_event_read_format {
+	PERF_FORMAT_TOTAL_TIME_ENABLED		= 1U << 0,
+	PERF_FORMAT_TOTAL_TIME_RUNNING		= 1U << 1,
+	PERF_FORMAT_ID				= 1U << 2,
+	PERF_FORMAT_GROUP			= 1U << 3,
+
+	PERF_FORMAT_MAX = 1U << 4,		/* non-ABI */
+};
+
+#define PERF_ATTR_SIZE_VER0	64	/* sizeof first published struct */
+#define PERF_ATTR_SIZE_VER1	72	/* add: config2 */
+#define PERF_ATTR_SIZE_VER2	80	/* add: branch_sample_type */
+#define PERF_ATTR_SIZE_VER3	96	/* add: sample_regs_user */
+					/* add: sample_stack_user */
+
+/*
+ * Hardware event_id to monitor via a performance monitoring event:
+ */
+struct perf_event_attr {
+
+	/*
+	 * Major type: hardware/software/tracepoint/etc.
+	 */
+	__u32			type;
+
+	/*
+	 * Size of the attr structure, for fwd/bwd compat.
+	 */
+	__u32			size;
+
+	/*
+	 * Type specific configuration information.
+	 */
+	__u64			config;
+
+	union {
+		__u64		sample_period;
+		__u64		sample_freq;
+	};
+
+	__u64			sample_type;
+	__u64			read_format;
+
+	__u64			disabled       :  1, /* off by default        */
+				inherit	       :  1, /* children inherit it   */
+				pinned	       :  1, /* must always be on PMU */
+				exclusive      :  1, /* only group on PMU     */
+				exclude_user   :  1, /* don't count user      */
+				exclude_kernel :  1, /* ditto kernel          */
+				exclude_hv     :  1, /* ditto hypervisor      */
+				exclude_idle   :  1, /* don't count when idle */
+				mmap           :  1, /* include mmap data     */
+				comm	       :  1, /* include comm data     */
+				freq           :  1, /* use freq, not period  */
+				inherit_stat   :  1, /* per task counts       */
+				enable_on_exec :  1, /* next exec enables     */
+				task           :  1, /* trace fork/exit       */
+				watermark      :  1, /* wakeup_watermark      */
+				/*
+				 * precise_ip:
+				 *
+				 *  0 - SAMPLE_IP can have arbitrary skid
+				 *  1 - SAMPLE_IP must have constant skid
+				 *  2 - SAMPLE_IP requested to have 0 skid
+				 *  3 - SAMPLE_IP must have 0 skid
+				 *
+				 *  See also PERF_RECORD_MISC_EXACT_IP
+				 */
+				precise_ip     :  2, /* skid constraint       */
+				mmap_data      :  1, /* non-exec mmap data    */
+				sample_id_all  :  1, /* sample_type all events */
+
+				exclude_host   :  1, /* don't count in host   */
+				exclude_guest  :  1, /* don't count in guest  */
+
+				exclude_callchain_kernel : 1, /* exclude kernel callchains */
+				exclude_callchain_user   : 1, /* exclude user callchains */
+				mmap2          :  1, /* include mmap with inode data     */
+
+				__reserved_1   : 40;
+
+	union {
+		__u32		wakeup_events;	  /* wakeup every n events */
+		__u32		wakeup_watermark; /* bytes before wakeup   */
+	};
+
+	__u32			bp_type;
+	union {
+		__u64		bp_addr;
+		__u64		config1; /* extension of config */
+	};
+	union {
+		__u64		bp_len;
+		__u64		config2; /* extension of config1 */
+	};
+	__u64	branch_sample_type; /* enum perf_branch_sample_type */
+
+	/*
+	 * Defines set of user regs to dump on samples.
+	 * See asm/perf_regs.h for details.
+	 */
+	__u64	sample_regs_user;
+
+	/*
+	 * Defines size of the user stack to dump on samples.
+	 */
+	__u32	sample_stack_user;
+
+	/* Align to u64. */
+	__u32	__reserved_2;
+};
+
+#define perf_flags(attr)	(*(&(attr)->read_format + 1))
+
+/*
+ * Ioctls that can be done on a perf event fd:
+ */
+#define PERF_EVENT_IOC_ENABLE		_IO ('$', 0)
+#define PERF_EVENT_IOC_DISABLE		_IO ('$', 1)
+#define PERF_EVENT_IOC_REFRESH		_IO ('$', 2)
+#define PERF_EVENT_IOC_RESET		_IO ('$', 3)
+#define PERF_EVENT_IOC_PERIOD		_IOW('$', 4, __u64)
+#define PERF_EVENT_IOC_SET_OUTPUT	_IO ('$', 5)
+#define PERF_EVENT_IOC_SET_FILTER	_IOW('$', 6, char *)
+#define PERF_EVENT_IOC_ID		_IOR('$', 7, __u64 *)
+
+enum perf_event_ioc_flags {
+	PERF_IOC_FLAG_GROUP		= 1U << 0,
+};
+
+/*
+ * Structure of the page that can be mapped via mmap
+ */
+struct perf_event_mmap_page {
+	__u32	version;		/* version number of this structure */
+	__u32	compat_version;		/* lowest version this is compat with */
+
+	/*
+	 * Bits needed to read the hw events in user-space.
+	 *
+	 *   u32 seq, time_mult, time_shift, idx, width;
+	 *   u64 count, enabled, running;
+	 *   u64 cyc, time_offset;
+	 *   s64 pmc = 0;
+	 *
+	 *   do {
+	 *     seq = pc->lock;
+	 *     barrier()
+	 *
+	 *     enabled = pc->time_enabled;
+	 *     running = pc->time_running;
+	 *
+	 *     if (pc->cap_usr_time && enabled != running) {
+	 *       cyc = rdtsc();
+	 *       time_offset = pc->time_offset;
+	 *       time_mult   = pc->time_mult;
+	 *       time_shift  = pc->time_shift;
+	 *     }
+	 *
+	 *     idx = pc->index;
+	 *     count = pc->offset;
+	 *     if (pc->cap_usr_rdpmc && idx) {
+	 *       width = pc->pmc_width;
+	 *       pmc = rdpmc(idx - 1);
+	 *     }
+	 *
+	 *     barrier();
+	 *   } while (pc->lock != seq);
+	 *
+	 * NOTE: for obvious reason this only works on self-monitoring
+	 *       processes.
+	 */
+	__u32	lock;			/* seqlock for synchronization */
+	__u32	index;			/* hardware event identifier */
+	__s64	offset;			/* add to hardware event value */
+	__u64	time_enabled;		/* time event active */
+	__u64	time_running;		/* time event on cpu */
+	union {
+		__u64	capabilities;
+		struct {
+			__u64	cap_bit0		: 1, /* Always 0, deprecated, see commit 860f085b74e9 */
+				cap_bit0_is_deprecated	: 1, /* Always 1, signals that bit 0 is zero */
+
+				cap_user_rdpmc		: 1, /* The RDPMC instruction can be used to read counts */
+				cap_user_time		: 1, /* The time_* fields are used */
+				cap_user_time_zero	: 1, /* The time_zero field is used */
+				cap_____res		: 59;
+		};
+	};
+
+	/*
+	 * If cap_usr_rdpmc this field provides the bit-width of the value
+	 * read using the rdpmc() or equivalent instruction. This can be used
+	 * to sign extend the result like:
+	 *
+	 *   pmc <<= 64 - width;
+	 *   pmc >>= 64 - width; // signed shift right
+	 *   count += pmc;
+	 */
+	__u16	pmc_width;
+
+	/*
+	 * If cap_usr_time the below fields can be used to compute the time
+	 * delta since time_enabled (in ns) using rdtsc or similar.
+	 *
+	 *   u64 quot, rem;
+	 *   u64 delta;
+	 *
+	 *   quot = (cyc >> time_shift);
+	 *   rem = cyc & ((1 << time_shift) - 1);
+	 *   delta = time_offset + quot * time_mult +
+	 *              ((rem * time_mult) >> time_shift);
+	 *
+	 * Where time_offset,time_mult,time_shift and cyc are read in the
+	 * seqcount loop described above. This delta can then be added to
+	 * enabled and possible running (if idx), improving the scaling:
+	 *
+	 *   enabled += delta;
+	 *   if (idx)
+	 *     running += delta;
+	 *
+	 *   quot = count / running;
+	 *   rem  = count % running;
+	 *   count = quot * enabled + (rem * enabled) / running;
+	 */
+	__u16	time_shift;
+	__u32	time_mult;
+	__u64	time_offset;
+	/*
+	 * If cap_usr_time_zero, the hardware clock (e.g. TSC) can be calculated
+	 * from sample timestamps.
+	 *
+	 *   time = timestamp - time_zero;
+	 *   quot = time / time_mult;
+	 *   rem  = time % time_mult;
+	 *   cyc = (quot << time_shift) + (rem << time_shift) / time_mult;
+	 *
+	 * And vice versa:
+	 *
+	 *   quot = cyc >> time_shift;
+	 *   rem  = cyc & ((1 << time_shift) - 1);
+	 *   timestamp = time_zero + quot * time_mult +
+	 *               ((rem * time_mult) >> time_shift);
+	 */
+	__u64	time_zero;
+	__u32	size;			/* Header size up to __reserved[] fields. */
+
+		/*
+		 * Hole for extension of the self monitor capabilities
+		 */
+
+	__u8	__reserved[118*8+4];	/* align to 1k. */
+
+	/*
+	 * Control data for the mmap() data buffer.
+	 *
+	 * User-space reading the @data_head value should issue an smp_rmb(),
+	 * after reading this value.
+	 *
+	 * When the mapping is PROT_WRITE the @data_tail value should be
+	 * written by userspace to reflect the last read data, after issueing
+	 * an smp_mb() to separate the data read from the ->data_tail store.
+	 * In this case the kernel will not over-write unread data.
+	 *
+	 * See perf_output_put_handle() for the data ordering.
+	 */
+	__u64   data_head;		/* head in the data section */
+	__u64	data_tail;		/* user-space written tail */
+};
+
+#define PERF_RECORD_MISC_CPUMODE_MASK		(7 << 0)
+#define PERF_RECORD_MISC_CPUMODE_UNKNOWN	(0 << 0)
+#define PERF_RECORD_MISC_KERNEL			(1 << 0)
+#define PERF_RECORD_MISC_USER			(2 << 0)
+#define PERF_RECORD_MISC_HYPERVISOR		(3 << 0)
+#define PERF_RECORD_MISC_GUEST_KERNEL		(4 << 0)
+#define PERF_RECORD_MISC_GUEST_USER		(5 << 0)
+
+#define PERF_RECORD_MISC_MMAP_DATA		(1 << 13)
+/*
+ * Indicates that the content of PERF_SAMPLE_IP points to
+ * the actual instruction that triggered the event. See also
+ * perf_event_attr::precise_ip.
+ */
+#define PERF_RECORD_MISC_EXACT_IP		(1 << 14)
+/*
+ * Reserve the last bit to indicate some extended misc field
+ */
+#define PERF_RECORD_MISC_EXT_RESERVED		(1 << 15)
+
+struct perf_event_header {
+	__u32	type;
+	__u16	misc;
+	__u16	size;
+};
+
+enum perf_event_type {
+
+	/*
+	 * If perf_event_attr.sample_id_all is set then all event types will
+	 * have the sample_type selected fields related to where/when
+	 * (identity) an event took place (TID, TIME, ID, STREAM_ID, CPU,
+	 * IDENTIFIER) described in PERF_RECORD_SAMPLE below, it will be stashed
+	 * just after the perf_event_header and the fields already present for
+	 * the existing fields, i.e. at the end of the payload. That way a newer
+	 * perf.data file will be supported by older perf tools, with these new
+	 * optional fields being ignored.
+	 *
+	 * struct sample_id {
+	 * 	{ u32			pid, tid; } && PERF_SAMPLE_TID
+	 * 	{ u64			time;     } && PERF_SAMPLE_TIME
+	 * 	{ u64			id;       } && PERF_SAMPLE_ID
+	 * 	{ u64			stream_id;} && PERF_SAMPLE_STREAM_ID
+	 * 	{ u32			cpu, res; } && PERF_SAMPLE_CPU
+	 *	{ u64			id;	  } && PERF_SAMPLE_IDENTIFIER
+	 * } && perf_event_attr::sample_id_all
+	 *
+	 * Note that PERF_SAMPLE_IDENTIFIER duplicates PERF_SAMPLE_ID.  The
+	 * advantage of PERF_SAMPLE_IDENTIFIER is that its position is fixed
+	 * relative to header.size.
+	 */
+
+	/*
+	 * The MMAP events record the PROT_EXEC mappings so that we can
+	 * correlate userspace IPs to code. They have the following structure:
+	 *
+	 * struct {
+	 *	struct perf_event_header	header;
+	 *
+	 *	u32				pid, tid;
+	 *	u64				addr;
+	 *	u64				len;
+	 *	u64				pgoff;
+	 *	char				filename[];
+	 * 	struct sample_id		sample_id;
+	 * };
+	 */
+	PERF_RECORD_MMAP			= 1,
+
+	/*
+	 * struct {
+	 *	struct perf_event_header	header;
+	 *	u64				id;
+	 *	u64				lost;
+	 * 	struct sample_id		sample_id;
+	 * };
+	 */
+	PERF_RECORD_LOST			= 2,
+
+	/*
+	 * struct {
+	 *	struct perf_event_header	header;
+	 *
+	 *	u32				pid, tid;
+	 *	char				comm[];
+	 * 	struct sample_id		sample_id;
+	 * };
+	 */
+	PERF_RECORD_COMM			= 3,
+
+	/*
+	 * struct {
+	 *	struct perf_event_header	header;
+	 *	u32				pid, ppid;
+	 *	u32				tid, ptid;
+	 *	u64				time;
+	 * 	struct sample_id		sample_id;
+	 * };
+	 */
+	PERF_RECORD_EXIT			= 4,
+
+	/*
+	 * struct {
+	 *	struct perf_event_header	header;
+	 *	u64				time;
+	 *	u64				id;
+	 *	u64				stream_id;
+	 * 	struct sample_id		sample_id;
+	 * };
+	 */
+	PERF_RECORD_THROTTLE			= 5,
+	PERF_RECORD_UNTHROTTLE			= 6,
+
+	/*
+	 * struct {
+	 *	struct perf_event_header	header;
+	 *	u32				pid, ppid;
+	 *	u32				tid, ptid;
+	 *	u64				time;
+	 * 	struct sample_id		sample_id;
+	 * };
+	 */
+	PERF_RECORD_FORK			= 7,
+
+	/*
+	 * struct {
+	 *	struct perf_event_header	header;
+	 *	u32				pid, tid;
+	 *
+	 *	struct read_format		values;
+	 * 	struct sample_id		sample_id;
+	 * };
+	 */
+	PERF_RECORD_READ			= 8,
+
+	/*
+	 * struct {
+	 *	struct perf_event_header	header;
+	 *
+	 *	#
+	 *	# Note that PERF_SAMPLE_IDENTIFIER duplicates PERF_SAMPLE_ID.
+	 *	# The advantage of PERF_SAMPLE_IDENTIFIER is that its position
+	 *	# is fixed relative to header.
+	 *	#
+	 *
+	 *	{ u64			id;	  } && PERF_SAMPLE_IDENTIFIER
+	 *	{ u64			ip;	  } && PERF_SAMPLE_IP
+	 *	{ u32			pid, tid; } && PERF_SAMPLE_TID
+	 *	{ u64			time;     } && PERF_SAMPLE_TIME
+	 *	{ u64			addr;     } && PERF_SAMPLE_ADDR
+	 *	{ u64			id;	  } && PERF_SAMPLE_ID
+	 *	{ u64			stream_id;} && PERF_SAMPLE_STREAM_ID
+	 *	{ u32			cpu, res; } && PERF_SAMPLE_CPU
+	 *	{ u64			period;   } && PERF_SAMPLE_PERIOD
+	 *
+	 *	{ struct read_format	values;	  } && PERF_SAMPLE_READ
+	 *
+	 *	{ u64			nr,
+	 *	  u64			ips[nr];  } && PERF_SAMPLE_CALLCHAIN
+	 *
+	 *	#
+	 *	# The RAW record below is opaque data wrt the ABI
+	 *	#
+	 *	# That is, the ABI doesn't make any promises wrt to
+	 *	# the stability of its content, it may vary depending
+	 *	# on event, hardware, kernel version and phase of
+	 *	# the moon.
+	 *	#
+	 *	# In other words, PERF_SAMPLE_RAW contents are not an ABI.
+	 *	#
+	 *
+	 *	{ u32			size;
+	 *	  char                  data[size];}&& PERF_SAMPLE_RAW
+	 *
+	 *	{ u64                   nr;
+	 *        { u64 from, to, flags } lbr[nr];} && PERF_SAMPLE_BRANCH_STACK
+	 *
+	 * 	{ u64			abi; # enum perf_sample_regs_abi
+	 * 	  u64			regs[weight(mask)]; } && PERF_SAMPLE_REGS_USER
+	 *
+	 * 	{ u64			size;
+	 * 	  char			data[size];
+	 * 	  u64			dyn_size; } && PERF_SAMPLE_STACK_USER
+	 *
+	 *	{ u64			weight;   } && PERF_SAMPLE_WEIGHT
+	 *	{ u64			data_src; } && PERF_SAMPLE_DATA_SRC
+	 *	{ u64			transaction; } && PERF_SAMPLE_TRANSACTION
+	 * };
+	 */
+	PERF_RECORD_SAMPLE			= 9,
+
+	/*
+	 * The MMAP2 records are an augmented version of MMAP, they add
+	 * maj, min, ino numbers to be used to uniquely identify each mapping
+	 *
+	 * struct {
+	 *	struct perf_event_header	header;
+	 *
+	 *	u32				pid, tid;
+	 *	u64				addr;
+	 *	u64				len;
+	 *	u64				pgoff;
+	 *	u32				maj;
+	 *	u32				min;
+	 *	u64				ino;
+	 *	u64				ino_generation;
+	 *	char				filename[];
+	 * 	struct sample_id		sample_id;
+	 * };
+	 */
+	PERF_RECORD_MMAP2			= 10,
+
+	PERF_RECORD_MAX,			/* non-ABI */
+};
+
+#define PERF_MAX_STACK_DEPTH		127
+
+enum perf_callchain_context {
+	PERF_CONTEXT_HV			= (__u64)-32,
+	PERF_CONTEXT_KERNEL		= (__u64)-128,
+	PERF_CONTEXT_USER		= (__u64)-512,
+
+	PERF_CONTEXT_GUEST		= (__u64)-2048,
+	PERF_CONTEXT_GUEST_KERNEL	= (__u64)-2176,
+	PERF_CONTEXT_GUEST_USER		= (__u64)-2560,
+
+	PERF_CONTEXT_MAX		= (__u64)-4095,
+};
+
+#define PERF_FLAG_FD_NO_GROUP		(1U << 0)
+#define PERF_FLAG_FD_OUTPUT		(1U << 1)
+#define PERF_FLAG_PID_CGROUP		(1U << 2) /* pid=cgroup id, per-cpu mode only */
+
+union perf_mem_data_src {
+	__u64 val;
+	struct {
+		__u64   mem_op:5,	/* type of opcode */
+			mem_lvl:14,	/* memory hierarchy level */
+			mem_snoop:5,	/* snoop mode */
+			mem_lock:2,	/* lock instr */
+			mem_dtlb:7,	/* tlb access */
+			mem_rsvd:31;
+	};
+};
+
+/* type of opcode (load/store/prefetch,code) */
+#define PERF_MEM_OP_NA		0x01 /* not available */
+#define PERF_MEM_OP_LOAD	0x02 /* load instruction */
+#define PERF_MEM_OP_STORE	0x04 /* store instruction */
+#define PERF_MEM_OP_PFETCH	0x08 /* prefetch */
+#define PERF_MEM_OP_EXEC	0x10 /* code (execution) */
+#define PERF_MEM_OP_SHIFT	0
+
+/* memory hierarchy (memory level, hit or miss) */
+#define PERF_MEM_LVL_NA		0x01  /* not available */
+#define PERF_MEM_LVL_HIT	0x02  /* hit level */
+#define PERF_MEM_LVL_MISS	0x04  /* miss level  */
+#define PERF_MEM_LVL_L1		0x08  /* L1 */
+#define PERF_MEM_LVL_LFB	0x10  /* Line Fill Buffer */
+#define PERF_MEM_LVL_L2		0x20  /* L2 */
+#define PERF_MEM_LVL_L3		0x40  /* L3 */
+#define PERF_MEM_LVL_LOC_RAM	0x80  /* Local DRAM */
+#define PERF_MEM_LVL_REM_RAM1	0x100 /* Remote DRAM (1 hop) */
+#define PERF_MEM_LVL_REM_RAM2	0x200 /* Remote DRAM (2 hops) */
+#define PERF_MEM_LVL_REM_CCE1	0x400 /* Remote Cache (1 hop) */
+#define PERF_MEM_LVL_REM_CCE2	0x800 /* Remote Cache (2 hops) */
+#define PERF_MEM_LVL_IO		0x1000 /* I/O memory */
+#define PERF_MEM_LVL_UNC	0x2000 /* Uncached memory */
+#define PERF_MEM_LVL_SHIFT	5
+
+/* snoop mode */
+#define PERF_MEM_SNOOP_NA	0x01 /* not available */
+#define PERF_MEM_SNOOP_NONE	0x02 /* no snoop */
+#define PERF_MEM_SNOOP_HIT	0x04 /* snoop hit */
+#define PERF_MEM_SNOOP_MISS	0x08 /* snoop miss */
+#define PERF_MEM_SNOOP_HITM	0x10 /* snoop hit modified */
+#define PERF_MEM_SNOOP_SHIFT	19
+
+/* locked instruction */
+#define PERF_MEM_LOCK_NA	0x01 /* not available */
+#define PERF_MEM_LOCK_LOCKED	0x02 /* locked transaction */
+#define PERF_MEM_LOCK_SHIFT	24
+
+/* TLB access */
+#define PERF_MEM_TLB_NA		0x01 /* not available */
+#define PERF_MEM_TLB_HIT	0x02 /* hit level */
+#define PERF_MEM_TLB_MISS	0x04 /* miss level */
+#define PERF_MEM_TLB_L1		0x08 /* L1 */
+#define PERF_MEM_TLB_L2		0x10 /* L2 */
+#define PERF_MEM_TLB_WK		0x20 /* Hardware Walker*/
+#define PERF_MEM_TLB_OS		0x40 /* OS fault handler */
+#define PERF_MEM_TLB_SHIFT	26
+
+#define PERF_MEM_S(a, s) \
+	(((u64)PERF_MEM_##a##_##s) << PERF_MEM_##a##_SHIFT)
+
+/*
+ * single taken branch record layout:
+ *
+ *      from: source instruction (may not always be a branch insn)
+ *        to: branch target
+ *   mispred: branch target was mispredicted
+ * predicted: branch target was predicted
+ *
+ * support for mispred, predicted is optional. In case it
+ * is not supported mispred = predicted = 0.
+ *
+ *     in_tx: running in a hardware transaction
+ *     abort: aborting a hardware transaction
+ */
+struct perf_branch_entry {
+	__u64	from;
+	__u64	to;
+	__u64	mispred:1,  /* target mispredicted */
+		predicted:1,/* target predicted */
+		in_tx:1,    /* in transaction */
+		abort:1,    /* transaction abort */
+		reserved:60;
+};
+
+#endif /* _LINUX_PERF_EVENT_H */
diff -Naur sniper-6.1_old/include/sim_api.h sniper-6.1/include/sim_api.h
--- sniper-6.1_old/include/sim_api.h	2015-03-24 16:56:51.000000000 +0100
+++ sniper-6.1/include/sim_api.h	2017-08-01 14:34:47.048025000 +0200
@@ -18,6 +18,19 @@
 #define SIM_CMD_NAMED_MARKER    13
 #define SIM_CMD_SET_THREAD_NAME 14
 
+#define SIM_CMD_GET_TEMPERATURE 15
+#define SIM_CMD_GET_POWER 16
+#define SIM_CMD_SET_THREAD_AFFINITY 17
+#define SIM_CMD_GET_THREAD_APP_ID	18
+#define SIM_CMD_IS_THREAD_FINISHED	19
+#define SIM_CMD_GET_IPS		20
+#define SIM_CMD_GET_ACCUMULATED_INSTRUCTIONS		21
+#define SIM_CMD_SET_ISLAND_BOOSTING	22
+#define SIM_CMD_RESERVE_CORES_FOR_APPLICATION	23
+#define SIM_CM_IS_APPLICATION_FINISHED	24
+#define SIM_CMD_GET_AVERAGE_TEMPERATURE_LAST_WINDOW 25
+#define SIM_CMD_GET_AVERAGE_IPC_LAST_WINDOW 26
+
 #define SIM_OPT_INSTRUMENT_DETAILED    0
 #define SIM_OPT_INSTRUMENT_WARMUP      1
 #define SIM_OPT_INSTRUMENT_FASTFORWARD 2
@@ -91,4 +104,109 @@
 #define SimSetInstrumentMode(opt) SimMagic1(SIM_CMD_INSTRUMENT_MODE, opt)
 #define SimInSimulator()          (SimMagic0(SIM_CMD_IN_SIMULATOR)!=SIM_CMD_IN_SIMULATOR)
 
+/**	New API function that returns the current temperature of the specified core ID.
+	Note that the returned temperature is an integer that holds the value in microKelvin,
+	and hence the temperature value should be divided by 1000000.0 to convert it back to
+	Kelvin.
+ */
+#define SimGetTemperature(proc)		SimMagic1(SIM_CMD_GET_TEMPERATURE, proc)
+
+/**	New API function that returns the current temperature of the core from where the function is called.
+	Note that the returned temperature is an integer that holds the value in microKelvin,
+	and hence the temperature value should be divided by 1000000.0 to convert it back to
+	Kelvin.
+ */
+#define SimGetOwnTemperature()		SimGetTemperature(SimGetProcId())
+
+/** New API function that returns the current power consumption of the specified core ID.
+ */
+#define SimGetPower(proc)			SimMagic1(SIM_CMD_GET_POWER, proc)
+
+/** New API function that returns the current power consumption of the core from where the function is called.
+ */
+#define SimGetOwnPower()			SimGetPower(SimGetProcId())
+
+/** New API function that sets the affinity of a thread ID to a certain core ID. Sniper will then
+    migrate the thread to the specified core in the next appropriate time epoch.
+ */
+#define SimSetThreadAffinity(thread, affinity)	SimMagic2(SIM_CMD_SET_THREAD_AFFINITY, thread, affinity)
+
+/** New API function that sets the affinity of the thread that calls this function to a certain core ID.
+    Sniper will then migrate the thread to the specified core in the next appropriate time epoch.
+    This is normally used when the scheduler/power manager wants to be executed in a certain core.
+ */
+#define SimSetOwnAffinity(affinity)	SimSetThreadAffinity(SimGetThreadId(), affinity)
+
+/** New API function that returns the application ID to which the specified thread ID belongs to.
+ */
+#define SimGetThreadAppId(thread)	SimMagic1(SIM_CMD_GET_THREAD_APP_ID, thread)
+
+/** New API function that returns whether a certain thread ID has finished execution. Note that Sniper does
+    not delete thread IDs from its thread list (similar to processes IDs in Linux).
+ */
+#define SimIsThreadFinished(thread)	SimMagic1(SIM_CMD_IS_THREAD_FINISHED, thread)
+
+/** New API function that returns whether a certain application ID has finished execution. Note that Sniper
+    does not delete application IDs from its application list (similar to processes IDs in Linux).
+ */
+#define SimIsApplicationFinished(app)	SimMagic1(SIM_CM_IS_APPLICATION_FINISHED, app)
+
+/** New API function that returns the current Instructions per Second (IPS) of the specified core ID.
+ */
+#define SimGetIps(proc)			SimMagic1(SIM_CMD_GET_IPS, proc)
+
+/** New API function that returns the total executed instructions (accumulated since the beggining of the
+    simulation) of the specified core ID.
+ */
+#define SimGetAccumulatedInstructions(proc)			SimMagic1(SIM_CMD_GET_ACCUMULATED_INSTRUCTIONS, proc)
+
+/** New API function that returns the total executed instructions (accumulated since the beggining of the
+    simulation) of the core from where the function is called.
+ */
+#define SimGetOwnAccumulatedInstructions()			SimGetAccumulatedInstructions(SimGetProcId())
+
+/** New API function that sets the status of Turbo Boost (similar to Intel's Turbo Boost) for the specified
+    voltage island.
+ */
+#define SimSetIslandBoosting(island, boostingIsland)			SimMagic2(SIM_CMD_SET_ISLAND_BOOSTING, island, boostingIsland)
+
+/** New API function that activates Turbo Boost (similar to Intel's Turbo Boost) for the specified
+    voltage island.
+ */
+#define SimActivateIslandBoosting(island)	SimSetIslandBoosting(island, true)
+
+/** New API function that deactivates Turbo Boost (similar to Intel's Turbo Boost) for the specified
+    voltage island.
+ */
+#define SimDeactivateIslandBoosting(island)	SimSetIslandBoosting(island, false)
+
+/** New API function that reserves a core for a certain application for newly created threads. That is,
+    threads that were already spawned before this command was issued should be migrated with
+    SimSetThreadAffinity(). However, when one or more cores are reserved for a certain application, then
+    newly created threads will have their affinities automatically set to one of the reserved cores, saving
+    an additional thread migration. In case that an application has no cores reserved for it, then the
+    default affinity selection of Sniper is used.
+ */
+#define SimReserveCoreForApplication(proc,app)	SimMagic2(SIM_CMD_RESERVE_CORES_FOR_APPLICATION, proc, app)
+
+/**	New API function that returns the average temperature of a core (or floorplan unit
+	if the index corresponds to a block in the floorplan that is not a core) during
+	the last (fixed-time and hardcoded) time window.
+	The size of the window is specified by WINDOW_SIZE, and the duration of the window
+	corresponds to (WINDOW_SIZE * samplingInterval).
+	Note that the returned temperature is an integer that holds the value in microKelvin,
+	and hence the temperature value should be divided by 1000000.0 to convert it back to
+	Kelvin.
+ */
+#define SimGetAverageTemperatureLastWindow(unit)	SimMagic1(SIM_CMD_GET_AVERAGE_TEMPERATURE_LAST_WINDOW, unit)
+
+/** New API function that returns the average instructions per cycle (IPC) of the specified core
+	during the last (fixed-time and hardcoded) time window.
+	The size of the window is specified by WINDOW_SIZE, and the duration of the window
+	corresponds to (WINDOW_SIZE * samplingInterval).
+ */
+#define SimGetAverageIpcLastWindow(proc)			SimMagic1(SIM_CMD_GET_AVERAGE_IPC_LAST_WINDOW, proc)
+
+
+
 #endif /* __SIM_API */
diff -Naur sniper-6.1_old/scripts/energystats.py sniper-6.1/scripts/energystats.py
--- sniper-6.1_old/scripts/energystats.py	2015-03-24 16:56:51.000000000 +0100
+++ sniper-6.1/scripts/energystats.py	2017-08-01 14:34:47.900026000 +0200
@@ -15,7 +15,9 @@
   # Build a table of (frequency, voltage) pairs.
   # Frequencies should be from high to low, and end with zero (or the lowest possible frequency)
   if tech == 22:
-    return [ (2000, 1.0), (1800, 0.9), (1500, 0.8), (1000, 0.7), (0, 0.6) ]
+#    return [ (2000, 1.0), (1800, 0.9), (1500, 0.8), (1000, 0.7), (0, 0.6) ]
+#    return [ (4000, 1.415), (3800, 1.36), (3600, 1.305), (3400, 1.25), (3200, 1.194), (3000, 1.139), (2800, 1.084), (2600, 1.028), (2400, 0.972), (2200, 0.916), (2000, 0.86), (1800, 0.803), (1600, 0.746), (1400, 0.688), (1200, 0.63), (1000, 0.571), (800, 0.51), (600, 0.447), (400, 0.381), (200, 0.307), (0, 0.307) ]
+    return [ (4000, 1.415), (3800, 1.36), (3600, 1.305), (3400, 1.25), (3200, 1.194), (3000, 1.139), (2800, 1.084), (2600, 1.028), (2400, 0.972), (2200, 0.916), (2000, 0.86), (1800, 0.803), (1600, 0.746), (1400, 0.688), (1200, 0.63), (1000, 0.63), (800, 0.63), (600, 0.63), (400, 0.63), (200, 0.63), (0, 0.63) ]
   elif tech == 45:
     return [ (2000, 1.2), (1800, 1.1), (1500, 1.0), (1000, 0.9), (0, 0.8) ]
   else:
@@ -73,7 +75,7 @@
     if sim.stats.time() == self.time_last_power:
       # Time did not advance: don't recompute
       return
-    if not self.power or (sim.stats.time() - self.time_last_power >= 10 * sim.util.Time.US):
+    if not self.power or (sim.stats.time() - self.time_last_power >= 1000 * sim.util.Time.US):
       # Time advanced significantly, or no power result yet: compute power
       #   Save snapshot
       current = 'energystats-temp%s' % ('B' if self.name_last and self.name_last[-1] == 'A' else 'A')
@@ -105,7 +107,8 @@
       self.power[('L1-I', core)] = get_power(power['Core'][core], 'Instruction Fetch Unit/Instruction Cache/')
       self.power[('L1-D', core)] = get_power(power['Core'][core], 'Load Store Unit/Data Cache/')
       self.power[('L2',   core)] = get_power(power['Core'][core], 'L2/')
-      self.power[('core', core)] = get_power(power['Core'][core]) - (self.power[('L1-I', core)] + self.power[('L1-D', core)] + self.power[('L2', core)])
+      #self.power[('core', core)] = get_power(power['Core'][core]) - (self.power[('L1-I', core)] + self.power[('L1-D', core)] + self.power[('L2', core)])
+      self.power[('core', core)] = get_power(power['Core'][core])
     self.power[('processor', 0)] = get_power(power['Processor'])
     self.power[('dram', 0)] = get_power(power['DRAM'])
 
@@ -113,8 +116,10 @@
     if self.power and sim.stats.time() > self.time_last_energy:
       time_delta = sim.stats.time() - self.time_last_energy
       for (component, core), power in self.power.items():
-        self.energy[(component, core, 'energy-static')] = self.energy.get((component, core, 'energy-static'), 0) + long(time_delta * power.s)
-        self.energy[(component, core, 'energy-dynamic')] = self.energy.get((component, core, 'energy-dynamic'), 0) + long(time_delta * power.d)
+        #self.energy[(component, core, 'energy-static')] = self.energy.get((component, core, 'energy-static'), 0) + long(time_delta * power.s)
+        #self.energy[(component, core, 'energy-dynamic')] = self.energy.get((component, core, 'energy-dynamic'), 0) + long(time_delta * power.d)
+        self.energy[(component, core, 'energy-static')] = long(power.s * 1000000)
+        self.energy[(component, core, 'energy-dynamic')] = long(power.d * 1000000)
       self.time_last_energy = sim.stats.time()
 
   def get_vdd_from_freq(self, f):
diff -Naur sniper-6.1_old/scripts/stattrace.py sniper-6.1/scripts/stattrace.py
--- sniper-6.1_old/scripts/stattrace.py	2015-03-24 16:56:51.000000000 +0100
+++ sniper-6.1/scripts/stattrace.py	2017-08-01 14:34:47.824026000 +0200
@@ -53,12 +53,13 @@
   def periodic(self, time, time_delta):
     if self.isTerminal:
       self.fd.write('[STAT:%s] ' % self.stat_name)
-    self.fd.write('%u' % (time / 1e6)) # Time in ns
+    #self.fd.write('%u' % (time / 1e6)) # Time in ns
+    self.fd.write('%u' % (time / 1e9)) # Time in us
     for core in range(sim.config.ncores):
       timediff = (self.stats['time'][core].delta - self.stats['ffwd_time'][core].delta) / 1e6 # Time in ns
       statdiff = self.stats['stat'][core].delta
       value = statdiff / (timediff or 1) # Avoid division by zero
-      self.fd.write(' %.3f' % value)
+      #self.fd.write(' %.3f' % value)
     self.fd.write('\n')
 
   def getStatsGetter(self, component, core, metric):
