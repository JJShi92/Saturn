diff -Naur local_old/ecoSch/ecoSch.cc local/ecoSch/ecoSch.cc
--- local_old/ecoSch/ecoSch.cc	1970-01-01 01:00:00.000000000 +0100
+++ local/ecoSch/ecoSch.cc	2017-07-28 15:07:48.339928000 +0200
@@ -0,0 +1,774 @@
+
+#include <iostream>
+#include <stdio.h>
+#include <stdlib.h>
+#include <algorithm>
+#include <unistd.h>
+#include <string.h>
+#include <time.h>
+#include <vector>
+#include <math.h>
+#include <float.h>
+#include <string>
+#include <fstream>
+#include <sstream>
+#include <stdexcept>
+
+#include "hooks_base.h"
+#include "sim_api.h"
+
+using namespace std;
+
+
+#define nullptr NULL
+
+#ifndef T_KELVIN_H_
+#define T_KELVIN_H_
+const long double T_KELVIN = 273.15;
+#endif /* T_KELVIN_H_ */
+
+
+#define TOTAL_POWER_BUDGET	250.0
+#define MAX_FREQUENCY	4000
+#define MIN_FREQUENCY	200
+#define FREQUENCY_STEP	200
+
+
+// Units in miliseconds
+//double SECONDS_TO_EXEC_TIME_UNIT = 1000.0;
+//double NANOSECONDS_TO_EXEC_TIME_UNIT = 1000000.0;
+// Units in microseconds
+double SECONDS_TO_EXEC_TIME_UNIT = 1000000.0;
+double NANOSECONDS_TO_EXEC_TIME_UNIT = 1000.0;
+
+#define SCHEDULING_INTERVAL		1000
+
+
+vector<pthread_t> threadCoreAgent;
+vector<pthread_t> threadIslandAgent;
+struct timespec start;
+
+long coresPerIsland;
+
+void *coreAgent(void * arg);
+void *islandAgent(void * arg);
+
+
+
+
+
+
+double tempS1;
+double tempS2;
+
+double Tamb = 45 + T_KELVIN;
+double Tdtm = 60 + T_KELVIN;
+
+double maxPowerBudget = 20.0;
+
+vector<double> islandPowerBudgetRequest;
+vector<double> islandPowerBudgetReceived;
+vector<pthread_mutex_t> flagIslandPowerBudgetRequest;
+vector<pthread_mutex_t> flagIslandPowerBudgetReceived;
+
+vector<double> coreSavings;
+vector<pthread_mutex_t> flagCoreSavings;
+
+vector<double> maxSavingsIsland;
+vector<int> coreMaxSavingsIsland;
+vector<pthread_mutex_t> flagCoreSavingsIsland;
+
+
+class Thread{
+public:
+	int threadId;
+	int mappedToCore;
+
+	Thread(){
+		threadId = -1;
+		mappedToCore = -1;
+	}
+};
+
+class Application{
+public:
+	unsigned int appId;
+	vector<Thread> threads;
+
+	Application(){
+		appId = 0;
+	}
+};
+
+vector<Application> applications;
+
+
+
+class Core{
+public:
+	int mappedThreadId;
+
+	Core(){
+		mappedThreadId = -1;
+	}
+};
+
+vector<Core> cores;
+vector<pthread_mutex_t> flagCoreMapping;
+
+
+int main(int argc, char* argv[])
+{
+	// Get initial time
+	struct timespec end;
+	//double currentTime = 0, previousTime = 0;
+	clock_gettime(CLOCK_MONOTONIC, &start);
+
+	// Initialize the number of cores per island as pass in the command line
+	if (argc > 1)
+		coresPerIsland = atoi(argv[1]);
+	else
+		coresPerIsland = 1;
+
+	// Start ROI
+	parmacs_roi_begin();
+
+
+	long unsigned int totalNumberCores;
+	if(SimInSimulator())
+		totalNumberCores = SimGetNumProcs();
+	else
+		totalNumberCores = 64;
+	int totalNumberIslands = totalNumberCores / coresPerIsland;
+	cout << "There are " << totalNumberIslands << " islands in the system" << endl; fflush(NULL);
+
+
+	// Initiliaze the income multipliers and the temperature region limits
+	tempS1 = (Tdtm - Tamb)*0.33 + Tamb;
+	tempS2 = (Tdtm - Tamb)*0.66 + Tamb;
+	cout << "tempS1: " << tempS1 - T_KELVIN << endl; fflush(NULL);
+	cout << "tempS2: " << tempS2 - T_KELVIN << endl; fflush(NULL);
+	pthread_mutex_t mutexAux = PTHREAD_MUTEX_INITIALIZER;
+	for(unsigned int i = 0; i < totalNumberCores; i++){
+		coreSavings.push_back(0);
+		flagCoreSavings.push_back(mutexAux);
+		Core newCore;
+		cores.push_back(newCore);
+		flagCoreMapping.push_back(mutexAux);
+	}
+	for(unsigned int i = 0; i < totalNumberIslands; i++){
+		maxSavingsIsland.push_back(0);
+		coreMaxSavingsIsland.push_back(0);
+		islandPowerBudgetRequest.push_back(0);
+		islandPowerBudgetReceived.push_back(TOTAL_POWER_BUDGET / totalNumberIslands);
+		flagCoreSavingsIsland.push_back(mutexAux);
+		flagIslandPowerBudgetRequest.push_back(mutexAux);
+		flagIslandPowerBudgetReceived.push_back(mutexAux);
+	}
+
+
+
+	// Initiliaze a vector containing all applications
+	int totalNumberThreads = SimGetNumThreads();
+	for(unsigned int thread = 0; thread < totalNumberThreads; thread++){
+		unsigned int appId = SimGetThreadAppId(thread);
+
+		int appIndex = -1;
+		for(unsigned int appIndexAux = 0; appIndexAux < applications.size(); appIndexAux++){
+			if(applications[appIndexAux].appId == appId){
+				appIndex = appIndexAux;
+				break;
+			}
+		}
+
+		if(appIndex < 0){
+			if(appId != 0){
+				Application newApplication;
+				newApplication.appId = appId;
+				applications.push_back(newApplication);
+			}
+		}
+	}
+	cout << "Total Number of Applications: " << applications.size() << endl; fflush(NULL);
+
+
+
+
+	// Initialize the thread variables, and start every core agent thread
+	vector<int> coreAgentNumber;
+	for(unsigned int i = 0; i < totalNumberCores; i++){
+		threadCoreAgent.push_back(0);
+		coreAgentNumber.push_back((int) i);
+	}
+	for(unsigned int i = 0; i < totalNumberCores; i++){
+		if (pthread_create(&threadCoreAgent[i], NULL, &coreAgent, (void *)&coreAgentNumber[i])) {
+			cout << "Failed Thread Core Agent" << endl; fflush(NULL);
+			exit(0);
+		}
+	}
+
+	// Same thing for the islands
+	vector<int> islandAgentNumber;
+	for(unsigned int i = 0; i < totalNumberIslands; i++){
+		threadIslandAgent.push_back(0);
+		islandAgentNumber.push_back((int) i);
+	}
+	for(unsigned int i = 0; i < totalNumberIslands; i++){
+		if (pthread_create(&threadIslandAgent[i], NULL, &islandAgent, (void *)&islandAgentNumber[i])) {
+			cout << "Failed Thread Island Agent" << endl; fflush(NULL);
+			exit(0);
+		}
+	}
+
+
+
+/*
+	cout << "SimGetProcId(): " << SimGetProcId() << endl; fflush(NULL);
+	cout << "SimGetThreadId(): " << SimGetThreadId() << endl; fflush(NULL);
+	cout << "SimGetNumProcs(): " << SimGetNumProcs() << endl; fflush(NULL);
+	cout << "SimGetNumThreads(): " << SimGetNumThreads() << endl; fflush(NULL);
+	cout << "SimGetOwnFreqMHz(): " << SimGetOwnFreqMHz() << endl; fflush(NULL);
+
+	SimSetOwnFreqMHz(2000);
+	SimSetThreadAffinity(0, 4);
+*/
+
+
+	usleep( 2*SCHEDULING_INTERVAL );
+	cout << "Entering infinite scheduling loop" << endl; fflush(NULL);
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned int currentTime;
+	unsigned int lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+	while(1){
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		if(SCHEDULING_INTERVAL > (currentTime - lastTime))
+			usleep( SCHEDULING_INTERVAL - currentTime + lastTime);
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+
+		// Get total number of threads and iterate through them
+		totalNumberThreads = SimGetNumThreads();
+		for(int thread = 0; thread < totalNumberThreads; thread++){
+			unsigned int appId = SimGetThreadAppId(thread);
+
+			if(appId != 0){
+				// Find the index of the application
+				int appIndex = -1;
+				for(unsigned int appIndexAux = 0; appIndexAux < applications.size(); appIndexAux++){
+					if(applications[appIndexAux].appId == appId){
+						appIndex = appIndexAux;
+						break;
+					}
+				}
+
+				if(appIndex >= 0){
+					// Now find the index of the thread
+					int threadIndex = -1;
+					for(unsigned int threadInApplication = 0; threadInApplication < applications[appIndex].threads.size(); threadInApplication++){
+						if(applications[appIndex].threads[threadInApplication].threadId == thread){
+							threadIndex = threadInApplication;
+							break;
+						}
+					}
+
+					// If the index was less than zero, this thread was not in the list of thread of the applicaiton
+					if(threadIndex < 0){
+						// Verify that the thread is not finished, as we could have already removed it from the list because it is finished
+						if(SimIsThreadFinished(thread) == false){
+							Thread newThread;
+							newThread.threadId = thread;
+							applications[appIndex].threads.push_back(newThread);
+						}
+					}
+					else{
+						// If the thread already existed, verify that it has not finished
+						if(SimIsThreadFinished(thread)){
+
+							// If the thread is finished, we indicate that the thread is no longer mapped to that core
+							int threadMappedToCore = applications[appIndex].threads[threadIndex].mappedToCore;
+
+							pthread_mutex_lock(&flagCoreMapping[threadMappedToCore]);
+							cores[threadMappedToCore].mappedThreadId = -1;
+							pthread_mutex_unlock(&flagCoreMapping[threadMappedToCore]);
+
+							applications[appIndex].threads.erase(applications[appIndex].threads.begin() + threadIndex);
+							//if(applications[appIndex].threads.size() == 0){
+							//	applications.erase(applications.begin() + appIndex);
+							//}
+						}
+					}
+				}
+				else{
+					if(SimIsThreadFinished(thread) == false){
+						cout << "ERROR: New application found after initialization!!: " << appId << endl; fflush(NULL);
+					}
+				}
+			}
+		}
+
+
+
+		/*for(unsigned int appIndex = 0; appIndex < applications.size(); appIndex++){
+			cout << "Application " << applications[appIndex].appId << endl;
+			if(applications[appIndex].threads.size() > 0){
+				for(unsigned int threadInApplication = 0; threadInApplication < applications[appIndex].threads.size(); threadInApplication++){
+					cout << "   Thread " << applications[appIndex].threads[threadInApplication].threadId << endl;
+				}
+			}
+			else{
+				cout << "   Finished" << endl;
+			}
+		}
+		fflush(NULL);*/
+
+
+
+
+
+
+
+		// Distribute the global power budget among the islands according to the requested power budgets
+		double totalRequestedPowerBudget = 0;
+		for(unsigned int islandIndex = 0; islandIndex < totalNumberIslands; islandIndex++){
+			pthread_mutex_lock(&flagIslandPowerBudgetRequest[islandIndex]);
+			if(islandPowerBudgetRequest[islandIndex] > 0)
+				totalRequestedPowerBudget += islandPowerBudgetRequest[islandIndex];
+			pthread_mutex_unlock(&flagIslandPowerBudgetRequest[islandIndex]);
+		}
+		for(unsigned int islandIndex = 0; islandIndex < totalNumberIslands; islandIndex++){
+			pthread_mutex_lock(&flagIslandPowerBudgetRequest[islandIndex]);
+			double partialRequestedPowerBudget = islandPowerBudgetRequest[islandIndex];
+			pthread_mutex_unlock(&flagIslandPowerBudgetRequest[islandIndex]);
+
+			pthread_mutex_lock(&flagIslandPowerBudgetReceived[islandIndex]);
+			if((partialRequestedPowerBudget > 0) && (totalRequestedPowerBudget > 0))
+				islandPowerBudgetReceived[islandIndex] = (TOTAL_POWER_BUDGET * partialRequestedPowerBudget)/totalRequestedPowerBudget;
+			else
+				islandPowerBudgetReceived[islandIndex] = 0;
+			pthread_mutex_unlock(&flagIslandPowerBudgetReceived[islandIndex]);
+		}
+
+
+
+
+
+
+
+
+
+
+		// Check if there is any new thread to be mapped. Threads will already have being mapped by Sniper's scheduler, but we now migrate them
+		// to the core we want.
+		// In case of the economic scheduling algorithm, threads are mapped to the core that globally has the highest savings
+		for(unsigned int appIndex = 0; appIndex < applications.size(); appIndex++){
+			for(unsigned int threadInApplication = 0; threadInApplication < applications[appIndex].threads.size(); threadInApplication++){
+				// mappedToCore < 0 means that the thread is unmapped
+				if(applications[appIndex].threads[threadInApplication].mappedToCore < 0){
+
+					// Check if there are free cores. If there are, map a new task to a free core. Otherwise, just map ut to the core with maximum savings
+					/*bool existsFreeCore = false;
+					for(int coreIndex = 0; coreIndex < totalNumberCores; coreIndex++){
+						if(cores[coreIndex].mappedThreadId < 0){
+							existsFreeCore = true;
+							break;
+						}
+					}*/
+
+					// Find the core with the maximum core savings
+					double globalMaxSavings = -DBL_MAX;
+					int coreIndexToMapApplication = -1;
+					int islandToMapApplication = -1;
+					for(unsigned int islandNumber = 0; islandNumber < totalNumberIslands; islandNumber++){
+						pthread_mutex_lock(&flagCoreSavingsIsland[islandNumber]);
+						double partialMaxSavings =  maxSavingsIsland[islandNumber];
+						int partialCoreMaxSavingsInsideIsland = coreMaxSavingsIsland[islandNumber];
+						pthread_mutex_unlock(&flagCoreSavingsIsland[islandNumber]);
+						if(globalMaxSavings < partialMaxSavings){
+							//if( (existsFreeCore == false) ||
+							//	(cores[partialCoreMaxSavingsInsideIsland + islandNumber * coresPerIsland].mappedThreadId < 0)){
+							int auxCoreNumber = partialCoreMaxSavingsInsideIsland + islandNumber * coresPerIsland;
+							pthread_mutex_lock(&flagCoreMapping[auxCoreNumber]);
+							if(cores[auxCoreNumber].mappedThreadId < 0){
+								globalMaxSavings = partialMaxSavings;
+								coreIndexToMapApplication = auxCoreNumber;
+								islandToMapApplication = islandNumber;
+							}
+							pthread_mutex_unlock(&flagCoreMapping[auxCoreNumber]);
+						}
+					}
+
+					// If for some reason no core to map the thread was found, then we search again
+					if(coreIndexToMapApplication < 0){
+						globalMaxSavings = -DBL_MAX;
+						for(unsigned int islandNumber = 0; islandNumber < totalNumberIslands; islandNumber++){
+							if(coreIndexToMapApplication < 0){
+								pthread_mutex_lock(&flagCoreSavingsIsland[islandNumber]);
+								double partialMaxSavings =  maxSavingsIsland[islandNumber];
+								pthread_mutex_unlock(&flagCoreSavingsIsland[islandNumber]);
+								if(globalMaxSavings < partialMaxSavings){
+									for(int coreNumber = 0; coreNumber < coresPerIsland; coreNumber++){
+										int auxCoreNumber = coreNumber + islandNumber * coresPerIsland;
+										pthread_mutex_lock(&flagCoreMapping[auxCoreNumber]);
+										if(cores[auxCoreNumber].mappedThreadId < 0){
+											pthread_mutex_unlock(&flagCoreMapping[auxCoreNumber]);
+											globalMaxSavings = partialMaxSavings;
+											coreIndexToMapApplication = auxCoreNumber;
+											islandToMapApplication = islandNumber;
+											break;
+										}
+										pthread_mutex_unlock(&flagCoreMapping[auxCoreNumber]);
+									}
+								}
+							}
+							else{
+								break;
+							}
+						}
+					}
+
+					cout << "Mapping for application " << applications[appIndex].appId << " thread " << applications[appIndex].threads[threadInApplication].threadId << " to core " << coreIndexToMapApplication << " in island " << islandToMapApplication << " with savings " << globalMaxSavings << endl; fflush(NULL);
+					if((coreIndexToMapApplication >= 0) && (islandToMapApplication >= 0)){
+						// After finding the core with highest global savings, migrate the thread to that core
+						applications[appIndex].threads[threadInApplication].mappedToCore = coreIndexToMapApplication;
+						pthread_mutex_lock(&flagCoreMapping[coreIndexToMapApplication]);
+						cores[coreIndexToMapApplication].mappedThreadId = applications[appIndex].threads[threadInApplication].threadId;
+						pthread_mutex_unlock(&flagCoreMapping[coreIndexToMapApplication]);
+
+						if(SimInSimulator()){
+							SimSetThreadAffinity(applications[appIndex].threads[threadInApplication].threadId, coreIndexToMapApplication);
+						}
+
+
+						// Reset the core savings to zero
+						pthread_mutex_lock(&flagCoreSavings[coreIndexToMapApplication]);
+						coreSavings[coreIndexToMapApplication] = -DBL_MAX;
+						pthread_mutex_unlock(&flagCoreSavings[coreIndexToMapApplication]);
+
+						// Update the maximum savings in the island
+						double currentMaxSavingsIsland = -DBL_MAX;
+						int currentCoreMaxSavingsIsland = -1;
+						for(int core = 0; core < coresPerIsland; core++){
+							// Get the value of the savings of the current core
+							int auxCoreNumber = core + islandToMapApplication * coresPerIsland;
+							pthread_mutex_lock(&flagCoreSavings[auxCoreNumber]);
+							double singleCoreSavings = coreSavings[auxCoreNumber];
+							pthread_mutex_unlock(&flagCoreSavings[auxCoreNumber]);
+
+							// If the current core has more savings, then save this value
+							if(currentMaxSavingsIsland < singleCoreSavings){
+								currentMaxSavingsIsland = singleCoreSavings;
+								currentCoreMaxSavingsIsland = core;
+							}
+						}
+						pthread_mutex_lock(&flagCoreSavingsIsland[islandToMapApplication]);
+						maxSavingsIsland[islandToMapApplication] = currentMaxSavingsIsland;
+						coreMaxSavingsIsland[islandToMapApplication] = currentCoreMaxSavingsIsland;
+						pthread_mutex_unlock(&flagCoreSavingsIsland[islandToMapApplication]);
+						//cout << "New highest savings core in island " << islandToMapApplication << " is core " << currentCoreMaxSavingsIsland << " with savings " << currentMaxSavingsIsland << endl; fflush(NULL);
+					}
+					else{
+						// If even after the second search of a core where to map the task we don't find one, then print an error
+						//cout << "ERROR: No core found to map new task" << endl; fflush(NULL);
+					}
+				}
+			}
+		}
+
+
+
+
+
+
+
+
+
+
+		// If the only application running is the scheduler finish the simulation
+		if(applications.size() <= 0){
+			// Finilize the ROI and exit the application
+			parmacs_roi_end();
+			exit(0);
+		}
+	}
+
+
+
+	// Now wait for the threads of the core and island agents to finish
+	for(unsigned int i = 0; i < totalNumberCores; i++){
+		pthread_join(threadCoreAgent[i], NULL);
+	}
+	for(unsigned int i = 0; i < totalNumberIslands; i++){
+		pthread_join(threadIslandAgent[i], NULL);
+	}
+
+	// Finilize the ROI and exit the application
+	parmacs_roi_end();
+
+	exit(0);
+}
+
+
+
+
+void *coreAgent(void * arg)
+{
+	// Migrate the core agent to the corresponding core
+	int coreAgentNumber = *((int *)arg);
+	if(SimInSimulator())
+		SimSetOwnAffinity(coreAgentNumber);
+
+
+/*	stringstream fileName;
+	fileName << "/home/santiago/sniper/coreAgent_" << coreAgentNumber;
+	ofstream outputStream;
+	outputStream.open(fileName.str().c_str());
+	if (outputStream.is_open()){
+		if (outputStream.good()){
+			outputStream.precision(12);
+		}
+		else{
+			cout << "Error: Output file: \"" << fileName.str() << "\" could not be open for writing." << endl; fflush(NULL);
+			outputStream.close();
+		}
+	}
+	else{
+		cout << "Error: Output file: \"" << fileName.str() << "\" could not be open for writing." << endl; fflush(NULL);
+	}*/
+
+
+
+
+
+	struct timespec end;
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned int currentTime;
+	unsigned int lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+	while(1){
+		//unsigned long threadId = SimGetThreadId();
+		//clock_gettime(CLOCK_MONOTONIC, &end);
+		//double printTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		//outputStream << "Time: " << printTime/1000000 << " \tCore agent: " << coreAgentNumber << " \tThread ID: " << threadId << endl;
+
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		if(SCHEDULING_INTERVAL > (currentTime - lastTime))
+			usleep( SCHEDULING_INTERVAL - currentTime + lastTime);
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+
+		// Get own temperature and temperature
+		double temperature;
+		double power;
+		if(SimInSimulator()){
+			temperature = ((double)SimGetOwnTemperature())/1000000.0;
+			power = ((double)SimGetOwnPower())/1000000.0;
+		}
+		else{
+			temperature = 0;
+			power = 0;
+		}
+
+		// Addapt the income multiplier to the core's temperature
+		double incomeMultiplier;
+		if(temperature <= tempS1)
+			incomeMultiplier = 1.0;
+		else if(temperature <= tempS2)
+			incomeMultiplier = 1.0 - (0.4 * (temperature - tempS1))/(tempS2 - tempS1);
+		else
+			incomeMultiplier = 0.6 - (0.6 * (temperature - tempS2))/(Tdtm - tempS2);
+
+		// Update the savings of the core
+		pthread_mutex_lock(&flagCoreSavings[coreAgentNumber]);
+		coreSavings[coreAgentNumber] = maxPowerBudget * incomeMultiplier - power;
+		pthread_mutex_unlock(&flagCoreSavings[coreAgentNumber]);
+	}
+
+
+	return 0;
+}
+
+
+
+
+void *islandAgent(void * arg)
+{
+	// Migrate the island agent to the first core of the corresponding island
+	int islandAgentNumber = *((int *)arg);
+	if(SimInSimulator())
+		SimSetOwnAffinity(islandAgentNumber * coresPerIsland);
+
+
+	vector<bool> coreActive;
+	vector<double> powerCores;
+	vector<double> incomeMultiplier;
+	for(int core = 0; core < coresPerIsland; core++){
+		powerCores.push_back(0);
+		incomeMultiplier.push_back(0);
+		coreActive.push_back(false);
+	}
+
+
+
+
+
+	struct timespec end;
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned int currentTime;
+	unsigned int lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+	while(1){
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		if(SCHEDULING_INTERVAL > (currentTime - lastTime))
+			usleep( SCHEDULING_INTERVAL - currentTime + lastTime);
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+
+		// Check all cores in the island and update the values for the cores with maximum savings
+		double currentMaxSavingsIsland = -DBL_MAX;
+		int currentCoreMaxSavingsIsland = -1;
+		for(int core = 0; core < coresPerIsland; core++){
+			// Get the value of the savings of the current core
+			int auxCoreNumber = core + islandAgentNumber * coresPerIsland;
+			pthread_mutex_lock(&flagCoreSavings[auxCoreNumber]);
+			double singleCoreSavings = coreSavings[auxCoreNumber];
+			pthread_mutex_unlock(&flagCoreSavings[auxCoreNumber]);
+
+			// If the current core has more savings, then save this value
+			if(currentMaxSavingsIsland < singleCoreSavings){
+				currentMaxSavingsIsland = singleCoreSavings;
+				currentCoreMaxSavingsIsland = core;
+			}
+		}
+		pthread_mutex_lock(&flagCoreSavingsIsland[islandAgentNumber]);
+		maxSavingsIsland[islandAgentNumber] = currentMaxSavingsIsland;
+		coreMaxSavingsIsland[islandAgentNumber] = currentCoreMaxSavingsIsland;
+		pthread_mutex_unlock(&flagCoreSavingsIsland[islandAgentNumber]);
+
+
+
+
+
+		// Check how many cores are active in the island and compute the island's requested power budget
+		double currentIslandPowerBudgetRequest = 0;
+		int numberActiveCoresInIsland = 0;
+		double incomeMultiplierSummation = 0;
+		for(int core = 0; core < coresPerIsland; core++){
+			int auxCoreNumber = core + islandAgentNumber * coresPerIsland;
+			pthread_mutex_lock(&flagCoreMapping[auxCoreNumber]);
+			int coreMappedWithThread = cores[auxCoreNumber].mappedThreadId;
+			pthread_mutex_unlock(&flagCoreMapping[auxCoreNumber]);
+
+			// If the core was active, compute the required power budget (adjusted to the income) and compute the island's required budget
+			if(coreMappedWithThread >= 0){
+				numberActiveCoresInIsland++;
+				coreActive[core] = true;
+
+				// Get own temperature and temperature
+				double temperature;
+				if(SimInSimulator()){
+					temperature = ((double)SimGetTemperature(auxCoreNumber))/1000000.0;
+					powerCores[core] = ((double)SimGetPower(auxCoreNumber))/1000000.0;
+				}
+				else{
+					temperature = 0;
+					powerCores[core] = 0;
+				}
+
+				// Addapt the income multiplier to the core's temperature
+				if(temperature <= tempS1)
+					incomeMultiplier[core] = 1.0;
+				else if(temperature <= tempS2)
+					incomeMultiplier[core] = 1.0 - (0.4 * (temperature - tempS1))/(tempS2 - tempS1);
+				else
+					incomeMultiplier[core] = 0.6 - (0.6 * (temperature - tempS2))/(Tdtm - tempS2);
+
+				// If the temperature was below the threshold, then the income is possitve and we add the required core's budget to the island's
+				// required budget. If the income is negative, this core gets no budget and we ignore it
+				if(incomeMultiplier[core] >= 0){
+					incomeMultiplierSummation += incomeMultiplier[core];
+					currentIslandPowerBudgetRequest += maxPowerBudget * incomeMultiplier[core];
+				}
+			}
+			else{
+				coreActive[core] = false;
+			}
+		}
+		if(currentIslandPowerBudgetRequest < 0)
+			currentIslandPowerBudgetRequest = 0;
+		pthread_mutex_lock(&flagIslandPowerBudgetRequest[islandAgentNumber]);
+		islandPowerBudgetRequest[islandAgentNumber] = currentIslandPowerBudgetRequest;
+		pthread_mutex_unlock(&flagIslandPowerBudgetRequest[islandAgentNumber]);
+
+
+
+
+
+
+		// Finally, according to the actual power budget in the island given by the global power source, adapt the DVFS levels of the island
+		if(numberActiveCoresInIsland > 0){
+
+			// Get a copy of the power budget of the island
+			pthread_mutex_lock(&flagIslandPowerBudgetReceived[islandAgentNumber]);
+			double currentIslandPowerBudgetReceived = islandPowerBudgetReceived[islandAgentNumber];
+			pthread_mutex_unlock(&flagIslandPowerBudgetReceived[islandAgentNumber]);
+
+			unsigned int currentIslandFrequency = SimGetFreqMHz(islandAgentNumber * coresPerIsland);
+			if(currentIslandFrequency == MIN_FREQUENCY){
+				cout << "Island " << islandAgentNumber << " at 200MHz, with incomeMultiplierSummation:" << incomeMultiplierSummation << endl; fflush(NULL);
+
+				for(int core = 0; core < coresPerIsland; core++){
+					if((incomeMultiplier[core] >= 0) && (incomeMultiplierSummation > 0)){
+						cout << "  Core " << core << " has power consumption " << powerCores[core] << " and incomeMultiplier " << incomeMultiplier[core] << " and a power budget " << (currentIslandPowerBudgetReceived * incomeMultiplier[core])/incomeMultiplierSummation << endl; fflush(NULL);
+					}
+					else{
+						cout << "  Core " << core << " has power consumption " << powerCores[core] << " and incomeMultiplier " << incomeMultiplier[core] << endl; fflush(NULL);
+					}
+				}
+			}
+
+			// If the power of some core exceeds the budget, reduce the frequency by one step.
+			// If no core exceeds the power budget, increase the frequency by one step
+			bool allCoresSatisfyPowerBudget = true;
+			for(int core = 0; core < coresPerIsland; core++){
+				if(coreActive[core]){
+					double thisCorePowerBudget = 0;
+					if((incomeMultiplier[core] >= 0) && (incomeMultiplierSummation > 0))
+						thisCorePowerBudget = (currentIslandPowerBudgetReceived * incomeMultiplier[core])/incomeMultiplierSummation;
+					if(powerCores[core] > thisCorePowerBudget){
+						allCoresSatisfyPowerBudget = false;
+						break;
+					}
+				}
+			}
+
+
+			if(SimInSimulator()){
+				// First read the frequency of the island
+				unsigned int currentIslandFrequency = SimGetFreqMHz(islandAgentNumber * coresPerIsland);
+
+				if(allCoresSatisfyPowerBudget){
+					if(currentIslandFrequency < MAX_FREQUENCY){
+						SimSetFreqMHz(islandAgentNumber * coresPerIsland, currentIslandFrequency + FREQUENCY_STEP);
+					}
+				}
+				else{
+					if(currentIslandFrequency > MIN_FREQUENCY){
+						SimSetFreqMHz(islandAgentNumber * coresPerIsland, currentIslandFrequency - FREQUENCY_STEP);
+					}
+				}
+			}
+		}
+		else{
+			//if(SimInSimulator()){
+			//	SimSetFreqMHz(islandAgentNumber * coresPerIsland, MAX_FREQUENCY);
+			//}
+		}
+	}
+
+	return 0;
+}
+
diff -Naur local_old/ecoSch/Makefile local/ecoSch/Makefile
--- local_old/ecoSch/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ local/ecoSch/Makefile	2017-07-28 15:07:48.339928000 +0200
@@ -0,0 +1,11 @@
+include ../../tools/hooks/buildconf.makefile
+TARGET = ecoSch
+
+$(TARGET): ecoSch.o
+	$(HOOKS_CXX) ecoSch.o $(HOOKS_LDFLAGS) -o $@
+
+%.o : %.cc
+	$(HOOKS_CXX) $< $(HOOKS_CXXFLAGS) -c -o $@
+
+clean :
+	rm -f *.o $(TARGET)
diff -Naur local_old/__init__.py local/__init__.py
--- local_old/__init__.py	2014-08-13 10:25:18.000000000 +0200
+++ local/__init__.py	2017-07-28 15:07:48.399928000 +0200
@@ -4,7 +4,7 @@
 
 
 def allbenchmarks():
-    return [ 'pi' ]
+    return [ 'pi', 'ecoSch', 'priceTheory', 'mine', 'mineM' ]
 
 def allinputs():
   return ('test', 'small', 'large')
@@ -23,7 +23,18 @@
       else:
         raise ValueError("Invalid input size %s" % inputsize)
       return '%s/pi/pi %s' % (HOME, num_steps)
-
+    elif program == 'ecoSch':
+      num_cores = nthreads
+      return '%s/ecoSch/ecoSch %s' % (HOME, num_cores)
+    elif program == 'priceTheory':
+      num_cores = nthreads
+      return '%s/priceTheory/priceTheory %s' % (HOME, num_cores)
+    elif program == 'mine':
+      num_cores = nthreads
+      return '%s/mine/mine %s' % (HOME, num_cores)
+    elif program == 'mineM':
+      num_cores = nthreads
+      return '%s/mineM/mineM %s' % (HOME, num_cores)
     else:
       raise ValueError("Unknown program %s" % program)
 
diff -Naur local_old/Makefile local/Makefile
--- local_old/Makefile	2014-08-13 10:25:18.000000000 +0200
+++ local/Makefile	2017-07-28 15:07:48.435928000 +0200
@@ -2,6 +2,14 @@
 
 all:
 	make -C pi
+	make -C ecoSch
+	make -C priceTheory
+	make -C mine
+	make -C mineM
 
 clean:
 	make -C pi clean
+	make -C ecoSch clean
+	make -C priceTheory clean
+	make -C mine clean
+	make -C mineM clean
diff -Naur local_old/mine/Makefile local/mine/Makefile
--- local_old/mine/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ local/mine/Makefile	2017-07-28 15:07:48.399928000 +0200
@@ -0,0 +1,11 @@
+include ../../tools/hooks/buildconf.makefile
+TARGET = mine
+
+$(TARGET): mine.o
+	$(HOOKS_CXX) mine.o $(HOOKS_LDFLAGS) -o $@
+
+%.o : %.cc
+	$(HOOKS_CXX) $< $(HOOKS_CXXFLAGS) -c -o $@
+
+clean :
+	rm -f *.o $(TARGET)
diff -Naur local_old/mine/mine.cc local/mine/mine.cc
--- local_old/mine/mine.cc	1970-01-01 01:00:00.000000000 +0100
+++ local/mine/mine.cc	2017-07-28 15:07:48.399928000 +0200
@@ -0,0 +1,1243 @@
+
+#include <iostream>
+#include <stdio.h>
+#include <stdlib.h>
+#include <algorithm>
+#include <unistd.h>
+#include <string.h>
+#include <time.h>
+#include <vector>
+#include <math.h>
+#include <float.h>
+#include <string>
+#include <fstream>
+#include <sstream>
+#include <stdexcept>
+#include <limits.h>
+
+#include "hooks_base.h"
+#include "sim_api.h"
+
+using namespace std;
+
+
+#define nullptr NULL
+
+#ifndef T_KELVIN_H_
+#define T_KELVIN_H_
+const float T_KELVIN = 273.15;
+#endif /* T_KELVIN_H_ */
+
+
+#define MAX_FREQUENCY	4000
+#define MIN_FREQUENCY	200
+#define FREQUENCY_STEP	200
+
+
+// Units in miliseconds
+//double SECONDS_TO_EXEC_TIME_UNIT = 1000.0;
+//double NANOSECONDS_TO_EXEC_TIME_UNIT = 1000000.0;
+// Units in microseconds
+double SECONDS_TO_EXEC_TIME_UNIT = 1000000.0;
+double NANOSECONDS_TO_EXEC_TIME_UNIT = 1000.0;
+
+#define SCHEDULING_INTERVAL		1000
+
+const float Tamb = 45 + T_KELVIN;
+const float Tdtm = 60 + T_KELVIN;
+
+
+
+long unsigned int totalNumberCores;
+int totalNumberIslands;
+long coresPerIsland;
+struct timespec start;
+
+
+
+//vector<pthread_t> threadIslandAgent;
+vector<pthread_t> threadApplicationAgent;
+//void *islandAgent(void * arg);
+void *applicationAgent(void * arg);
+
+
+
+const int randomCoresForInitialAgentMapping[] = { 4, 52, 3, 15, 44, 60, 32, 41, 17, 48,
+											38, 8, 23, 24, 28, 56, 14, 27, 48, 20,
+											12, 51, 18, 1, 6, 54, 16, 45, 57, 37,
+											49, 58 };
+
+//const int numberOfThreadsPerApp[] = { 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 };
+//const int numberOfThreadsPerApp[] = { 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 };
+const int numberOfThreadsPerApp[] = { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 };
+//const int numberOfThreadsPerApp[] = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 };
+//const int numberOfThreadsPerApp[] = { 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };
+
+vector<int> coresReservedForApplication;
+vector<pthread_mutex_t> flagReservedCores;
+
+vector<unsigned long int> previousInstructionCountCore;
+vector<unsigned long int> lastTimeinstructionCountCore;
+vector<pthread_mutex_t> flagPreviousInstructionCountCore;
+
+vector<int> offsetThreadIndexForApplication;
+vector<int> threadReservedCore;
+vector<pthread_mutex_t> flagThreadReservedCore;
+
+
+vector<int> agentsMappedToIsland;
+vector<pthread_mutex_t> flagAgentsMappedToIsland;
+
+vector< vector<int> > neighbouringIslands;
+void fillNeighbouringIslandsVector(void);
+#define MAX_NUMBER_NEIGHBOUR_ISLANDS	5	// Including the island in the center of the neighbours
+#define MIGRATION_THERMAL_HISTERESIS_BOUND	1
+#define MIGRATION_MINIMUM_IPC_BOUND		2
+#define MIGRATION_IPC_HISTERESIS_BOUND		1
+
+#define INVALID_APPLICATION	-1
+#define INVALID_CORE		-1
+#define INVALID_THREAD		-1
+
+
+class Thread{
+public:
+	int threadId;
+	int mappedToCore;
+
+	Thread(){
+		threadId = INVALID_THREAD;
+		mappedToCore = INVALID_CORE;
+	}
+};
+
+class Application{
+public:
+	int appId;
+
+	Application(){
+		appId = INVALID_APPLICATION;
+	}
+};
+vector<Application> applications;
+
+
+
+class Core{
+public:
+	int mappedThreadId;
+	int mappedApplicationId;
+
+	Core(){
+		mappedThreadId = INVALID_THREAD;
+		mappedApplicationId = INVALID_APPLICATION;
+	}
+};
+
+//vector<Core> cores;
+//vector<pthread_mutex_t> flagCoreMapping;
+
+
+
+
+
+int main(int argc, char* argv[])
+{
+	// Get initial time
+	struct timespec end;
+	clock_gettime(CLOCK_MONOTONIC, &start);
+
+	// Initialize the number of cores per island as pass in the command line
+	if (argc > 1)
+		coresPerIsland = atoi(argv[1]);
+	else
+		coresPerIsland = 1;
+
+	// Start ROI
+	parmacs_roi_begin();
+
+
+	totalNumberCores = SimGetNumProcs();
+	totalNumberIslands = totalNumberCores / coresPerIsland;
+	cout << "There are " << totalNumberIslands << " islands in the system" << endl; fflush(NULL);
+
+
+	fillNeighbouringIslandsVector();
+
+
+
+	// Initiliaze the reserved core vectors and their mutexes
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned long int currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+	pthread_mutex_t mutexAux = PTHREAD_MUTEX_INITIALIZER;
+	for(unsigned int i = 0; i < totalNumberCores; i++){
+		//Core newCore;
+		//cores.push_back(newCore);
+		//flagCoreMapping.push_back(mutexAux);
+
+		coresReservedForApplication.push_back(INVALID_APPLICATION);
+		flagReservedCores.push_back(mutexAux);
+
+		previousInstructionCountCore.push_back(SimGetAccumulatedInstructions(i));
+		lastTimeinstructionCountCore.push_back(currentTime);
+		flagPreviousInstructionCountCore.push_back(mutexAux);
+	}
+
+
+
+	// Initiliaze a vector containing all applications
+	vector<int> applicationAgentNumber;
+	unsigned int totalNumberThreads = SimGetNumThreads();
+	for(unsigned int thread = 0; thread < totalNumberThreads; thread++){
+		int appId = SimGetThreadAppId(thread);
+
+		int appIndex = -1;
+		for(unsigned int appIndexAux = 0; appIndexAux < applications.size(); appIndexAux++){
+			if(applications[appIndexAux].appId == appId){
+				appIndex = appIndexAux;
+				break;
+			}
+		}
+
+		if(appIndex < 0){
+			if(appId != 0){
+				Application newApplication;
+				newApplication.appId = appId;
+				applications.push_back(newApplication);
+
+				applicationAgentNumber.push_back(appId);
+				threadApplicationAgent.push_back(0);
+
+				agentsMappedToIsland.push_back(randomCoresForInitialAgentMapping[appId - 1] / coresPerIsland);
+				flagAgentsMappedToIsland.push_back(mutexAux);
+			}
+		}
+	}
+	int totalNumberApplications = applications.size();
+	cout << "Total Number of Applications: " << totalNumberApplications << endl; fflush(NULL);
+
+	// Initialize the vectors containing the coreId reserved for each application thread
+	for(int appId = 0; appId < totalNumberApplications; appId++){
+		for(int threadNumber = 0; threadNumber < numberOfThreadsPerApp[appId]; threadNumber++){
+			threadReservedCore.push_back(INVALID_CORE);
+			flagThreadReservedCore.push_back(mutexAux);
+		}
+
+		if(appId > 0){
+			offsetThreadIndexForApplication.push_back(numberOfThreadsPerApp[appId - 1] + offsetThreadIndexForApplication[appId - 1]);
+		}
+		else{
+			offsetThreadIndexForApplication.push_back(0);
+		}
+	}
+
+
+	// Initialize the thread variables, and start every application agent thread
+	for(int i = 0; i < totalNumberApplications; i++){
+		if (pthread_create(&threadApplicationAgent[i], NULL, &applicationAgent, (void *)&applicationAgentNumber[i])) {
+			cout << "Failed Thread Application Agent" << endl; fflush(NULL);
+			exit(0);
+		}
+	}
+
+
+
+	// Same thing for the islands
+	/*vector<int> islandAgentNumber;
+	for(int i = 0; i < totalNumberIslands; i++){
+		threadIslandAgent.push_back(0);
+		islandAgentNumber.push_back(i);
+	}
+	for(int i = 0; i < totalNumberIslands; i++){
+		if (pthread_create(&threadIslandAgent[i], NULL, &islandAgent, (void *)&islandAgentNumber[i])) {
+			cout << "Failed Thread Island Agent" << endl; fflush(NULL);
+			exit(0);
+		}
+	}*/
+
+	// Enable hardware Turbo Boost in all islands
+	for(int i = 0; i < totalNumberIslands; i++){
+		SimActivateIslandBoosting(i);
+	}
+
+
+
+
+
+
+
+
+
+
+
+	//usleep( 2*SCHEDULING_INTERVAL );
+	cout << "Entering infinite scheduling loop" << endl; fflush(NULL);
+	/*clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned int currentTime;
+	unsigned int lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+	while(1){
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		if(SCHEDULING_INTERVAL > (currentTime - lastTime))
+			usleep( SCHEDULING_INTERVAL - currentTime + lastTime);
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+
+		for(unsigned int appIndex = 0; appIndex < applications.size(); appIndex++){
+			cout << "Application " << applications[appIndex].appId << endl;
+			if(applications[appIndex].threads.size() > 0){
+				for(unsigned int threadInApplication = 0; threadInApplication < applications[appIndex].threads.size(); threadInApplication++){
+					cout << "   Thread " << applications[appIndex].threads[threadInApplication].threadId << endl;
+				}
+			}
+			else{
+				cout << "   Finished" << endl;
+			}
+		}
+		fflush(NULL);
+
+
+
+
+
+
+
+		// If the only application running is the scheduler finish the simulation
+		if(applications.size() <= 0){
+			// Finilize the ROI and exit the application
+			parmacs_roi_end();
+			exit(0);
+		}
+	}*/
+
+
+
+	// Now wait for the threads of the core and island agents to finish
+	for(int i = 0; i < totalNumberApplications; i++){
+		pthread_join(threadApplicationAgent[i], NULL);
+	}
+	//for(int i = 0; i < totalNumberIslands; i++){
+	//	pthread_join(threadIslandAgent[i], NULL);
+	//}
+
+	// Finilize the ROI and exit the application
+	parmacs_roi_end();
+	exit(0);
+}
+
+
+
+
+
+
+
+void *applicationAgent(void * arg)
+{
+	// Migrate the island agent to the first core of the corresponding island
+	int applicationAgentNumber = *((int *)arg);
+	int agentMappedToCore = randomCoresForInitialAgentMapping[applicationAgentNumber - 1];
+	SimSetOwnAffinity(agentMappedToCore);
+
+	int thisAgentMappedtoIsland = agentMappedToCore / coresPerIsland;
+	unsigned int totalNumberAgents = agentsMappedToIsland.size();
+
+	int offsetThreadIndexForThisApplication = offsetThreadIndexForApplication[applicationAgentNumber - 1];
+	int numberThreadsThisApplication = numberOfThreadsPerApp[applicationAgentNumber - 1];
+
+
+	vector<float> currentIPCapplication;
+	vector<float> currentIPSapplication;
+	vector<Thread> threads;
+	for(int threadNumber = 0; threadNumber < numberThreadsThisApplication; threadNumber++){
+		Thread newThread;
+		threads.push_back(newThread);
+
+		currentIPSapplication.push_back(0);
+		currentIPCapplication.push_back(0);
+	}
+
+
+
+
+	/*vector<float> averageTemperatureNeighbouringIslands;
+	vector< vector<float> > temperatureNeighbouringIslands;
+	vector< vector<int> > threadMappedToCoreNeighbouringIslands;
+	vector< vector<int> > applicationMappedToCoreNeighbouringIslands;
+	vector<int> freeCoresNeighbouringIslands;
+	{
+		vector<float> auxTemperatureNeighbouringIslands;
+		vector<int> auxIntVectorNeighbouringIslands;
+		for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+			auxTemperatureNeighbouringIslands.push_back(0);
+			auxIntVectorNeighbouringIslands.push_back(-1);
+		}
+		for(int auxNeighbourIsland = 0; auxNeighbourIsland < MAX_NUMBER_NEIGHBOUR_ISLANDS; auxNeighbourIsland++){
+			temperatureNeighbouringIslands.push_back(auxTemperatureNeighbouringIslands);
+			threadMappedToCoreNeighbouringIslands.push_back(auxIntVectorNeighbouringIslands);
+			applicationMappedToCoreNeighbouringIslands.push_back(auxIntVectorNeighbouringIslands);
+			freeCoresNeighbouringIslands.push_back(coresPerIsland);
+			averageTemperatureNeighbouringIslands.push_back(0);
+		}
+	}*/
+
+
+	// This sleep interval is just to try to get agents to be executed interleaved, and not all at the same time.
+	usleep( 20 * applicationAgentNumber);
+
+
+
+	/*stringstream fileName;
+	fileName << "/home/santiago/sniper/applicationAgent_" << applicationAgentNumber;
+	ofstream outputStream;
+	outputStream.open(fileName.str().c_str());
+	if (outputStream.is_open()){
+		if (outputStream.good()){
+			outputStream.precision(12);
+		}
+		else{
+			cout << "Error: Output file: \"" << fileName.str() << "\" could not be open for writing." << endl; fflush(NULL);
+			outputStream.close();
+		}
+	}
+	else{
+		cout << "Error: Output file: \"" << fileName.str() << "\" could not be open for writing." << endl; fflush(NULL);
+	}*/
+
+
+
+
+
+
+
+
+
+	struct timespec end;
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned int currentTime;
+	unsigned int lastTime = 0;
+	while(1){
+		//unsigned long threadId = SimGetThreadId();
+		//clock_gettime(CLOCK_MONOTONIC, &end);
+		//double printTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		//outputStream << "Time: " << printTime/1000000 << " \tApplication agent: " << applicationAgentNumber << " \tThread ID: " << threadId << endl;
+
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		if(SCHEDULING_INTERVAL > (currentTime - lastTime))
+			usleep( SCHEDULING_INTERVAL - currentTime + lastTime);
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+
+
+
+		if(SimIsApplicationFinished(applicationAgentNumber)){
+
+			for(unsigned int coreNumber = 0; coreNumber < totalNumberCores; coreNumber++){
+				pthread_mutex_lock(&flagReservedCores[coreNumber]);
+				if(coresReservedForApplication[coreNumber] == applicationAgentNumber)
+					coresReservedForApplication[coreNumber] = INVALID_APPLICATION;
+				pthread_mutex_unlock(&flagReservedCores[coreNumber]);
+			}
+
+			// Find which thread of the other application was mapped to this core to do the exchange
+			for(int threadNumber = 0; threadNumber < numberThreadsThisApplication; threadNumber++){
+				pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+				threadReservedCore[offsetThreadIndexForThisApplication + threadNumber] = INVALID_CORE;
+				pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+
+				threads[threadNumber].threadId = INVALID_THREAD;
+				threads[threadNumber].mappedToCore = INVALID_CORE;
+			}
+			usleep(UINT_MAX);
+		}
+		else{
+
+			// Update the threads belonging to this application
+			unsigned int totalNumberThreads = SimGetNumThreads();
+			for(unsigned int sniperThread = 0; sniperThread < totalNumberThreads; sniperThread++){
+				int appId = SimGetThreadAppId(sniperThread);
+
+				if(appId == applicationAgentNumber){
+
+					// Now find the index of the thread
+					int threadIndex = -1;
+					for(int threadInApplication = 0; threadInApplication < numberThreadsThisApplication; threadInApplication++){
+						if(threads[threadInApplication].threadId == sniperThread){
+							threadIndex = threadInApplication;
+							break;
+						}
+					}
+
+					// If the index was less than zero, this thread was not in the list of threads of this applicaiton
+					if(threadIndex < 0){
+						// Verify that the thread is not finished
+						if(SimIsThreadFinished(sniperThread) == false){
+							for(int threadInApplication = 0; threadInApplication < numberThreadsThisApplication; threadInApplication++){
+								if(threads[threadInApplication].threadId == INVALID_THREAD){
+									threads[threadInApplication].threadId = sniperThread;
+									threads[threadInApplication].mappedToCore = INVALID_CORE;
+									break;
+								}
+							}
+						}
+					}
+					else{
+						// If the thread already existed, verify that it has not finished
+						if(SimIsThreadFinished(sniperThread)){
+							// If the thread is finished, we indicate that the thread is no longer mapped to that core
+							//int threadMappedToCore = threads[threadIndex].mappedToCore;
+							//pthread_mutex_lock(&flagCoreMapping[threadMappedToCore]);
+							//cores[threadMappedToCore].mappedThreadId = -1;
+							//cores[threadMappedToCore].mappedApplicationId = -1;
+							//pthread_mutex_unlock(&flagCoreMapping[threadMappedToCore]);
+
+							// We erase the thread from the list of threads of the application
+							//threads.erase(threads.begin() + threadIndex);
+
+							// If there are no more threads to run for this application, then we terminate the agent
+							// We are acutally not doing this, because applications will be re-executed
+							//if(threads.size() == 0){
+							//	return 0;
+							//}
+
+							// We mark the thread in our list as invalid, meaning that is not associated with any Sniper thread
+							threads[threadIndex].threadId = INVALID_THREAD;
+							threads[threadIndex].mappedToCore = INVALID_CORE;
+						}
+					}
+				}
+			}
+
+
+
+
+
+			// Compute current MIPS for all threads of this application
+			/*for(int threadNumber = 0; threadNumber < numberThreadsThisApplication; threadNumber++){
+				if((threads[threadNumber].threadId >= 0) && (threads[threadNumber].mappedToCore >= 0)){
+					unsigned int currentInstructionCount = SimGetAccumulatedInstructions(threads[threadNumber].mappedToCore);
+					pthread_mutex_lock(&flagPreviousInstructionCountCore[threads[threadNumber].mappedToCore]);
+					currentIPSapplication[threadNumber] = ((float)(currentInstructionCount - previousInstructionCountCore[threads[threadNumber].mappedToCore]))/(lastTime - lastTimeinstructionCountCore[threads[threadNumber].mappedToCore]);
+					previousInstructionCountCore[threads[threadNumber].mappedToCore] = currentInstructionCount;
+					lastTimeinstructionCountCore[threads[threadNumber].mappedToCore] = lastTime;
+					pthread_mutex_unlock(&flagPreviousInstructionCountCore[threads[threadNumber].mappedToCore]);
+
+					currentIPCapplication[threadNumber] = currentIPSapplication[threadNumber] / (SimGetFreqMHz(threads[threadNumber].mappedToCore) * 1e6);
+				}
+				else{
+					currentIPSapplication[threadNumber] = 0;
+					currentIPCapplication[threadNumber] = 0;
+				}
+			}*/
+
+
+
+
+
+
+
+
+
+			// Count the number of threads of this application that are have not yet cores reserved. The first goal is to reserve cores for all threads
+			// and then map them to free cores.
+			// Only after all threads of the application are reserved to map to cores try to migrate to improve overall performance
+			int numberReservedCoresForApplication = 0;
+			for(int threadNumber = 0; threadNumber < numberThreadsThisApplication; threadNumber++){
+				// mappedToCore < 0 means that the thread is unmapped in what respect to our scheduler
+				pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+				if(threadReservedCore[offsetThreadIndexForThisApplication + threadNumber] >= 0){
+					numberReservedCoresForApplication++;
+				}
+				pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+			}
+			if((numberThreadsThisApplication - numberReservedCoresForApplication) > 0){
+				// Reserve all cores for this application in one run. Without this while, we only reserve up to the amount of cores in one island per iteration
+				while((numberThreadsThisApplication - numberReservedCoresForApplication) > 0){
+					// Search for the island with more free cores. If more than one island has the same number of free cores, then choose the coolest island
+					int islandWithMoreFreeCores = -1;
+					int highestNumberFreeCores = 0;
+					float averageTemperatureIslandWithMoreFreeCores;
+					for(unsigned int neighbourIslandIndex = 0; neighbourIslandIndex < neighbouringIslands[thisAgentMappedtoIsland].size(); neighbourIslandIndex++){
+						// First count the number of free cores in each island
+						int freeCoresThisIsland = 0;
+						for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+							int absoluteCoreNumber = auxCoreNumber + neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex]*coresPerIsland;
+
+							pthread_mutex_lock(&flagReservedCores[absoluteCoreNumber]);
+							if(coresReservedForApplication[absoluteCoreNumber] < 0)
+								freeCoresThisIsland++;
+							pthread_mutex_unlock(&flagReservedCores[absoluteCoreNumber]);
+						}
+
+						// If the island has at least one free core
+						if(freeCoresThisIsland > 0){
+							// Compare it with the highest number of free cores of neighbouring islands so far
+							if(highestNumberFreeCores < freeCoresThisIsland){
+								// Compute the average temperature of the island
+								averageTemperatureIslandWithMoreFreeCores = 0;
+								for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+									int absoluteCoreNumber = auxCoreNumber + neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex]*coresPerIsland;
+									averageTemperatureIslandWithMoreFreeCores += ((float)SimGetTemperature(absoluteCoreNumber))/1000000;
+								}
+								averageTemperatureIslandWithMoreFreeCores /= coresPerIsland;
+
+								// Replace the new highest number of free cores
+								highestNumberFreeCores = freeCoresThisIsland;
+								islandWithMoreFreeCores = neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex];
+							}
+							// In case there is more than one island with the same number of free cores, keep the coolest island that has no other agent mapped
+							else if(highestNumberFreeCores == freeCoresThisIsland){
+
+								// Check if the new island considered has agents mapped to it
+								bool agentMappedToIslandThisIsland = false;
+								for(unsigned int auxAgentIndex = 0; auxAgentIndex < totalNumberAgents; auxAgentIndex++){
+									if((applicationAgentNumber - 1) != auxAgentIndex){
+										pthread_mutex_lock(&flagAgentsMappedToIsland[auxAgentIndex]);
+										if(agentsMappedToIsland[auxAgentIndex] == neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex]){
+											agentMappedToIslandThisIsland = true;
+											pthread_mutex_unlock(&flagAgentsMappedToIsland[auxAgentIndex]);
+											break;
+										}
+										pthread_mutex_unlock(&flagAgentsMappedToIsland[auxAgentIndex]);
+									}
+								}
+
+								if(agentMappedToIslandThisIsland == false){
+									// Compute the average temperature of the island
+									float averageTemperatureThisIsland = 0;
+									for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+										int absoluteCoreNumber = auxCoreNumber + neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex]*coresPerIsland;
+										averageTemperatureThisIsland += ((float)SimGetTemperature(absoluteCoreNumber))/1000000;
+									}
+									averageTemperatureThisIsland /= coresPerIsland;
+
+									if(averageTemperatureIslandWithMoreFreeCores > averageTemperatureThisIsland){
+										averageTemperatureIslandWithMoreFreeCores = averageTemperatureThisIsland;
+										islandWithMoreFreeCores = neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex];
+									}
+								}
+							}
+						}
+					}
+
+
+
+					// If no island has free cores, the agent needs to look in neighbouring islands of the current neighbours
+					if(highestNumberFreeCores <= 0){
+						// FIXME: In this implementation, since we have a small number of islands and we want to keep it simple, we do it globally
+						// Search for the island with more free cores. If more than one island has the same number of free cores, then choose the coolest island
+						for(int globalIslandIndex = 0; globalIslandIndex < totalNumberIslands; globalIslandIndex++){
+							// First count the number of free cores in each island
+							int freeCoresThisIsland = 0;
+							for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+								int absoluteCoreNumber = auxCoreNumber + globalIslandIndex*coresPerIsland;
+
+								pthread_mutex_lock(&flagReservedCores[absoluteCoreNumber]);
+								if(coresReservedForApplication[absoluteCoreNumber] < 0)
+									freeCoresThisIsland++;
+								pthread_mutex_unlock(&flagReservedCores[absoluteCoreNumber]);
+							}
+
+							// If the island has at least one free core
+							if(freeCoresThisIsland > 0){
+								// Compare it with the highest number of free cores of neighbouring islands so far
+								if(highestNumberFreeCores < freeCoresThisIsland){
+									// Compute the average temperature of the island
+									averageTemperatureIslandWithMoreFreeCores = 0;
+									for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+										int absoluteCoreNumber = auxCoreNumber + globalIslandIndex*coresPerIsland;
+										averageTemperatureIslandWithMoreFreeCores += ((float)SimGetTemperature(absoluteCoreNumber))/1000000;
+									}
+									averageTemperatureIslandWithMoreFreeCores /= coresPerIsland;
+
+									// Replace the new highest number of free cores
+									highestNumberFreeCores = freeCoresThisIsland;
+									islandWithMoreFreeCores = globalIslandIndex;
+								}
+								// In case there is more than one island with the same number of free cores, keep the coolest island
+								else if(highestNumberFreeCores == freeCoresThisIsland){
+									// Compute the average temperature of the island
+									float averageTemperatureThisIsland = 0;
+									for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+										int absoluteCoreNumber = auxCoreNumber + globalIslandIndex*coresPerIsland;
+										averageTemperatureThisIsland += ((float)SimGetTemperature(absoluteCoreNumber))/1000000;
+									}
+									averageTemperatureThisIsland /= coresPerIsland;
+
+									if(averageTemperatureIslandWithMoreFreeCores > averageTemperatureThisIsland){
+										averageTemperatureIslandWithMoreFreeCores = averageTemperatureThisIsland;
+										islandWithMoreFreeCores = globalIslandIndex;
+									}
+								}
+							}
+						}
+					}
+
+
+					// At this point we should have found at least one island with some free cores
+					if((highestNumberFreeCores > 0) && (islandWithMoreFreeCores >= 0)){
+
+						// We start going through the threads that do not have cores reserved
+						for(int threadNumber = 0; threadNumber < numberThreadsThisApplication; threadNumber++){
+							// mappedToCore < 0 means that the thread is unmapped in what respect to our scheduler
+							pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+							int auxThreadReservedCore = threadReservedCore[offsetThreadIndexForThisApplication + threadNumber];
+							pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+							if(auxThreadReservedCore < 0){
+
+								// Search which cores inside the island are the ones that are free
+								for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+									int absoluteCoreNumber = auxCoreNumber + islandWithMoreFreeCores*coresPerIsland;
+
+									// Once we found an unreserved core inside the island we reserve it to later map a thread to it
+									pthread_mutex_lock(&flagReservedCores[absoluteCoreNumber]);
+									if(coresReservedForApplication[absoluteCoreNumber] < 0){
+										coresReservedForApplication[absoluteCoreNumber] = applicationAgentNumber;
+										pthread_mutex_unlock(&flagReservedCores[absoluteCoreNumber]);
+										SimReserveCoreForApplication(absoluteCoreNumber, applicationAgentNumber);
+
+										pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+										threadReservedCore[offsetThreadIndexForThisApplication + threadNumber] = absoluteCoreNumber;
+										pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+
+										// In case this is the first thread of this application that we are mapping, also move the agent to this core
+										if((numberReservedCoresForApplication <= 0) && (agentMappedToCore != absoluteCoreNumber)){
+											agentMappedToCore = absoluteCoreNumber;
+											SimSetOwnAffinity(agentMappedToCore);
+											thisAgentMappedtoIsland = agentMappedToCore / coresPerIsland;
+
+											pthread_mutex_lock(&flagAgentsMappedToIsland[applicationAgentNumber - 1]);
+											agentsMappedToIsland[applicationAgentNumber - 1] = thisAgentMappedtoIsland;
+											pthread_mutex_unlock(&flagAgentsMappedToIsland[applicationAgentNumber - 1]);
+										}
+
+										numberReservedCoresForApplication++;
+										break;
+									}
+									pthread_mutex_unlock(&flagReservedCores[absoluteCoreNumber]);
+								}
+							}
+						}
+					}
+					else{
+						cout << "ERROR: No free cores available in the entire system" << endl; fflush(NULL);
+					}
+				}
+			}
+			// If all cores are already reserved, then here we apply task migrations
+			/*else{
+
+				// Find the maximum temperatures of all the cores of the application
+				float maxTemperatureApplication = 0;
+				int applicationThreadWithMaxTemperature = INVALID_THREAD;
+				int coreMaximumTemperature = INVALID_CORE;
+				for(unsigned int threadInApplication = 0; threadInApplication < numberThreadsThisApplication; threadInApplication++){
+					pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadInApplication]);
+					int auxThreadReservedCore = threadReservedCore[offsetThreadIndexForThisApplication + threadInApplication];
+					pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadInApplication]);
+					if(auxThreadReservedCore >= 0){
+						float temperatureThread = ((float)SimGetTemperature(auxThreadReservedCore))/1000000;
+						if(maxTemperatureApplication < temperatureThread){
+							maxTemperatureApplication = temperatureThread;
+							applicationThreadWithMaxTemperature = threadInApplication;
+							coreMaximumTemperature = auxThreadReservedCore;
+						}
+					}
+				}
+
+
+				// Find the coolest core among all neighbouring islands
+				int coreMinimumTemperature = INVALID_CORE;
+				float minTemperatureNeighbouringIslands = FLT_MAX;
+				for(unsigned int neighbourIslandIndex = 0; neighbourIslandIndex < neighbouringIslands[thisAgentMappedtoIsland].size(); neighbourIslandIndex++){
+					for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+						int absoluteCoreNumber = auxCoreNumber + neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex]*coresPerIsland;
+						float temperatureCore = ((float)SimGetTemperature(absoluteCoreNumber))/1000000;
+						if(minTemperatureNeighbouringIslands > temperatureCore){
+							minTemperatureNeighbouringIslands = temperatureCore;
+							coreMinimumTemperature = absoluteCoreNumber;
+						}
+					}
+				}
+
+
+
+				// If there was a thermal violation on some core of the application, migrate the thread to the coolest core in the neighbouring islands
+				// If there was already a thread map to that core, simply exchange them
+				// Note that this happens only if the temperature difference is larger than a histeresis bound, and if the other core also does not have
+				// a thermal violation
+				if((maxTemperatureApplication > Tdtm) && (applicationThreadWithMaxTemperature >= 0) && (coreMinimumTemperature >= 0) && (coreMaximumTemperature >= 0)){
+
+					if( ((minTemperatureNeighbouringIslands < Tdtm) && ((maxTemperatureApplication - minTemperatureNeighbouringIslands) >= MIGRATION_THERMAL_HISTERESIS_BOUND)) ||
+						((maxTemperatureApplication - minTemperatureNeighbouringIslands) >= 3*MIGRATION_THERMAL_HISTERESIS_BOUND) ){
+
+						pthread_mutex_lock(&flagReservedCores[coreMinimumTemperature]);
+						// If the core was not reserved for any application
+						if(coresReservedForApplication[coreMinimumTemperature] < 0){
+							coresReservedForApplication[coreMinimumTemperature] = applicationAgentNumber;
+							pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+
+							pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature]);
+							threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature] = coreMinimumTemperature;
+							pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature]);
+
+							SimReserveCoreForApplication(coreMinimumTemperature, applicationAgentNumber);
+							SimReserveCoreForApplication(coreMaximumTemperature, INVALID_APPLICATION);
+						}
+						// If the core was reserved for this same application
+						else if(coresReservedForApplication[coreMinimumTemperature] == applicationAgentNumber){
+							pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+
+							// Find which thread of the other application was mapped to this core to do the exchange
+							for(int auxThreadIndex = 0; auxThreadIndex < numberThreadsThisApplication; auxThreadIndex++){
+								pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex]);
+								if(threadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex] == coreMinimumTemperature){
+									threadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex] = coreMaximumTemperature;
+									pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex]);
+									break;
+								}
+								pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex]);
+							}
+
+							pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature]);
+							threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature] = coreMinimumTemperature;
+							pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature]);
+						}
+						// If the core was reserved for some other application
+						else{
+							int previousMappedApplication = coresReservedForApplication[coreMinimumTemperature];
+							coresReservedForApplication[coreMinimumTemperature] = applicationAgentNumber;
+							pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+
+							pthread_mutex_lock(&flagReservedCores[coreMaximumTemperature]);
+							coresReservedForApplication[coreMaximumTemperature] = previousMappedApplication;
+							pthread_mutex_unlock(&flagReservedCores[coreMaximumTemperature]);
+
+							// Find which thread of the other application was mapped to this core to do the exchange
+							int offsetThreadIndexForOtherApplication = offsetThreadIndexForApplication[previousMappedApplication - 1];
+							for(int auxThreadIndexOtherApp = 0; auxThreadIndexOtherApp < numberOfThreadsPerApp[previousMappedApplication - 1]; auxThreadIndexOtherApp++){
+								pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp]);
+								if(threadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp] == coreMinimumTemperature){
+									threadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp] = coreMaximumTemperature;
+									pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp]);
+									break;
+								}
+								pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp]);
+							}
+
+							pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature]);
+							threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature] = coreMinimumTemperature;
+							pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature]);
+
+							SimReserveCoreForApplication(coreMinimumTemperature, applicationAgentNumber);
+							SimReserveCoreForApplication(coreMaximumTemperature, previousMappedApplication);
+						}
+					}
+				}
+				// If there was no thermal violation, try to map threads with high IPC to cool cores. This is to try to avoid a future thermal violation.
+				// We could also be looking at power, but is most likely that there will be a performance counter in eery core, but not a power meter
+				else{
+
+					// First find the application core with the maximum IPC
+					float maxIPCApplication = 0;
+					int applicationThreadWithMaxIPC = INVALID_THREAD;
+					int coreMaximumIPC = INVALID_CORE;
+					for(unsigned int threadInApplication = 0; threadInApplication < numberThreadsThisApplication; threadInApplication++){
+						if((threads[threadInApplication].threadId >= 0) && (threads[threadInApplication].mappedToCore >= 0)){
+							if(maxIPCApplication < currentIPCapplication[threadInApplication]){
+								maxIPCApplication = currentIPCapplication[threadInApplication];
+								applicationThreadWithMaxIPC = threadInApplication;
+								coreMaximumIPC = threads[threadInApplication].mappedToCore;
+							}
+						}
+					}
+
+
+
+					// Only trigger a migration if the IPC is larger than the minimum bound for migration, and if the temperature difference between the
+					// highest IPC core and the coolest core is larger than the threshold
+					if((coreMaximumIPC >= 0) && (coreMinimumTemperature >= 0) && (coreMaximumIPC != coreMinimumTemperature)){
+						float temperatureCoreMaxIPC = ((float)SimGetTemperature(coreMaximumIPC))/1000000;
+						if((maxIPCApplication > MIGRATION_MINIMUM_IPC_BOUND) && ((temperatureCoreMaxIPC - minTemperatureNeighbouringIslands) >= MIGRATION_THERMAL_HISTERESIS_BOUND)){
+
+							pthread_mutex_lock(&flagReservedCores[coreMinimumTemperature]);
+							// If the core was not reserved for any application, simply migrate it
+							if(coresReservedForApplication[coreMinimumTemperature] < 0){
+								coresReservedForApplication[coreMinimumTemperature] = applicationAgentNumber;
+								pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+
+								pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC]);
+								threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC] = coreMinimumTemperature;
+								pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC]);
+
+								SimReserveCoreForApplication(coreMinimumTemperature, applicationAgentNumber);
+								SimReserveCoreForApplication(coreMaximumIPC, INVALID_APPLICATION);
+							}
+							// If the core was reserved for this same application, we only do the exchange if the IPC different between the highest IPC and
+							// the IPC of the coolest core is bigger than the minimum migration difference
+							else if(coresReservedForApplication[coreMinimumTemperature] == applicationAgentNumber){
+								pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+
+								// Find which thread of the other application was mapped to this core to do the exchange
+								int threadIndexWithMinimumTemperature = -1;
+								for(int auxThreadIndex = 0; auxThreadIndex < numberThreadsThisApplication; auxThreadIndex++){
+									pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex]);
+									if(threadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex] == coreMinimumTemperature){
+										if((maxIPCApplication - currentIPCapplication[auxThreadIndex]) > MIGRATION_IPC_HISTERESIS_BOUND){
+											threadIndexWithMinimumTemperature = auxThreadIndex;
+											threadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex] = coreMaximumIPC;
+										}
+										pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex]);
+										break;
+									}
+									pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex]);
+								}
+
+								// We do the migration if we found the core with minimum temperature and the IPC difference was larger than the minimum difference
+								if(threadIndexWithMinimumTemperature >= 0){
+									pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC]);
+									threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC] = coreMinimumTemperature;
+									pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC]);
+								}
+							}
+							// If the core was reserved for some other application, we only do the exchange if the IPC different between the highest IPC and
+							// the IPC of the coolest core is bigger than the minimum migration difference
+							else{
+								// Compute current MIPS of the core with the minimum temperature
+								pthread_mutex_lock(&flagPreviousInstructionCountCore[coreMinimumTemperature]);
+								float currentIPCcoreMinimumTemperature = (((float)(SimGetAccumulatedInstructions(coreMinimumTemperature) - previousInstructionCountCore[coreMinimumTemperature]))/(lastTime - lastTimeinstructionCountCore[coreMinimumTemperature])) / (SimGetFreqMHz(coreMinimumTemperature) * 1e6);
+								pthread_mutex_unlock(&flagPreviousInstructionCountCore[coreMinimumTemperature]);
+
+								if((maxIPCApplication - currentIPCcoreMinimumTemperature) > MIGRATION_IPC_HISTERESIS_BOUND){
+
+									int previousMappedApplication = coresReservedForApplication[coreMinimumTemperature];
+									coresReservedForApplication[coreMinimumTemperature] = applicationAgentNumber;
+									pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+
+									pthread_mutex_lock(&flagReservedCores[coreMaximumIPC]);
+									coresReservedForApplication[coreMaximumIPC] = previousMappedApplication;
+									pthread_mutex_unlock(&flagReservedCores[coreMaximumIPC]);
+
+									// Find which thread of the other application was mapped to this core to do the exchange
+									int offsetThreadIndexForOtherApplication = offsetThreadIndexForApplication[previousMappedApplication - 1];
+									for(int auxThreadIndexOtherApp = 0; auxThreadIndexOtherApp < numberOfThreadsPerApp[previousMappedApplication - 1]; auxThreadIndexOtherApp++){
+										pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp]);
+										if(threadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp] == coreMinimumTemperature){
+											threadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp] = coreMaximumIPC;
+											pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp]);
+											break;
+										}
+										pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp]);
+									}
+
+									pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC]);
+									threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC] = coreMinimumTemperature;
+									pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC]);
+
+									SimReserveCoreForApplication(coreMinimumTemperature, applicationAgentNumber);
+									SimReserveCoreForApplication(coreMaximumIPC, previousMappedApplication);
+								}
+								else{
+									pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+								}
+							}
+						}
+					}
+
+
+				}
+			}*/
+
+
+
+
+			// Check if there is any new thread of this application to be mapped.
+			// Threads will already have being mapped by Sniper's scheduler, but we now migrate them to the core we want.
+			// Threads are mapped according to the cores reserved by the application
+			// FIXME: This could be improved, given that when a new thread is created, it will have already been created in one of the reserved cores for
+			// this application. This involves some slight unnecessary overheads for this one-time migration of new threads
+			for(int threadInApplication = 0; threadInApplication < numberThreadsThisApplication; threadInApplication++){
+				// mappedToCore < 0 means that the thread is unmapped in what respect to our scheduler
+				//if((offsetThreadIndexForThisApplication + threadInApplication) < threadReservedCore.size()){
+				if(threads[threadInApplication].threadId >= 0){
+					pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadInApplication]);
+					int auxThreadReservedCore = threadReservedCore[offsetThreadIndexForThisApplication + threadInApplication];
+					pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadInApplication]);
+					if(threads[threadInApplication].mappedToCore != auxThreadReservedCore){
+
+						cout << "Application agent " << applicationAgentNumber << " mapping thread " << threads[threadInApplication].threadId << " to core " << auxThreadReservedCore << " in island " << auxThreadReservedCore / coresPerIsland  << endl; fflush(NULL);
+						// After finding a core, migrate the thread to that core
+						threads[threadInApplication].mappedToCore = auxThreadReservedCore;
+						//pthread_mutex_lock(&flagCoreMapping[coreIndexToMapApplication]);
+						//cores[coreIndexToMapApplication].mappedThreadId = threads[threadInApplication].threadId;
+						//cores[coreIndexToMapApplication].mappedApplicationId = applicationAgentNumber;
+						//pthread_mutex_unlock(&flagCoreMapping[coreIndexToMapApplication]);
+
+						SimSetThreadAffinity(threads[threadInApplication].threadId, auxThreadReservedCore);
+					}
+				}
+			}
+		}
+
+
+
+	}
+
+	return 0;
+}
+
+
+
+
+/*
+void *islandAgent(void * arg)
+{
+	// Migrate the island agent to the first core of the corresponding island
+	int islandAgentNumber = *((int *)arg);
+	SimSetOwnAffinity(islandAgentNumber * coresPerIsland);
+
+
+
+	struct timespec end;
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned int currentTime;
+	unsigned int lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+	while(1){
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		if(SCHEDULING_INTERVAL > (currentTime - lastTime))
+			usleep( SCHEDULING_INTERVAL - currentTime + lastTime);
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+
+
+
+
+		// Find the maximum temperature in the island
+		bool thermalViolation = false;
+		for(int core = 0; core < coresPerIsland; core++){
+			if((((float)SimGetTemperature(core + islandAgentNumber * coresPerIsland))/1000000) > Tdtm){
+				thermalViolation = true;
+				break;
+			}
+		}
+
+		// Read the frequency of the island
+		unsigned int currentIslandFrequency = SimGetFreqMHz(islandAgentNumber * coresPerIsland);
+		if(thermalViolation == true){
+			// If there was a thermal violation, reduce the frequency of the island
+			if(currentIslandFrequency > MIN_FREQUENCY){
+				SimSetFreqMHz(islandAgentNumber * coresPerIsland, currentIslandFrequency - FREQUENCY_STEP);
+			}
+		}
+		else{
+			// If there was no thermal violation, increase the frequency of the island
+			if(currentIslandFrequency < MAX_FREQUENCY){
+				SimSetFreqMHz(islandAgentNumber * coresPerIsland, currentIslandFrequency + FREQUENCY_STEP);
+			}
+		}
+	}
+
+	return 0;
+}*/
+
+
+
+
+
+
+
+
+
+
+/*
+void *coreAgent(void * arg)
+{
+	// Migrate the core agent to the corresponding core
+	int coreAgentNumber = *((int *)arg);
+	if(SimInSimulator())
+		SimSetOwnAffinity(coreAgentNumber);
+
+
+	stringstream fileName;
+	fileName << "/home/santiago/sniper/coreAgent_" << coreAgentNumber;
+	ofstream outputStream;
+	outputStream.open(fileName.str().c_str());
+	if (outputStream.is_open()){
+		if (outputStream.good()){
+			outputStream.precision(12);
+		}
+		else{
+			cout << "Error: Output file: \"" << fileName.str() << "\" could not be open for writing." << endl; fflush(NULL);
+			outputStream.close();
+		}
+	}
+	else{
+		cout << "Error: Output file: \"" << fileName.str() << "\" could not be open for writing." << endl; fflush(NULL);
+	}
+
+
+
+	unsigned long int currentInstructionCount;
+	double currentIPS;
+
+	struct timespec end;
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned long int currentTime;
+	unsigned long int lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+	unsigned long int previousInstructionCount = SimGetAccumulatedInstructions(coreAgentNumber);
+	unsigned long int lastTimeInstructionCout = lastTime;
+	while(1){
+		//unsigned long threadId = SimGetThreadId();
+		//clock_gettime(CLOCK_MONOTONIC, &end);
+		//double printTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		//outputStream << "Time: " << printTime/1000000 << " \tCore agent: " << coreAgentNumber << " \tThread ID: " << threadId << endl;
+
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		if(SCHEDULING_INTERVAL > (currentTime - lastTime))
+			usleep( SCHEDULING_INTERVAL - currentTime + lastTime);
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+
+		// Compute current MIPS
+		currentInstructionCount = SimGetAccumulatedInstructions(coreAgentNumber);
+		currentIPS = ((double)(currentInstructionCount - previousInstructionCount))/(lastTime - lastTimeInstructionCout);
+		outputStream << "Time: " << lastTime/1000000.0 << " \tCore agent: " << coreAgentNumber << " \tcurrentIPS: " << currentIPS << " \tcurrentInstructionCount: " << currentInstructionCount << " \tpreviousInstructionCount:" << previousInstructionCount << " \tlastTime:" << lastTime << " \tlastTimeInstructionCout:" << lastTimeInstructionCout << endl;
+		previousInstructionCount = currentInstructionCount;
+		lastTimeInstructionCout = lastTime;
+
+
+		// Get own temperature and temperature
+		double temperature = ((double)SimGetTemperature(coreAgentNumber))/1000000.0;
+		double power = ((double)SimGetPower(coreAgentNumber))/1000000.0;
+
+
+
+	}
+
+
+	return 0;
+}
+*/
+
+
+
+
+void fillNeighbouringIslandsVector(void)
+{
+	vector<int> neighboursIsland_0, neighboursIsland_1, neighboursIsland_2, neighboursIsland_3, neighboursIsland_4, neighboursIsland_5, neighboursIsland_6, \
+				neighboursIsland_7, neighboursIsland_8, neighboursIsland_9, neighboursIsland_10, neighboursIsland_11, neighboursIsland_12, \
+				neighboursIsland_13, neighboursIsland_14, neighboursIsland_15;
+
+	// 0  1  2  3
+	// 4  5  6  7
+	// 8  9  10 11
+	// 12 13 14 15
+
+	// Include itself, that is, the island in the center of the neighbours
+	neighboursIsland_0.push_back(0);
+	neighboursIsland_0.push_back(1);
+	neighboursIsland_0.push_back(4);
+
+	neighboursIsland_1.push_back(1);
+	neighboursIsland_1.push_back(0);
+	neighboursIsland_1.push_back(2);
+	neighboursIsland_1.push_back(5);
+
+	neighboursIsland_2.push_back(2);
+	neighboursIsland_2.push_back(1);
+	neighboursIsland_2.push_back(3);
+	neighboursIsland_2.push_back(6);
+
+	neighboursIsland_3.push_back(3);
+	neighboursIsland_3.push_back(2);
+	neighboursIsland_3.push_back(7);
+
+	neighboursIsland_4.push_back(4);
+	neighboursIsland_4.push_back(0);
+	neighboursIsland_4.push_back(5);
+	neighboursIsland_4.push_back(8);
+
+	neighboursIsland_5.push_back(5);
+	neighboursIsland_5.push_back(1);
+	neighboursIsland_5.push_back(4);
+	neighboursIsland_5.push_back(6);
+	neighboursIsland_5.push_back(9);
+
+	neighboursIsland_6.push_back(6);
+	neighboursIsland_6.push_back(2);
+	neighboursIsland_6.push_back(5);
+	neighboursIsland_6.push_back(7);
+	neighboursIsland_6.push_back(10);
+
+	neighboursIsland_7.push_back(7);
+	neighboursIsland_7.push_back(3);
+	neighboursIsland_7.push_back(6);
+	neighboursIsland_7.push_back(11);
+
+	neighboursIsland_8.push_back(8);
+	neighboursIsland_8.push_back(4);
+	neighboursIsland_8.push_back(9);
+	neighboursIsland_8.push_back(12);
+
+	neighboursIsland_9.push_back(9);
+	neighboursIsland_9.push_back(5);
+	neighboursIsland_9.push_back(8);
+	neighboursIsland_9.push_back(10);
+	neighboursIsland_9.push_back(13);
+
+	neighboursIsland_10.push_back(10);
+	neighboursIsland_10.push_back(6);
+	neighboursIsland_10.push_back(9);
+	neighboursIsland_10.push_back(11);
+	neighboursIsland_10.push_back(14);
+
+	neighboursIsland_11.push_back(11);
+	neighboursIsland_11.push_back(7);
+	neighboursIsland_11.push_back(10);
+	neighboursIsland_11.push_back(15);
+
+	neighboursIsland_12.push_back(12);
+	neighboursIsland_12.push_back(8);
+	neighboursIsland_12.push_back(13);
+
+	neighboursIsland_13.push_back(13);
+	neighboursIsland_13.push_back(9);
+	neighboursIsland_13.push_back(12);
+	neighboursIsland_13.push_back(14);
+
+	neighboursIsland_14.push_back(14);
+	neighboursIsland_14.push_back(10);
+	neighboursIsland_14.push_back(13);
+	neighboursIsland_14.push_back(15);
+
+	neighboursIsland_15.push_back(15);
+	neighboursIsland_15.push_back(11);
+	neighboursIsland_15.push_back(14);
+
+
+	neighbouringIslands.push_back(neighboursIsland_0);
+	neighbouringIslands.push_back(neighboursIsland_1);
+	neighbouringIslands.push_back(neighboursIsland_2);
+	neighbouringIslands.push_back(neighboursIsland_3);
+	neighbouringIslands.push_back(neighboursIsland_4);
+	neighbouringIslands.push_back(neighboursIsland_5);
+	neighbouringIslands.push_back(neighboursIsland_6);
+	neighbouringIslands.push_back(neighboursIsland_7);
+	neighbouringIslands.push_back(neighboursIsland_8);
+	neighbouringIslands.push_back(neighboursIsland_9);
+	neighbouringIslands.push_back(neighboursIsland_10);
+	neighbouringIslands.push_back(neighboursIsland_11);
+	neighbouringIslands.push_back(neighboursIsland_12);
+	neighbouringIslands.push_back(neighboursIsland_13);
+	neighbouringIslands.push_back(neighboursIsland_14);
+	neighbouringIslands.push_back(neighboursIsland_15);
+}
+
+
diff -Naur local_old/mineM/Makefile local/mineM/Makefile
--- local_old/mineM/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ local/mineM/Makefile	2017-07-28 15:07:48.383928000 +0200
@@ -0,0 +1,11 @@
+include ../../tools/hooks/buildconf.makefile
+TARGET = mineM
+
+$(TARGET): mineM.o
+	$(HOOKS_CXX) mineM.o $(HOOKS_LDFLAGS) -o $@
+
+%.o : %.cc
+	$(HOOKS_CXX) $< $(HOOKS_CXXFLAGS) -c -o $@
+
+clean :
+	rm -f *.o $(TARGET)
diff -Naur local_old/mineM/mineM.cc local/mineM/mineM.cc
--- local_old/mineM/mineM.cc	1970-01-01 01:00:00.000000000 +0100
+++ local/mineM/mineM.cc	2017-07-28 15:07:48.383928000 +0200
@@ -0,0 +1,1298 @@
+
+#include <iostream>
+#include <stdio.h>
+#include <stdlib.h>
+#include <algorithm>
+#include <unistd.h>
+#include <string.h>
+#include <time.h>
+#include <vector>
+#include <math.h>
+#include <float.h>
+#include <string>
+#include <fstream>
+#include <sstream>
+#include <stdexcept>
+#include <limits.h>
+
+#include "hooks_base.h"
+#include "sim_api.h"
+
+using namespace std;
+
+
+#define nullptr NULL
+
+#ifndef T_KELVIN_H_
+#define T_KELVIN_H_
+const float T_KELVIN = 273.15;
+#endif /* T_KELVIN_H_ */
+
+
+#define MAX_FREQUENCY	4000
+#define MIN_FREQUENCY	200
+#define FREQUENCY_STEP	200
+
+
+// Units in miliseconds
+//double SECONDS_TO_EXEC_TIME_UNIT = 1000.0;
+//double NANOSECONDS_TO_EXEC_TIME_UNIT = 1000000.0;
+// Units in microseconds
+const double SECONDS_TO_EXEC_TIME_UNIT = 1000000.0;
+const double NANOSECONDS_TO_EXEC_TIME_UNIT = 1000.0;
+
+#define SCHEDULING_INTERVAL		1000
+
+const float Tamb = 45 + T_KELVIN;
+const float Tdtm = 60 + T_KELVIN;
+
+
+
+long unsigned int totalNumberCores;
+int totalNumberIslands;
+long coresPerIsland;
+struct timespec start;
+
+
+
+//vector<pthread_t> threadIslandAgent;
+vector<pthread_t> threadApplicationAgent;
+//void *islandAgent(void * arg);
+void *applicationAgent(void * arg);
+
+
+
+//const int randomCoresForInitialAgentMapping[] = { 4, 52, 3, 15, 44, 60, 32, 41, 17, 48,
+//											38, 8, 23, 24, 28, 56, 14, 27, 48, 20,
+//											12, 51, 18, 1, 6, 54, 16, 45, 57, 37,
+//											49, 58 };
+const int randomCoresForInitialAgentMapping[] = { 4, 56, 32, 28, 20, 40, 12, 48, 52, 0, 60, 24, 44, 36, 8, 16};
+
+const int numberOfThreadsPerApp[] = { 9, 9, 9, 9, 9, 8 };
+//const int numberOfThreadsPerApp[] = { 8, 12, 16, 6, 8, 4 };
+//const int numberOfThreadsPerApp[] = { 10, 8, 6, 11, 13, 8 };
+//const int numberOfThreadsPerApp[] = { 7, 5, 11, 8, 10, 8 };
+//
+//const int numberOfThreadsPerApp[] = { 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 };
+//const int numberOfThreadsPerApp[] = { 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11 };
+//const int numberOfThreadsPerApp[] = { 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 };
+//const int numberOfThreadsPerApp[] = { 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 };
+//const int numberOfThreadsPerApp[] = { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 };
+//const int numberOfThreadsPerApp[] = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 };
+//const int numberOfThreadsPerApp[] = { 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };
+
+vector<int> coresReservedForApplication;
+vector<pthread_mutex_t> flagReservedCores;
+vector<unsigned int> lastMigrationInCore;
+vector<pthread_mutex_t> flagLastMigrationCores;
+
+vector<unsigned long int> previousInstructionCountCore;
+vector<unsigned long int> lastTimeinstructionCountCore;
+vector<pthread_mutex_t> flagPreviousInstructionCountCore;
+
+vector<int> offsetThreadIndexForApplication;
+vector<int> threadReservedCore;
+vector<pthread_mutex_t> flagThreadReservedCore;
+
+
+vector<int> agentsMappedToIsland;
+vector<pthread_mutex_t> flagAgentsMappedToIsland;
+
+vector< vector<int> > neighbouringIslands;
+void fillNeighbouringIslandsVector(void);
+
+#define MAX_NUMBER_NEIGHBOUR_ISLANDS	5	// Including the island in the center of the neighbours
+#define MIGRATION_THERMAL_HISTERESIS_BOUND	1
+#define MIGRATION_MINIMUM_IPC_BOUND		2
+#define MIGRATION_IPC_HISTERESIS_BOUND		1
+#define MIGRATION_TIME_THRESHOLD	20000
+
+#define INVALID_APPLICATION	-1
+#define INVALID_CORE		-1
+#define INVALID_THREAD		-1
+
+
+class Thread{
+public:
+	int threadId;
+	int mappedToCore;
+	unsigned int lastMigration;
+
+	Thread(){
+		threadId = INVALID_THREAD;
+		mappedToCore = INVALID_CORE;
+		lastMigration = 0;
+	}
+};
+
+class Application{
+public:
+	int appId;
+
+	Application(){
+		appId = INVALID_APPLICATION;
+	}
+};
+vector<Application> applications;
+
+
+
+class Core{
+public:
+	int mappedThreadId;
+	int mappedApplicationId;
+
+	Core(){
+		mappedThreadId = INVALID_THREAD;
+		mappedApplicationId = INVALID_APPLICATION;
+	}
+};
+
+//vector<Core> cores;
+//vector<pthread_mutex_t> flagCoreMapping;
+
+
+
+
+
+int main(int argc, char* argv[])
+{
+	// Get initial time
+	struct timespec end;
+	clock_gettime(CLOCK_MONOTONIC, &start);
+
+	// Initialize the number of cores per island as pass in the command line
+	if (argc > 1)
+		coresPerIsland = atoi(argv[1]);
+	else
+		coresPerIsland = 1;
+
+	// Start ROI
+	parmacs_roi_begin();
+
+
+	totalNumberCores = SimGetNumProcs();
+	totalNumberIslands = totalNumberCores / coresPerIsland;
+	cout << "There are " << totalNumberIslands << " islands in the system" << endl; fflush(NULL);
+
+
+	fillNeighbouringIslandsVector();
+
+
+
+	// Initiliaze the reserved core vectors and their mutexes
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned long int currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+	pthread_mutex_t mutexAux = PTHREAD_MUTEX_INITIALIZER;
+	for(unsigned int i = 0; i < totalNumberCores; i++){
+		//Core newCore;
+		//cores.push_back(newCore);
+		//flagCoreMapping.push_back(mutexAux);
+
+		coresReservedForApplication.push_back(INVALID_APPLICATION);
+		flagReservedCores.push_back(mutexAux);
+		lastMigrationInCore.push_back(0);
+		flagLastMigrationCores.push_back(mutexAux);
+
+
+		previousInstructionCountCore.push_back(SimGetAccumulatedInstructions(i));
+		lastTimeinstructionCountCore.push_back(currentTime);
+		flagPreviousInstructionCountCore.push_back(mutexAux);
+	}
+
+
+
+	// Initiliaze a vector containing all applications
+	vector<int> applicationAgentNumber;
+	unsigned int totalNumberThreads = SimGetNumThreads();
+	for(unsigned int thread = 0; thread < totalNumberThreads; thread++){
+		int appId = SimGetThreadAppId(thread);
+
+		int appIndex = -1;
+		for(unsigned int appIndexAux = 0; appIndexAux < applications.size(); appIndexAux++){
+			if(applications[appIndexAux].appId == appId){
+				appIndex = appIndexAux;
+				break;
+			}
+		}
+
+		if(appIndex < 0){
+			if(appId != 0){
+				Application newApplication;
+				newApplication.appId = appId;
+				applications.push_back(newApplication);
+
+				applicationAgentNumber.push_back(appId);
+				threadApplicationAgent.push_back(0);
+
+				agentsMappedToIsland.push_back(randomCoresForInitialAgentMapping[appId - 1] / coresPerIsland);
+				flagAgentsMappedToIsland.push_back(mutexAux);
+			}
+		}
+	}
+	int totalNumberApplications = applications.size();
+	cout << "Total Number of Applications: " << totalNumberApplications << endl; fflush(NULL);
+
+	// Initialize the vectors containing the coreId reserved for each application thread
+	for(int appId = 0; appId < totalNumberApplications; appId++){
+		for(int threadNumber = 0; threadNumber < numberOfThreadsPerApp[appId]; threadNumber++){
+			threadReservedCore.push_back(INVALID_CORE);
+			flagThreadReservedCore.push_back(mutexAux);
+		}
+
+		if(appId > 0){
+			offsetThreadIndexForApplication.push_back(numberOfThreadsPerApp[appId - 1] + offsetThreadIndexForApplication[appId - 1]);
+		}
+		else{
+			offsetThreadIndexForApplication.push_back(0);
+		}
+	}
+
+
+	// Initialize the thread variables, and start every application agent thread
+	for(int i = 0; i < totalNumberApplications; i++){
+		if (pthread_create(&threadApplicationAgent[i], NULL, &applicationAgent, (void *)&applicationAgentNumber[i])) {
+			cout << "Failed Thread Application Agent" << endl; fflush(NULL);
+			exit(0);
+		}
+	}
+
+
+
+	// Same thing for the islands
+	/*vector<int> islandAgentNumber;
+	for(int i = 0; i < totalNumberIslands; i++){
+		threadIslandAgent.push_back(0);
+		islandAgentNumber.push_back(i);
+	}
+	for(int i = 0; i < totalNumberIslands; i++){
+		if (pthread_create(&threadIslandAgent[i], NULL, &islandAgent, (void *)&islandAgentNumber[i])) {
+			cout << "Failed Thread Island Agent" << endl; fflush(NULL);
+			exit(0);
+		}
+	}*/
+
+	// Enable hardware Turbo Boost in all islands
+	for(int i = 0; i < totalNumberIslands; i++){
+		SimActivateIslandBoosting(i);
+	}
+
+
+
+
+
+
+
+
+
+
+
+	//usleep( 2*SCHEDULING_INTERVAL );
+	cout << "Entering infinite scheduling loop" << endl; fflush(NULL);
+	/*clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned int currentTime;
+	unsigned int lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+	while(1){
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		if(SCHEDULING_INTERVAL > (currentTime - lastTime))
+			usleep( SCHEDULING_INTERVAL - currentTime + lastTime);
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+
+		for(unsigned int appIndex = 0; appIndex < applications.size(); appIndex++){
+			cout << "Application " << applications[appIndex].appId << endl;
+			if(applications[appIndex].threads.size() > 0){
+				for(unsigned int threadInApplication = 0; threadInApplication < applications[appIndex].threads.size(); threadInApplication++){
+					cout << "   Thread " << applications[appIndex].threads[threadInApplication].threadId << endl;
+				}
+			}
+			else{
+				cout << "   Finished" << endl;
+			}
+		}
+		fflush(NULL);
+
+
+
+
+
+
+
+		// If the only application running is the scheduler finish the simulation
+		if(applications.size() <= 0){
+			// Finilize the ROI and exit the application
+			parmacs_roi_end();
+			exit(0);
+		}
+	}*/
+
+
+
+	// Now wait for the threads of the core and island agents to finish
+	for(int i = 0; i < totalNumberApplications; i++){
+		pthread_join(threadApplicationAgent[i], NULL);
+	}
+	//for(int i = 0; i < totalNumberIslands; i++){
+	//	pthread_join(threadIslandAgent[i], NULL);
+	//}
+
+	// Finilize the ROI and exit the application
+	parmacs_roi_end();
+	exit(0);
+}
+
+
+
+
+
+
+
+void *applicationAgent(void * arg)
+{
+	// Migrate the island agent to the first core of the corresponding island
+	int applicationAgentNumber = *((int *)arg);
+	int agentMappedToCore = randomCoresForInitialAgentMapping[applicationAgentNumber - 1];
+	SimSetOwnAffinity(agentMappedToCore);
+
+	int thisAgentMappedtoIsland = agentMappedToCore / coresPerIsland;
+	unsigned int totalNumberAgents = agentsMappedToIsland.size();
+
+	int offsetThreadIndexForThisApplication = offsetThreadIndexForApplication[applicationAgentNumber - 1];
+	int numberThreadsThisApplication = numberOfThreadsPerApp[applicationAgentNumber - 1];
+
+
+	//vector<float> currentIPCapplication;
+	//vector<float> currentIPSapplication;
+	vector<Thread> threads;
+	for(int threadNumber = 0; threadNumber < numberThreadsThisApplication; threadNumber++){
+		Thread newThread;
+		threads.push_back(newThread);
+
+		//currentIPSapplication.push_back(0);
+		//currentIPCapplication.push_back(0);
+	}
+
+
+
+
+	/*vector<float> averageTemperatureNeighbouringIslands;
+	vector< vector<float> > temperatureNeighbouringIslands;
+	vector< vector<int> > threadMappedToCoreNeighbouringIslands;
+	vector< vector<int> > applicationMappedToCoreNeighbouringIslands;
+	vector<int> freeCoresNeighbouringIslands;
+	{
+		vector<float> auxTemperatureNeighbouringIslands;
+		vector<int> auxIntVectorNeighbouringIslands;
+		for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+			auxTemperatureNeighbouringIslands.push_back(0);
+			auxIntVectorNeighbouringIslands.push_back(-1);
+		}
+		for(int auxNeighbourIsland = 0; auxNeighbourIsland < MAX_NUMBER_NEIGHBOUR_ISLANDS; auxNeighbourIsland++){
+			temperatureNeighbouringIslands.push_back(auxTemperatureNeighbouringIslands);
+			threadMappedToCoreNeighbouringIslands.push_back(auxIntVectorNeighbouringIslands);
+			applicationMappedToCoreNeighbouringIslands.push_back(auxIntVectorNeighbouringIslands);
+			freeCoresNeighbouringIslands.push_back(coresPerIsland);
+			averageTemperatureNeighbouringIslands.push_back(0);
+		}
+	}*/
+
+
+	// This sleep interval is just to try to get agents to be executed interleaved, and not all at the same time.
+	usleep( 20 * applicationAgentNumber);
+
+
+
+	/*stringstream fileName;
+	fileName << "/home/santiago/sniper/applicationAgent_" << applicationAgentNumber;
+	ofstream outputStream;
+	outputStream.open(fileName.str().c_str());
+	if (outputStream.is_open()){
+		if (outputStream.good()){
+			outputStream.precision(12);
+		}
+		else{
+			cout << "Error: Output file: \"" << fileName.str() << "\" could not be open for writing." << endl; fflush(NULL);
+			outputStream.close();
+		}
+	}
+	else{
+		cout << "Error: Output file: \"" << fileName.str() << "\" could not be open for writing." << endl; fflush(NULL);
+	}*/
+
+
+
+
+
+
+
+
+
+	struct timespec end;
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned int currentTime;
+	unsigned int lastTime = 0;
+	while(1){
+		//unsigned long threadId = SimGetThreadId();
+		//clock_gettime(CLOCK_MONOTONIC, &end);
+		//double printTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		//outputStream << "Time: " << printTime/1000000 << " \tApplication agent: " << applicationAgentNumber << " \tThread ID: " << threadId << endl;
+
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		if(SCHEDULING_INTERVAL > (currentTime - lastTime))
+			usleep( SCHEDULING_INTERVAL - currentTime + lastTime);
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+
+
+
+		if(SimIsApplicationFinished(applicationAgentNumber)){
+
+			for(unsigned int coreNumber = 0; coreNumber < totalNumberCores; coreNumber++){
+
+				if(coresReservedForApplication[coreNumber] == applicationAgentNumber){
+					coresReservedForApplication[coreNumber] = INVALID_APPLICATION;
+
+					pthread_mutex_lock(&flagLastMigrationCores[coreNumber]);
+					lastMigrationInCore[coreNumber] = 0;
+					pthread_mutex_unlock(&flagLastMigrationCores[coreNumber]);
+				}
+				pthread_mutex_unlock(&flagReservedCores[coreNumber]);
+			}
+
+			// Find which thread of the other application was mapped to this core to do the exchange
+			for(int threadNumber = 0; threadNumber < numberThreadsThisApplication; threadNumber++){
+				pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+				threadReservedCore[offsetThreadIndexForThisApplication + threadNumber] = INVALID_CORE;
+				pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+
+				threads[threadNumber].threadId = INVALID_THREAD;
+				threads[threadNumber].mappedToCore = INVALID_CORE;
+				threads[threadNumber].lastMigration = 0;
+			}
+			usleep(UINT_MAX);
+		}
+		else{
+
+			// Update the threads belonging to this application
+			unsigned int totalNumberThreads = SimGetNumThreads();
+			for(unsigned int sniperThread = 0; sniperThread < totalNumberThreads; sniperThread++){
+				int appId = SimGetThreadAppId(sniperThread);
+
+				if(appId == applicationAgentNumber){
+
+					// Now find the index of the thread
+					int threadIndex = -1;
+					for(int threadInApplication = 0; threadInApplication < numberThreadsThisApplication; threadInApplication++){
+						if(threads[threadInApplication].threadId == sniperThread){
+							threadIndex = threadInApplication;
+							break;
+						}
+					}
+
+					// If the index was less than zero, this thread was not in the list of threads of this applicaiton
+					if(threadIndex < 0){
+						// Verify that the thread is not finished
+						if(SimIsThreadFinished(sniperThread) == false){
+							for(int threadInApplication = 0; threadInApplication < numberThreadsThisApplication; threadInApplication++){
+								if(threads[threadInApplication].threadId == INVALID_THREAD){
+									threads[threadInApplication].threadId = sniperThread;
+									threads[threadInApplication].mappedToCore = INVALID_CORE;
+									threads[threadInApplication].lastMigration = lastTime;
+									break;
+								}
+							}
+						}
+					}
+					else{
+						// If the thread already existed, verify that it has not finished
+						if(SimIsThreadFinished(sniperThread)){
+							// If the thread is finished, we indicate that the thread is no longer mapped to that core
+							//int threadMappedToCore = threads[threadIndex].mappedToCore;
+							//pthread_mutex_lock(&flagCoreMapping[threadMappedToCore]);
+							//cores[threadMappedToCore].mappedThreadId = -1;
+							//cores[threadMappedToCore].mappedApplicationId = -1;
+							//pthread_mutex_unlock(&flagCoreMapping[threadMappedToCore]);
+
+							// We erase the thread from the list of threads of the application
+							//threads.erase(threads.begin() + threadIndex);
+
+							// If there are no more threads to run for this application, then we terminate the agent
+							// We are acutally not doing this, because applications will be re-executed
+							//if(threads.size() == 0){
+							//	return 0;
+							//}
+
+							// We mark the thread in our list as invalid, meaning that is not associated with any Sniper thread
+							threads[threadIndex].threadId = INVALID_THREAD;
+							threads[threadIndex].mappedToCore = INVALID_CORE;
+							threads[threadIndex].lastMigration = 0;
+						}
+					}
+				}
+			}
+
+
+
+
+
+			// Compute current MIPS for all threads of this application
+			/*for(int threadNumber = 0; threadNumber < numberThreadsThisApplication; threadNumber++){
+				if((threads[threadNumber].threadId >= 0) && (threads[threadNumber].mappedToCore >= 0)){
+					unsigned int currentInstructionCount = SimGetAccumulatedInstructions(threads[threadNumber].mappedToCore);
+					pthread_mutex_lock(&flagPreviousInstructionCountCore[threads[threadNumber].mappedToCore]);
+					currentIPSapplication[threadNumber] = ((float)(currentInstructionCount - previousInstructionCountCore[threads[threadNumber].mappedToCore]))/(lastTime - lastTimeinstructionCountCore[threads[threadNumber].mappedToCore]);
+					previousInstructionCountCore[threads[threadNumber].mappedToCore] = currentInstructionCount;
+					lastTimeinstructionCountCore[threads[threadNumber].mappedToCore] = lastTime;
+					pthread_mutex_unlock(&flagPreviousInstructionCountCore[threads[threadNumber].mappedToCore]);
+
+					currentIPCapplication[threadNumber] = currentIPSapplication[threadNumber] / (SimGetFreqMHz(threads[threadNumber].mappedToCore) * 1e6);
+				}
+				else{
+					currentIPSapplication[threadNumber] = 0;
+					currentIPCapplication[threadNumber] = 0;
+				}
+			}*/
+
+
+
+
+
+
+
+
+
+			// Count the number of threads of this application that are have not yet cores reserved. The first goal is to reserve cores for all threads
+			// and then map them to free cores.
+			// Only after all threads of the application are reserved to map to cores try to migrate to improve overall performance
+			int numberReservedCoresForApplication = 0;
+			for(int threadNumber = 0; threadNumber < numberThreadsThisApplication; threadNumber++){
+				// mappedToCore < 0 means that the thread is unmapped in what respect to our scheduler
+				pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+				if(threadReservedCore[offsetThreadIndexForThisApplication + threadNumber] >= 0){
+					numberReservedCoresForApplication++;
+				}
+				pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+			}
+			if((numberThreadsThisApplication - numberReservedCoresForApplication) > 0){
+				// Reserve all cores for this application in one run. Without this while, we only reserve up to the amount of cores in one island per iteration
+				while((numberThreadsThisApplication - numberReservedCoresForApplication) > 0){
+					// Search for the island with more free cores. If more than one island has the same number of free cores, then choose the coolest island
+					int islandWithMoreFreeCores = -1;
+					int highestNumberFreeCores = 0;
+					float averageTemperatureIslandWithMoreFreeCores;
+					for(unsigned int neighbourIslandIndex = 0; neighbourIslandIndex < neighbouringIslands[thisAgentMappedtoIsland].size(); neighbourIslandIndex++){
+						// First count the number of free cores in each island
+						int freeCoresThisIsland = 0;
+						for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+							int absoluteCoreNumber = auxCoreNumber + neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex]*coresPerIsland;
+
+							pthread_mutex_lock(&flagReservedCores[absoluteCoreNumber]);
+							if(coresReservedForApplication[absoluteCoreNumber] < 0)
+								freeCoresThisIsland++;
+							pthread_mutex_unlock(&flagReservedCores[absoluteCoreNumber]);
+						}
+
+						// If the island has at least one free core
+						if(freeCoresThisIsland > 0){
+							// Compare it with the highest number of free cores of neighbouring islands so far
+							if(highestNumberFreeCores < freeCoresThisIsland){
+								// Compute the average temperature of the island
+								averageTemperatureIslandWithMoreFreeCores = 0;
+								for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+									int absoluteCoreNumber = auxCoreNumber + neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex]*coresPerIsland;
+									averageTemperatureIslandWithMoreFreeCores += ((float)SimGetTemperature(absoluteCoreNumber))/1000000;
+								}
+								averageTemperatureIslandWithMoreFreeCores /= coresPerIsland;
+
+								// Replace the new highest number of free cores
+								highestNumberFreeCores = freeCoresThisIsland;
+								islandWithMoreFreeCores = neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex];
+							}
+							// In case there is more than one island with the same number of free cores, keep the coolest island that has no other agent mapped
+							else if(highestNumberFreeCores == freeCoresThisIsland){
+
+								// Check if the new island considered has agents mapped to it
+								bool agentMappedToIslandThisIsland = false;
+								for(unsigned int auxAgentIndex = 0; auxAgentIndex < totalNumberAgents; auxAgentIndex++){
+									if((applicationAgentNumber - 1) != auxAgentIndex){
+										pthread_mutex_lock(&flagAgentsMappedToIsland[auxAgentIndex]);
+										if(agentsMappedToIsland[auxAgentIndex] == neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex]){
+											agentMappedToIslandThisIsland = true;
+											pthread_mutex_unlock(&flagAgentsMappedToIsland[auxAgentIndex]);
+											break;
+										}
+										pthread_mutex_unlock(&flagAgentsMappedToIsland[auxAgentIndex]);
+									}
+								}
+
+								if(agentMappedToIslandThisIsland == false){
+									// Compute the average temperature of the island
+									float averageTemperatureThisIsland = 0;
+									for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+										int absoluteCoreNumber = auxCoreNumber + neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex]*coresPerIsland;
+										averageTemperatureThisIsland += ((float)SimGetTemperature(absoluteCoreNumber))/1000000;
+									}
+									averageTemperatureThisIsland /= coresPerIsland;
+
+									if(averageTemperatureIslandWithMoreFreeCores > averageTemperatureThisIsland){
+										averageTemperatureIslandWithMoreFreeCores = averageTemperatureThisIsland;
+										islandWithMoreFreeCores = neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex];
+									}
+								}
+							}
+						}
+					}
+
+
+
+					// If no island has free cores, the agent needs to look in neighbouring islands of the current neighbours
+					if(highestNumberFreeCores <= 0){
+						// FIXME: In this implementation, since we have a small number of islands and we want to keep it simple, we do it globally
+						// Search for the island with more free cores. If more than one island has the same number of free cores, then choose the coolest island
+						for(int globalIslandIndex = 0; globalIslandIndex < totalNumberIslands; globalIslandIndex++){
+							// First count the number of free cores in each island
+							int freeCoresThisIsland = 0;
+							for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+								int absoluteCoreNumber = auxCoreNumber + globalIslandIndex*coresPerIsland;
+
+								pthread_mutex_lock(&flagReservedCores[absoluteCoreNumber]);
+								if(coresReservedForApplication[absoluteCoreNumber] < 0)
+									freeCoresThisIsland++;
+								pthread_mutex_unlock(&flagReservedCores[absoluteCoreNumber]);
+							}
+
+							// If the island has at least one free core
+							if(freeCoresThisIsland > 0){
+								// Compare it with the highest number of free cores of neighbouring islands so far
+								if(highestNumberFreeCores < freeCoresThisIsland){
+									// Compute the average temperature of the island
+									averageTemperatureIslandWithMoreFreeCores = 0;
+									for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+										int absoluteCoreNumber = auxCoreNumber + globalIslandIndex*coresPerIsland;
+										averageTemperatureIslandWithMoreFreeCores += ((float)SimGetTemperature(absoluteCoreNumber))/1000000;
+									}
+									averageTemperatureIslandWithMoreFreeCores /= coresPerIsland;
+
+									// Replace the new highest number of free cores
+									highestNumberFreeCores = freeCoresThisIsland;
+									islandWithMoreFreeCores = globalIslandIndex;
+								}
+								// In case there is more than one island with the same number of free cores, keep the coolest island
+								else if(highestNumberFreeCores == freeCoresThisIsland){
+									// Compute the average temperature of the island
+									float averageTemperatureThisIsland = 0;
+									for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+										int absoluteCoreNumber = auxCoreNumber + globalIslandIndex*coresPerIsland;
+										averageTemperatureThisIsland += ((float)SimGetTemperature(absoluteCoreNumber))/1000000;
+									}
+									averageTemperatureThisIsland /= coresPerIsland;
+
+									if(averageTemperatureIslandWithMoreFreeCores > averageTemperatureThisIsland){
+										averageTemperatureIslandWithMoreFreeCores = averageTemperatureThisIsland;
+										islandWithMoreFreeCores = globalIslandIndex;
+									}
+								}
+							}
+						}
+					}
+
+
+					// At this point we should have found at least one island with some free cores
+					if((highestNumberFreeCores > 0) && (islandWithMoreFreeCores >= 0)){
+
+						// We start going through the threads that do not have cores reserved
+						for(int threadNumber = 0; threadNumber < numberThreadsThisApplication; threadNumber++){
+							// mappedToCore < 0 means that the thread is unmapped in what respect to our scheduler
+							pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+							int auxThreadReservedCore = threadReservedCore[offsetThreadIndexForThisApplication + threadNumber];
+							pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+							if(auxThreadReservedCore < 0){
+
+								// Search which cores inside the island are the ones that are free
+								for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+									int absoluteCoreNumber = auxCoreNumber + islandWithMoreFreeCores*coresPerIsland;
+
+									// Once we found an unreserved core inside the island we reserve it to later map a thread to it
+									pthread_mutex_lock(&flagReservedCores[absoluteCoreNumber]);
+									if(coresReservedForApplication[absoluteCoreNumber] < 0){
+										coresReservedForApplication[absoluteCoreNumber] = applicationAgentNumber;
+										pthread_mutex_unlock(&flagReservedCores[absoluteCoreNumber]);
+										SimReserveCoreForApplication(absoluteCoreNumber, applicationAgentNumber);
+
+										pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+										threadReservedCore[offsetThreadIndexForThisApplication + threadNumber] = absoluteCoreNumber;
+										pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+
+										// In case this is the first thread of this application that we are mapping, also move the agent to this core
+										if((numberReservedCoresForApplication <= 0) && (agentMappedToCore != absoluteCoreNumber)){
+											agentMappedToCore = absoluteCoreNumber;
+											SimSetOwnAffinity(agentMappedToCore);
+											thisAgentMappedtoIsland = agentMappedToCore / coresPerIsland;
+
+											pthread_mutex_lock(&flagAgentsMappedToIsland[applicationAgentNumber - 1]);
+											agentsMappedToIsland[applicationAgentNumber - 1] = thisAgentMappedtoIsland;
+											pthread_mutex_unlock(&flagAgentsMappedToIsland[applicationAgentNumber - 1]);
+										}
+
+										numberReservedCoresForApplication++;
+										break;
+									}
+									pthread_mutex_unlock(&flagReservedCores[absoluteCoreNumber]);
+								}
+							}
+						}
+					}
+					else{
+						cout << "ERROR: No free cores available in the entire system" << endl; fflush(NULL);
+					}
+				}
+			}
+			// If all cores are already reserved, then here we apply task migrations
+			else{
+
+				// Find the maximum average temperatures of all the cores of the application
+				float maxTemperatureApplication = 0;
+				int applicationThreadWithMaxTemperature = INVALID_THREAD;
+				int coreMaximumTemperature = INVALID_CORE;
+				for(unsigned int threadInApplication = 0; threadInApplication < numberThreadsThisApplication; threadInApplication++){
+
+					if((threads[threadInApplication].threadId >= 0) && (threads[threadInApplication].mappedToCore >= 0)){
+						// Only consider cores which have not been migrated recently
+						if((lastTime - threads[threadInApplication].lastMigration) >= MIGRATION_TIME_THRESHOLD){
+							pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadInApplication]);
+							int auxThreadReservedCore = threadReservedCore[offsetThreadIndexForThisApplication + threadInApplication];
+							pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadInApplication]);
+							if(auxThreadReservedCore >= 0){
+								float temperatureThread = ((float)SimGetAverageTemperatureLastWindow(auxThreadReservedCore))/1000000;
+								if(maxTemperatureApplication < temperatureThread){
+									maxTemperatureApplication = temperatureThread;
+									applicationThreadWithMaxTemperature = threadInApplication;
+									coreMaximumTemperature = auxThreadReservedCore;
+								}
+							}
+						}
+					}
+				}
+
+
+				// Find the coolest core among all neighbouring islands
+				int coreMinimumTemperature = INVALID_CORE;
+				float minTemperatureNeighbouringIslands = FLT_MAX;
+				for(unsigned int neighbourIslandIndex = 0; neighbourIslandIndex < neighbouringIslands[thisAgentMappedtoIsland].size(); neighbourIslandIndex++){
+					for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+						int absoluteCoreNumber = auxCoreNumber + neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex]*coresPerIsland;
+
+						pthread_mutex_lock(&flagLastMigrationCores[absoluteCoreNumber]);
+						unsigned int auxLastMigration = lastMigrationInCore[absoluteCoreNumber];
+						pthread_mutex_unlock(&flagLastMigrationCores[absoluteCoreNumber]);
+
+						// Only consider cores which have not been migrated recently
+						if((lastTime - auxLastMigration) >= MIGRATION_TIME_THRESHOLD){
+							float temperatureCore = ((float)SimGetAverageTemperatureLastWindow(absoluteCoreNumber))/1000000;
+							if(minTemperatureNeighbouringIslands > temperatureCore){
+								minTemperatureNeighbouringIslands = temperatureCore;
+								coreMinimumTemperature = absoluteCoreNumber;
+							}
+						}
+					}
+				}
+
+
+
+				// If there was a thermal violation on some core of the application, migrate the thread to the coolest core in the neighbouring islands
+				// If there was already a thread map to that core, simply exchange them
+				// Note that this happens only if the temperature difference is larger than a histeresis bound, and if the other core also does not have
+				// a thermal violation
+				if((maxTemperatureApplication > Tdtm) && (applicationThreadWithMaxTemperature >= 0) && (coreMinimumTemperature >= 0) && (coreMaximumTemperature >= 0)){
+
+					if( ((minTemperatureNeighbouringIslands < Tdtm) && ((maxTemperatureApplication - minTemperatureNeighbouringIslands) >= MIGRATION_THERMAL_HISTERESIS_BOUND)) ||
+						((maxTemperatureApplication - minTemperatureNeighbouringIslands) >= 3*MIGRATION_THERMAL_HISTERESIS_BOUND) ){
+
+						pthread_mutex_lock(&flagReservedCores[coreMinimumTemperature]);
+						// If the core was not reserved for any application
+						if(coresReservedForApplication[coreMinimumTemperature] < 0){
+							coresReservedForApplication[coreMinimumTemperature] = applicationAgentNumber;
+							pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+
+							pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature]);
+							int previousCoreReservedForThread = threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature];
+							threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature] = coreMinimumTemperature;
+							pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature]);
+
+							pthread_mutex_lock(&flagLastMigrationCores[previousCoreReservedForThread]);
+							lastMigrationInCore[previousCoreReservedForThread] = 0;
+							pthread_mutex_unlock(&flagLastMigrationCores[previousCoreReservedForThread]);
+
+							SimReserveCoreForApplication(coreMinimumTemperature, applicationAgentNumber);
+							SimReserveCoreForApplication(coreMaximumTemperature, INVALID_APPLICATION);
+						}
+						// If the core was reserved for this same application
+						else if(coresReservedForApplication[coreMinimumTemperature] == applicationAgentNumber){
+							pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+
+							// Find which thread of the other application was mapped to this core to do the exchange
+							for(int auxThreadIndex = 0; auxThreadIndex < numberThreadsThisApplication; auxThreadIndex++){
+								pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex]);
+								if(threadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex] == coreMinimumTemperature){
+									threadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex] = coreMaximumTemperature;
+									pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex]);
+									break;
+								}
+								pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex]);
+							}
+
+							pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature]);
+							threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature] = coreMinimumTemperature;
+							pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature]);
+						}
+						// If the core was reserved for some other application
+						else{
+							int previousMappedApplication = coresReservedForApplication[coreMinimumTemperature];
+							coresReservedForApplication[coreMinimumTemperature] = applicationAgentNumber;
+							pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+
+							pthread_mutex_lock(&flagReservedCores[coreMaximumTemperature]);
+							coresReservedForApplication[coreMaximumTemperature] = previousMappedApplication;
+							pthread_mutex_unlock(&flagReservedCores[coreMaximumTemperature]);
+
+							// Find which thread of the other application was mapped to this core to do the exchange
+							int offsetThreadIndexForOtherApplication = offsetThreadIndexForApplication[previousMappedApplication - 1];
+							for(int auxThreadIndexOtherApp = 0; auxThreadIndexOtherApp < numberOfThreadsPerApp[previousMappedApplication - 1]; auxThreadIndexOtherApp++){
+								pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp]);
+								if(threadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp] == coreMinimumTemperature){
+									threadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp] = coreMaximumTemperature;
+									pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp]);
+									break;
+								}
+								pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp]);
+							}
+
+							pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature]);
+							threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature] = coreMinimumTemperature;
+							pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature]);
+
+							SimReserveCoreForApplication(coreMinimumTemperature, applicationAgentNumber);
+							SimReserveCoreForApplication(coreMaximumTemperature, previousMappedApplication);
+						}
+					}
+				}
+				// If there was no thermal violation, try to map threads with high IPC to cool cores. This is to try to avoid a future thermal violation.
+				// We could also be looking at power, but is most likely that there will be a performance counter in eery core, but not a power meter
+				else{
+
+					// First find the application core with the maximum average IPC
+					float maxIPCApplication = 0;
+					int applicationThreadWithMaxIPC = INVALID_THREAD;
+					int coreMaximumIPC = INVALID_CORE;
+					for(unsigned int threadInApplication = 0; threadInApplication < numberThreadsThisApplication; threadInApplication++){
+						if((threads[threadInApplication].threadId >= 0) && (threads[threadInApplication].mappedToCore >= 0)){
+							if((lastTime - threads[threadInApplication].lastMigration) >= MIGRATION_TIME_THRESHOLD){
+								float currentIPCcore = ((float)SimGetAverageIpcLastWindow(threads[threadInApplication].mappedToCore))/1000000;
+								if(maxIPCApplication < currentIPCcore){
+									maxIPCApplication = currentIPCcore;
+									applicationThreadWithMaxIPC = threadInApplication;
+									coreMaximumIPC = threads[threadInApplication].mappedToCore;
+								}
+							}
+						}
+					}
+
+
+
+					// Only trigger a migration if the IPC is larger than the minimum bound for migration, and if the temperature difference between the
+					// highest IPC core and the coolest core is larger than the threshold
+					if((coreMaximumIPC >= 0) && (coreMinimumTemperature >= 0) && (coreMaximumIPC != coreMinimumTemperature)){
+						float temperatureCoreMaxIPC = ((float)SimGetAverageTemperatureLastWindow(coreMaximumIPC))/1000000;
+						if((maxIPCApplication > MIGRATION_MINIMUM_IPC_BOUND) && ((temperatureCoreMaxIPC - minTemperatureNeighbouringIslands) >= MIGRATION_THERMAL_HISTERESIS_BOUND)){
+
+							pthread_mutex_lock(&flagReservedCores[coreMinimumTemperature]);
+							// If the core was not reserved for any application, simply migrate it
+							if(coresReservedForApplication[coreMinimumTemperature] < 0){
+								coresReservedForApplication[coreMinimumTemperature] = applicationAgentNumber;
+								pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+
+								pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC]);
+								int previousCoreReservedForThread = threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC];
+								threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC] = coreMinimumTemperature;
+								pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC]);
+
+								pthread_mutex_lock(&flagLastMigrationCores[previousCoreReservedForThread]);
+								lastMigrationInCore[previousCoreReservedForThread] = 0;
+								pthread_mutex_unlock(&flagLastMigrationCores[previousCoreReservedForThread]);
+
+								SimReserveCoreForApplication(coreMinimumTemperature, applicationAgentNumber);
+								SimReserveCoreForApplication(coreMaximumIPC, INVALID_APPLICATION);
+							}
+							// If the core was reserved for this same application, we only do the exchange if the IPC different between the highest IPC and
+							// the IPC of the coolest core is bigger than the minimum migration difference
+							else if(coresReservedForApplication[coreMinimumTemperature] == applicationAgentNumber){
+								pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+
+								// Find which thread of the other application was mapped to this core to do the exchange
+								int threadIndexWithMinimumTemperature = -1;
+								for(int auxThreadIndex = 0; auxThreadIndex < numberThreadsThisApplication; auxThreadIndex++){
+									pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex]);
+									if(threadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex] == coreMinimumTemperature){
+										float currentIPCcoreMinimumTemperature = ((float)SimGetAverageIpcLastWindow(coreMinimumTemperature))/1000000;
+										if((maxIPCApplication - currentIPCcoreMinimumTemperature) > MIGRATION_IPC_HISTERESIS_BOUND){
+											threadIndexWithMinimumTemperature = auxThreadIndex;
+											threadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex] = coreMaximumIPC;
+										}
+										pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex]);
+										break;
+									}
+									pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex]);
+								}
+
+								// We do the migration if we found the core with minimum temperature and the IPC difference was larger than the minimum difference
+								if(threadIndexWithMinimumTemperature >= 0){
+									pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC]);
+									threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC] = coreMinimumTemperature;
+									pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC]);
+								}
+							}
+							// If the core was reserved for some other application, we only do the exchange if the IPC different between the highest IPC and
+							// the IPC of the coolest core is bigger than the minimum migration difference
+							else{
+								// Compute current MIPS of the core with the minimum temperature
+								float currentIPCcoreMinimumTemperature = ((float)SimGetAverageIpcLastWindow(coreMinimumTemperature))/1000000;
+								if((maxIPCApplication - currentIPCcoreMinimumTemperature) > MIGRATION_IPC_HISTERESIS_BOUND){
+
+									int previousMappedApplication = coresReservedForApplication[coreMinimumTemperature];
+									coresReservedForApplication[coreMinimumTemperature] = applicationAgentNumber;
+									pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+
+									pthread_mutex_lock(&flagReservedCores[coreMaximumIPC]);
+									coresReservedForApplication[coreMaximumIPC] = previousMappedApplication;
+									pthread_mutex_unlock(&flagReservedCores[coreMaximumIPC]);
+
+									// Find which thread of the other application was mapped to this core to do the exchange
+									int offsetThreadIndexForOtherApplication = offsetThreadIndexForApplication[previousMappedApplication - 1];
+									for(int auxThreadIndexOtherApp = 0; auxThreadIndexOtherApp < numberOfThreadsPerApp[previousMappedApplication - 1]; auxThreadIndexOtherApp++){
+										pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp]);
+										if(threadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp] == coreMinimumTemperature){
+											threadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp] = coreMaximumIPC;
+											pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp]);
+											break;
+										}
+										pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp]);
+									}
+
+									pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC]);
+									threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC] = coreMinimumTemperature;
+									pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC]);
+
+									SimReserveCoreForApplication(coreMinimumTemperature, applicationAgentNumber);
+									SimReserveCoreForApplication(coreMaximumIPC, previousMappedApplication);
+								}
+								else{
+									pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+								}
+							}
+						}
+					}
+
+
+				}
+			}
+
+
+
+
+			// Check if there is any new thread of this application to be mapped.
+			// Threads will already have being mapped by Sniper's scheduler, but we now migrate them to the core we want.
+			// Threads are mapped according to the cores reserved by the application
+			// FIXME: This could be improved, given that when a new thread is created, it will have already been created in one of the reserved cores for
+			// this application. This involves some slight unnecessary overheads for this one-time migration of new threads
+			for(int threadInApplication = 0; threadInApplication < numberThreadsThisApplication; threadInApplication++){
+				// mappedToCore < 0 means that the thread is unmapped in what respect to our scheduler
+				//if((offsetThreadIndexForThisApplication + threadInApplication) < threadReservedCore.size()){
+				if(threads[threadInApplication].threadId >= 0){
+					pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadInApplication]);
+					int auxThreadReservedCore = threadReservedCore[offsetThreadIndexForThisApplication + threadInApplication];
+					pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadInApplication]);
+					if(threads[threadInApplication].mappedToCore != auxThreadReservedCore){
+
+						//cout << "Application agent " << applicationAgentNumber << " mapping thread " << threads[threadInApplication].threadId << " to core " << auxThreadReservedCore << " in island " << auxThreadReservedCore / coresPerIsland  << endl; fflush(NULL);
+						// After finding a core, migrate the thread to that core
+						threads[threadInApplication].mappedToCore = auxThreadReservedCore;
+						threads[threadInApplication].lastMigration = lastTime;
+						//pthread_mutex_lock(&flagCoreMapping[coreIndexToMapApplication]);
+						//cores[coreIndexToMapApplication].mappedThreadId = threads[threadInApplication].threadId;
+						//cores[coreIndexToMapApplication].mappedApplicationId = applicationAgentNumber;
+						//pthread_mutex_unlock(&flagCoreMapping[coreIndexToMapApplication]);
+
+						pthread_mutex_lock(&flagLastMigrationCores[auxThreadReservedCore]);
+						lastMigrationInCore[auxThreadReservedCore] = lastTime;
+						pthread_mutex_unlock(&flagLastMigrationCores[auxThreadReservedCore]);
+
+						SimSetThreadAffinity(threads[threadInApplication].threadId, auxThreadReservedCore);
+					}
+				}
+			}
+		}
+
+
+
+	}
+
+	return 0;
+}
+
+
+
+
+/*
+void *islandAgent(void * arg)
+{
+	// Migrate the island agent to the first core of the corresponding island
+	int islandAgentNumber = *((int *)arg);
+	SimSetOwnAffinity(islandAgentNumber * coresPerIsland);
+
+
+
+	struct timespec end;
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned int currentTime;
+	unsigned int lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+	while(1){
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		if(SCHEDULING_INTERVAL > (currentTime - lastTime))
+			usleep( SCHEDULING_INTERVAL - currentTime + lastTime);
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+
+
+
+
+		// Find the maximum temperature in the island
+		bool thermalViolation = false;
+		for(int core = 0; core < coresPerIsland; core++){
+			if((((float)SimGetTemperature(core + islandAgentNumber * coresPerIsland))/1000000) > Tdtm){
+				thermalViolation = true;
+				break;
+			}
+		}
+
+		// Read the frequency of the island
+		unsigned int currentIslandFrequency = SimGetFreqMHz(islandAgentNumber * coresPerIsland);
+		if(thermalViolation == true){
+			// If there was a thermal violation, reduce the frequency of the island
+			if(currentIslandFrequency > MIN_FREQUENCY){
+				SimSetFreqMHz(islandAgentNumber * coresPerIsland, currentIslandFrequency - FREQUENCY_STEP);
+			}
+		}
+		else{
+			// If there was no thermal violation, increase the frequency of the island
+			if(currentIslandFrequency < MAX_FREQUENCY){
+				SimSetFreqMHz(islandAgentNumber * coresPerIsland, currentIslandFrequency + FREQUENCY_STEP);
+			}
+		}
+	}
+
+	return 0;
+}*/
+
+
+
+
+
+
+
+
+
+
+/*
+void *coreAgent(void * arg)
+{
+	// Migrate the core agent to the corresponding core
+	int coreAgentNumber = *((int *)arg);
+	if(SimInSimulator())
+		SimSetOwnAffinity(coreAgentNumber);
+
+
+	stringstream fileName;
+	fileName << "/home/santiago/sniper/coreAgent_" << coreAgentNumber;
+	ofstream outputStream;
+	outputStream.open(fileName.str().c_str());
+	if (outputStream.is_open()){
+		if (outputStream.good()){
+			outputStream.precision(12);
+		}
+		else{
+			cout << "Error: Output file: \"" << fileName.str() << "\" could not be open for writing." << endl; fflush(NULL);
+			outputStream.close();
+		}
+	}
+	else{
+		cout << "Error: Output file: \"" << fileName.str() << "\" could not be open for writing." << endl; fflush(NULL);
+	}
+
+
+
+	unsigned long int currentInstructionCount;
+	double currentIPS;
+
+	struct timespec end;
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned long int currentTime;
+	unsigned long int lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+	unsigned long int previousInstructionCount = SimGetAccumulatedInstructions(coreAgentNumber);
+	unsigned long int lastTimeInstructionCout = lastTime;
+	while(1){
+		//unsigned long threadId = SimGetThreadId();
+		//clock_gettime(CLOCK_MONOTONIC, &end);
+		//double printTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		//outputStream << "Time: " << printTime/1000000 << " \tCore agent: " << coreAgentNumber << " \tThread ID: " << threadId << endl;
+
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		if(SCHEDULING_INTERVAL > (currentTime - lastTime))
+			usleep( SCHEDULING_INTERVAL - currentTime + lastTime);
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+
+		// Compute current MIPS
+		currentInstructionCount = SimGetAccumulatedInstructions(coreAgentNumber);
+		currentIPS = ((double)(currentInstructionCount - previousInstructionCount))/(lastTime - lastTimeInstructionCout);
+		outputStream << "Time: " << lastTime/1000000.0 << " \tCore agent: " << coreAgentNumber << " \tcurrentIPS: " << currentIPS << " \tcurrentInstructionCount: " << currentInstructionCount << " \tpreviousInstructionCount:" << previousInstructionCount << " \tlastTime:" << lastTime << " \tlastTimeInstructionCout:" << lastTimeInstructionCout << endl;
+		previousInstructionCount = currentInstructionCount;
+		lastTimeInstructionCout = lastTime;
+
+
+		// Get own temperature and temperature
+		double temperature = ((double)SimGetTemperature(coreAgentNumber))/1000000.0;
+		double power = ((double)SimGetPower(coreAgentNumber))/1000000.0;
+
+
+
+	}
+
+
+	return 0;
+}
+*/
+
+
+
+
+void fillNeighbouringIslandsVector(void)
+{
+	vector<int> neighboursIsland_0, neighboursIsland_1, neighboursIsland_2, neighboursIsland_3, neighboursIsland_4, neighboursIsland_5, neighboursIsland_6, \
+				neighboursIsland_7, neighboursIsland_8, neighboursIsland_9, neighboursIsland_10, neighboursIsland_11, neighboursIsland_12, \
+				neighboursIsland_13, neighboursIsland_14, neighboursIsland_15;
+
+	// 0  1  2  3
+	// 4  5  6  7
+	// 8  9  10 11
+	// 12 13 14 15
+
+	// Include itself, that is, the island in the center of the neighbours
+	neighboursIsland_0.push_back(0);
+	neighboursIsland_0.push_back(1);
+	neighboursIsland_0.push_back(4);
+
+	neighboursIsland_1.push_back(1);
+	neighboursIsland_1.push_back(0);
+	neighboursIsland_1.push_back(2);
+	neighboursIsland_1.push_back(5);
+
+	neighboursIsland_2.push_back(2);
+	neighboursIsland_2.push_back(1);
+	neighboursIsland_2.push_back(3);
+	neighboursIsland_2.push_back(6);
+
+	neighboursIsland_3.push_back(3);
+	neighboursIsland_3.push_back(2);
+	neighboursIsland_3.push_back(7);
+
+	neighboursIsland_4.push_back(4);
+	neighboursIsland_4.push_back(0);
+	neighboursIsland_4.push_back(5);
+	neighboursIsland_4.push_back(8);
+
+	neighboursIsland_5.push_back(5);
+	neighboursIsland_5.push_back(1);
+	neighboursIsland_5.push_back(4);
+	neighboursIsland_5.push_back(6);
+	neighboursIsland_5.push_back(9);
+
+	neighboursIsland_6.push_back(6);
+	neighboursIsland_6.push_back(2);
+	neighboursIsland_6.push_back(5);
+	neighboursIsland_6.push_back(7);
+	neighboursIsland_6.push_back(10);
+
+	neighboursIsland_7.push_back(7);
+	neighboursIsland_7.push_back(3);
+	neighboursIsland_7.push_back(6);
+	neighboursIsland_7.push_back(11);
+
+	neighboursIsland_8.push_back(8);
+	neighboursIsland_8.push_back(4);
+	neighboursIsland_8.push_back(9);
+	neighboursIsland_8.push_back(12);
+
+	neighboursIsland_9.push_back(9);
+	neighboursIsland_9.push_back(5);
+	neighboursIsland_9.push_back(8);
+	neighboursIsland_9.push_back(10);
+	neighboursIsland_9.push_back(13);
+
+	neighboursIsland_10.push_back(10);
+	neighboursIsland_10.push_back(6);
+	neighboursIsland_10.push_back(9);
+	neighboursIsland_10.push_back(11);
+	neighboursIsland_10.push_back(14);
+
+	neighboursIsland_11.push_back(11);
+	neighboursIsland_11.push_back(7);
+	neighboursIsland_11.push_back(10);
+	neighboursIsland_11.push_back(15);
+
+	neighboursIsland_12.push_back(12);
+	neighboursIsland_12.push_back(8);
+	neighboursIsland_12.push_back(13);
+
+	neighboursIsland_13.push_back(13);
+	neighboursIsland_13.push_back(9);
+	neighboursIsland_13.push_back(12);
+	neighboursIsland_13.push_back(14);
+
+	neighboursIsland_14.push_back(14);
+	neighboursIsland_14.push_back(10);
+	neighboursIsland_14.push_back(13);
+	neighboursIsland_14.push_back(15);
+
+	neighboursIsland_15.push_back(15);
+	neighboursIsland_15.push_back(11);
+	neighboursIsland_15.push_back(14);
+
+
+	neighbouringIslands.push_back(neighboursIsland_0);
+	neighbouringIslands.push_back(neighboursIsland_1);
+	neighbouringIslands.push_back(neighboursIsland_2);
+	neighbouringIslands.push_back(neighboursIsland_3);
+	neighbouringIslands.push_back(neighboursIsland_4);
+	neighbouringIslands.push_back(neighboursIsland_5);
+	neighbouringIslands.push_back(neighboursIsland_6);
+	neighbouringIslands.push_back(neighboursIsland_7);
+	neighbouringIslands.push_back(neighboursIsland_8);
+	neighbouringIslands.push_back(neighboursIsland_9);
+	neighbouringIslands.push_back(neighboursIsland_10);
+	neighbouringIslands.push_back(neighboursIsland_11);
+	neighbouringIslands.push_back(neighboursIsland_12);
+	neighbouringIslands.push_back(neighboursIsland_13);
+	neighbouringIslands.push_back(neighboursIsland_14);
+	neighbouringIslands.push_back(neighboursIsland_15);
+}
+
+
diff -Naur local_old/mineM/mineM_timeThreshold.cc local/mineM/mineM_timeThreshold.cc
--- local_old/mineM/mineM_timeThreshold.cc	1970-01-01 01:00:00.000000000 +0100
+++ local/mineM/mineM_timeThreshold.cc	2017-07-28 15:07:48.383928000 +0200
@@ -0,0 +1,1291 @@
+
+#include <iostream>
+#include <stdio.h>
+#include <stdlib.h>
+#include <algorithm>
+#include <unistd.h>
+#include <string.h>
+#include <time.h>
+#include <vector>
+#include <math.h>
+#include <float.h>
+#include <string>
+#include <fstream>
+#include <sstream>
+#include <stdexcept>
+#include <limits.h>
+
+#include "hooks_base.h"
+#include "sim_api.h"
+
+using namespace std;
+
+
+#define nullptr NULL
+
+#ifndef T_KELVIN_H_
+#define T_KELVIN_H_
+const float T_KELVIN = 273.15;
+#endif /* T_KELVIN_H_ */
+
+
+#define MAX_FREQUENCY	4000
+#define MIN_FREQUENCY	200
+#define FREQUENCY_STEP	200
+
+
+// Units in miliseconds
+//double SECONDS_TO_EXEC_TIME_UNIT = 1000.0;
+//double NANOSECONDS_TO_EXEC_TIME_UNIT = 1000000.0;
+// Units in microseconds
+const double SECONDS_TO_EXEC_TIME_UNIT = 1000000.0;
+const double NANOSECONDS_TO_EXEC_TIME_UNIT = 1000.0;
+
+#define SCHEDULING_INTERVAL		1000
+
+const float Tamb = 45 + T_KELVIN;
+const float Tdtm = 60 + T_KELVIN;
+
+
+
+long unsigned int totalNumberCores;
+int totalNumberIslands;
+long coresPerIsland;
+struct timespec start;
+
+
+
+//vector<pthread_t> threadIslandAgent;
+vector<pthread_t> threadApplicationAgent;
+//void *islandAgent(void * arg);
+void *applicationAgent(void * arg);
+
+
+
+const int randomCoresForInitialAgentMapping[] = { 4, 52, 3, 15, 44, 60, 32, 41, 17, 48,
+											38, 8, 23, 24, 28, 56, 14, 27, 48, 20,
+											12, 51, 18, 1, 6, 54, 16, 45, 57, 37,
+											49, 58 };
+
+//const int numberOfThreadsPerApp[] = { 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 };
+//const int numberOfThreadsPerApp[] = { 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 };
+//const int numberOfThreadsPerApp[] = { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 };
+//const int numberOfThreadsPerApp[] = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 };
+const int numberOfThreadsPerApp[] = { 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };
+
+vector<int> coresReservedForApplication;
+vector<pthread_mutex_t> flagReservedCores;
+vector<unsigned int> lastMigrationInCore;
+vector<pthread_mutex_t> flagLastMigrationCores;
+
+vector<unsigned long int> previousInstructionCountCore;
+vector<unsigned long int> lastTimeinstructionCountCore;
+vector<pthread_mutex_t> flagPreviousInstructionCountCore;
+
+vector<int> offsetThreadIndexForApplication;
+vector<int> threadReservedCore;
+vector<pthread_mutex_t> flagThreadReservedCore;
+
+
+vector<int> agentsMappedToIsland;
+vector<pthread_mutex_t> flagAgentsMappedToIsland;
+
+vector< vector<int> > neighbouringIslands;
+void fillNeighbouringIslandsVector(void);
+
+#define MAX_NUMBER_NEIGHBOUR_ISLANDS	5	// Including the island in the center of the neighbours
+#define MIGRATION_THERMAL_HISTERESIS_BOUND	1
+#define MIGRATION_MINIMUM_IPC_BOUND		2
+#define MIGRATION_IPC_HISTERESIS_BOUND		1
+#define MIGRATION_TIME_THRESHOLD	20000
+
+#define INVALID_APPLICATION	-1
+#define INVALID_CORE		-1
+#define INVALID_THREAD		-1
+
+
+class Thread{
+public:
+	int threadId;
+	int mappedToCore;
+	unsigned int lastMigration;
+
+	Thread(){
+		threadId = INVALID_THREAD;
+		mappedToCore = INVALID_CORE;
+		lastMigration = 0;
+	}
+};
+
+class Application{
+public:
+	int appId;
+
+	Application(){
+		appId = INVALID_APPLICATION;
+	}
+};
+vector<Application> applications;
+
+
+
+class Core{
+public:
+	int mappedThreadId;
+	int mappedApplicationId;
+
+	Core(){
+		mappedThreadId = INVALID_THREAD;
+		mappedApplicationId = INVALID_APPLICATION;
+	}
+};
+
+//vector<Core> cores;
+//vector<pthread_mutex_t> flagCoreMapping;
+
+
+
+
+
+int main(int argc, char* argv[])
+{
+	// Get initial time
+	struct timespec end;
+	clock_gettime(CLOCK_MONOTONIC, &start);
+
+	// Initialize the number of cores per island as pass in the command line
+	if (argc > 1)
+		coresPerIsland = atoi(argv[1]);
+	else
+		coresPerIsland = 1;
+
+	// Start ROI
+	parmacs_roi_begin();
+
+
+	totalNumberCores = SimGetNumProcs();
+	totalNumberIslands = totalNumberCores / coresPerIsland;
+	cout << "There are " << totalNumberIslands << " islands in the system" << endl; fflush(NULL);
+
+
+	fillNeighbouringIslandsVector();
+
+
+
+	// Initiliaze the reserved core vectors and their mutexes
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned long int currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+	pthread_mutex_t mutexAux = PTHREAD_MUTEX_INITIALIZER;
+	for(unsigned int i = 0; i < totalNumberCores; i++){
+		//Core newCore;
+		//cores.push_back(newCore);
+		//flagCoreMapping.push_back(mutexAux);
+
+		coresReservedForApplication.push_back(INVALID_APPLICATION);
+		flagReservedCores.push_back(mutexAux);
+		lastMigrationInCore.push_back(0);
+		flagLastMigrationCores.push_back(mutexAux);
+
+
+		previousInstructionCountCore.push_back(SimGetAccumulatedInstructions(i));
+		lastTimeinstructionCountCore.push_back(currentTime);
+		flagPreviousInstructionCountCore.push_back(mutexAux);
+	}
+
+
+
+	// Initiliaze a vector containing all applications
+	vector<int> applicationAgentNumber;
+	unsigned int totalNumberThreads = SimGetNumThreads();
+	for(unsigned int thread = 0; thread < totalNumberThreads; thread++){
+		int appId = SimGetThreadAppId(thread);
+
+		int appIndex = -1;
+		for(unsigned int appIndexAux = 0; appIndexAux < applications.size(); appIndexAux++){
+			if(applications[appIndexAux].appId == appId){
+				appIndex = appIndexAux;
+				break;
+			}
+		}
+
+		if(appIndex < 0){
+			if(appId != 0){
+				Application newApplication;
+				newApplication.appId = appId;
+				applications.push_back(newApplication);
+
+				applicationAgentNumber.push_back(appId);
+				threadApplicationAgent.push_back(0);
+
+				agentsMappedToIsland.push_back(randomCoresForInitialAgentMapping[appId - 1] / coresPerIsland);
+				flagAgentsMappedToIsland.push_back(mutexAux);
+			}
+		}
+	}
+	int totalNumberApplications = applications.size();
+	cout << "Total Number of Applications: " << totalNumberApplications << endl; fflush(NULL);
+
+	// Initialize the vectors containing the coreId reserved for each application thread
+	for(int appId = 0; appId < totalNumberApplications; appId++){
+		for(int threadNumber = 0; threadNumber < numberOfThreadsPerApp[appId]; threadNumber++){
+			threadReservedCore.push_back(INVALID_CORE);
+			flagThreadReservedCore.push_back(mutexAux);
+		}
+
+		if(appId > 0){
+			offsetThreadIndexForApplication.push_back(numberOfThreadsPerApp[appId - 1] + offsetThreadIndexForApplication[appId - 1]);
+		}
+		else{
+			offsetThreadIndexForApplication.push_back(0);
+		}
+	}
+
+
+	// Initialize the thread variables, and start every application agent thread
+	for(int i = 0; i < totalNumberApplications; i++){
+		if (pthread_create(&threadApplicationAgent[i], NULL, &applicationAgent, (void *)&applicationAgentNumber[i])) {
+			cout << "Failed Thread Application Agent" << endl; fflush(NULL);
+			exit(0);
+		}
+	}
+
+
+
+	// Same thing for the islands
+	/*vector<int> islandAgentNumber;
+	for(int i = 0; i < totalNumberIslands; i++){
+		threadIslandAgent.push_back(0);
+		islandAgentNumber.push_back(i);
+	}
+	for(int i = 0; i < totalNumberIslands; i++){
+		if (pthread_create(&threadIslandAgent[i], NULL, &islandAgent, (void *)&islandAgentNumber[i])) {
+			cout << "Failed Thread Island Agent" << endl; fflush(NULL);
+			exit(0);
+		}
+	}*/
+
+	// Enable hardware Turbo Boost in all islands
+	for(int i = 0; i < totalNumberIslands; i++){
+		SimActivateIslandBoosting(i);
+	}
+
+
+
+
+
+
+
+
+
+
+
+	//usleep( 2*SCHEDULING_INTERVAL );
+	cout << "Entering infinite scheduling loop" << endl; fflush(NULL);
+	/*clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned int currentTime;
+	unsigned int lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+	while(1){
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		if(SCHEDULING_INTERVAL > (currentTime - lastTime))
+			usleep( SCHEDULING_INTERVAL - currentTime + lastTime);
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+
+		for(unsigned int appIndex = 0; appIndex < applications.size(); appIndex++){
+			cout << "Application " << applications[appIndex].appId << endl;
+			if(applications[appIndex].threads.size() > 0){
+				for(unsigned int threadInApplication = 0; threadInApplication < applications[appIndex].threads.size(); threadInApplication++){
+					cout << "   Thread " << applications[appIndex].threads[threadInApplication].threadId << endl;
+				}
+			}
+			else{
+				cout << "   Finished" << endl;
+			}
+		}
+		fflush(NULL);
+
+
+
+
+
+
+
+		// If the only application running is the scheduler finish the simulation
+		if(applications.size() <= 0){
+			// Finilize the ROI and exit the application
+			parmacs_roi_end();
+			exit(0);
+		}
+	}*/
+
+
+
+	// Now wait for the threads of the core and island agents to finish
+	for(int i = 0; i < totalNumberApplications; i++){
+		pthread_join(threadApplicationAgent[i], NULL);
+	}
+	//for(int i = 0; i < totalNumberIslands; i++){
+	//	pthread_join(threadIslandAgent[i], NULL);
+	//}
+
+	// Finilize the ROI and exit the application
+	parmacs_roi_end();
+	exit(0);
+}
+
+
+
+
+
+
+
+void *applicationAgent(void * arg)
+{
+	// Migrate the island agent to the first core of the corresponding island
+	int applicationAgentNumber = *((int *)arg);
+	int agentMappedToCore = randomCoresForInitialAgentMapping[applicationAgentNumber - 1];
+	SimSetOwnAffinity(agentMappedToCore);
+
+	int thisAgentMappedtoIsland = agentMappedToCore / coresPerIsland;
+	unsigned int totalNumberAgents = agentsMappedToIsland.size();
+
+	int offsetThreadIndexForThisApplication = offsetThreadIndexForApplication[applicationAgentNumber - 1];
+	int numberThreadsThisApplication = numberOfThreadsPerApp[applicationAgentNumber - 1];
+
+
+	vector<float> currentIPCapplication;
+	vector<float> currentIPSapplication;
+	vector<Thread> threads;
+	for(int threadNumber = 0; threadNumber < numberThreadsThisApplication; threadNumber++){
+		Thread newThread;
+		threads.push_back(newThread);
+
+		currentIPSapplication.push_back(0);
+		currentIPCapplication.push_back(0);
+	}
+
+
+
+
+	/*vector<float> averageTemperatureNeighbouringIslands;
+	vector< vector<float> > temperatureNeighbouringIslands;
+	vector< vector<int> > threadMappedToCoreNeighbouringIslands;
+	vector< vector<int> > applicationMappedToCoreNeighbouringIslands;
+	vector<int> freeCoresNeighbouringIslands;
+	{
+		vector<float> auxTemperatureNeighbouringIslands;
+		vector<int> auxIntVectorNeighbouringIslands;
+		for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+			auxTemperatureNeighbouringIslands.push_back(0);
+			auxIntVectorNeighbouringIslands.push_back(-1);
+		}
+		for(int auxNeighbourIsland = 0; auxNeighbourIsland < MAX_NUMBER_NEIGHBOUR_ISLANDS; auxNeighbourIsland++){
+			temperatureNeighbouringIslands.push_back(auxTemperatureNeighbouringIslands);
+			threadMappedToCoreNeighbouringIslands.push_back(auxIntVectorNeighbouringIslands);
+			applicationMappedToCoreNeighbouringIslands.push_back(auxIntVectorNeighbouringIslands);
+			freeCoresNeighbouringIslands.push_back(coresPerIsland);
+			averageTemperatureNeighbouringIslands.push_back(0);
+		}
+	}*/
+
+
+	// This sleep interval is just to try to get agents to be executed interleaved, and not all at the same time.
+	usleep( 20 * applicationAgentNumber);
+
+
+
+	/*stringstream fileName;
+	fileName << "/home/santiago/sniper/applicationAgent_" << applicationAgentNumber;
+	ofstream outputStream;
+	outputStream.open(fileName.str().c_str());
+	if (outputStream.is_open()){
+		if (outputStream.good()){
+			outputStream.precision(12);
+		}
+		else{
+			cout << "Error: Output file: \"" << fileName.str() << "\" could not be open for writing." << endl; fflush(NULL);
+			outputStream.close();
+		}
+	}
+	else{
+		cout << "Error: Output file: \"" << fileName.str() << "\" could not be open for writing." << endl; fflush(NULL);
+	}*/
+
+
+
+
+
+
+
+
+
+	struct timespec end;
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned int currentTime;
+	unsigned int lastTime = 0;
+	while(1){
+		//unsigned long threadId = SimGetThreadId();
+		//clock_gettime(CLOCK_MONOTONIC, &end);
+		//double printTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		//outputStream << "Time: " << printTime/1000000 << " \tApplication agent: " << applicationAgentNumber << " \tThread ID: " << threadId << endl;
+
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		if(SCHEDULING_INTERVAL > (currentTime - lastTime))
+			usleep( SCHEDULING_INTERVAL - currentTime + lastTime);
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+
+
+
+		if(SimIsApplicationFinished(applicationAgentNumber)){
+
+			for(unsigned int coreNumber = 0; coreNumber < totalNumberCores; coreNumber++){
+
+				if(coresReservedForApplication[coreNumber] == applicationAgentNumber){
+					coresReservedForApplication[coreNumber] = INVALID_APPLICATION;
+
+					pthread_mutex_lock(&flagLastMigrationCores[coreNumber]);
+					lastMigrationInCore[coreNumber] = 0;
+					pthread_mutex_unlock(&flagLastMigrationCores[coreNumber]);
+				}
+				pthread_mutex_unlock(&flagReservedCores[coreNumber]);
+			}
+
+			// Find which thread of the other application was mapped to this core to do the exchange
+			for(int threadNumber = 0; threadNumber < numberThreadsThisApplication; threadNumber++){
+				pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+				threadReservedCore[offsetThreadIndexForThisApplication + threadNumber] = INVALID_CORE;
+				pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+
+				threads[threadNumber].threadId = INVALID_THREAD;
+				threads[threadNumber].mappedToCore = INVALID_CORE;
+				threads[threadNumber].lastMigration = 0;
+			}
+			usleep(UINT_MAX);
+		}
+		else{
+
+			// Update the threads belonging to this application
+			unsigned int totalNumberThreads = SimGetNumThreads();
+			for(unsigned int sniperThread = 0; sniperThread < totalNumberThreads; sniperThread++){
+				int appId = SimGetThreadAppId(sniperThread);
+
+				if(appId == applicationAgentNumber){
+
+					// Now find the index of the thread
+					int threadIndex = -1;
+					for(int threadInApplication = 0; threadInApplication < numberThreadsThisApplication; threadInApplication++){
+						if(threads[threadInApplication].threadId == sniperThread){
+							threadIndex = threadInApplication;
+							break;
+						}
+					}
+
+					// If the index was less than zero, this thread was not in the list of threads of this applicaiton
+					if(threadIndex < 0){
+						// Verify that the thread is not finished
+						if(SimIsThreadFinished(sniperThread) == false){
+							for(int threadInApplication = 0; threadInApplication < numberThreadsThisApplication; threadInApplication++){
+								if(threads[threadInApplication].threadId == INVALID_THREAD){
+									threads[threadInApplication].threadId = sniperThread;
+									threads[threadInApplication].mappedToCore = INVALID_CORE;
+									threads[threadInApplication].lastMigration = lastTime;
+									break;
+								}
+							}
+						}
+					}
+					else{
+						// If the thread already existed, verify that it has not finished
+						if(SimIsThreadFinished(sniperThread)){
+							// If the thread is finished, we indicate that the thread is no longer mapped to that core
+							//int threadMappedToCore = threads[threadIndex].mappedToCore;
+							//pthread_mutex_lock(&flagCoreMapping[threadMappedToCore]);
+							//cores[threadMappedToCore].mappedThreadId = -1;
+							//cores[threadMappedToCore].mappedApplicationId = -1;
+							//pthread_mutex_unlock(&flagCoreMapping[threadMappedToCore]);
+
+							// We erase the thread from the list of threads of the application
+							//threads.erase(threads.begin() + threadIndex);
+
+							// If there are no more threads to run for this application, then we terminate the agent
+							// We are acutally not doing this, because applications will be re-executed
+							//if(threads.size() == 0){
+							//	return 0;
+							//}
+
+							// We mark the thread in our list as invalid, meaning that is not associated with any Sniper thread
+							threads[threadIndex].threadId = INVALID_THREAD;
+							threads[threadIndex].mappedToCore = INVALID_CORE;
+							threads[threadIndex].lastMigration = 0;
+						}
+					}
+				}
+			}
+
+
+
+
+
+			// Compute current MIPS for all threads of this application
+			for(int threadNumber = 0; threadNumber < numberThreadsThisApplication; threadNumber++){
+				if((threads[threadNumber].threadId >= 0) && (threads[threadNumber].mappedToCore >= 0)){
+					unsigned int currentInstructionCount = SimGetAccumulatedInstructions(threads[threadNumber].mappedToCore);
+					pthread_mutex_lock(&flagPreviousInstructionCountCore[threads[threadNumber].mappedToCore]);
+					currentIPSapplication[threadNumber] = ((float)(currentInstructionCount - previousInstructionCountCore[threads[threadNumber].mappedToCore]))/(lastTime - lastTimeinstructionCountCore[threads[threadNumber].mappedToCore]);
+					previousInstructionCountCore[threads[threadNumber].mappedToCore] = currentInstructionCount;
+					lastTimeinstructionCountCore[threads[threadNumber].mappedToCore] = lastTime;
+					pthread_mutex_unlock(&flagPreviousInstructionCountCore[threads[threadNumber].mappedToCore]);
+
+					currentIPCapplication[threadNumber] = currentIPSapplication[threadNumber] / (SimGetFreqMHz(threads[threadNumber].mappedToCore) * 1e6);
+				}
+				else{
+					currentIPSapplication[threadNumber] = 0;
+					currentIPCapplication[threadNumber] = 0;
+				}
+			}
+
+
+
+
+
+
+
+
+
+			// Count the number of threads of this application that are have not yet cores reserved. The first goal is to reserve cores for all threads
+			// and then map them to free cores.
+			// Only after all threads of the application are reserved to map to cores try to migrate to improve overall performance
+			int numberReservedCoresForApplication = 0;
+			for(int threadNumber = 0; threadNumber < numberThreadsThisApplication; threadNumber++){
+				// mappedToCore < 0 means that the thread is unmapped in what respect to our scheduler
+				pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+				if(threadReservedCore[offsetThreadIndexForThisApplication + threadNumber] >= 0){
+					numberReservedCoresForApplication++;
+				}
+				pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+			}
+			if((numberThreadsThisApplication - numberReservedCoresForApplication) > 0){
+				// Reserve all cores for this application in one run. Without this while, we only reserve up to the amount of cores in one island per iteration
+				while((numberThreadsThisApplication - numberReservedCoresForApplication) > 0){
+					// Search for the island with more free cores. If more than one island has the same number of free cores, then choose the coolest island
+					int islandWithMoreFreeCores = -1;
+					int highestNumberFreeCores = 0;
+					float averageTemperatureIslandWithMoreFreeCores;
+					for(unsigned int neighbourIslandIndex = 0; neighbourIslandIndex < neighbouringIslands[thisAgentMappedtoIsland].size(); neighbourIslandIndex++){
+						// First count the number of free cores in each island
+						int freeCoresThisIsland = 0;
+						for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+							int absoluteCoreNumber = auxCoreNumber + neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex]*coresPerIsland;
+
+							pthread_mutex_lock(&flagReservedCores[absoluteCoreNumber]);
+							if(coresReservedForApplication[absoluteCoreNumber] < 0)
+								freeCoresThisIsland++;
+							pthread_mutex_unlock(&flagReservedCores[absoluteCoreNumber]);
+						}
+
+						// If the island has at least one free core
+						if(freeCoresThisIsland > 0){
+							// Compare it with the highest number of free cores of neighbouring islands so far
+							if(highestNumberFreeCores < freeCoresThisIsland){
+								// Compute the average temperature of the island
+								averageTemperatureIslandWithMoreFreeCores = 0;
+								for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+									int absoluteCoreNumber = auxCoreNumber + neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex]*coresPerIsland;
+									averageTemperatureIslandWithMoreFreeCores += ((float)SimGetTemperature(absoluteCoreNumber))/1000000;
+								}
+								averageTemperatureIslandWithMoreFreeCores /= coresPerIsland;
+
+								// Replace the new highest number of free cores
+								highestNumberFreeCores = freeCoresThisIsland;
+								islandWithMoreFreeCores = neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex];
+							}
+							// In case there is more than one island with the same number of free cores, keep the coolest island that has no other agent mapped
+							else if(highestNumberFreeCores == freeCoresThisIsland){
+
+								// Check if the new island considered has agents mapped to it
+								bool agentMappedToIslandThisIsland = false;
+								for(unsigned int auxAgentIndex = 0; auxAgentIndex < totalNumberAgents; auxAgentIndex++){
+									if((applicationAgentNumber - 1) != auxAgentIndex){
+										pthread_mutex_lock(&flagAgentsMappedToIsland[auxAgentIndex]);
+										if(agentsMappedToIsland[auxAgentIndex] == neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex]){
+											agentMappedToIslandThisIsland = true;
+											pthread_mutex_unlock(&flagAgentsMappedToIsland[auxAgentIndex]);
+											break;
+										}
+										pthread_mutex_unlock(&flagAgentsMappedToIsland[auxAgentIndex]);
+									}
+								}
+
+								if(agentMappedToIslandThisIsland == false){
+									// Compute the average temperature of the island
+									float averageTemperatureThisIsland = 0;
+									for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+										int absoluteCoreNumber = auxCoreNumber + neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex]*coresPerIsland;
+										averageTemperatureThisIsland += ((float)SimGetTemperature(absoluteCoreNumber))/1000000;
+									}
+									averageTemperatureThisIsland /= coresPerIsland;
+
+									if(averageTemperatureIslandWithMoreFreeCores > averageTemperatureThisIsland){
+										averageTemperatureIslandWithMoreFreeCores = averageTemperatureThisIsland;
+										islandWithMoreFreeCores = neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex];
+									}
+								}
+							}
+						}
+					}
+
+
+
+					// If no island has free cores, the agent needs to look in neighbouring islands of the current neighbours
+					if(highestNumberFreeCores <= 0){
+						// FIXME: In this implementation, since we have a small number of islands and we want to keep it simple, we do it globally
+						// Search for the island with more free cores. If more than one island has the same number of free cores, then choose the coolest island
+						for(int globalIslandIndex = 0; globalIslandIndex < totalNumberIslands; globalIslandIndex++){
+							// First count the number of free cores in each island
+							int freeCoresThisIsland = 0;
+							for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+								int absoluteCoreNumber = auxCoreNumber + globalIslandIndex*coresPerIsland;
+
+								pthread_mutex_lock(&flagReservedCores[absoluteCoreNumber]);
+								if(coresReservedForApplication[absoluteCoreNumber] < 0)
+									freeCoresThisIsland++;
+								pthread_mutex_unlock(&flagReservedCores[absoluteCoreNumber]);
+							}
+
+							// If the island has at least one free core
+							if(freeCoresThisIsland > 0){
+								// Compare it with the highest number of free cores of neighbouring islands so far
+								if(highestNumberFreeCores < freeCoresThisIsland){
+									// Compute the average temperature of the island
+									averageTemperatureIslandWithMoreFreeCores = 0;
+									for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+										int absoluteCoreNumber = auxCoreNumber + globalIslandIndex*coresPerIsland;
+										averageTemperatureIslandWithMoreFreeCores += ((float)SimGetTemperature(absoluteCoreNumber))/1000000;
+									}
+									averageTemperatureIslandWithMoreFreeCores /= coresPerIsland;
+
+									// Replace the new highest number of free cores
+									highestNumberFreeCores = freeCoresThisIsland;
+									islandWithMoreFreeCores = globalIslandIndex;
+								}
+								// In case there is more than one island with the same number of free cores, keep the coolest island
+								else if(highestNumberFreeCores == freeCoresThisIsland){
+									// Compute the average temperature of the island
+									float averageTemperatureThisIsland = 0;
+									for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+										int absoluteCoreNumber = auxCoreNumber + globalIslandIndex*coresPerIsland;
+										averageTemperatureThisIsland += ((float)SimGetTemperature(absoluteCoreNumber))/1000000;
+									}
+									averageTemperatureThisIsland /= coresPerIsland;
+
+									if(averageTemperatureIslandWithMoreFreeCores > averageTemperatureThisIsland){
+										averageTemperatureIslandWithMoreFreeCores = averageTemperatureThisIsland;
+										islandWithMoreFreeCores = globalIslandIndex;
+									}
+								}
+							}
+						}
+					}
+
+
+					// At this point we should have found at least one island with some free cores
+					if((highestNumberFreeCores > 0) && (islandWithMoreFreeCores >= 0)){
+
+						// We start going through the threads that do not have cores reserved
+						for(int threadNumber = 0; threadNumber < numberThreadsThisApplication; threadNumber++){
+							// mappedToCore < 0 means that the thread is unmapped in what respect to our scheduler
+							pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+							int auxThreadReservedCore = threadReservedCore[offsetThreadIndexForThisApplication + threadNumber];
+							pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+							if(auxThreadReservedCore < 0){
+
+								// Search which cores inside the island are the ones that are free
+								for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+									int absoluteCoreNumber = auxCoreNumber + islandWithMoreFreeCores*coresPerIsland;
+
+									// Once we found an unreserved core inside the island we reserve it to later map a thread to it
+									pthread_mutex_lock(&flagReservedCores[absoluteCoreNumber]);
+									if(coresReservedForApplication[absoluteCoreNumber] < 0){
+										coresReservedForApplication[absoluteCoreNumber] = applicationAgentNumber;
+										pthread_mutex_unlock(&flagReservedCores[absoluteCoreNumber]);
+										SimReserveCoreForApplication(absoluteCoreNumber, applicationAgentNumber);
+
+										pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+										threadReservedCore[offsetThreadIndexForThisApplication + threadNumber] = absoluteCoreNumber;
+										pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+
+										// In case this is the first thread of this application that we are mapping, also move the agent to this core
+										if((numberReservedCoresForApplication <= 0) && (agentMappedToCore != absoluteCoreNumber)){
+											agentMappedToCore = absoluteCoreNumber;
+											SimSetOwnAffinity(agentMappedToCore);
+											thisAgentMappedtoIsland = agentMappedToCore / coresPerIsland;
+
+											pthread_mutex_lock(&flagAgentsMappedToIsland[applicationAgentNumber - 1]);
+											agentsMappedToIsland[applicationAgentNumber - 1] = thisAgentMappedtoIsland;
+											pthread_mutex_unlock(&flagAgentsMappedToIsland[applicationAgentNumber - 1]);
+										}
+
+										numberReservedCoresForApplication++;
+										break;
+									}
+									pthread_mutex_unlock(&flagReservedCores[absoluteCoreNumber]);
+								}
+							}
+						}
+					}
+					else{
+						cout << "ERROR: No free cores available in the entire system" << endl; fflush(NULL);
+					}
+				}
+			}
+			// If all cores are already reserved, then here we apply task migrations
+			else{
+
+				// Find the maximum temperatures of all the cores of the application
+				float maxTemperatureApplication = 0;
+				int applicationThreadWithMaxTemperature = INVALID_THREAD;
+				int coreMaximumTemperature = INVALID_CORE;
+				for(unsigned int threadInApplication = 0; threadInApplication < numberThreadsThisApplication; threadInApplication++){
+
+					if((threads[threadInApplication].threadId >= 0) && (threads[threadInApplication].mappedToCore >= 0)){
+						// Only consider cores which have not been migrated recently
+						if((lastTime - threads[threadInApplication].lastMigration) >= MIGRATION_TIME_THRESHOLD){
+							pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadInApplication]);
+							int auxThreadReservedCore = threadReservedCore[offsetThreadIndexForThisApplication + threadInApplication];
+							pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadInApplication]);
+							if(auxThreadReservedCore >= 0){
+								float temperatureThread = ((float)SimGetTemperature(auxThreadReservedCore))/1000000;
+								if(maxTemperatureApplication < temperatureThread){
+									maxTemperatureApplication = temperatureThread;
+									applicationThreadWithMaxTemperature = threadInApplication;
+									coreMaximumTemperature = auxThreadReservedCore;
+								}
+							}
+						}
+					}
+				}
+
+
+				// Find the coolest core among all neighbouring islands
+				int coreMinimumTemperature = INVALID_CORE;
+				float minTemperatureNeighbouringIslands = FLT_MAX;
+				for(unsigned int neighbourIslandIndex = 0; neighbourIslandIndex < neighbouringIslands[thisAgentMappedtoIsland].size(); neighbourIslandIndex++){
+					for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+						int absoluteCoreNumber = auxCoreNumber + neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex]*coresPerIsland;
+
+						pthread_mutex_lock(&flagLastMigrationCores[absoluteCoreNumber]);
+						unsigned int auxLastMigration = lastMigrationInCore[absoluteCoreNumber];
+						pthread_mutex_unlock(&flagLastMigrationCores[absoluteCoreNumber]);
+
+						// Only consider cores which have not been migrated recently
+						if((lastTime - auxLastMigration) >= MIGRATION_TIME_THRESHOLD){
+							float temperatureCore = ((float)SimGetTemperature(absoluteCoreNumber))/1000000;
+							if(minTemperatureNeighbouringIslands > temperatureCore){
+								minTemperatureNeighbouringIslands = temperatureCore;
+								coreMinimumTemperature = absoluteCoreNumber;
+							}
+						}
+					}
+				}
+
+
+
+				// If there was a thermal violation on some core of the application, migrate the thread to the coolest core in the neighbouring islands
+				// If there was already a thread map to that core, simply exchange them
+				// Note that this happens only if the temperature difference is larger than a histeresis bound, and if the other core also does not have
+				// a thermal violation
+				if((maxTemperatureApplication > Tdtm) && (applicationThreadWithMaxTemperature >= 0) && (coreMinimumTemperature >= 0) && (coreMaximumTemperature >= 0)){
+
+					if( ((minTemperatureNeighbouringIslands < Tdtm) && ((maxTemperatureApplication - minTemperatureNeighbouringIslands) >= MIGRATION_THERMAL_HISTERESIS_BOUND)) ||
+						((maxTemperatureApplication - minTemperatureNeighbouringIslands) >= 3*MIGRATION_THERMAL_HISTERESIS_BOUND) ){
+
+						pthread_mutex_lock(&flagReservedCores[coreMinimumTemperature]);
+						// If the core was not reserved for any application
+						if(coresReservedForApplication[coreMinimumTemperature] < 0){
+							coresReservedForApplication[coreMinimumTemperature] = applicationAgentNumber;
+							pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+
+							pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature]);
+							int previousCoreReservedForThread = threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature];
+							threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature] = coreMinimumTemperature;
+							pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature]);
+
+							pthread_mutex_lock(&flagLastMigrationCores[previousCoreReservedForThread]);
+							lastMigrationInCore[previousCoreReservedForThread] = 0;
+							pthread_mutex_unlock(&flagLastMigrationCores[previousCoreReservedForThread]);
+
+							SimReserveCoreForApplication(coreMinimumTemperature, applicationAgentNumber);
+							SimReserveCoreForApplication(coreMaximumTemperature, INVALID_APPLICATION);
+						}
+						// If the core was reserved for this same application
+						else if(coresReservedForApplication[coreMinimumTemperature] == applicationAgentNumber){
+							pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+
+							// Find which thread of the other application was mapped to this core to do the exchange
+							for(int auxThreadIndex = 0; auxThreadIndex < numberThreadsThisApplication; auxThreadIndex++){
+								pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex]);
+								if(threadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex] == coreMinimumTemperature){
+									threadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex] = coreMaximumTemperature;
+									pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex]);
+									break;
+								}
+								pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex]);
+							}
+
+							pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature]);
+							threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature] = coreMinimumTemperature;
+							pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature]);
+						}
+						// If the core was reserved for some other application
+						else{
+							int previousMappedApplication = coresReservedForApplication[coreMinimumTemperature];
+							coresReservedForApplication[coreMinimumTemperature] = applicationAgentNumber;
+							pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+
+							pthread_mutex_lock(&flagReservedCores[coreMaximumTemperature]);
+							coresReservedForApplication[coreMaximumTemperature] = previousMappedApplication;
+							pthread_mutex_unlock(&flagReservedCores[coreMaximumTemperature]);
+
+							// Find which thread of the other application was mapped to this core to do the exchange
+							int offsetThreadIndexForOtherApplication = offsetThreadIndexForApplication[previousMappedApplication - 1];
+							for(int auxThreadIndexOtherApp = 0; auxThreadIndexOtherApp < numberOfThreadsPerApp[previousMappedApplication - 1]; auxThreadIndexOtherApp++){
+								pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp]);
+								if(threadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp] == coreMinimumTemperature){
+									threadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp] = coreMaximumTemperature;
+									pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp]);
+									break;
+								}
+								pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp]);
+							}
+
+							pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature]);
+							threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature] = coreMinimumTemperature;
+							pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature]);
+
+							SimReserveCoreForApplication(coreMinimumTemperature, applicationAgentNumber);
+							SimReserveCoreForApplication(coreMaximumTemperature, previousMappedApplication);
+						}
+					}
+				}
+				// If there was no thermal violation, try to map threads with high IPC to cool cores. This is to try to avoid a future thermal violation.
+				// We could also be looking at power, but is most likely that there will be a performance counter in eery core, but not a power meter
+				else{
+
+					// First find the application core with the maximum IPC
+					float maxIPCApplication = 0;
+					int applicationThreadWithMaxIPC = INVALID_THREAD;
+					int coreMaximumIPC = INVALID_CORE;
+					for(unsigned int threadInApplication = 0; threadInApplication < numberThreadsThisApplication; threadInApplication++){
+						if((threads[threadInApplication].threadId >= 0) && (threads[threadInApplication].mappedToCore >= 0)){
+							if((lastTime - threads[threadInApplication].lastMigration) >= MIGRATION_TIME_THRESHOLD){
+								if(maxIPCApplication < currentIPCapplication[threadInApplication]){
+									maxIPCApplication = currentIPCapplication[threadInApplication];
+									applicationThreadWithMaxIPC = threadInApplication;
+									coreMaximumIPC = threads[threadInApplication].mappedToCore;
+								}
+							}
+						}
+					}
+
+
+
+					// Only trigger a migration if the IPC is larger than the minimum bound for migration, and if the temperature difference between the
+					// highest IPC core and the coolest core is larger than the threshold
+					if((coreMaximumIPC >= 0) && (coreMinimumTemperature >= 0) && (coreMaximumIPC != coreMinimumTemperature)){
+						float temperatureCoreMaxIPC = ((float)SimGetTemperature(coreMaximumIPC))/1000000;
+						if((maxIPCApplication > MIGRATION_MINIMUM_IPC_BOUND) && ((temperatureCoreMaxIPC - minTemperatureNeighbouringIslands) >= MIGRATION_THERMAL_HISTERESIS_BOUND)){
+
+							pthread_mutex_lock(&flagReservedCores[coreMinimumTemperature]);
+							// If the core was not reserved for any application, simply migrate it
+							if(coresReservedForApplication[coreMinimumTemperature] < 0){
+								coresReservedForApplication[coreMinimumTemperature] = applicationAgentNumber;
+								pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+
+								pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC]);
+								int previousCoreReservedForThread = threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC];
+								threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC] = coreMinimumTemperature;
+								pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC]);
+
+								pthread_mutex_lock(&flagLastMigrationCores[previousCoreReservedForThread]);
+								lastMigrationInCore[previousCoreReservedForThread] = 0;
+								pthread_mutex_unlock(&flagLastMigrationCores[previousCoreReservedForThread]);
+
+								SimReserveCoreForApplication(coreMinimumTemperature, applicationAgentNumber);
+								SimReserveCoreForApplication(coreMaximumIPC, INVALID_APPLICATION);
+							}
+							// If the core was reserved for this same application, we only do the exchange if the IPC different between the highest IPC and
+							// the IPC of the coolest core is bigger than the minimum migration difference
+							else if(coresReservedForApplication[coreMinimumTemperature] == applicationAgentNumber){
+								pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+
+								// Find which thread of the other application was mapped to this core to do the exchange
+								int threadIndexWithMinimumTemperature = -1;
+								for(int auxThreadIndex = 0; auxThreadIndex < numberThreadsThisApplication; auxThreadIndex++){
+									pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex]);
+									if(threadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex] == coreMinimumTemperature){
+										if((maxIPCApplication - currentIPCapplication[auxThreadIndex]) > MIGRATION_IPC_HISTERESIS_BOUND){
+											threadIndexWithMinimumTemperature = auxThreadIndex;
+											threadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex] = coreMaximumIPC;
+										}
+										pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex]);
+										break;
+									}
+									pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex]);
+								}
+
+								// We do the migration if we found the core with minimum temperature and the IPC difference was larger than the minimum difference
+								if(threadIndexWithMinimumTemperature >= 0){
+									pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC]);
+									threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC] = coreMinimumTemperature;
+									pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC]);
+								}
+							}
+							// If the core was reserved for some other application, we only do the exchange if the IPC different between the highest IPC and
+							// the IPC of the coolest core is bigger than the minimum migration difference
+							else{
+								// Compute current MIPS of the core with the minimum temperature
+								pthread_mutex_lock(&flagPreviousInstructionCountCore[coreMinimumTemperature]);
+								float currentIPCcoreMinimumTemperature = (((float)(SimGetAccumulatedInstructions(coreMinimumTemperature) - previousInstructionCountCore[coreMinimumTemperature]))/(lastTime - lastTimeinstructionCountCore[coreMinimumTemperature])) / (SimGetFreqMHz(coreMinimumTemperature) * 1e6);
+								pthread_mutex_unlock(&flagPreviousInstructionCountCore[coreMinimumTemperature]);
+
+								if((maxIPCApplication - currentIPCcoreMinimumTemperature) > MIGRATION_IPC_HISTERESIS_BOUND){
+
+									int previousMappedApplication = coresReservedForApplication[coreMinimumTemperature];
+									coresReservedForApplication[coreMinimumTemperature] = applicationAgentNumber;
+									pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+
+									pthread_mutex_lock(&flagReservedCores[coreMaximumIPC]);
+									coresReservedForApplication[coreMaximumIPC] = previousMappedApplication;
+									pthread_mutex_unlock(&flagReservedCores[coreMaximumIPC]);
+
+									// Find which thread of the other application was mapped to this core to do the exchange
+									int offsetThreadIndexForOtherApplication = offsetThreadIndexForApplication[previousMappedApplication - 1];
+									for(int auxThreadIndexOtherApp = 0; auxThreadIndexOtherApp < numberOfThreadsPerApp[previousMappedApplication - 1]; auxThreadIndexOtherApp++){
+										pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp]);
+										if(threadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp] == coreMinimumTemperature){
+											threadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp] = coreMaximumIPC;
+											pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp]);
+											break;
+										}
+										pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp]);
+									}
+
+									pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC]);
+									threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC] = coreMinimumTemperature;
+									pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC]);
+
+									SimReserveCoreForApplication(coreMinimumTemperature, applicationAgentNumber);
+									SimReserveCoreForApplication(coreMaximumIPC, previousMappedApplication);
+								}
+								else{
+									pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+								}
+							}
+						}
+					}
+
+
+				}
+			}
+
+
+
+
+			// Check if there is any new thread of this application to be mapped.
+			// Threads will already have being mapped by Sniper's scheduler, but we now migrate them to the core we want.
+			// Threads are mapped according to the cores reserved by the application
+			// FIXME: This could be improved, given that when a new thread is created, it will have already been created in one of the reserved cores for
+			// this application. This involves some slight unnecessary overheads for this one-time migration of new threads
+			for(int threadInApplication = 0; threadInApplication < numberThreadsThisApplication; threadInApplication++){
+				// mappedToCore < 0 means that the thread is unmapped in what respect to our scheduler
+				//if((offsetThreadIndexForThisApplication + threadInApplication) < threadReservedCore.size()){
+				if(threads[threadInApplication].threadId >= 0){
+					pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadInApplication]);
+					int auxThreadReservedCore = threadReservedCore[offsetThreadIndexForThisApplication + threadInApplication];
+					pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadInApplication]);
+					if(threads[threadInApplication].mappedToCore != auxThreadReservedCore){
+
+						//cout << "Application agent " << applicationAgentNumber << " mapping thread " << threads[threadInApplication].threadId << " to core " << auxThreadReservedCore << " in island " << auxThreadReservedCore / coresPerIsland  << endl; fflush(NULL);
+						// After finding a core, migrate the thread to that core
+						threads[threadInApplication].mappedToCore = auxThreadReservedCore;
+						threads[threadInApplication].lastMigration = lastTime;
+						//pthread_mutex_lock(&flagCoreMapping[coreIndexToMapApplication]);
+						//cores[coreIndexToMapApplication].mappedThreadId = threads[threadInApplication].threadId;
+						//cores[coreIndexToMapApplication].mappedApplicationId = applicationAgentNumber;
+						//pthread_mutex_unlock(&flagCoreMapping[coreIndexToMapApplication]);
+
+						pthread_mutex_lock(&flagLastMigrationCores[auxThreadReservedCore]);
+						lastMigrationInCore[auxThreadReservedCore] = lastTime;
+						pthread_mutex_unlock(&flagLastMigrationCores[auxThreadReservedCore]);
+
+						SimSetThreadAffinity(threads[threadInApplication].threadId, auxThreadReservedCore);
+					}
+				}
+			}
+		}
+
+
+
+	}
+
+	return 0;
+}
+
+
+
+
+/*
+void *islandAgent(void * arg)
+{
+	// Migrate the island agent to the first core of the corresponding island
+	int islandAgentNumber = *((int *)arg);
+	SimSetOwnAffinity(islandAgentNumber * coresPerIsland);
+
+
+
+	struct timespec end;
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned int currentTime;
+	unsigned int lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+	while(1){
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		if(SCHEDULING_INTERVAL > (currentTime - lastTime))
+			usleep( SCHEDULING_INTERVAL - currentTime + lastTime);
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+
+
+
+
+		// Find the maximum temperature in the island
+		bool thermalViolation = false;
+		for(int core = 0; core < coresPerIsland; core++){
+			if((((float)SimGetTemperature(core + islandAgentNumber * coresPerIsland))/1000000) > Tdtm){
+				thermalViolation = true;
+				break;
+			}
+		}
+
+		// Read the frequency of the island
+		unsigned int currentIslandFrequency = SimGetFreqMHz(islandAgentNumber * coresPerIsland);
+		if(thermalViolation == true){
+			// If there was a thermal violation, reduce the frequency of the island
+			if(currentIslandFrequency > MIN_FREQUENCY){
+				SimSetFreqMHz(islandAgentNumber * coresPerIsland, currentIslandFrequency - FREQUENCY_STEP);
+			}
+		}
+		else{
+			// If there was no thermal violation, increase the frequency of the island
+			if(currentIslandFrequency < MAX_FREQUENCY){
+				SimSetFreqMHz(islandAgentNumber * coresPerIsland, currentIslandFrequency + FREQUENCY_STEP);
+			}
+		}
+	}
+
+	return 0;
+}*/
+
+
+
+
+
+
+
+
+
+
+/*
+void *coreAgent(void * arg)
+{
+	// Migrate the core agent to the corresponding core
+	int coreAgentNumber = *((int *)arg);
+	if(SimInSimulator())
+		SimSetOwnAffinity(coreAgentNumber);
+
+
+	stringstream fileName;
+	fileName << "/home/santiago/sniper/coreAgent_" << coreAgentNumber;
+	ofstream outputStream;
+	outputStream.open(fileName.str().c_str());
+	if (outputStream.is_open()){
+		if (outputStream.good()){
+			outputStream.precision(12);
+		}
+		else{
+			cout << "Error: Output file: \"" << fileName.str() << "\" could not be open for writing." << endl; fflush(NULL);
+			outputStream.close();
+		}
+	}
+	else{
+		cout << "Error: Output file: \"" << fileName.str() << "\" could not be open for writing." << endl; fflush(NULL);
+	}
+
+
+
+	unsigned long int currentInstructionCount;
+	double currentIPS;
+
+	struct timespec end;
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned long int currentTime;
+	unsigned long int lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+	unsigned long int previousInstructionCount = SimGetAccumulatedInstructions(coreAgentNumber);
+	unsigned long int lastTimeInstructionCout = lastTime;
+	while(1){
+		//unsigned long threadId = SimGetThreadId();
+		//clock_gettime(CLOCK_MONOTONIC, &end);
+		//double printTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		//outputStream << "Time: " << printTime/1000000 << " \tCore agent: " << coreAgentNumber << " \tThread ID: " << threadId << endl;
+
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		if(SCHEDULING_INTERVAL > (currentTime - lastTime))
+			usleep( SCHEDULING_INTERVAL - currentTime + lastTime);
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+
+		// Compute current MIPS
+		currentInstructionCount = SimGetAccumulatedInstructions(coreAgentNumber);
+		currentIPS = ((double)(currentInstructionCount - previousInstructionCount))/(lastTime - lastTimeInstructionCout);
+		outputStream << "Time: " << lastTime/1000000.0 << " \tCore agent: " << coreAgentNumber << " \tcurrentIPS: " << currentIPS << " \tcurrentInstructionCount: " << currentInstructionCount << " \tpreviousInstructionCount:" << previousInstructionCount << " \tlastTime:" << lastTime << " \tlastTimeInstructionCout:" << lastTimeInstructionCout << endl;
+		previousInstructionCount = currentInstructionCount;
+		lastTimeInstructionCout = lastTime;
+
+
+		// Get own temperature and temperature
+		double temperature = ((double)SimGetTemperature(coreAgentNumber))/1000000.0;
+		double power = ((double)SimGetPower(coreAgentNumber))/1000000.0;
+
+
+
+	}
+
+
+	return 0;
+}
+*/
+
+
+
+
+void fillNeighbouringIslandsVector(void)
+{
+	vector<int> neighboursIsland_0, neighboursIsland_1, neighboursIsland_2, neighboursIsland_3, neighboursIsland_4, neighboursIsland_5, neighboursIsland_6, \
+				neighboursIsland_7, neighboursIsland_8, neighboursIsland_9, neighboursIsland_10, neighboursIsland_11, neighboursIsland_12, \
+				neighboursIsland_13, neighboursIsland_14, neighboursIsland_15;
+
+	// 0  1  2  3
+	// 4  5  6  7
+	// 8  9  10 11
+	// 12 13 14 15
+
+	// Include itself, that is, the island in the center of the neighbours
+	neighboursIsland_0.push_back(0);
+	neighboursIsland_0.push_back(1);
+	neighboursIsland_0.push_back(4);
+
+	neighboursIsland_1.push_back(1);
+	neighboursIsland_1.push_back(0);
+	neighboursIsland_1.push_back(2);
+	neighboursIsland_1.push_back(5);
+
+	neighboursIsland_2.push_back(2);
+	neighboursIsland_2.push_back(1);
+	neighboursIsland_2.push_back(3);
+	neighboursIsland_2.push_back(6);
+
+	neighboursIsland_3.push_back(3);
+	neighboursIsland_3.push_back(2);
+	neighboursIsland_3.push_back(7);
+
+	neighboursIsland_4.push_back(4);
+	neighboursIsland_4.push_back(0);
+	neighboursIsland_4.push_back(5);
+	neighboursIsland_4.push_back(8);
+
+	neighboursIsland_5.push_back(5);
+	neighboursIsland_5.push_back(1);
+	neighboursIsland_5.push_back(4);
+	neighboursIsland_5.push_back(6);
+	neighboursIsland_5.push_back(9);
+
+	neighboursIsland_6.push_back(6);
+	neighboursIsland_6.push_back(2);
+	neighboursIsland_6.push_back(5);
+	neighboursIsland_6.push_back(7);
+	neighboursIsland_6.push_back(10);
+
+	neighboursIsland_7.push_back(7);
+	neighboursIsland_7.push_back(3);
+	neighboursIsland_7.push_back(6);
+	neighboursIsland_7.push_back(11);
+
+	neighboursIsland_8.push_back(8);
+	neighboursIsland_8.push_back(4);
+	neighboursIsland_8.push_back(9);
+	neighboursIsland_8.push_back(12);
+
+	neighboursIsland_9.push_back(9);
+	neighboursIsland_9.push_back(5);
+	neighboursIsland_9.push_back(8);
+	neighboursIsland_9.push_back(10);
+	neighboursIsland_9.push_back(13);
+
+	neighboursIsland_10.push_back(10);
+	neighboursIsland_10.push_back(6);
+	neighboursIsland_10.push_back(9);
+	neighboursIsland_10.push_back(11);
+	neighboursIsland_10.push_back(14);
+
+	neighboursIsland_11.push_back(11);
+	neighboursIsland_11.push_back(7);
+	neighboursIsland_11.push_back(10);
+	neighboursIsland_11.push_back(15);
+
+	neighboursIsland_12.push_back(12);
+	neighboursIsland_12.push_back(8);
+	neighboursIsland_12.push_back(13);
+
+	neighboursIsland_13.push_back(13);
+	neighboursIsland_13.push_back(9);
+	neighboursIsland_13.push_back(12);
+	neighboursIsland_13.push_back(14);
+
+	neighboursIsland_14.push_back(14);
+	neighboursIsland_14.push_back(10);
+	neighboursIsland_14.push_back(13);
+	neighboursIsland_14.push_back(15);
+
+	neighboursIsland_15.push_back(15);
+	neighboursIsland_15.push_back(11);
+	neighboursIsland_15.push_back(14);
+
+
+	neighbouringIslands.push_back(neighboursIsland_0);
+	neighbouringIslands.push_back(neighboursIsland_1);
+	neighbouringIslands.push_back(neighboursIsland_2);
+	neighbouringIslands.push_back(neighboursIsland_3);
+	neighbouringIslands.push_back(neighboursIsland_4);
+	neighbouringIslands.push_back(neighboursIsland_5);
+	neighbouringIslands.push_back(neighboursIsland_6);
+	neighbouringIslands.push_back(neighboursIsland_7);
+	neighbouringIslands.push_back(neighboursIsland_8);
+	neighbouringIslands.push_back(neighboursIsland_9);
+	neighbouringIslands.push_back(neighboursIsland_10);
+	neighbouringIslands.push_back(neighboursIsland_11);
+	neighbouringIslands.push_back(neighboursIsland_12);
+	neighbouringIslands.push_back(neighboursIsland_13);
+	neighbouringIslands.push_back(neighboursIsland_14);
+	neighbouringIslands.push_back(neighboursIsland_15);
+}
+
+
diff -Naur local_old/mineM/mineThermalMigration.cc local/mineM/mineThermalMigration.cc
--- local_old/mineM/mineThermalMigration.cc	1970-01-01 01:00:00.000000000 +0100
+++ local/mineM/mineThermalMigration.cc	2017-07-28 15:07:48.383928000 +0200
@@ -0,0 +1,1243 @@
+
+#include <iostream>
+#include <stdio.h>
+#include <stdlib.h>
+#include <algorithm>
+#include <unistd.h>
+#include <string.h>
+#include <time.h>
+#include <vector>
+#include <math.h>
+#include <float.h>
+#include <string>
+#include <fstream>
+#include <sstream>
+#include <stdexcept>
+#include <limits.h>
+
+#include "hooks_base.h"
+#include "sim_api.h"
+
+using namespace std;
+
+
+#define nullptr NULL
+
+#ifndef T_KELVIN_H_
+#define T_KELVIN_H_
+const float T_KELVIN = 273.15;
+#endif /* T_KELVIN_H_ */
+
+
+#define MAX_FREQUENCY	4000
+#define MIN_FREQUENCY	200
+#define FREQUENCY_STEP	200
+
+
+// Units in miliseconds
+//double SECONDS_TO_EXEC_TIME_UNIT = 1000.0;
+//double NANOSECONDS_TO_EXEC_TIME_UNIT = 1000000.0;
+// Units in microseconds
+double SECONDS_TO_EXEC_TIME_UNIT = 1000000.0;
+double NANOSECONDS_TO_EXEC_TIME_UNIT = 1000.0;
+
+#define SCHEDULING_INTERVAL		1000
+
+const float Tamb = 45 + T_KELVIN;
+const float Tdtm = 60 + T_KELVIN;
+
+
+
+long unsigned int totalNumberCores;
+int totalNumberIslands;
+long coresPerIsland;
+struct timespec start;
+
+
+
+//vector<pthread_t> threadIslandAgent;
+vector<pthread_t> threadApplicationAgent;
+//void *islandAgent(void * arg);
+void *applicationAgent(void * arg);
+
+
+
+const int randomCoresForInitialAgentMapping[] = { 4, 52, 3, 15, 44, 60, 32, 41, 17, 48,
+											38, 8, 23, 24, 28, 56, 14, 27, 48, 20,
+											12, 51, 18, 1, 6, 54, 16, 45, 57, 37,
+											49, 58 };
+
+//const int numberOfThreadsPerApp[] = { 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 };
+//const int numberOfThreadsPerApp[] = { 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 };
+const int numberOfThreadsPerApp[] = { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 };
+//const int numberOfThreadsPerApp[] = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 };
+//const int numberOfThreadsPerApp[] = { 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };
+
+vector<int> coresReservedForApplication;
+vector<pthread_mutex_t> flagReservedCores;
+
+vector<unsigned long int> previousInstructionCountCore;
+vector<unsigned long int> lastTimeinstructionCountCore;
+vector<pthread_mutex_t> flagPreviousInstructionCountCore;
+
+vector<int> offsetThreadIndexForApplication;
+vector<int> threadReservedCore;
+vector<pthread_mutex_t> flagThreadReservedCore;
+
+
+vector<int> agentsMappedToIsland;
+vector<pthread_mutex_t> flagAgentsMappedToIsland;
+
+vector< vector<int> > neighbouringIslands;
+void fillNeighbouringIslandsVector(void);
+#define MAX_NUMBER_NEIGHBOUR_ISLANDS	5	// Including the island in the center of the neighbours
+#define MIGRATION_THERMAL_HISTERESIS_BOUND	1
+#define MIGRATION_MINIMUM_IPC_BOUND		2
+#define MIGRATION_IPC_HISTERESIS_BOUND		1
+
+#define INVALID_APPLICATION	-1
+#define INVALID_CORE		-1
+#define INVALID_THREAD		-1
+
+
+class Thread{
+public:
+	int threadId;
+	int mappedToCore;
+
+	Thread(){
+		threadId = INVALID_THREAD;
+		mappedToCore = INVALID_CORE;
+	}
+};
+
+class Application{
+public:
+	int appId;
+
+	Application(){
+		appId = INVALID_APPLICATION;
+	}
+};
+vector<Application> applications;
+
+
+
+class Core{
+public:
+	int mappedThreadId;
+	int mappedApplicationId;
+
+	Core(){
+		mappedThreadId = INVALID_THREAD;
+		mappedApplicationId = INVALID_APPLICATION;
+	}
+};
+
+//vector<Core> cores;
+//vector<pthread_mutex_t> flagCoreMapping;
+
+
+
+
+
+int main(int argc, char* argv[])
+{
+	// Get initial time
+	struct timespec end;
+	clock_gettime(CLOCK_MONOTONIC, &start);
+
+	// Initialize the number of cores per island as pass in the command line
+	if (argc > 1)
+		coresPerIsland = atoi(argv[1]);
+	else
+		coresPerIsland = 1;
+
+	// Start ROI
+	parmacs_roi_begin();
+
+
+	totalNumberCores = SimGetNumProcs();
+	totalNumberIslands = totalNumberCores / coresPerIsland;
+	cout << "There are " << totalNumberIslands << " islands in the system" << endl; fflush(NULL);
+
+
+	fillNeighbouringIslandsVector();
+
+
+
+	// Initiliaze the reserved core vectors and their mutexes
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned long int currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+	pthread_mutex_t mutexAux = PTHREAD_MUTEX_INITIALIZER;
+	for(unsigned int i = 0; i < totalNumberCores; i++){
+		//Core newCore;
+		//cores.push_back(newCore);
+		//flagCoreMapping.push_back(mutexAux);
+
+		coresReservedForApplication.push_back(INVALID_APPLICATION);
+		flagReservedCores.push_back(mutexAux);
+
+		previousInstructionCountCore.push_back(SimGetAccumulatedInstructions(i));
+		lastTimeinstructionCountCore.push_back(currentTime);
+		flagPreviousInstructionCountCore.push_back(mutexAux);
+	}
+
+
+
+	// Initiliaze a vector containing all applications
+	vector<int> applicationAgentNumber;
+	unsigned int totalNumberThreads = SimGetNumThreads();
+	for(unsigned int thread = 0; thread < totalNumberThreads; thread++){
+		int appId = SimGetThreadAppId(thread);
+
+		int appIndex = -1;
+		for(unsigned int appIndexAux = 0; appIndexAux < applications.size(); appIndexAux++){
+			if(applications[appIndexAux].appId == appId){
+				appIndex = appIndexAux;
+				break;
+			}
+		}
+
+		if(appIndex < 0){
+			if(appId != 0){
+				Application newApplication;
+				newApplication.appId = appId;
+				applications.push_back(newApplication);
+
+				applicationAgentNumber.push_back(appId);
+				threadApplicationAgent.push_back(0);
+
+				agentsMappedToIsland.push_back(randomCoresForInitialAgentMapping[appId - 1] / coresPerIsland);
+				flagAgentsMappedToIsland.push_back(mutexAux);
+			}
+		}
+	}
+	int totalNumberApplications = applications.size();
+	cout << "Total Number of Applications: " << totalNumberApplications << endl; fflush(NULL);
+
+	// Initialize the vectors containing the coreId reserved for each application thread
+	for(int appId = 0; appId < totalNumberApplications; appId++){
+		for(int threadNumber = 0; threadNumber < numberOfThreadsPerApp[appId]; threadNumber++){
+			threadReservedCore.push_back(INVALID_CORE);
+			flagThreadReservedCore.push_back(mutexAux);
+		}
+
+		if(appId > 0){
+			offsetThreadIndexForApplication.push_back(numberOfThreadsPerApp[appId - 1] + offsetThreadIndexForApplication[appId - 1]);
+		}
+		else{
+			offsetThreadIndexForApplication.push_back(0);
+		}
+	}
+
+
+	// Initialize the thread variables, and start every application agent thread
+	for(int i = 0; i < totalNumberApplications; i++){
+		if (pthread_create(&threadApplicationAgent[i], NULL, &applicationAgent, (void *)&applicationAgentNumber[i])) {
+			cout << "Failed Thread Application Agent" << endl; fflush(NULL);
+			exit(0);
+		}
+	}
+
+
+
+	// Same thing for the islands
+	/*vector<int> islandAgentNumber;
+	for(int i = 0; i < totalNumberIslands; i++){
+		threadIslandAgent.push_back(0);
+		islandAgentNumber.push_back(i);
+	}
+	for(int i = 0; i < totalNumberIslands; i++){
+		if (pthread_create(&threadIslandAgent[i], NULL, &islandAgent, (void *)&islandAgentNumber[i])) {
+			cout << "Failed Thread Island Agent" << endl; fflush(NULL);
+			exit(0);
+		}
+	}*/
+
+	// Enable hardware Turbo Boost in all islands
+	for(int i = 0; i < totalNumberIslands; i++){
+		SimActivateIslandBoosting(i);
+	}
+
+
+
+
+
+
+
+
+
+
+
+	//usleep( 2*SCHEDULING_INTERVAL );
+	cout << "Entering infinite scheduling loop" << endl; fflush(NULL);
+	/*clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned int currentTime;
+	unsigned int lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+	while(1){
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		if(SCHEDULING_INTERVAL > (currentTime - lastTime))
+			usleep( SCHEDULING_INTERVAL - currentTime + lastTime);
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+
+		for(unsigned int appIndex = 0; appIndex < applications.size(); appIndex++){
+			cout << "Application " << applications[appIndex].appId << endl;
+			if(applications[appIndex].threads.size() > 0){
+				for(unsigned int threadInApplication = 0; threadInApplication < applications[appIndex].threads.size(); threadInApplication++){
+					cout << "   Thread " << applications[appIndex].threads[threadInApplication].threadId << endl;
+				}
+			}
+			else{
+				cout << "   Finished" << endl;
+			}
+		}
+		fflush(NULL);
+
+
+
+
+
+
+
+		// If the only application running is the scheduler finish the simulation
+		if(applications.size() <= 0){
+			// Finilize the ROI and exit the application
+			parmacs_roi_end();
+			exit(0);
+		}
+	}*/
+
+
+
+	// Now wait for the threads of the core and island agents to finish
+	for(int i = 0; i < totalNumberApplications; i++){
+		pthread_join(threadApplicationAgent[i], NULL);
+	}
+	//for(int i = 0; i < totalNumberIslands; i++){
+	//	pthread_join(threadIslandAgent[i], NULL);
+	//}
+
+	// Finilize the ROI and exit the application
+	parmacs_roi_end();
+	exit(0);
+}
+
+
+
+
+
+
+
+void *applicationAgent(void * arg)
+{
+	// Migrate the island agent to the first core of the corresponding island
+	int applicationAgentNumber = *((int *)arg);
+	int agentMappedToCore = randomCoresForInitialAgentMapping[applicationAgentNumber - 1];
+	SimSetOwnAffinity(agentMappedToCore);
+
+	int thisAgentMappedtoIsland = agentMappedToCore / coresPerIsland;
+	unsigned int totalNumberAgents = agentsMappedToIsland.size();
+
+	int offsetThreadIndexForThisApplication = offsetThreadIndexForApplication[applicationAgentNumber - 1];
+	int numberThreadsThisApplication = numberOfThreadsPerApp[applicationAgentNumber - 1];
+
+
+	vector<float> currentIPCapplication;
+	vector<float> currentIPSapplication;
+	vector<Thread> threads;
+	for(int threadNumber = 0; threadNumber < numberThreadsThisApplication; threadNumber++){
+		Thread newThread;
+		threads.push_back(newThread);
+
+		currentIPSapplication.push_back(0);
+		currentIPCapplication.push_back(0);
+	}
+
+
+
+
+	/*vector<float> averageTemperatureNeighbouringIslands;
+	vector< vector<float> > temperatureNeighbouringIslands;
+	vector< vector<int> > threadMappedToCoreNeighbouringIslands;
+	vector< vector<int> > applicationMappedToCoreNeighbouringIslands;
+	vector<int> freeCoresNeighbouringIslands;
+	{
+		vector<float> auxTemperatureNeighbouringIslands;
+		vector<int> auxIntVectorNeighbouringIslands;
+		for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+			auxTemperatureNeighbouringIslands.push_back(0);
+			auxIntVectorNeighbouringIslands.push_back(-1);
+		}
+		for(int auxNeighbourIsland = 0; auxNeighbourIsland < MAX_NUMBER_NEIGHBOUR_ISLANDS; auxNeighbourIsland++){
+			temperatureNeighbouringIslands.push_back(auxTemperatureNeighbouringIslands);
+			threadMappedToCoreNeighbouringIslands.push_back(auxIntVectorNeighbouringIslands);
+			applicationMappedToCoreNeighbouringIslands.push_back(auxIntVectorNeighbouringIslands);
+			freeCoresNeighbouringIslands.push_back(coresPerIsland);
+			averageTemperatureNeighbouringIslands.push_back(0);
+		}
+	}*/
+
+
+	// This sleep interval is just to try to get agents to be executed interleaved, and not all at the same time.
+	usleep( 20 * applicationAgentNumber);
+
+
+
+	/*stringstream fileName;
+	fileName << "/home/santiago/sniper/applicationAgent_" << applicationAgentNumber;
+	ofstream outputStream;
+	outputStream.open(fileName.str().c_str());
+	if (outputStream.is_open()){
+		if (outputStream.good()){
+			outputStream.precision(12);
+		}
+		else{
+			cout << "Error: Output file: \"" << fileName.str() << "\" could not be open for writing." << endl; fflush(NULL);
+			outputStream.close();
+		}
+	}
+	else{
+		cout << "Error: Output file: \"" << fileName.str() << "\" could not be open for writing." << endl; fflush(NULL);
+	}*/
+
+
+
+
+
+
+
+
+
+	struct timespec end;
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned int currentTime;
+	unsigned int lastTime = 0;
+	while(1){
+		//unsigned long threadId = SimGetThreadId();
+		//clock_gettime(CLOCK_MONOTONIC, &end);
+		//double printTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		//outputStream << "Time: " << printTime/1000000 << " \tApplication agent: " << applicationAgentNumber << " \tThread ID: " << threadId << endl;
+
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		if(SCHEDULING_INTERVAL > (currentTime - lastTime))
+			usleep( SCHEDULING_INTERVAL - currentTime + lastTime);
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+
+
+
+		if(SimIsApplicationFinished(applicationAgentNumber)){
+
+			for(unsigned int coreNumber = 0; coreNumber < totalNumberCores; coreNumber++){
+				pthread_mutex_lock(&flagReservedCores[coreNumber]);
+				if(coresReservedForApplication[coreNumber] == applicationAgentNumber)
+					coresReservedForApplication[coreNumber] = INVALID_APPLICATION;
+				pthread_mutex_unlock(&flagReservedCores[coreNumber]);
+			}
+
+			// Find which thread of the other application was mapped to this core to do the exchange
+			for(int threadNumber = 0; threadNumber < numberThreadsThisApplication; threadNumber++){
+				pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+				threadReservedCore[offsetThreadIndexForThisApplication + threadNumber] = INVALID_CORE;
+				pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+
+				threads[threadNumber].threadId = INVALID_THREAD;
+				threads[threadNumber].mappedToCore = INVALID_CORE;
+			}
+			usleep(UINT_MAX);
+		}
+		else{
+
+			// Update the threads belonging to this application
+			unsigned int totalNumberThreads = SimGetNumThreads();
+			for(unsigned int sniperThread = 0; sniperThread < totalNumberThreads; sniperThread++){
+				int appId = SimGetThreadAppId(sniperThread);
+
+				if(appId == applicationAgentNumber){
+
+					// Now find the index of the thread
+					int threadIndex = -1;
+					for(int threadInApplication = 0; threadInApplication < numberThreadsThisApplication; threadInApplication++){
+						if(threads[threadInApplication].threadId == sniperThread){
+							threadIndex = threadInApplication;
+							break;
+						}
+					}
+
+					// If the index was less than zero, this thread was not in the list of threads of this applicaiton
+					if(threadIndex < 0){
+						// Verify that the thread is not finished
+						if(SimIsThreadFinished(sniperThread) == false){
+							for(int threadInApplication = 0; threadInApplication < numberThreadsThisApplication; threadInApplication++){
+								if(threads[threadInApplication].threadId == INVALID_THREAD){
+									threads[threadInApplication].threadId = sniperThread;
+									threads[threadInApplication].mappedToCore = INVALID_CORE;
+									break;
+								}
+							}
+						}
+					}
+					else{
+						// If the thread already existed, verify that it has not finished
+						if(SimIsThreadFinished(sniperThread)){
+							// If the thread is finished, we indicate that the thread is no longer mapped to that core
+							//int threadMappedToCore = threads[threadIndex].mappedToCore;
+							//pthread_mutex_lock(&flagCoreMapping[threadMappedToCore]);
+							//cores[threadMappedToCore].mappedThreadId = -1;
+							//cores[threadMappedToCore].mappedApplicationId = -1;
+							//pthread_mutex_unlock(&flagCoreMapping[threadMappedToCore]);
+
+							// We erase the thread from the list of threads of the application
+							//threads.erase(threads.begin() + threadIndex);
+
+							// If there are no more threads to run for this application, then we terminate the agent
+							// We are acutally not doing this, because applications will be re-executed
+							//if(threads.size() == 0){
+							//	return 0;
+							//}
+
+							// We mark the thread in our list as invalid, meaning that is not associated with any Sniper thread
+							threads[threadIndex].threadId = INVALID_THREAD;
+							threads[threadIndex].mappedToCore = INVALID_CORE;
+						}
+					}
+				}
+			}
+
+
+
+
+
+			// Compute current MIPS for all threads of this application
+			/*for(int threadNumber = 0; threadNumber < numberThreadsThisApplication; threadNumber++){
+				if((threads[threadNumber].threadId >= 0) && (threads[threadNumber].mappedToCore >= 0)){
+					unsigned int currentInstructionCount = SimGetAccumulatedInstructions(threads[threadNumber].mappedToCore);
+					pthread_mutex_lock(&flagPreviousInstructionCountCore[threads[threadNumber].mappedToCore]);
+					currentIPSapplication[threadNumber] = ((float)(currentInstructionCount - previousInstructionCountCore[threads[threadNumber].mappedToCore]))/(lastTime - lastTimeinstructionCountCore[threads[threadNumber].mappedToCore]);
+					previousInstructionCountCore[threads[threadNumber].mappedToCore] = currentInstructionCount;
+					lastTimeinstructionCountCore[threads[threadNumber].mappedToCore] = lastTime;
+					pthread_mutex_unlock(&flagPreviousInstructionCountCore[threads[threadNumber].mappedToCore]);
+
+					currentIPCapplication[threadNumber] = currentIPSapplication[threadNumber] / (SimGetFreqMHz(threads[threadNumber].mappedToCore) * 1e6);
+				}
+				else{
+					currentIPSapplication[threadNumber] = 0;
+					currentIPCapplication[threadNumber] = 0;
+				}
+			}*/
+
+
+
+
+
+
+
+
+
+			// Count the number of threads of this application that are have not yet cores reserved. The first goal is to reserve cores for all threads
+			// and then map them to free cores.
+			// Only after all threads of the application are reserved to map to cores try to migrate to improve overall performance
+			int numberReservedCoresForApplication = 0;
+			for(int threadNumber = 0; threadNumber < numberThreadsThisApplication; threadNumber++){
+				// mappedToCore < 0 means that the thread is unmapped in what respect to our scheduler
+				pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+				if(threadReservedCore[offsetThreadIndexForThisApplication + threadNumber] >= 0){
+					numberReservedCoresForApplication++;
+				}
+				pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+			}
+			if((numberThreadsThisApplication - numberReservedCoresForApplication) > 0){
+				// Reserve all cores for this application in one run. Without this while, we only reserve up to the amount of cores in one island per iteration
+				while((numberThreadsThisApplication - numberReservedCoresForApplication) > 0){
+					// Search for the island with more free cores. If more than one island has the same number of free cores, then choose the coolest island
+					int islandWithMoreFreeCores = -1;
+					int highestNumberFreeCores = 0;
+					float averageTemperatureIslandWithMoreFreeCores;
+					for(unsigned int neighbourIslandIndex = 0; neighbourIslandIndex < neighbouringIslands[thisAgentMappedtoIsland].size(); neighbourIslandIndex++){
+						// First count the number of free cores in each island
+						int freeCoresThisIsland = 0;
+						for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+							int absoluteCoreNumber = auxCoreNumber + neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex]*coresPerIsland;
+
+							pthread_mutex_lock(&flagReservedCores[absoluteCoreNumber]);
+							if(coresReservedForApplication[absoluteCoreNumber] < 0)
+								freeCoresThisIsland++;
+							pthread_mutex_unlock(&flagReservedCores[absoluteCoreNumber]);
+						}
+
+						// If the island has at least one free core
+						if(freeCoresThisIsland > 0){
+							// Compare it with the highest number of free cores of neighbouring islands so far
+							if(highestNumberFreeCores < freeCoresThisIsland){
+								// Compute the average temperature of the island
+								averageTemperatureIslandWithMoreFreeCores = 0;
+								for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+									int absoluteCoreNumber = auxCoreNumber + neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex]*coresPerIsland;
+									averageTemperatureIslandWithMoreFreeCores += ((float)SimGetTemperature(absoluteCoreNumber))/1000000;
+								}
+								averageTemperatureIslandWithMoreFreeCores /= coresPerIsland;
+
+								// Replace the new highest number of free cores
+								highestNumberFreeCores = freeCoresThisIsland;
+								islandWithMoreFreeCores = neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex];
+							}
+							// In case there is more than one island with the same number of free cores, keep the coolest island that has no other agent mapped
+							else if(highestNumberFreeCores == freeCoresThisIsland){
+
+								// Check if the new island considered has agents mapped to it
+								bool agentMappedToIslandThisIsland = false;
+								for(unsigned int auxAgentIndex = 0; auxAgentIndex < totalNumberAgents; auxAgentIndex++){
+									if((applicationAgentNumber - 1) != auxAgentIndex){
+										pthread_mutex_lock(&flagAgentsMappedToIsland[auxAgentIndex]);
+										if(agentsMappedToIsland[auxAgentIndex] == neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex]){
+											agentMappedToIslandThisIsland = true;
+											pthread_mutex_unlock(&flagAgentsMappedToIsland[auxAgentIndex]);
+											break;
+										}
+										pthread_mutex_unlock(&flagAgentsMappedToIsland[auxAgentIndex]);
+									}
+								}
+
+								if(agentMappedToIslandThisIsland == false){
+									// Compute the average temperature of the island
+									float averageTemperatureThisIsland = 0;
+									for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+										int absoluteCoreNumber = auxCoreNumber + neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex]*coresPerIsland;
+										averageTemperatureThisIsland += ((float)SimGetTemperature(absoluteCoreNumber))/1000000;
+									}
+									averageTemperatureThisIsland /= coresPerIsland;
+
+									if(averageTemperatureIslandWithMoreFreeCores > averageTemperatureThisIsland){
+										averageTemperatureIslandWithMoreFreeCores = averageTemperatureThisIsland;
+										islandWithMoreFreeCores = neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex];
+									}
+								}
+							}
+						}
+					}
+
+
+
+					// If no island has free cores, the agent needs to look in neighbouring islands of the current neighbours
+					if(highestNumberFreeCores <= 0){
+						// FIXME: In this implementation, since we have a small number of islands and we want to keep it simple, we do it globally
+						// Search for the island with more free cores. If more than one island has the same number of free cores, then choose the coolest island
+						for(int globalIslandIndex = 0; globalIslandIndex < totalNumberIslands; globalIslandIndex++){
+							// First count the number of free cores in each island
+							int freeCoresThisIsland = 0;
+							for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+								int absoluteCoreNumber = auxCoreNumber + globalIslandIndex*coresPerIsland;
+
+								pthread_mutex_lock(&flagReservedCores[absoluteCoreNumber]);
+								if(coresReservedForApplication[absoluteCoreNumber] < 0)
+									freeCoresThisIsland++;
+								pthread_mutex_unlock(&flagReservedCores[absoluteCoreNumber]);
+							}
+
+							// If the island has at least one free core
+							if(freeCoresThisIsland > 0){
+								// Compare it with the highest number of free cores of neighbouring islands so far
+								if(highestNumberFreeCores < freeCoresThisIsland){
+									// Compute the average temperature of the island
+									averageTemperatureIslandWithMoreFreeCores = 0;
+									for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+										int absoluteCoreNumber = auxCoreNumber + globalIslandIndex*coresPerIsland;
+										averageTemperatureIslandWithMoreFreeCores += ((float)SimGetTemperature(absoluteCoreNumber))/1000000;
+									}
+									averageTemperatureIslandWithMoreFreeCores /= coresPerIsland;
+
+									// Replace the new highest number of free cores
+									highestNumberFreeCores = freeCoresThisIsland;
+									islandWithMoreFreeCores = globalIslandIndex;
+								}
+								// In case there is more than one island with the same number of free cores, keep the coolest island
+								else if(highestNumberFreeCores == freeCoresThisIsland){
+									// Compute the average temperature of the island
+									float averageTemperatureThisIsland = 0;
+									for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+										int absoluteCoreNumber = auxCoreNumber + globalIslandIndex*coresPerIsland;
+										averageTemperatureThisIsland += ((float)SimGetTemperature(absoluteCoreNumber))/1000000;
+									}
+									averageTemperatureThisIsland /= coresPerIsland;
+
+									if(averageTemperatureIslandWithMoreFreeCores > averageTemperatureThisIsland){
+										averageTemperatureIslandWithMoreFreeCores = averageTemperatureThisIsland;
+										islandWithMoreFreeCores = globalIslandIndex;
+									}
+								}
+							}
+						}
+					}
+
+
+					// At this point we should have found at least one island with some free cores
+					if((highestNumberFreeCores > 0) && (islandWithMoreFreeCores >= 0)){
+
+						// We start going through the threads that do not have cores reserved
+						for(int threadNumber = 0; threadNumber < numberThreadsThisApplication; threadNumber++){
+							// mappedToCore < 0 means that the thread is unmapped in what respect to our scheduler
+							pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+							int auxThreadReservedCore = threadReservedCore[offsetThreadIndexForThisApplication + threadNumber];
+							pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+							if(auxThreadReservedCore < 0){
+
+								// Search which cores inside the island are the ones that are free
+								for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+									int absoluteCoreNumber = auxCoreNumber + islandWithMoreFreeCores*coresPerIsland;
+
+									// Once we found an unreserved core inside the island we reserve it to later map a thread to it
+									pthread_mutex_lock(&flagReservedCores[absoluteCoreNumber]);
+									if(coresReservedForApplication[absoluteCoreNumber] < 0){
+										coresReservedForApplication[absoluteCoreNumber] = applicationAgentNumber;
+										pthread_mutex_unlock(&flagReservedCores[absoluteCoreNumber]);
+										SimReserveCoreForApplication(absoluteCoreNumber, applicationAgentNumber);
+
+										pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+										threadReservedCore[offsetThreadIndexForThisApplication + threadNumber] = absoluteCoreNumber;
+										pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadNumber]);
+
+										// In case this is the first thread of this application that we are mapping, also move the agent to this core
+										if((numberReservedCoresForApplication <= 0) && (agentMappedToCore != absoluteCoreNumber)){
+											agentMappedToCore = absoluteCoreNumber;
+											SimSetOwnAffinity(agentMappedToCore);
+											thisAgentMappedtoIsland = agentMappedToCore / coresPerIsland;
+
+											pthread_mutex_lock(&flagAgentsMappedToIsland[applicationAgentNumber - 1]);
+											agentsMappedToIsland[applicationAgentNumber - 1] = thisAgentMappedtoIsland;
+											pthread_mutex_unlock(&flagAgentsMappedToIsland[applicationAgentNumber - 1]);
+										}
+
+										numberReservedCoresForApplication++;
+										break;
+									}
+									pthread_mutex_unlock(&flagReservedCores[absoluteCoreNumber]);
+								}
+							}
+						}
+					}
+					else{
+						cout << "ERROR: No free cores available in the entire system" << endl; fflush(NULL);
+					}
+				}
+			}
+			// If all cores are already reserved, then here we apply task migrations
+			else{
+
+				// Find the maximum temperatures of all the cores of the application
+				float maxTemperatureApplication = 0;
+				int applicationThreadWithMaxTemperature = INVALID_THREAD;
+				int coreMaximumTemperature = INVALID_CORE;
+				for(unsigned int threadInApplication = 0; threadInApplication < numberThreadsThisApplication; threadInApplication++){
+					pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadInApplication]);
+					int auxThreadReservedCore = threadReservedCore[offsetThreadIndexForThisApplication + threadInApplication];
+					pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadInApplication]);
+					if(auxThreadReservedCore >= 0){
+						float temperatureThread = ((float)SimGetTemperature(auxThreadReservedCore))/1000000;
+						if(maxTemperatureApplication < temperatureThread){
+							maxTemperatureApplication = temperatureThread;
+							applicationThreadWithMaxTemperature = threadInApplication;
+							coreMaximumTemperature = auxThreadReservedCore;
+						}
+					}
+				}
+
+
+				// Find the coolest core among all neighbouring islands
+				int coreMinimumTemperature = INVALID_CORE;
+				float minTemperatureNeighbouringIslands = FLT_MAX;
+				for(unsigned int neighbourIslandIndex = 0; neighbourIslandIndex < neighbouringIslands[thisAgentMappedtoIsland].size(); neighbourIslandIndex++){
+					for(int auxCoreNumber = 0; auxCoreNumber < coresPerIsland; auxCoreNumber++){
+						int absoluteCoreNumber = auxCoreNumber + neighbouringIslands[thisAgentMappedtoIsland][neighbourIslandIndex]*coresPerIsland;
+						float temperatureCore = ((float)SimGetTemperature(absoluteCoreNumber))/1000000;
+						if(minTemperatureNeighbouringIslands > temperatureCore){
+							minTemperatureNeighbouringIslands = temperatureCore;
+							coreMinimumTemperature = absoluteCoreNumber;
+						}
+					}
+				}
+
+
+
+				// If there was a thermal violation on some core of the application, migrate the thread to the coolest core in the neighbouring islands
+				// If there was already a thread map to that core, simply exchange them
+				// Note that this happens only if the temperature difference is larger than a histeresis bound, and if the other core also does not have
+				// a thermal violation
+				if((maxTemperatureApplication > Tdtm) && (applicationThreadWithMaxTemperature >= 0) && (coreMinimumTemperature >= 0) && (coreMaximumTemperature >= 0)){
+
+					if( ((minTemperatureNeighbouringIslands < Tdtm) && ((maxTemperatureApplication - minTemperatureNeighbouringIslands) >= MIGRATION_THERMAL_HISTERESIS_BOUND)) ||
+						((maxTemperatureApplication - minTemperatureNeighbouringIslands) >= 3*MIGRATION_THERMAL_HISTERESIS_BOUND) ){
+
+						pthread_mutex_lock(&flagReservedCores[coreMinimumTemperature]);
+						// If the core was not reserved for any application
+						if(coresReservedForApplication[coreMinimumTemperature] < 0){
+							coresReservedForApplication[coreMinimumTemperature] = applicationAgentNumber;
+							pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+
+							pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature]);
+							threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature] = coreMinimumTemperature;
+							pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature]);
+
+							SimReserveCoreForApplication(coreMinimumTemperature, applicationAgentNumber);
+							SimReserveCoreForApplication(coreMaximumTemperature, INVALID_APPLICATION);
+						}
+						// If the core was reserved for this same application
+						else if(coresReservedForApplication[coreMinimumTemperature] == applicationAgentNumber){
+							pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+
+							// Find which thread of the other application was mapped to this core to do the exchange
+							for(int auxThreadIndex = 0; auxThreadIndex < numberThreadsThisApplication; auxThreadIndex++){
+								pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex]);
+								if(threadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex] == coreMinimumTemperature){
+									threadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex] = coreMaximumTemperature;
+									pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex]);
+									break;
+								}
+								pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex]);
+							}
+
+							pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature]);
+							threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature] = coreMinimumTemperature;
+							pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature]);
+						}
+						// If the core was reserved for some other application
+						else{
+							int previousMappedApplication = coresReservedForApplication[coreMinimumTemperature];
+							coresReservedForApplication[coreMinimumTemperature] = applicationAgentNumber;
+							pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+
+							pthread_mutex_lock(&flagReservedCores[coreMaximumTemperature]);
+							coresReservedForApplication[coreMaximumTemperature] = previousMappedApplication;
+							pthread_mutex_unlock(&flagReservedCores[coreMaximumTemperature]);
+
+							// Find which thread of the other application was mapped to this core to do the exchange
+							int offsetThreadIndexForOtherApplication = offsetThreadIndexForApplication[previousMappedApplication - 1];
+							for(int auxThreadIndexOtherApp = 0; auxThreadIndexOtherApp < numberOfThreadsPerApp[previousMappedApplication - 1]; auxThreadIndexOtherApp++){
+								pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp]);
+								if(threadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp] == coreMinimumTemperature){
+									threadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp] = coreMaximumTemperature;
+									pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp]);
+									break;
+								}
+								pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp]);
+							}
+
+							pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature]);
+							threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature] = coreMinimumTemperature;
+							pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxTemperature]);
+
+							SimReserveCoreForApplication(coreMinimumTemperature, applicationAgentNumber);
+							SimReserveCoreForApplication(coreMaximumTemperature, previousMappedApplication);
+						}
+					}
+				}
+				// If there was no thermal violation, try to map threads with high IPC to cool cores. This is to try to avoid a future thermal violation.
+				// We could also be looking at power, but is most likely that there will be a performance counter in eery core, but not a power meter
+				/*else{
+
+					// First find the application core with the maximum IPC
+					float maxIPCApplication = 0;
+					int applicationThreadWithMaxIPC = INVALID_THREAD;
+					int coreMaximumIPC = INVALID_CORE;
+					for(unsigned int threadInApplication = 0; threadInApplication < numberThreadsThisApplication; threadInApplication++){
+						if((threads[threadInApplication].threadId >= 0) && (threads[threadInApplication].mappedToCore >= 0)){
+							if(maxIPCApplication < currentIPCapplication[threadInApplication]){
+								maxIPCApplication = currentIPCapplication[threadInApplication];
+								applicationThreadWithMaxIPC = threadInApplication;
+								coreMaximumIPC = threads[threadInApplication].mappedToCore;
+							}
+						}
+					}
+
+
+
+					// Only trigger a migration if the IPC is larger than the minimum bound for migration, and if the temperature difference between the
+					// highest IPC core and the coolest core is larger than the threshold
+					if((coreMaximumIPC >= 0) && (coreMinimumTemperature >= 0) && (coreMaximumIPC != coreMinimumTemperature)){
+						float temperatureCoreMaxIPC = ((float)SimGetTemperature(coreMaximumIPC))/1000000;
+						if((maxIPCApplication > MIGRATION_MINIMUM_IPC_BOUND) && ((temperatureCoreMaxIPC - minTemperatureNeighbouringIslands) >= MIGRATION_THERMAL_HISTERESIS_BOUND)){
+
+							pthread_mutex_lock(&flagReservedCores[coreMinimumTemperature]);
+							// If the core was not reserved for any application, simply migrate it
+							if(coresReservedForApplication[coreMinimumTemperature] < 0){
+								coresReservedForApplication[coreMinimumTemperature] = applicationAgentNumber;
+								pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+
+								pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC]);
+								threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC] = coreMinimumTemperature;
+								pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC]);
+
+								SimReserveCoreForApplication(coreMinimumTemperature, applicationAgentNumber);
+								SimReserveCoreForApplication(coreMaximumIPC, INVALID_APPLICATION);
+							}
+							// If the core was reserved for this same application, we only do the exchange if the IPC different between the highest IPC and
+							// the IPC of the coolest core is bigger than the minimum migration difference
+							else if(coresReservedForApplication[coreMinimumTemperature] == applicationAgentNumber){
+								pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+
+								// Find which thread of the other application was mapped to this core to do the exchange
+								int threadIndexWithMinimumTemperature = -1;
+								for(int auxThreadIndex = 0; auxThreadIndex < numberThreadsThisApplication; auxThreadIndex++){
+									pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex]);
+									if(threadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex] == coreMinimumTemperature){
+										if((maxIPCApplication - currentIPCapplication[auxThreadIndex]) > MIGRATION_IPC_HISTERESIS_BOUND){
+											threadIndexWithMinimumTemperature = auxThreadIndex;
+											threadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex] = coreMaximumIPC;
+										}
+										pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex]);
+										break;
+									}
+									pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + auxThreadIndex]);
+								}
+
+								// We do the migration if we found the core with minimum temperature and the IPC difference was larger than the minimum difference
+								if(threadIndexWithMinimumTemperature >= 0){
+									pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC]);
+									threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC] = coreMinimumTemperature;
+									pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC]);
+								}
+							}
+							// If the core was reserved for some other application, we only do the exchange if the IPC different between the highest IPC and
+							// the IPC of the coolest core is bigger than the minimum migration difference
+							else{
+								// Compute current MIPS of the core with the minimum temperature
+								pthread_mutex_lock(&flagPreviousInstructionCountCore[coreMinimumTemperature]);
+								float currentIPCcoreMinimumTemperature = (((float)(SimGetAccumulatedInstructions(coreMinimumTemperature) - previousInstructionCountCore[coreMinimumTemperature]))/(lastTime - lastTimeinstructionCountCore[coreMinimumTemperature])) / (SimGetFreqMHz(coreMinimumTemperature) * 1e6);
+								pthread_mutex_unlock(&flagPreviousInstructionCountCore[coreMinimumTemperature]);
+
+								if((maxIPCApplication - currentIPCcoreMinimumTemperature) > MIGRATION_IPC_HISTERESIS_BOUND){
+
+									int previousMappedApplication = coresReservedForApplication[coreMinimumTemperature];
+									coresReservedForApplication[coreMinimumTemperature] = applicationAgentNumber;
+									pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+
+									pthread_mutex_lock(&flagReservedCores[coreMaximumIPC]);
+									coresReservedForApplication[coreMaximumIPC] = previousMappedApplication;
+									pthread_mutex_unlock(&flagReservedCores[coreMaximumIPC]);
+
+									// Find which thread of the other application was mapped to this core to do the exchange
+									int offsetThreadIndexForOtherApplication = offsetThreadIndexForApplication[previousMappedApplication - 1];
+									for(int auxThreadIndexOtherApp = 0; auxThreadIndexOtherApp < numberOfThreadsPerApp[previousMappedApplication - 1]; auxThreadIndexOtherApp++){
+										pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp]);
+										if(threadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp] == coreMinimumTemperature){
+											threadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp] = coreMaximumIPC;
+											pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp]);
+											break;
+										}
+										pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForOtherApplication + auxThreadIndexOtherApp]);
+									}
+
+									pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC]);
+									threadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC] = coreMinimumTemperature;
+									pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + applicationThreadWithMaxIPC]);
+
+									SimReserveCoreForApplication(coreMinimumTemperature, applicationAgentNumber);
+									SimReserveCoreForApplication(coreMaximumIPC, previousMappedApplication);
+								}
+								else{
+									pthread_mutex_unlock(&flagReservedCores[coreMinimumTemperature]);
+								}
+							}
+						}
+					}
+
+
+				}*/
+			}
+
+
+
+
+			// Check if there is any new thread of this application to be mapped.
+			// Threads will already have being mapped by Sniper's scheduler, but we now migrate them to the core we want.
+			// Threads are mapped according to the cores reserved by the application
+			// FIXME: This could be improved, given that when a new thread is created, it will have already been created in one of the reserved cores for
+			// this application. This involves some slight unnecessary overheads for this one-time migration of new threads
+			for(int threadInApplication = 0; threadInApplication < numberThreadsThisApplication; threadInApplication++){
+				// mappedToCore < 0 means that the thread is unmapped in what respect to our scheduler
+				//if((offsetThreadIndexForThisApplication + threadInApplication) < threadReservedCore.size()){
+				if(threads[threadInApplication].threadId >= 0){
+					pthread_mutex_lock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadInApplication]);
+					int auxThreadReservedCore = threadReservedCore[offsetThreadIndexForThisApplication + threadInApplication];
+					pthread_mutex_unlock(&flagThreadReservedCore[offsetThreadIndexForThisApplication + threadInApplication]);
+					if(threads[threadInApplication].mappedToCore != auxThreadReservedCore){
+
+						cout << "Application agent " << applicationAgentNumber << " mapping thread " << threads[threadInApplication].threadId << " to core " << auxThreadReservedCore << " in island " << auxThreadReservedCore / coresPerIsland  << endl; fflush(NULL);
+						// After finding a core, migrate the thread to that core
+						threads[threadInApplication].mappedToCore = auxThreadReservedCore;
+						//pthread_mutex_lock(&flagCoreMapping[coreIndexToMapApplication]);
+						//cores[coreIndexToMapApplication].mappedThreadId = threads[threadInApplication].threadId;
+						//cores[coreIndexToMapApplication].mappedApplicationId = applicationAgentNumber;
+						//pthread_mutex_unlock(&flagCoreMapping[coreIndexToMapApplication]);
+
+						SimSetThreadAffinity(threads[threadInApplication].threadId, auxThreadReservedCore);
+					}
+				}
+			}
+		}
+
+
+
+	}
+
+	return 0;
+}
+
+
+
+
+/*
+void *islandAgent(void * arg)
+{
+	// Migrate the island agent to the first core of the corresponding island
+	int islandAgentNumber = *((int *)arg);
+	SimSetOwnAffinity(islandAgentNumber * coresPerIsland);
+
+
+
+	struct timespec end;
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned int currentTime;
+	unsigned int lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+	while(1){
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		if(SCHEDULING_INTERVAL > (currentTime - lastTime))
+			usleep( SCHEDULING_INTERVAL - currentTime + lastTime);
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+
+
+
+
+		// Find the maximum temperature in the island
+		bool thermalViolation = false;
+		for(int core = 0; core < coresPerIsland; core++){
+			if((((float)SimGetTemperature(core + islandAgentNumber * coresPerIsland))/1000000) > Tdtm){
+				thermalViolation = true;
+				break;
+			}
+		}
+
+		// Read the frequency of the island
+		unsigned int currentIslandFrequency = SimGetFreqMHz(islandAgentNumber * coresPerIsland);
+		if(thermalViolation == true){
+			// If there was a thermal violation, reduce the frequency of the island
+			if(currentIslandFrequency > MIN_FREQUENCY){
+				SimSetFreqMHz(islandAgentNumber * coresPerIsland, currentIslandFrequency - FREQUENCY_STEP);
+			}
+		}
+		else{
+			// If there was no thermal violation, increase the frequency of the island
+			if(currentIslandFrequency < MAX_FREQUENCY){
+				SimSetFreqMHz(islandAgentNumber * coresPerIsland, currentIslandFrequency + FREQUENCY_STEP);
+			}
+		}
+	}
+
+	return 0;
+}*/
+
+
+
+
+
+
+
+
+
+
+/*
+void *coreAgent(void * arg)
+{
+	// Migrate the core agent to the corresponding core
+	int coreAgentNumber = *((int *)arg);
+	if(SimInSimulator())
+		SimSetOwnAffinity(coreAgentNumber);
+
+
+	stringstream fileName;
+	fileName << "/home/santiago/sniper/coreAgent_" << coreAgentNumber;
+	ofstream outputStream;
+	outputStream.open(fileName.str().c_str());
+	if (outputStream.is_open()){
+		if (outputStream.good()){
+			outputStream.precision(12);
+		}
+		else{
+			cout << "Error: Output file: \"" << fileName.str() << "\" could not be open for writing." << endl; fflush(NULL);
+			outputStream.close();
+		}
+	}
+	else{
+		cout << "Error: Output file: \"" << fileName.str() << "\" could not be open for writing." << endl; fflush(NULL);
+	}
+
+
+
+	unsigned long int currentInstructionCount;
+	double currentIPS;
+
+	struct timespec end;
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned long int currentTime;
+	unsigned long int lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+	unsigned long int previousInstructionCount = SimGetAccumulatedInstructions(coreAgentNumber);
+	unsigned long int lastTimeInstructionCout = lastTime;
+	while(1){
+		//unsigned long threadId = SimGetThreadId();
+		//clock_gettime(CLOCK_MONOTONIC, &end);
+		//double printTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		//outputStream << "Time: " << printTime/1000000 << " \tCore agent: " << coreAgentNumber << " \tThread ID: " << threadId << endl;
+
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		if(SCHEDULING_INTERVAL > (currentTime - lastTime))
+			usleep( SCHEDULING_INTERVAL - currentTime + lastTime);
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+
+		// Compute current MIPS
+		currentInstructionCount = SimGetAccumulatedInstructions(coreAgentNumber);
+		currentIPS = ((double)(currentInstructionCount - previousInstructionCount))/(lastTime - lastTimeInstructionCout);
+		outputStream << "Time: " << lastTime/1000000.0 << " \tCore agent: " << coreAgentNumber << " \tcurrentIPS: " << currentIPS << " \tcurrentInstructionCount: " << currentInstructionCount << " \tpreviousInstructionCount:" << previousInstructionCount << " \tlastTime:" << lastTime << " \tlastTimeInstructionCout:" << lastTimeInstructionCout << endl;
+		previousInstructionCount = currentInstructionCount;
+		lastTimeInstructionCout = lastTime;
+
+
+		// Get own temperature and temperature
+		double temperature = ((double)SimGetTemperature(coreAgentNumber))/1000000.0;
+		double power = ((double)SimGetPower(coreAgentNumber))/1000000.0;
+
+
+
+	}
+
+
+	return 0;
+}
+*/
+
+
+
+
+void fillNeighbouringIslandsVector(void)
+{
+	vector<int> neighboursIsland_0, neighboursIsland_1, neighboursIsland_2, neighboursIsland_3, neighboursIsland_4, neighboursIsland_5, neighboursIsland_6, \
+				neighboursIsland_7, neighboursIsland_8, neighboursIsland_9, neighboursIsland_10, neighboursIsland_11, neighboursIsland_12, \
+				neighboursIsland_13, neighboursIsland_14, neighboursIsland_15;
+
+	// 0  1  2  3
+	// 4  5  6  7
+	// 8  9  10 11
+	// 12 13 14 15
+
+	// Include itself, that is, the island in the center of the neighbours
+	neighboursIsland_0.push_back(0);
+	neighboursIsland_0.push_back(1);
+	neighboursIsland_0.push_back(4);
+
+	neighboursIsland_1.push_back(1);
+	neighboursIsland_1.push_back(0);
+	neighboursIsland_1.push_back(2);
+	neighboursIsland_1.push_back(5);
+
+	neighboursIsland_2.push_back(2);
+	neighboursIsland_2.push_back(1);
+	neighboursIsland_2.push_back(3);
+	neighboursIsland_2.push_back(6);
+
+	neighboursIsland_3.push_back(3);
+	neighboursIsland_3.push_back(2);
+	neighboursIsland_3.push_back(7);
+
+	neighboursIsland_4.push_back(4);
+	neighboursIsland_4.push_back(0);
+	neighboursIsland_4.push_back(5);
+	neighboursIsland_4.push_back(8);
+
+	neighboursIsland_5.push_back(5);
+	neighboursIsland_5.push_back(1);
+	neighboursIsland_5.push_back(4);
+	neighboursIsland_5.push_back(6);
+	neighboursIsland_5.push_back(9);
+
+	neighboursIsland_6.push_back(6);
+	neighboursIsland_6.push_back(2);
+	neighboursIsland_6.push_back(5);
+	neighboursIsland_6.push_back(7);
+	neighboursIsland_6.push_back(10);
+
+	neighboursIsland_7.push_back(7);
+	neighboursIsland_7.push_back(3);
+	neighboursIsland_7.push_back(6);
+	neighboursIsland_7.push_back(11);
+
+	neighboursIsland_8.push_back(8);
+	neighboursIsland_8.push_back(4);
+	neighboursIsland_8.push_back(9);
+	neighboursIsland_8.push_back(12);
+
+	neighboursIsland_9.push_back(9);
+	neighboursIsland_9.push_back(5);
+	neighboursIsland_9.push_back(8);
+	neighboursIsland_9.push_back(10);
+	neighboursIsland_9.push_back(13);
+
+	neighboursIsland_10.push_back(10);
+	neighboursIsland_10.push_back(6);
+	neighboursIsland_10.push_back(9);
+	neighboursIsland_10.push_back(11);
+	neighboursIsland_10.push_back(14);
+
+	neighboursIsland_11.push_back(11);
+	neighboursIsland_11.push_back(7);
+	neighboursIsland_11.push_back(10);
+	neighboursIsland_11.push_back(15);
+
+	neighboursIsland_12.push_back(12);
+	neighboursIsland_12.push_back(8);
+	neighboursIsland_12.push_back(13);
+
+	neighboursIsland_13.push_back(13);
+	neighboursIsland_13.push_back(9);
+	neighboursIsland_13.push_back(12);
+	neighboursIsland_13.push_back(14);
+
+	neighboursIsland_14.push_back(14);
+	neighboursIsland_14.push_back(10);
+	neighboursIsland_14.push_back(13);
+	neighboursIsland_14.push_back(15);
+
+	neighboursIsland_15.push_back(15);
+	neighboursIsland_15.push_back(11);
+	neighboursIsland_15.push_back(14);
+
+
+	neighbouringIslands.push_back(neighboursIsland_0);
+	neighbouringIslands.push_back(neighboursIsland_1);
+	neighbouringIslands.push_back(neighboursIsland_2);
+	neighbouringIslands.push_back(neighboursIsland_3);
+	neighbouringIslands.push_back(neighboursIsland_4);
+	neighbouringIslands.push_back(neighboursIsland_5);
+	neighbouringIslands.push_back(neighboursIsland_6);
+	neighbouringIslands.push_back(neighboursIsland_7);
+	neighbouringIslands.push_back(neighboursIsland_8);
+	neighbouringIslands.push_back(neighboursIsland_9);
+	neighbouringIslands.push_back(neighboursIsland_10);
+	neighbouringIslands.push_back(neighboursIsland_11);
+	neighbouringIslands.push_back(neighboursIsland_12);
+	neighbouringIslands.push_back(neighboursIsland_13);
+	neighbouringIslands.push_back(neighboursIsland_14);
+	neighbouringIslands.push_back(neighboursIsland_15);
+}
+
+
diff -Naur local_old/priceTheory/Makefile local/priceTheory/Makefile
--- local_old/priceTheory/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ local/priceTheory/Makefile	2017-07-28 15:07:48.435928000 +0200
@@ -0,0 +1,11 @@
+include ../../tools/hooks/buildconf.makefile
+TARGET = priceTheory
+
+$(TARGET): priceTheory.o
+	$(HOOKS_CXX) priceTheory.o $(HOOKS_LDFLAGS) -o $@
+
+%.o : %.cc
+	$(HOOKS_CXX) $< $(HOOKS_CXXFLAGS) -c -o $@
+
+clean :
+	rm -f *.o $(TARGET)
diff -Naur local_old/priceTheory/priceTheory.cc local/priceTheory/priceTheory.cc
--- local_old/priceTheory/priceTheory.cc	1970-01-01 01:00:00.000000000 +0100
+++ local/priceTheory/priceTheory.cc	2017-07-28 15:07:48.435928000 +0200
@@ -0,0 +1,714 @@
+
+#include <iostream>
+#include <stdio.h>
+#include <stdlib.h>
+#include <algorithm>
+#include <unistd.h>
+#include <string.h>
+#include <time.h>
+#include <vector>
+#include <math.h>
+#include <float.h>
+#include <string>
+#include <fstream>
+#include <sstream>
+#include <stdexcept>
+
+#include "hooks_base.h"
+#include "sim_api.h"
+
+using namespace std;
+
+
+#define nullptr NULL
+
+#ifndef T_KELVIN_H_
+#define T_KELVIN_H_
+const double T_KELVIN = 273.15;
+#endif /* T_KELVIN_H_ */
+
+#define ISLAND_CACHE_POWER_CONSUMPTION	0.72
+#define MAX_FREQUENCY	4000
+#define MIN_FREQUENCY	200
+#define FREQUENCY_STEP	200
+
+
+// Units in miliseconds
+//double SECONDS_TO_EXEC_TIME_UNIT = 1000.0;
+//double NANOSECONDS_TO_EXEC_TIME_UNIT = 1000000.0;
+// Units in microseconds
+double SECONDS_TO_EXEC_TIME_UNIT = 1000000.0;
+double NANOSECONDS_TO_EXEC_TIME_UNIT = 1000.0;
+
+#define SCHEDULING_INTERVAL		1000
+
+
+
+const int numberOfThreadsPerApp[] = { 9, 9, 9, 9, 9, 8 };
+//const int numberOfThreadsPerApp[] = { 8, 12, 16, 6, 8, 4 };
+//const int numberOfThreadsPerApp[] = { 10, 8, 6, 11, 13, 8 };
+//const int numberOfThreadsPerApp[] = { 7, 5, 11, 8, 10, 8 };
+//
+//const int numberOfThreadsPerApp[] = { 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 };
+//const int numberOfThreadsPerApp[] = { 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11 };
+//const int numberOfThreadsPerApp[] = { 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 };
+//const int numberOfThreadsPerApp[] = { 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 };
+//const int numberOfThreadsPerApp[] = { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 };
+//const int numberOfThreadsPerApp[] = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 };
+//const int numberOfThreadsPerApp[] = { 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };
+
+
+vector<pthread_t> threadCoreAgent;
+vector<pthread_t> threadIslandAgent;
+struct timespec start;
+
+int totalNumberCores;
+int totalNumberIslands;
+long coresPerIsland;
+
+void *coreAgent(void * arg);
+void *islandAgent(void * arg);
+
+
+double totalAllowance;
+vector<double> islandCurrentPowerConsumption;
+vector<double> islandAllowance;
+vector<pthread_mutex_t> flagIslandAllowance;
+
+vector<double> corePrice;
+vector<pthread_mutex_t> flagCorePrice;
+vector<double> coreBasePrice;
+vector<pthread_mutex_t> flagCoreBasePrice;
+
+
+
+const double Tamb = 45 + T_KELVIN;
+const double Tdtm = 60 + T_KELVIN;
+const double TDP = 250;
+
+const double powerThreshold = 230;
+const double dvfsChangeToleranceFactor = 0.2;
+
+
+
+
+class Thread{
+public:
+	int threadId;
+	int mappedToCore;
+
+	Thread(){
+		threadId = -1;
+		mappedToCore = -1;
+	}
+};
+
+class Application{
+public:
+	unsigned int appId;
+	vector<Thread> threads;
+
+	Application(){
+		appId = 0;
+	}
+};
+
+vector<Application> applications;
+
+
+
+class Core{
+public:
+	int mappedThreadId;
+
+	Core(){
+		mappedThreadId = -1;
+	}
+};
+
+vector<Core> cores;
+vector<pthread_mutex_t> flagCoreMapping;
+
+
+int main(int argc, char* argv[])
+{
+	// Get initial time
+	struct timespec end;
+	clock_gettime(CLOCK_MONOTONIC, &start);
+
+	// Initialize the number of cores per island as pass in the command line
+	if (argc > 1)
+		coresPerIsland = atoi(argv[1]);
+	else
+		coresPerIsland = 1;
+
+	// Start ROI
+	parmacs_roi_begin();
+
+
+
+	totalNumberCores = SimGetNumProcs();
+	totalNumberIslands = totalNumberCores / coresPerIsland;
+	totalAllowance = TDP;
+	cout << "There are " << totalNumberIslands << " islands in the system" << endl; fflush(NULL);
+
+
+	// Initiliaze the income multipliers and the temperature region limits
+	pthread_mutex_t mutexAux = PTHREAD_MUTEX_INITIALIZER;
+	for(int i = 0; i < totalNumberCores; i++){
+		Core newCore;
+		cores.push_back(newCore);
+		flagCoreMapping.push_back(mutexAux);
+
+		corePrice.push_back((totalAllowance / totalNumberCores)/MAX_FREQUENCY);
+		flagCorePrice.push_back(mutexAux);
+
+		coreBasePrice.push_back((totalAllowance / totalNumberCores)/MAX_FREQUENCY);
+		flagCoreBasePrice.push_back(mutexAux);
+	}
+	for(int i = 0; i < totalNumberIslands; i++){
+		islandCurrentPowerConsumption.push_back(0);
+		islandAllowance.push_back(totalAllowance / totalNumberIslands);
+		flagIslandAllowance.push_back(mutexAux);
+	}
+
+
+
+	// Initiliaze a vector containing all applications
+	int totalNumberThreads = SimGetNumThreads();
+	for(unsigned int thread = 0; thread < totalNumberThreads; thread++){
+		unsigned int appId = SimGetThreadAppId(thread);
+
+		int appIndex = -1;
+		for(unsigned int appIndexAux = 0; appIndexAux < applications.size(); appIndexAux++){
+			if(applications[appIndexAux].appId == appId){
+				appIndex = appIndexAux;
+				break;
+			}
+		}
+
+		if(appIndex < 0){
+			if(appId != 0){
+				Application newApplication;
+				newApplication.appId = appId;
+				applications.push_back(newApplication);
+			}
+		}
+	}
+	cout << "Total Number of Applications: " << applications.size() << endl; fflush(NULL);
+
+
+
+
+	// Initialize the thread variables, and start every core agent thread
+	vector<int> coreAgentNumber;
+	for(int i = 0; i < totalNumberCores; i++){
+		threadCoreAgent.push_back(0);
+		coreAgentNumber.push_back(i);
+	}
+	for(int i = 0; i < totalNumberCores; i++){
+		if (pthread_create(&threadCoreAgent[i], NULL, &coreAgent, (void *)&coreAgentNumber[i])) {
+			cout << "Failed Thread Core Agent" << endl; fflush(NULL);
+			exit(0);
+		}
+	}
+
+	// Same thing for the islands
+	vector<int> islandAgentNumber;
+	for(unsigned int i = 0; i < totalNumberIslands; i++){
+		threadIslandAgent.push_back(0);
+		islandAgentNumber.push_back((int) i);
+	}
+	for(unsigned int i = 0; i < totalNumberIslands; i++){
+		if (pthread_create(&threadIslandAgent[i], NULL, &islandAgent, (void *)&islandAgentNumber[i])) {
+			cout << "Failed Thread Island Agent" << endl; fflush(NULL);
+			exit(0);
+		}
+	}
+
+
+
+
+
+
+
+
+	//usleep( 2*SCHEDULING_INTERVAL );
+	cout << "Entering infinite scheduling loop" << endl; fflush(NULL);
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned int currentTime;
+	unsigned int lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+	while(1){
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		if(SCHEDULING_INTERVAL > (currentTime - lastTime))
+			usleep( SCHEDULING_INTERVAL - currentTime + lastTime);
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+
+		// Get total number of threads and iterate through them
+		totalNumberThreads = SimGetNumThreads();
+		for(int thread = 0; thread < totalNumberThreads; thread++){
+			unsigned int appId = SimGetThreadAppId(thread);
+
+			if(appId != 0){
+				// Find the index of the application
+				int appIndex = -1;
+				for(unsigned int appIndexAux = 0; appIndexAux < applications.size(); appIndexAux++){
+					if(applications[appIndexAux].appId == appId){
+						appIndex = appIndexAux;
+						break;
+					}
+				}
+
+				if(appIndex >= 0){
+					// Now find the index of the thread
+					int threadIndex = -1;
+					for(unsigned int threadInApplication = 0; threadInApplication < applications[appIndex].threads.size(); threadInApplication++){
+						if(applications[appIndex].threads[threadInApplication].threadId == thread){
+							threadIndex = threadInApplication;
+							break;
+						}
+					}
+
+					// If the index was less than zero, this thread was not in the list of thread of the applicaiton
+					if(threadIndex < 0){
+						// Verify that the thread is not finished, as we could have already removed it from the list because it is finished
+						if(SimIsThreadFinished(thread) == false){
+							Thread newThread;
+							newThread.threadId = thread;
+							applications[appIndex].threads.push_back(newThread);
+						}
+					}
+					else{
+						// If the thread already existed, verify that it has not finished
+						if(SimIsThreadFinished(thread)){
+
+							// If the thread is finished, we indicate that the thread is no longer mapped to that core
+							int threadMappedToCore = applications[appIndex].threads[threadIndex].mappedToCore;
+
+							pthread_mutex_lock(&flagCoreMapping[threadMappedToCore]);
+							cores[threadMappedToCore].mappedThreadId = -1;
+							pthread_mutex_unlock(&flagCoreMapping[threadMappedToCore]);
+
+							applications[appIndex].threads.erase(applications[appIndex].threads.begin() + threadIndex);
+							//if(applications[appIndex].threads.size() == 0){
+							//	applications.erase(applications.begin() + appIndex);
+							//}
+						}
+					}
+				}
+				else{
+					if(SimIsThreadFinished(thread) == false){
+						cout << "ERROR: New application found after initialization!!: " << appId << endl; fflush(NULL);
+					}
+				}
+			}
+		}
+
+
+
+		/*for(unsigned int appIndex = 0; appIndex < applications.size(); appIndex++){
+			cout << "Application " << applications[appIndex].appId << endl;
+			if(applications[appIndex].threads.size() > 0){
+				for(unsigned int threadInApplication = 0; threadInApplication < applications[appIndex].threads.size(); threadInApplication++){
+					cout << "   Thread " << applications[appIndex].threads[threadInApplication].threadId << endl;
+				}
+			}
+			else{
+				cout << "   Finished" << endl;
+			}
+		}
+		fflush(NULL);*/
+
+
+
+
+
+
+
+
+		// Check if there is any new thread to be mapped. Threads will already have being mapped by Sniper's scheduler, but we now migrate them
+		// to the core we want.
+		// In case of the economic scheduling algorithm, threads are mapped to the core that globally has the highest savings
+		int numberOfThreadsPreviousApplications = 0;
+		for(unsigned int appIndex = 0; appIndex < applications.size(); appIndex++){
+			for(unsigned int threadInApplication = 0; threadInApplication < applications[appIndex].threads.size(); threadInApplication++){
+				// mappedToCore < 0 means that the thread is unmapped
+				if(applications[appIndex].threads[threadInApplication].mappedToCore < 0){
+
+					int coreIndexToMapApplication = -1;
+					int islandToMapApplication = -1;
+					/*for(unsigned int islandNumber = 0; islandNumber < totalNumberIslands; islandNumber++){
+						for(int coreNumber = 0; coreNumber < coresPerIsland; coreNumber++){
+							int auxCoreNumber = coreNumber + islandNumber * coresPerIsland;
+							pthread_mutex_lock(&flagCoreMapping[auxCoreNumber]);
+							if(cores[auxCoreNumber].mappedThreadId < 0){
+								coreIndexToMapApplication = auxCoreNumber;
+								islandToMapApplication = islandNumber;
+								pthread_mutex_unlock(&flagCoreMapping[auxCoreNumber]);
+								break;
+							}
+							pthread_mutex_unlock(&flagCoreMapping[auxCoreNumber]);
+						}
+					}*/
+					int auxCoreNumber = numberOfThreadsPreviousApplications;
+					while(coreIndexToMapApplication < 0){
+						pthread_mutex_lock(&flagCoreMapping[auxCoreNumber]);
+						if(cores[auxCoreNumber].mappedThreadId < 0){
+							coreIndexToMapApplication = auxCoreNumber;
+							islandToMapApplication = auxCoreNumber / coresPerIsland;
+						}
+						pthread_mutex_unlock(&flagCoreMapping[auxCoreNumber]);
+
+						// Test the next core
+						auxCoreNumber++;
+						if(auxCoreNumber >= totalNumberCores)
+							auxCoreNumber = 0;
+
+						// If for some reason we checked all cores and didn't found any free cores, anyway stop the loop
+						if(auxCoreNumber == numberOfThreadsPreviousApplications)
+							break;
+					}
+
+
+
+
+					cout << "Mapping for application " << applications[appIndex].appId << " thread " << applications[appIndex].threads[threadInApplication].threadId << " to core " << coreIndexToMapApplication << " in island " << islandToMapApplication << endl; fflush(NULL);
+					if((coreIndexToMapApplication >= 0) && (islandToMapApplication >= 0)){
+
+						applications[appIndex].threads[threadInApplication].mappedToCore = coreIndexToMapApplication;
+						pthread_mutex_lock(&flagCoreMapping[coreIndexToMapApplication]);
+						cores[coreIndexToMapApplication].mappedThreadId = applications[appIndex].threads[threadInApplication].threadId;
+						pthread_mutex_unlock(&flagCoreMapping[coreIndexToMapApplication]);
+
+						SimSetThreadAffinity(applications[appIndex].threads[threadInApplication].threadId, coreIndexToMapApplication);
+					}
+					else{
+						//cout << "ERROR: No core found to map new task" << endl; fflush(NULL);
+					}
+				}
+			}
+			numberOfThreadsPreviousApplications += numberOfThreadsPerApp[applications[appIndex].appId - 1];
+		}
+
+
+
+
+
+
+
+		// Count the total number of active application threads and compute the demand assuming that all threads want to execute at maximum frequency
+		unsigned int totalNumberApplicationThreads = 0;
+		for(unsigned int appIndex = 0; appIndex < applications.size(); appIndex++){
+			totalNumberApplicationThreads += applications[appIndex].threads.size();
+		}
+		unsigned int totalDemand = totalNumberApplicationThreads * MAX_FREQUENCY;
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+		// Distribute the global allownca among the islands according to each island's current power consumption
+		// For that, we first compute the total current power consumption, each island's current power consumption
+		// While we are at it, we also compute the total supply in MHz, that is, number of active cores in each island multiplied by its frequency
+		double totalCurrentPowerConsumption = 0;
+		unsigned int totalSupply = 0;
+		for(unsigned int islandIndex = 0; islandIndex < totalNumberIslands; islandIndex++){
+			int islandCurrentActiveCores = 0;
+			islandCurrentPowerConsumption[islandIndex] = ISLAND_CACHE_POWER_CONSUMPTION;
+			for(int coreNumber = 0; coreNumber < coresPerIsland; coreNumber++){
+				unsigned int auxCoreNumber = coreNumber + islandIndex * coresPerIsland;
+				islandCurrentPowerConsumption[islandIndex] += ((double)SimGetPower(auxCoreNumber))/1000000.0;
+
+				pthread_mutex_lock(&flagCoreMapping[auxCoreNumber]);
+				if(cores[auxCoreNumber].mappedThreadId >= 0)
+					islandCurrentActiveCores++;
+				pthread_mutex_unlock(&flagCoreMapping[auxCoreNumber]);
+			}
+			totalCurrentPowerConsumption += islandCurrentPowerConsumption[islandIndex];
+			totalSupply += islandCurrentActiveCores * SimGetFreqMHz(islandIndex * coresPerIsland);
+		}
+
+		// Compute the new total power budget based on the total current power consumption, current total demand, and current total supply
+		if(totalCurrentPowerConsumption < powerThreshold){
+			// Increase the total allowance because the current power consumption is below the threshold
+			totalAllowance = totalAllowance + totalAllowance*((totalDemand - totalSupply)/totalDemand);
+		}
+		else if(totalCurrentPowerConsumption > TDP){
+			// Reduce the total allowance because the current power consumption exceeds TDP
+			totalAllowance = totalAllowance + totalAllowance * ((TDP - totalCurrentPowerConsumption)/TDP);
+		}
+		else{
+			// No change to the allowance
+		}
+
+		// Compute the islands' allowance based on the global allowance, the island's current power consumption, and the total current power consumption
+		for(unsigned int islandIndex = 0; islandIndex < totalNumberIslands; islandIndex++){
+			pthread_mutex_lock(&flagIslandAllowance[islandIndex]);
+			islandAllowance[islandIndex] = totalAllowance*((totalCurrentPowerConsumption - islandCurrentPowerConsumption[islandIndex])/totalCurrentPowerConsumption);
+			pthread_mutex_unlock(&flagIslandAllowance[islandIndex]);
+		}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+		// If the only application running is the scheduler finish the simulation
+		if(applications.size() <= 0){
+			// Finilize the ROI and exit the application
+			parmacs_roi_end();
+			exit(0);
+		}
+	}
+
+
+
+	// Now wait for the threads of the core and island agents to finish
+	for(unsigned int i = 0; i < totalNumberCores; i++){
+		pthread_join(threadCoreAgent[i], NULL);
+	}
+	for(unsigned int i = 0; i < totalNumberIslands; i++){
+		pthread_join(threadIslandAgent[i], NULL);
+	}
+
+	// Finilize the ROI and exit the application
+	parmacs_roi_end();
+
+	exit(0);
+}
+
+
+
+
+void *coreAgent(void * arg)
+{
+	// Migrate the core agent to the corresponding core
+	int coreAgentNumber = *((int *)arg);
+	SimSetOwnAffinity(coreAgentNumber);
+
+	int coreInIsland = coreAgentNumber / coresPerIsland;
+
+	double coreAllowance;
+	double taskBid = TDP / totalNumberCores;
+	unsigned int coreSupply;
+
+
+/*	stringstream fileName;
+	fileName << "/home/santiago/sniper/coreAgent_" << coreAgentNumber;
+	ofstream outputStream;
+	outputStream.open(fileName.str().c_str());
+	if (outputStream.is_open()){
+		if (outputStream.good()){
+			outputStream.precision(12);
+		}
+		else{
+			cout << "Error: Output file: \"" << fileName.str() << "\" could not be open for writing." << endl; fflush(NULL);
+			outputStream.close();
+		}
+	}
+	else{
+		cout << "Error: Output file: \"" << fileName.str() << "\" could not be open for writing." << endl; fflush(NULL);
+	}*/
+
+
+
+
+
+	struct timespec end;
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned int currentTime;
+	unsigned int lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+	while(1){
+		//unsigned long threadId = SimGetThreadId();
+		//clock_gettime(CLOCK_MONOTONIC, &end);
+		//double printTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		//outputStream << "Time: " << printTime/1000000 << " \tCore agent: " << coreAgentNumber << " \tThread ID: " << threadId << endl;
+
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		if(SCHEDULING_INTERVAL > (currentTime - lastTime))
+			usleep( SCHEDULING_INTERVAL - currentTime + lastTime);
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+
+
+
+		// Check if there is a thread mapped to this core
+		pthread_mutex_lock(&flagCoreMapping[coreAgentNumber]);
+		int mappedThreadId = cores[coreAgentNumber].mappedThreadId;
+		pthread_mutex_unlock(&flagCoreMapping[coreAgentNumber]);
+
+		// If there is thread mapped to this core, proceed with the computation
+		if(mappedThreadId >= 0){
+
+			// Update the value of the core allowance
+			pthread_mutex_lock(&flagIslandAllowance[coreInIsland]);
+			coreAllowance = islandAllowance[coreInIsland] / coresPerIsland;
+			pthread_mutex_unlock(&flagIslandAllowance[coreInIsland]);
+
+			// The core supply is the core's frequency
+			coreSupply = SimGetOwnFreqMHz();
+
+			// The core's price is adapted according to the current task bid
+			pthread_mutex_lock(&flagCorePrice[coreAgentNumber]);
+			corePrice[coreAgentNumber] = taskBid / coreSupply;
+			pthread_mutex_unlock(&flagCorePrice[coreAgentNumber]);
+
+
+			// Update the bid of the task
+			double bidCap = coreAllowance*2 - taskBid;
+			taskBid = taskBid + (MAX_FREQUENCY - coreSupply)*(taskBid / coreSupply);
+			if(taskBid > bidCap)
+				taskBid = bidCap;
+		}
+		// If there are no threads mapped to this core, then the price of the core is zero
+		else{
+			pthread_mutex_lock(&flagCorePrice[coreAgentNumber]);
+			corePrice[coreAgentNumber] = 0;
+			pthread_mutex_unlock(&flagCorePrice[coreAgentNumber]);
+
+			taskBid = TDP / totalNumberCores;
+		}
+	}
+
+
+	return 0;
+}
+
+
+
+
+void *islandAgent(void * arg)
+{
+	// Migrate the island agent to the first core of the corresponding island
+	int islandAgentNumber = *((int *)arg);
+	SimSetOwnAffinity(islandAgentNumber * coresPerIsland);
+
+
+
+
+
+	struct timespec end;
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned int currentTime;
+	unsigned int lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+	while(1){
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		if(SCHEDULING_INTERVAL > (currentTime - lastTime))
+			usleep( SCHEDULING_INTERVAL - currentTime + lastTime);
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+
+
+
+		// Check if there was a thermal violation and reduce the frequency in such a case. This is not part of the price theory paper, but it is an
+		// easy way to include a DTM technique
+		bool thermalViolation = false;
+		for(int core = 0; core < coresPerIsland; core++){
+			if((((float)SimGetTemperature(core + islandAgentNumber * coresPerIsland))/1000000) > Tdtm){
+				thermalViolation = true;
+				break;
+			}
+		}
+		if(thermalViolation == true){
+			unsigned int currentIslandFrequency = SimGetFreqMHz(islandAgentNumber * coresPerIsland);
+			if(currentIslandFrequency > MIN_FREQUENCY){
+				SimSetFreqMHz(islandAgentNumber * coresPerIsland, currentIslandFrequency - FREQUENCY_STEP);
+			}
+		}
+		else{
+			// Check if we need to increase of decrease DVFS due to inflation or delfation of the cores' prices
+			// Increasing DVFS has priority over decreasing it
+			bool increaseDVFS = false;
+			bool decreaseDVFS = false;
+			for(int coreNumber = 0; coreNumber < coresPerIsland; coreNumber++){
+				unsigned int auxCoreNumber = coreNumber + islandAgentNumber * coresPerIsland;
+				pthread_mutex_lock(&flagCoreMapping[auxCoreNumber]);
+				int mappedThreadId = cores[auxCoreNumber].mappedThreadId;
+				pthread_mutex_unlock(&flagCoreMapping[auxCoreNumber]);
+
+				// Only decide to change the DVFS levels of an island based on the active cores
+				if(mappedThreadId >= 0){
+					pthread_mutex_lock(&flagCorePrice[auxCoreNumber]);
+					double auxCorePrice = corePrice[auxCoreNumber];
+					pthread_mutex_unlock(&flagCorePrice[auxCoreNumber]);
+
+					pthread_mutex_lock(&flagCoreBasePrice[auxCoreNumber]);
+					double auxCoreBasePrice = coreBasePrice[auxCoreNumber];
+					pthread_mutex_unlock(&flagCoreBasePrice[auxCoreNumber]);
+
+					if(auxCorePrice >= (auxCoreBasePrice + auxCoreBasePrice*dvfsChangeToleranceFactor)){
+						increaseDVFS = true;
+						break;
+					}
+					else if(auxCorePrice <= (auxCoreBasePrice - auxCoreBasePrice*dvfsChangeToleranceFactor)){
+						decreaseDVFS = true;
+					}
+				}
+			}
+
+			// If we are going to change the DVFS levels, reset the base prices to the current prices
+			if((increaseDVFS == true) || (decreaseDVFS == true)){
+				for(int coreNumber = 0; coreNumber < coresPerIsland; coreNumber++){
+					unsigned int auxCoreNumber = coreNumber + islandAgentNumber * coresPerIsland;
+					pthread_mutex_lock(&flagCorePrice[auxCoreNumber]);
+					double auxCorePrice = corePrice[auxCoreNumber];
+					pthread_mutex_unlock(&flagCorePrice[auxCoreNumber]);
+
+					pthread_mutex_lock(&flagCoreBasePrice[auxCoreNumber]);
+					coreBasePrice[auxCoreNumber] = auxCorePrice;
+					pthread_mutex_unlock(&flagCoreBasePrice[auxCoreNumber]);
+				}
+			}
+
+			// Effectively change the levels
+			if(increaseDVFS == true){
+				unsigned int currentIslandFrequency = SimGetFreqMHz(islandAgentNumber * coresPerIsland);
+				if(currentIslandFrequency < MAX_FREQUENCY){
+					SimSetFreqMHz(islandAgentNumber * coresPerIsland, currentIslandFrequency + FREQUENCY_STEP);
+				}
+			}
+			else if(decreaseDVFS == true){
+				unsigned int currentIslandFrequency = SimGetFreqMHz(islandAgentNumber * coresPerIsland);
+				if(currentIslandFrequency > MIN_FREQUENCY){
+					SimSetFreqMHz(islandAgentNumber * coresPerIsland, currentIslandFrequency - FREQUENCY_STEP);
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+
diff -Naur local_old/schedulerTemplate/schedulerTemplate.cc local/schedulerTemplate/schedulerTemplate.cc
--- local_old/schedulerTemplate/schedulerTemplate.cc	1970-01-01 01:00:00.000000000 +0100
+++ local/schedulerTemplate/schedulerTemplate.cc	2017-07-28 15:07:48.411928000 +0200
@@ -0,0 +1,472 @@
+
+#include <iostream>
+#include <stdio.h>
+#include <stdlib.h>
+#include <algorithm>
+#include <unistd.h>
+#include <string.h>
+#include <time.h>
+#include <vector>
+#include <math.h>
+#include <float.h>
+#include <string>
+#include <fstream>
+#include <sstream>
+#include <stdexcept>
+
+#include "hooks_base.h"
+#include "sim_api.h"
+
+using namespace std;
+
+
+#define nullptr NULL
+
+#ifndef T_KELVIN_H_
+#define T_KELVIN_H_
+const long double T_KELVIN = 273.15;
+#endif /* T_KELVIN_H_ */
+
+
+#define TOTAL_POWER_BUDGET	250.0
+#define MAX_FREQUENCY	4000
+#define MIN_FREQUENCY	200
+#define FREQUENCY_STEP	200
+
+
+// Units in miliseconds
+//double SECONDS_TO_EXEC_TIME_UNIT = 1000.0;
+//double NANOSECONDS_TO_EXEC_TIME_UNIT = 1000000.0;
+// Units in microseconds
+double SECONDS_TO_EXEC_TIME_UNIT = 1000000.0;
+double NANOSECONDS_TO_EXEC_TIME_UNIT = 1000.0;
+
+#define SCHEDULING_INTERVAL		1000
+
+
+vector<pthread_t> threadCoreAgent;
+vector<pthread_t> threadIslandAgent;
+struct timespec start;
+
+long coresPerIsland;
+
+void *coreAgent(void * arg);
+void *islandAgent(void * arg);
+
+
+
+
+
+
+
+double Tamb = 45 + T_KELVIN;
+double Tdtm = 65 + T_KELVIN;
+
+
+class Thread{
+public:
+	int threadId;
+	int mappedToCore;
+
+	Thread(){
+		threadId = -1;
+		mappedToCore = -1;
+	}
+};
+
+class Application{
+public:
+	unsigned int appId;
+	vector<Thread> threads;
+
+	Application(){
+		appId = 0;
+	}
+};
+
+vector<Application> applications;
+
+
+
+class Core{
+public:
+	int mappedThreadId;
+
+	Core(){
+		mappedThreadId = -1;
+	}
+};
+
+vector<Core> cores;
+vector<pthread_mutex_t> flagCoreMapping;
+
+
+int main(int argc, char* argv[])
+{
+	// Get initial time
+	struct timespec end;
+	clock_gettime(CLOCK_MONOTONIC, &start);
+
+	// Initialize the number of cores per island as pass in the command line
+	if (argc > 1)
+		coresPerIsland = atoi(argv[1]);
+	else
+		coresPerIsland = 1;
+
+	// Start ROI
+	parmacs_roi_begin();
+
+
+	long unsigned int totalNumberCores;
+	if(SimInSimulator())
+		totalNumberCores = SimGetNumProcs();
+	else
+		totalNumberCores = 64;
+	int totalNumberIslands = totalNumberCores / coresPerIsland;
+	cout << "There are " << totalNumberIslands << " islands in the system" << endl; fflush(NULL);
+
+
+	// Initiliaze the income multipliers and the temperature region limits
+	pthread_mutex_t mutexAux = PTHREAD_MUTEX_INITIALIZER;
+	for(unsigned int i = 0; i < totalNumberCores; i++){
+		Core newCore;
+		cores.push_back(newCore);
+		flagCoreMapping.push_back(mutexAux);
+	}
+	for(unsigned int i = 0; i < totalNumberIslands; i++){
+
+	}
+
+
+
+	// Initiliaze a vector containing all applications
+	int totalNumberThreads = SimGetNumThreads();
+	for(unsigned int thread = 0; thread < totalNumberThreads; thread++){
+		unsigned int appId = SimGetThreadAppId(thread);
+
+		int appIndex = -1;
+		for(unsigned int appIndexAux = 0; appIndexAux < applications.size(); appIndexAux++){
+			if(applications[appIndexAux].appId == appId){
+				appIndex = appIndexAux;
+				break;
+			}
+		}
+
+		if(appIndex < 0){
+			Application newApplication;
+			newApplication.appId = appId;
+			applications.push_back(newApplication);
+		}
+	}
+	cout << "Total Number of Applications: " << applications.size() << endl; fflush(NULL);
+
+
+
+
+	// Initialize the thread variables, and start every core agent thread
+	vector<int> coreAgentNumber;
+	for(unsigned int i = 0; i < totalNumberCores; i++){
+		threadCoreAgent.push_back(0);
+		coreAgentNumber.push_back((int) i);
+	}
+	for(unsigned int i = 0; i < totalNumberCores; i++){
+		if (pthread_create(&threadCoreAgent[i], NULL, &coreAgent, (void *)&coreAgentNumber[i])) {
+			cout << "Failed Thread Core Agent" << endl; fflush(NULL);
+			exit(0);
+		}
+	}
+
+	// Same thing for the islands
+	vector<int> islandAgentNumber;
+	for(unsigned int i = 0; i < totalNumberIslands; i++){
+		threadIslandAgent.push_back(0);
+		islandAgentNumber.push_back((int) i);
+	}
+	for(unsigned int i = 0; i < totalNumberIslands; i++){
+		if (pthread_create(&threadIslandAgent[i], NULL, &islandAgent, (void *)&islandAgentNumber[i])) {
+			cout << "Failed Thread Island Agent" << endl; fflush(NULL);
+			exit(0);
+		}
+	}
+
+
+
+
+
+
+
+
+	usleep( 2*SCHEDULING_INTERVAL );
+	cout << "Entering infinite scheduling loop" << endl; fflush(NULL);
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned int currentTime;
+	unsigned int lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+	while(1){
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		if(SCHEDULING_INTERVAL > (currentTime - lastTime))
+			usleep( SCHEDULING_INTERVAL - currentTime + lastTime);
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+
+		// Get total number of threads and iterate through them
+		totalNumberThreads = SimGetNumThreads();
+		for(int thread = 0; thread < totalNumberThreads; thread++){
+			unsigned int appId = SimGetThreadAppId(thread);
+
+			// Find the index of the application
+			int appIndex = -1;
+			for(unsigned int appIndexAux = 0; appIndexAux < applications.size(); appIndexAux++){
+				if(applications[appIndexAux].appId == appId){
+					appIndex = appIndexAux;
+					break;
+				}
+			}
+
+			if(appIndex >= 0){
+				// Now find the index of the thread
+				int threadIndex = -1;
+				for(unsigned int threadInApplication = 0; threadInApplication < applications[appIndex].threads.size(); threadInApplication++){
+					if(applications[appIndex].threads[threadInApplication].threadId == thread){
+						threadIndex = threadInApplication;
+						break;
+					}
+				}
+
+				// If the index was less than zero, this thread was not in the list of thread of the applicaiton
+				if(threadIndex < 0){
+					// Verify that the thread is not finished, as we could have already removed it from the list because it is finished
+					if(SimIsThreadFinished(thread) == false){
+						Thread newThread;
+						newThread.threadId = thread;
+						applications[appIndex].threads.push_back(newThread);
+					}
+				}
+				else{
+					// If the thread already existed, verify that it has not finished
+					if(SimIsThreadFinished(thread)){
+
+						// If the thread is finished, we indicate that the thread is no longer mapped to that core
+						int threadMappedToCore = applications[appIndex].threads[threadIndex].mappedToCore;
+
+						pthread_mutex_lock(&flagCoreMapping[threadMappedToCore]);
+						cores[threadMappedToCore].mappedThreadId = -1;
+						pthread_mutex_unlock(&flagCoreMapping[threadMappedToCore]);
+
+						applications[appIndex].threads.erase(applications[appIndex].threads.begin() + threadIndex);
+						if(applications[appIndex].threads.size() == 0){
+							applications.erase(applications.begin() + appIndex);
+						}
+					}
+				}
+			}
+			else{
+				if(SimIsThreadFinished(thread) == false){
+					cout << "ERROR: New application found after initialization!!" << endl; fflush(NULL);
+				}
+			}
+		}
+
+
+
+		for(unsigned int appIndex = 1; appIndex < applications.size(); appIndex++){
+			cout << "Application " << applications[appIndex].appId << endl;
+			if(applications[appIndex].threads.size() > 0){
+				for(unsigned int threadInApplication = 0; threadInApplication < applications[appIndex].threads.size(); threadInApplication++){
+					cout << "   Thread " << applications[appIndex].threads[threadInApplication].threadId << endl;
+				}
+			}
+			else{
+				cout << "   Finished" << endl;
+			}
+		}
+		fflush(NULL);
+
+
+
+
+
+		// Check if there is any new thread to be mapped. Threads will already have being mapped by Sniper's scheduler, but we now migrate them
+		// to the core we want.
+		for(unsigned int appIndex = 1; appIndex < applications.size(); appIndex++){
+			for(unsigned int threadInApplication = 0; threadInApplication < applications[appIndex].threads.size(); threadInApplication++){
+				// mappedToCore < 0 means that the thread is unmapped
+				if(applications[appIndex].threads[threadInApplication].mappedToCore < 0){
+
+
+					int coreIndexToMapApplication = -1;
+					int islandToMapApplication = -1;
+					for(unsigned int islandNumber = 0; islandNumber < totalNumberIslands; islandNumber++){
+						for(int coreNumber = 0; coreNumber < coresPerIsland; coreNumber++){
+							int auxCoreNumber = coreNumber + islandNumber * coresPerIsland;
+							pthread_mutex_lock(&flagCoreMapping[auxCoreNumber]);
+							if(cores[auxCoreNumber].mappedThreadId < 0){
+								coreIndexToMapApplication = auxCoreNumber;
+								islandToMapApplication = islandNumber;
+								pthread_mutex_unlock(&flagCoreMapping[auxCoreNumber]);
+								break;
+							}
+							pthread_mutex_unlock(&flagCoreMapping[auxCoreNumber]);
+						}
+					}
+
+
+					cout << "Mapping for application " << applications[appIndex].appId << " thread " << applications[appIndex].threads[threadInApplication].threadId << " to core " << coreIndexToMapApplication << " in island " << islandToMapApplication << endl; fflush(NULL);
+					if((coreIndexToMapApplication >= 0) && (islandToMapApplication >= 0)){
+						// After finding the core with highest global savings, migrate the thread to that core
+						applications[appIndex].threads[threadInApplication].mappedToCore = coreIndexToMapApplication;
+						pthread_mutex_lock(&flagCoreMapping[coreIndexToMapApplication]);
+						cores[coreIndexToMapApplication].mappedThreadId = applications[appIndex].threads[threadInApplication].threadId;
+						pthread_mutex_unlock(&flagCoreMapping[coreIndexToMapApplication]);
+
+						if(SimInSimulator()){
+							SimSetThreadAffinity(applications[appIndex].threads[threadInApplication].threadId, coreIndexToMapApplication);
+						}
+
+					}
+				}
+			}
+		}
+
+
+
+
+
+
+
+
+
+
+		// If the only application running is the scheduler finish the simulation
+		if(applications.size() <= 1){
+			// Finilize the ROI and exit the application
+			parmacs_roi_end();
+			exit(0);
+		}
+	}
+
+
+
+	// Now wait for the threads of the core and island agents to finish
+	for(unsigned int i = 0; i < totalNumberCores; i++){
+		pthread_join(threadCoreAgent[i], NULL);
+	}
+	for(unsigned int i = 0; i < totalNumberIslands; i++){
+		pthread_join(threadIslandAgent[i], NULL);
+	}
+
+	// Finilize the ROI and exit the application
+	parmacs_roi_end();
+
+	exit(0);
+}
+
+
+
+
+void *coreAgent(void * arg)
+{
+	// Migrate the core agent to the corresponding core
+	int coreAgentNumber = *((int *)arg);
+	if(SimInSimulator())
+		SimSetOwnAffinity(coreAgentNumber);
+
+
+/*	stringstream fileName;
+	fileName << "/home/santiago/sniper/coreAgent_" << coreAgentNumber;
+	ofstream outputStream;
+	outputStream.open(fileName.str().c_str());
+	if (outputStream.is_open()){
+		if (outputStream.good()){
+			outputStream.precision(12);
+		}
+		else{
+			cout << "Error: Output file: \"" << fileName.str() << "\" could not be open for writing." << endl; fflush(NULL);
+			outputStream.close();
+		}
+	}
+	else{
+		cout << "Error: Output file: \"" << fileName.str() << "\" could not be open for writing." << endl; fflush(NULL);
+	}*/
+
+
+
+
+
+	struct timespec end;
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned int currentTime;
+	unsigned int lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+	while(1){
+		//unsigned long threadId = SimGetThreadId();
+		//clock_gettime(CLOCK_MONOTONIC, &end);
+		//double printTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		//outputStream << "Time: " << printTime/1000000 << " \tCore agent: " << coreAgentNumber << " \tThread ID: " << threadId << endl;
+
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		if(SCHEDULING_INTERVAL > (currentTime - lastTime))
+			usleep( SCHEDULING_INTERVAL - currentTime + lastTime);
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+
+		// Get own temperature and temperature
+		double temperature;
+		double power;
+		if(SimInSimulator()){
+			temperature = ((double)SimGetOwnTemperature())/1000000.0;
+			power = ((double)SimGetOwnPower())/1000000.0;
+		}
+		else{
+			temperature = 0;
+			power = 0;
+		}
+
+
+	}
+
+
+	return 0;
+}
+
+
+
+
+void *islandAgent(void * arg)
+{
+	// Migrate the island agent to the first core of the corresponding island
+	int islandAgentNumber = *((int *)arg);
+	if(SimInSimulator())
+		SimSetOwnAffinity(islandAgentNumber * coresPerIsland);
+
+
+	vector<double> powerCores;
+	for(int core = 0; core < coresPerIsland; core++){
+		powerCores.push_back(0);
+	}
+
+
+
+
+
+	struct timespec end;
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	unsigned int currentTime;
+	unsigned int lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+	while(1){
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		currentTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+		if(SCHEDULING_INTERVAL > (currentTime - lastTime))
+			usleep( SCHEDULING_INTERVAL - currentTime + lastTime);
+		clock_gettime(CLOCK_MONOTONIC, &end);
+		lastTime = (((double)(end.tv_sec - start.tv_sec))*SECONDS_TO_EXEC_TIME_UNIT + ((double)(end.tv_nsec - start.tv_nsec))/NANOSECONDS_TO_EXEC_TIME_UNIT);
+
+
+
+	}
+
+	return 0;
+}
+
