diff -Naur temp/flp.c HotSpot/flp.c
--- temp/flp.c	2017-11-20 10:04:24.517682836 +0100
+++ HotSpot/flp.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1630 +0,0 @@
-#include <stdio.h>
-#include <string.h>
-#include <string.h>
-#ifdef _MSC_VER
-#define strcasecmp    _stricmp
-#define strncasecmp   _strnicmp
-#else
-#include <strings.h>
-#endif
-#include <stdlib.h>
-#include <math.h>
-
-#include "flp.h"
-#include "npe.h"
-#include "shape.h"
-#include "util.h"
-#include "temperature.h"
-#include "temperature_block.h"
-
-/* 
- * this is the metric function used for the floorplanning. 
- * in order to enable a different metric, just change the 
- * return statement of this function to return an appropriate
- * metric. The current metric used is a linear function of
- * area (A), temperature (T) and wire length (W):
- * lambdaA * A + lambdaT * T  + lambdaW * W
- * thermal model and power density are passed as parameters
- * since temperature is used in the metric. 
- */
-double flp_evaluate_metric(flp_t *flp, RC_model_t *model, double *power,
-						   double lambdaA, double lambdaT, double lambdaW)
-{
-	double tmax, area, wire_length, width, height, aspect;
-	double *temp;
-
-	temp = hotspot_vector(model);
-	populate_R_model(model, flp);
-	steady_state_temp(model, power, temp);
-	tmax = find_max_temp(model, temp);
-	area = get_total_area(flp);
-	wire_length = get_wire_metric(flp);
-	width = get_total_width(flp);
-	height = get_total_height(flp);
-	if (width > height)
-		aspect = width / height; 
-	else
-		aspect = height / width;
-	free_dvector(temp);
-
-	/* can return any arbitrary function of area, tmax and wire_length	*/
-	return (lambdaA * area + lambdaT * tmax + lambdaW * wire_length);
-}
-
-
-/* default flp_config	*/
-flp_config_t default_flp_config(void)
-{
-	flp_config_t config;
-
-	/* wrap around L2?	*/
-	config.wrap_l2 = TRUE;
-	strcpy(config.l2_label, "L2");
-	
-	/* model dead space around the rim of the chip? */
-	config.model_rim = FALSE;
-	config.rim_thickness = 50e-6;
-
-	/* area ratio below which to ignore dead space	*/
-	config.compact_ratio = 0.005;
-
-	/* 
-	 * no. of discrete orientations for a shape curve.
-	 * should be an even number greater than 1
-	 */
-	config.n_orients = 300;
-	
-	/* annealing parameters	*/
-	config.P0 = 0.99;		/* initial acceptance probability	*/
-	/* 
-	 * average change (delta) in cost. varies according to
-	 * the metric. need not be very accurate. just the right
-	 * order of magnitude is enough. for instance, if the
-	 * metric is flp area, this Davg is the average difference
-	 * in the area of successive slicing floorplan attempts.
-	 * since the areas are in the order of mm^2, the delta
-	 * is also in the same ball park. 
-	 */
-	config.Davg = 1.0;		/* for our a*A + b*T + c*W metric	*/
-	config.Kmoves = 7.0;	/* no. of moves to try in each step	*/
-	config.Rcool = 0.99;	/* ratio for the cooling schedule */
-	config.Rreject = 0.99;	/* ratio of rejects at which to stop annealing */
-	config.Nmax = 1000;		/* absolute max no. of annealing steps	*/
-
-	/* weights for the metric: lambdaA * A + lambdaT * T + lambdaW * W
-	 * the weights incorporate two things: 
-	 * 1) the conversion of A to mm^2, T to K and W to mm. 
-	 * 2) weighing the relative importance of A, T and K
-	 */
-	config.lambdaA = 5.0e+6;
-	config.lambdaT = 1.0;
-	config.lambdaW = 350;
-
-	return config;
-}
-
-/* 
- * parse a table of name-value string pairs and add the configuration
- * parameters to 'config'
- */
-void flp_config_add_from_strs(flp_config_t *config, str_pair *table, int size)
-{
-	int idx;
-	if ((idx = get_str_index(table, size, "wrap_l2")) >= 0)
-		if(sscanf(table[idx].value, "%d", &config->wrap_l2) != 1)
-			fatal("invalid format for configuration  parameter wrap_l2\n");
-	if ((idx = get_str_index(table, size, "l2_label")) >= 0)
-		if(sscanf(table[idx].value, "%s", config->l2_label) != 1)
-			fatal("invalid format for configuration  parameter l2_label\n");
-	if ((idx = get_str_index(table, size, "model_rim")) >= 0)
-		if(sscanf(table[idx].value, "%d", &config->model_rim) != 1)
-			fatal("invalid format for configuration  parameter model_rim\n");
-	if ((idx = get_str_index(table, size, "rim_thickness")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->rim_thickness) != 1)
-			fatal("invalid format for configuration  parameter rim_thickness\n");
-	if ((idx = get_str_index(table, size, "compact_ratio")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->compact_ratio) != 1)
-			fatal("invalid format for configuration  parameter compact_ratio\n");
-	if ((idx = get_str_index(table, size, "n_orients")) >= 0)
-		if(sscanf(table[idx].value, "%d", &config->n_orients) != 1)
-			fatal("invalid format for configuration  parameter n_orients\n");
-	if ((idx = get_str_index(table, size, "P0")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->P0) != 1)
-			fatal("invalid format for configuration  parameter P0\n");
-	if ((idx = get_str_index(table, size, "Davg")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->Davg) != 1)
-			fatal("invalid format for configuration  parameter Davg\n");
-	if ((idx = get_str_index(table, size, "Kmoves")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->Kmoves) != 1)
-			fatal("invalid format for configuration  parameter Kmoves\n");
-	if ((idx = get_str_index(table, size, "Rcool")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->Rcool) != 1)
-			fatal("invalid format for configuration  parameter Rcool\n");
-	if ((idx = get_str_index(table, size, "Rreject")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->Rreject) != 1)
-			fatal("invalid format for configuration  parameter Rreject\n");
-	if ((idx = get_str_index(table, size, "Nmax")) >= 0)
-		if(sscanf(table[idx].value, "%d", &config->Nmax) != 1)
-			fatal("invalid format for configuration  parameter Nmax\n");
-	if ((idx = get_str_index(table, size, "lambdaA")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->lambdaA) != 1)
-			fatal("invalid format for configuration  parameter lambdaA\n");
-	if ((idx = get_str_index(table, size, "lambdaT")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->lambdaT) != 1)
-			fatal("invalid format for configuration  parameter lambdaT\n");
-	if ((idx = get_str_index(table, size, "lambdaW")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->lambdaW) != 1)
-			fatal("invalid format for configuration  parameter lambdaW\n");
-			
-	if (config->rim_thickness <= 0)
-		fatal("rim thickness should be greater than zero\n");
-	if ((config->compact_ratio < 0) || (config->compact_ratio > 1))
-		fatal("compact_ratio should be between 0 and 1\n");
-	if ((config->n_orients <= 1) || (config->n_orients & 1))
-		fatal("n_orients should be an even number greater than 1\n");
-	if (config->Kmoves < 0)
-		fatal("Kmoves should be non-negative\n");
-	if ((config->P0 < 0) || (config->P0 > 1))
-		fatal("P0 should be between 0 and 1\n");
-	if ((config->Rcool < 0) || (config->Rcool > 1))
-		fatal("Rcool should be between 0 and 1\n");
-	if ((config->Rreject < 0) || (config->Rreject > 1))
-		fatal("Rreject should be between 0 and 1\n");
-	if (config->Nmax < 0)
-		fatal("Nmax should be non-negative\n");
-}
-
-/* 
- * convert config into a table of name-value pairs. returns the no.
- * of parameters converted
- */
-int flp_config_to_strs(flp_config_t *config, str_pair *table, int max_entries)
-{
-	if (max_entries < 15)
-		fatal("not enough entries in table\n");
-
-	sprintf(table[0].name, "wrap_l2");
-	sprintf(table[1].name, "l2_label");
-	sprintf(table[2].name, "model_rim");
-	sprintf(table[3].name, "rim_thickness");
-	sprintf(table[4].name, "compact_ratio");
-	sprintf(table[5].name, "n_orients");
-	sprintf(table[6].name, "P0");
-	sprintf(table[7].name, "Davg");
-	sprintf(table[8].name, "Kmoves");
-	sprintf(table[9].name, "Rcool");
-	sprintf(table[10].name, "Rreject");
-	sprintf(table[11].name, "Nmax");
-	sprintf(table[12].name, "lambdaA");
-	sprintf(table[13].name, "lambdaT");
-	sprintf(table[14].name, "lambdaW");
-
-	sprintf(table[0].value, "%d", config->wrap_l2);
-	sprintf(table[1].value, "%s", config->l2_label);
-	sprintf(table[2].value, "%d", config->model_rim);
-	sprintf(table[3].value, "%lg", config->rim_thickness);
-	sprintf(table[4].value, "%lg", config->compact_ratio);
-	sprintf(table[5].value, "%d", config->n_orients);
-	sprintf(table[6].value, "%lg", config->P0);
-	sprintf(table[7].value, "%lg", config->Davg);
-	sprintf(table[8].value, "%lg", config->Kmoves);
-	sprintf(table[9].value, "%lg", config->Rcool);
-	sprintf(table[10].value, "%lg", config->Rreject);
-	sprintf(table[11].value, "%d", config->Nmax);
-	sprintf(table[12].value, "%lg", config->lambdaA);
-	sprintf(table[13].value, "%lg", config->lambdaT);
-	sprintf(table[14].value, "%lg", config->lambdaW);
-
-	return 15;
-}
-
-/* 
- * copy L2 connectivity from 'from' of flp_desc to 'to' 
- * of flp. 'size' elements are copied. the arms are not 
- * connected amidst themselves or with L2 base block
- */
-void copy_l2_info (flp_t *flp, int to, flp_desc_t *flp_desc, int from, int size)
-{
-	int j, count;
-
-	for(count=0; count < L2_ARMS + 1; count++, to++) {
-		/* copy names */
-		strcpy(flp->units[to].name, flp_desc->units[from].name);
-		for(j=0; j < size; j++) {
-			/* rows	*/
-			flp->wire_density[to][j] = flp_desc->wire_density[from][j];
-			/* columns	*/	
-			flp->wire_density[j][to] = flp_desc->wire_density[j][from];
-		}
-	}
-	/* fix the names of the arms	*/
-	strcat(flp->units[to-L2_ARMS+L2_LEFT].name, L2_LEFT_STR);	
-	strcat(flp->units[to-L2_ARMS+L2_RIGHT].name, L2_RIGHT_STR);
-}
-
-
-/* create a floorplan placeholder from description	*/
-flp_t *flp_placeholder(flp_desc_t *flp_desc)
-{
-	int i, j, count, n_dead;
-	flp_t *flp;
-
-	/* wrap L2 around?	*/
-	int wrap_l2 = FALSE;
-	if (flp_desc->config.wrap_l2 && 
-		!strcasecmp(flp_desc->units[flp_desc->n_units-1].name, flp_desc->config.l2_label))
-		wrap_l2 = TRUE;
-
-	flp = (flp_t *) calloc (1, sizeof(flp_t));
-	if(!flp)
-		fatal("memory allocation error\n");
-	/* 
-	 * number of dead blocks = no. of core blocks - 1.
-	 * (one per vertical or horizontal cut). if L2 is 
-	 * wrapped around, core blocks = flp_desc->n_units-1
-	 */
-	n_dead = flp_desc->n_units - !!(wrap_l2) - 1; 
-	flp->n_units = flp_desc->n_units + n_dead;
-
-	/* wrap L2 around - extra arms are added */
-	if (wrap_l2)
-		flp->n_units += L2_ARMS;
-
-	/* 
-	 * model the dead space in the edge. let us make
-	 * one dead block per corner edge of a block. so, 
-	 * no. of rim blocks could be at most 2*n+2 where
-	 * n is the total no. of blocks (the worst case
-	 * is just all blocks lined up side-by-side)
-	 */
-	if (flp_desc->config.model_rim)
-		flp->n_units += (2*flp->n_units + 2);
-
-	flp->units = (unit_t *) calloc (flp->n_units, sizeof(unit_t));
-	flp->wire_density = (double **) calloc(flp->n_units, sizeof(double *));
-	if (!flp->units || !flp->wire_density)
-		fatal("memory allocation error\n");
-	for (i=0; i < flp->n_units; i++) {
-	  flp->wire_density[i] = (double *) calloc(flp->n_units, sizeof(double));
-	  if (!flp->wire_density[i])
-	  	fatal("memory allocation error\n");
-	}
-
-	/* copy connectivity (only for non-dead core blocks) */
-	for(i=0; i < flp_desc->n_units-!!(wrap_l2); i++) {
-	  strcpy(flp->units[i].name, flp_desc->units[i].name);
-	  for (j=0; j < flp_desc->n_units-!!(wrap_l2); j++) {
-	  	flp->wire_density[i][j] = flp_desc->wire_density[i][j];
-	  }
-	}
-
-	/* name the dead blocks	*/
-	for(count=0; count < n_dead; count++, i++)
-		sprintf(flp->units[i].name, DEAD_PREFIX"%d", count);
-
-	/* L2 connectivity info	*/
-	if (wrap_l2)
-		copy_l2_info(flp, i, flp_desc, flp_desc->n_units-1, flp_desc->n_units-1);
-
-	return flp;
-}
-
-/* 
- * note that if wrap_l2 is true, L2 is beyond the boundary in flp_desc 
- * but flp contains it within its boundaries.
- */
-void restore_dead_blocks(flp_t *flp, flp_desc_t *flp_desc, 
-						 int compacted, int wrap_l2, 
-						 int model_rim, int rim_blocks)
-{
-	int i, j, idx=0;
-	/* remove L2 and rim blocks and restore the compacted blocks */
-	if(model_rim)
-		flp->n_units -= rim_blocks;
-	if (wrap_l2)
-		flp->n_units -= (L2_ARMS+1);
-	flp->n_units += compacted;
-
-	/* reinitialize the dead blocks	*/
-	for(i=0; i < flp_desc->n_units-1; i++) {
-		idx = flp_desc->n_units + i;
-		sprintf(flp->units[idx].name, DEAD_PREFIX"%d", i);
-		flp->units[idx].leftx = flp->units[idx].bottomy = 0;
-		flp->units[idx].width = flp->units[idx].height = 0;
-		for(j=0; j < flp->n_units; j++)
-			flp->wire_density[idx][j] = flp->wire_density[j][idx] = 0;
-	}
-}
-
-/* translate the floorplan to new origin (x,y)	*/
-void flp_translate(flp_t *flp, double x, double y)
-{
-	int i;
-	double minx = flp->units[0].leftx;
-	double miny = flp->units[0].bottomy;
-
-	for (i=1; i < flp->n_units; i++) {
-		if (minx > flp->units[i].leftx)
-			minx = flp->units[i].leftx;
-		if (miny > flp->units[i].bottomy)
-			miny = flp->units[i].bottomy;
-	}
-	for (i=0; i < flp->n_units; i++) {
-		flp->units[i].leftx += (x - minx);
-		flp->units[i].bottomy += (y - miny);
-	}
-}
-
-/* scale the floorplan by a factor 'factor'	*/
-void flp_scale(flp_t *flp, double factor)
-{
-	int i;
-	double minx = flp->units[0].leftx;
-	double miny = flp->units[0].bottomy;
-
-	for (i=1; i < flp->n_units; i++) {
-		if (minx > flp->units[i].leftx)
-			minx = flp->units[i].leftx;
-		if (miny > flp->units[i].bottomy)
-			miny = flp->units[i].bottomy;
-	}
-	for(i=0; i < flp->n_units; i++) {
-		flp->units[i].leftx = (flp->units[i].leftx - minx) * factor + minx;
-		flp->units[i].bottomy = (flp->units[i].bottomy - miny) * factor + miny;
-		flp->units[i].width *= factor;
-		flp->units[i].height *= factor;
-	}
-}
-
-/* 
- * change the orientation of the floorplan by
- * rotating and/or flipping. the target orientation
- * is specified in 'target'. 'width', 'height', 'xorig'
- * and 'yorig' are those of 'flp' respectively.
- */
-void flp_change_orient(flp_t *flp, double xorig, double yorig,
-					   double width, double height, orient_t target)
-{
-	int i;
-
-	for(i=0; i < flp->n_units; i++) {
-		double leftx, bottomy, rightx, topy;
-		/* all co-ordinate calculations are 
-		 * done assuming (0,0) as the center. 
-		 * so, shift accordingly
-		 */
-		leftx = flp->units[i].leftx  - (xorig + width / 2.0);
-		bottomy = flp->units[i].bottomy - (yorig + height / 2.0);
-		rightx = leftx + flp->units[i].width;
-		topy = bottomy + flp->units[i].height;
-		/* when changing orientation, leftx and 
-		 * bottomy of a rectangle could change
-		 * to one of the other three corners. 
-		 * also, signs of the co-ordinates
-		 * change according to the rotation
-		 * or reflection. Further x & y are
-		 * swapped for rotations that are
-		 * odd multiples of 90 degrees
-		 */
-		switch(target) {
-			case ROT_0:
-					flp->units[i].leftx = leftx;
-					flp->units[i].bottomy = bottomy;
-					break;
-			case ROT_90:
-					flp->units[i].leftx = -topy;
-					flp->units[i].bottomy = leftx;
-					swap_dval(&(flp->units[i].width), &(flp->units[i].height));
-					break;
-			case ROT_180:
-					flp->units[i].leftx = -rightx;
-					flp->units[i].bottomy = -topy;
-					break;
-			case ROT_270:
-					flp->units[i].leftx = bottomy;
-					flp->units[i].bottomy = -rightx;
-					swap_dval(&(flp->units[i].width), &(flp->units[i].height));
-					break;
-			case FLIP_0:
-					flp->units[i].leftx = -rightx;
-					flp->units[i].bottomy = bottomy;
-					break;
-			case FLIP_90:
-					flp->units[i].leftx = bottomy;
-					flp->units[i].bottomy = leftx;
-					swap_dval(&(flp->units[i].width), &(flp->units[i].height));
-					break;
-			case FLIP_180:
-					flp->units[i].leftx = leftx;
-					flp->units[i].bottomy = -topy;
-					break;
-			case FLIP_270:
-					flp->units[i].leftx = -topy;
-					flp->units[i].bottomy = -rightx;
-					swap_dval(&(flp->units[i].width), &(flp->units[i].height));
-					break;
-			default:
-					fatal("unknown orientation\n");
-					break;
-		}
-		/* translate back to original origin	*/
-		flp->units[i].leftx += (xorig + width / 2.0);
-		flp->units[i].bottomy += (yorig + height / 2.0);
-	}
-}
-
-/* 
- * create a non-uniform grid-like floorplan equivalent to this.
- * this function is mainly useful when using the HotSpot block
- * model to model floorplans of drastically differing aspect
- * ratios and granularity. an example for such a floorplan
- * would be the standard ev6 floorplan that comes with HotSpot,
- * where the register file is subdivided into say 128 entries.
- * the HotSpot block model could result in inaccuracies while
- * trying to model such floorplans of differing granularity.
- * if such inaccuracies occur, use this function to create an 
- * equivalent floorplan that can be modeled accurately in 
- * HotSpot. 'map', if non-NULL, is an output parameter to store 
- * the 2-d array allocated by the function.
- */
-flp_t *flp_create_grid(flp_t *flp, int ***map)
-{
-	double x[MAX_UNITS], y[MAX_UNITS];
-	int i, j, n, xsize=0, ysize=0, count=0, found, **ptr;
-	flp_t *grid;
-
-	/* sort the units' boundary co-ordinates	*/
-	for(i=0; i < flp->n_units; i++) {
-		double r, t;
-		r = flp->units[i].leftx + flp->units[i].width;
-		t = flp->units[i].bottomy + flp->units[i].height;
-		if(bsearch_insert_double(x, xsize, flp->units[i].leftx))
-			xsize++;
-		if(bsearch_insert_double(y, ysize, flp->units[i].bottomy))
-			ysize++;
-		if(bsearch_insert_double(x, xsize, r))
-			xsize++;
-		if(bsearch_insert_double(y, ysize, t))
-			ysize++;
-	}
-
-	/* 
-	 * the grid formed by the lines from x and y arrays
-	 * is our desired floorplan. allocate memory for it
-	 */
-	grid = (flp_t *) calloc (1, sizeof(flp_t));
-	if(!grid)
-		fatal("memory allocation error\n");
-	grid->n_units = (xsize-1) * (ysize-1);	
-	grid->units = (unit_t *) calloc (grid->n_units, sizeof(unit_t));
-	grid->wire_density = (double **) calloc(grid->n_units, sizeof(double *));
-	if (!grid->units || !grid->wire_density)
-		fatal("memory allocation error\n");
-	for (i=0; i < grid->n_units; i++) {
-	  grid->wire_density[i] = (double *) calloc(grid->n_units, sizeof(double));
-	  if (!grid->wire_density[i])
-	  	fatal("memory allocation error\n");
-	}
-	/* mapping between blocks of 'flp' to those of 'grid'	*/
-	ptr = (int **) calloc(flp->n_units, sizeof(int *));
-	if (!ptr)
-		fatal("memory allocation error\n");
-	/* 
-	 * ptr is a 2-d array with each row of possibly different
-	 * length. the size of each row is stored in its first element.
-	 * here, it is basically the mapping between 'flp' to 'grid'
-	 * i.e., for each flp->unit, it stores the set of grid->units
-	 * it maps to.
-	 */
-	for(i=0; i < flp->n_units; i++) {
-		ptr[i] = (int *) calloc(grid->n_units+1, sizeof(int));
-		if(!ptr[i])
-	  		fatal("memory allocation error\n");
-	}
-
-	/* 
-	 * now populate the 'grid' blocks and map the blocks 
-	 * from 'flp' to 'grid'. for each block, identify the 
-	 * intervening lines that chop it into grid cells and 
-	 * assign the names of those cells from that of the 
-	 * block
-	 */
-	for(i=0; i < flp->n_units; i++) {
-		double *xstart, *xend, *ystart, *yend;
-		double *ptr1, *ptr2;
-		int grid_num=0;
-		if (!bsearch_double(x, xsize, flp->units[i].leftx, &xstart))
-			fatal("invalid sorted arrays\n");
-		if (!bsearch_double(x, xsize, flp->units[i].leftx+flp->units[i].width, &xend))
-			fatal("invalid sorted arrays\n");
-		if (!bsearch_double(y, ysize, flp->units[i].bottomy, &ystart))
-			fatal("invalid sorted arrays\n");
-		if (!bsearch_double(y, ysize, flp->units[i].bottomy+flp->units[i].height, &yend))
-			fatal("invalid sorted arrays\n");
-		for(ptr1 = xstart; ptr1 < xend; ptr1++)
-			for(ptr2 = ystart; ptr2 < yend; ptr2++) {
-				/* add this grid block if it has not been added already	*/
-				for(n=0, found=FALSE; n < count; n++) {
-					if (grid->units[n].leftx == ptr1[0] && grid->units[n].bottomy == ptr2[0]) {
-						found = TRUE;
-						break;
-					}
-				}
-				if(!found) {
-					sprintf(grid->units[count].name, "%s_%d", flp->units[i].name, grid_num);
-					grid->units[count].leftx = ptr1[0];
-					grid->units[count].bottomy = ptr2[0];
-					grid->units[count].width = ptr1[1]-ptr1[0];
-					grid->units[count].height = ptr2[1]-ptr2[0];
-					/* map between position in 'flp' to that in 'grid'	*/
-					ptr[i][++ptr[i][0]] = count;
-					grid_num++;
-					count++;
-				}
-			}
-	}
-
-	/* sanity check	*/
-	if(count != (xsize-1) * (ysize-1))
-		fatal("mismatch in the no. of units\n");
-
-	/* fill-in the wire densities	*/
-	for(i=0; i < flp->n_units; i++)
-		for(j=0; j < flp->n_units; j++) {
-			int p, q;
-			for(p=1; p <= ptr[i][0]; p++)
-				for(q=1; q <= ptr[j][0]; q++)
-					grid->wire_density[ptr[i][p]][ptr[j][q]] = flp->wire_density[i][j];
-		}
-
-	/* output the map	*/
-	if (map)
-		(*map) = ptr;
-	else
-		free_blkgrid_map(flp, ptr);
-	
-	return grid;
-}
-
-/* free the map allocated by flp_create_grid	*/
-void free_blkgrid_map(flp_t *flp, int **map)
-{
-	int i;
-
-	for(i=0; i < flp->n_units; i++)
-		free(map[i]);
-	free(map);
-}
-
-/* translate power numbers to the grid created by flp_create_grid	*/
-void xlate_power_blkgrid(flp_t *flp, flp_t *grid, \
-						 double *bpower, double *gpower, int **map)
-{
-	int i, p;
-
-	for(i=0; i < flp->n_units; i++)
-		for(p=1; p <= map[i][0]; p++)
-			/* retain the power density	*/
-			gpower[map[i][p]] = bpower[i] / (flp->units[i].width * flp->units[i].height) *\
-								grid->units[map[i][p]].width * grid->units[map[i][p]].height;
-}
-
-/* 
- * wrap the L2 around this floorplan. L2's area information 
- * is obtained from flp_desc. memory for L2 and its arms has
- * already been allocated in the flp. note that flp & flp_desc 
- * have L2 hidden beyond the boundary at this point
- */
-void flp_wrap_l2(flp_t *flp, flp_desc_t *flp_desc)
-{
-	/* 
-	 * x is the width of the L2 arms
-	 * y is the height of the bottom portion
-	 */
-	double x, y, core_width, core_height, total_side, core_area, l2_area;
-	unit_t *l2, *l2_left, *l2_right;
-
-	/* find L2 dimensions so that the total chip becomes a square	*/
-	core_area = get_total_area(flp);
-	core_width = get_total_width(flp);
-	core_height = get_total_height(flp);
-	/* flp_desc has L2 hidden beyond the boundary	*/
-	l2_area = flp_desc->units[flp_desc->n_units].area;
-	total_side = sqrt(core_area + l2_area);
-	/* 
-	 * width of the total chip after L2 wrapping is equal to 
-	 * the width of the core plus the width of the two arms
-	 */
-	x = (total_side - core_width) / 2.0;
-	y = total_side - core_height;
-	/* 
-	 * we are trying to solve the equation 
-	 * (2*x+core_width) * (y+core_height) 
-	 * = l2_area + core_area
-	 * for x and y. it is possible that the values 
-	 * turnout to be negative if we restrict the
-	 * total chip to be a square. in that case,
-	 * theoretically, any value of x in the range
-	 * (0, l2_area/(2*core_height)) and the 
-	 * corresponding value of y or any value of y
-	 * in the range (0, l2_area/core_width) and the
-	 * corresponding value of x would be a solution
-	 * we look for a solution with a reasonable 
-	 * aspect ratio. i.e., we constrain kx = y (or
-	 * ky = x  depending on the aspect ratio of the 
-	 * core) where k = WRAP_L2_RATIO. solving the equation 
-	 * with this constraint, we get the following
-	 */
-	if ( x <= 0 || y <= 0.0) {
-		double sum;
-		if (core_width >= core_height) {
-			sum = WRAP_L2_RATIO * core_width + 2 * core_height;
-			x = (sqrt(sum*sum + 8*WRAP_L2_RATIO*l2_area) - sum) / (4*WRAP_L2_RATIO);
-			y = WRAP_L2_RATIO * x;
-		} else {
-			sum = core_width + 2 * WRAP_L2_RATIO * core_height;
-			y = (sqrt(sum*sum + 8*WRAP_L2_RATIO*l2_area) - sum) / (4*WRAP_L2_RATIO);
-			x = WRAP_L2_RATIO * y;
-		}
-		total_side = 2 * x + core_width;
-	}
-	
-	/* fix the positions of core blocks	*/
-	flp_translate(flp, x, y);
-
-	/* restore the L2 blocks	*/
-	flp->n_units += (L2_ARMS+1);
-	/* copy L2 info again from flp_desc but from beyond the boundary	*/
-	copy_l2_info(flp, flp->n_units-L2_ARMS-1, flp_desc, 
-				 flp_desc->n_units, flp_desc->n_units);
-
-	/* fix the positions of the L2  blocks. connectivity
-	 * information has already been fixed (in flp_placeholder).
-	 * bottom L2 block - (leftx, bottomy) is already (0,0)
-	 */
-	l2 = &flp->units[flp->n_units-1-L2_ARMS];
-	l2->width = total_side;
-	l2->height = y;
-	l2->leftx = l2->bottomy = 0;
-
-	/* left L2 arm */
-	l2_left = &flp->units[flp->n_units-L2_ARMS+L2_LEFT];
-	l2_left->width = x;
-	l2_left->height = core_height;
-	l2_left->leftx = 0;
-	l2_left->bottomy = y;
-
-	/* right L2 arm */
-	l2_right = &flp->units[flp->n_units-L2_ARMS+L2_RIGHT];
-	l2_right->width = x;
-	l2_right->height = core_height;
-	l2_right->leftx = x + core_width;
-	l2_right->bottomy = y;
-}
-
-/*
- * wrap the rim strips around. each edge has rim blocks
- * equal to the number of blocks abutting that edge. at
- * the four corners, the rim blocks are extended by the
- * rim thickness in a clockwise fashion
- */
-int flp_wrap_rim(flp_t *flp, double rim_thickness)
-{
-	double width, height;
-	int i, j = 0, k, n = flp->n_units;
-	unit_t *unit;
-
-	width = get_total_width(flp) + 2 * rim_thickness;
-	height = get_total_height(flp) + 2 * rim_thickness;
-	flp_translate(flp, rim_thickness, rim_thickness);
-
-	for (i = 0; i < n; i++) {
-		/* shortcut	*/
-		unit = &flp->units[i];
-
-		/* block is on the western border	*/
-		if (eq(unit->leftx, rim_thickness)) {
-			sprintf(flp->units[n+j].name, "%s_%s", 
-					RIM_LEFT_STR, unit->name);
-			flp->units[n+j].width = rim_thickness;
-			flp->units[n+j].height = unit->height;
-			flp->units[n+j].leftx = 0;
-			flp->units[n+j].bottomy = unit->bottomy;
-			/* northwest corner	*/
-			if (eq(unit->bottomy + unit->height, height-rim_thickness))
-				flp->units[n+j].height += rim_thickness;
-			j++;
-		}
-
-		/* block is on the eastern border	*/
-		if (eq(unit->leftx + unit->width, width-rim_thickness)) {
-			sprintf(flp->units[n+j].name, "%s_%s", 
-					RIM_RIGHT_STR, unit->name);
-			flp->units[n+j].width = rim_thickness;
-			flp->units[n+j].height = unit->height;
-			flp->units[n+j].leftx = unit->leftx + unit->width;
-			flp->units[n+j].bottomy = unit->bottomy;
-			/* southeast corner	*/
-			if (eq(unit->bottomy, rim_thickness)) {
-				flp->units[n+j].height += rim_thickness;
-				flp->units[n+j].bottomy = 0;
-			}	
-			j++;
-		}
-
-		/* block is on the northern border 	*/
-		if (eq(unit->bottomy + unit->height, height-rim_thickness)) {
-			sprintf(flp->units[n+j].name, "%s_%s", 
-					RIM_TOP_STR, unit->name);
-			flp->units[n+j].width = unit->width;
-			flp->units[n+j].height = rim_thickness;
-			flp->units[n+j].leftx = unit->leftx;
-			flp->units[n+j].bottomy = unit->bottomy + unit->height;
-			/* northeast corner	*/
-			if (eq(unit->leftx + unit->width, width-rim_thickness))
-				flp->units[n+j].width += rim_thickness;
-			j++;
-		}
-
-		/* block is on the southern border	*/
-		if (eq(unit->bottomy, rim_thickness)) {
-			sprintf(flp->units[n+j].name, "%s_%s", 
-					RIM_BOTTOM_STR, unit->name);
-			flp->units[n+j].width = unit->width;
-			flp->units[n+j].height = rim_thickness;
-			flp->units[n+j].leftx = unit->leftx;
-			flp->units[n+j].bottomy = 0;
-			/* southwest corner	*/
-			if (eq(unit->leftx, rim_thickness)) {
-				flp->units[n+j].width += rim_thickness;
-				flp->units[n+j].leftx = 0;
-			}	
-			j++;
-		}
-	}	
-
-	flp->n_units += j;
-
-	/* update all the rim wire densities */
-	for(i=n; i < n+j; i++)
-		for(k=0; k <= i; k++)
-			flp->wire_density[i][k] = flp->wire_density[k][i] = 0;
-
-	return j;
-}
-
-/* 
- * floorplanning using simulated annealing.
- * precondition: flp is a pre-allocated placeholder.
- * returns the number of compacted blocks in the selected
- * floorplan
- */
-int floorplan(flp_t *flp, flp_desc_t *flp_desc, 
-			  RC_model_t *model, double *power)
-{
-	NPE_t *expr, *next, *best;	/* Normalized Polish Expressions */
-	tree_node_stack_t *stack;	/* for NPE evaluation	*/
-	tree_node_t *root;			/* shape curve tree	*/
-	double cost, new_cost, best_cost, sum_cost, T, Tcold;
-	int i, steps, downs, n, rejects, compacted, rim_blocks = 0;
-	int original_n = flp->n_units;
-	int wrap_l2;
-
-	/* to maintain the order of power values during
-	 * the compaction/shifting around of blocks
-	 */
-	double *tpower = hotspot_vector(model);
-
-	/* shortcut	*/
-	flp_config_t cfg = flp_desc->config;
-
-	/* 
-	 * make the rim strips disappear for slicing tree
-	 * purposes. can be restored at the end
-	 */
-	if (cfg.model_rim)
-		flp->n_units = (flp->n_units - 2) / 3;
-
-	/* wrap L2 around?	*/
-	wrap_l2 = FALSE;
-	if (cfg.wrap_l2 && 
-		!strcasecmp(flp_desc->units[flp_desc->n_units-1].name, cfg.l2_label)) {
-		wrap_l2 = TRUE;
-		/* make L2 disappear too */
-		flp_desc->n_units--;
-		flp->n_units -= (L2_ARMS+1);
-	}
-
-	/* initialization	*/
-	expr = NPE_get_initial(flp_desc);
-	stack = new_tree_node_stack();
-	init_rand();
-	
-	/* convert NPE to flp	*/
-	root = tree_from_NPE(flp_desc, stack, expr);
-	/* compacts too small dead blocks	*/
-	compacted = tree_to_flp(root, flp, TRUE, cfg.compact_ratio);
-	/* update the tpower vector according to the compaction	*/
-	trim_hotspot_vector(model, tpower, power, flp->n_units, compacted);
-	free_tree(root);
-	if(wrap_l2)
-		flp_wrap_l2(flp, flp_desc);
-	if(cfg.model_rim)
-		rim_blocks = flp_wrap_rim(flp, cfg.rim_thickness);
-
-	resize_thermal_model(model, flp->n_units);
-	#if VERBOSE > 2
-	print_flp(flp);
-	#endif
-	cost = flp_evaluate_metric(flp, model, tpower, cfg.lambdaA, cfg.lambdaT, cfg.lambdaW);
-	/* restore the compacted blocks	*/
-	restore_dead_blocks(flp, flp_desc, compacted, wrap_l2, cfg.model_rim, rim_blocks);
-
-	best = NPE_duplicate(expr);	/* best till now	*/
-	best_cost = cost;
-
-	/* simulated annealing	*/
-	steps = 0;
-	/* initial annealing temperature	*/
-	T = -cfg.Davg / log(cfg.P0);
-	/* 
-	 * final annealing temperature - we stop when there
-	 * are fewer than (1-cfg.Rreject) accepts.
-	 * of those accepts, assuming half are uphill moves,
-	 * we want the temperature so that the probability
-	 * of accepting uphill moves is as low as
-	 * (1-cfg.Rreject)/2.
-	 */
-	Tcold = -cfg.Davg / log ((1.0 - cfg.Rreject) / 2.0);
-	#if VERBOSE > 0
-	fprintf(stdout, "initial cost: %g\tinitial T: %g\tfinal T: %g\n", cost, T, Tcold);
-	#endif
-	/* 
-	 * stop annealing if temperature has cooled down enough or
-	 * max no. of iterations have been tried
-	 */
-	while (T >= Tcold && steps < cfg.Nmax) {
-		/* shortcut	*/
-		n = cfg.Kmoves * flp->n_units; 
-		i = downs = rejects = 0;
-		sum_cost = 0;
-		/* try enough total or downhill moves per T */
-		while ((i < 2 * n) && (downs < n)) {
-			next = make_random_move(expr);
-
-			/* convert NPE to flp	*/
-			root = tree_from_NPE(flp_desc, stack, next);
-			compacted = tree_to_flp(root, flp, TRUE, cfg.compact_ratio);
-			/* update the tpower vector according to the compaction	*/
-			trim_hotspot_vector(model, tpower, power, flp->n_units, compacted);
-			free_tree(root);
-			if(wrap_l2)
-				flp_wrap_l2(flp, flp_desc);
-			if(cfg.model_rim)
-				rim_blocks = flp_wrap_rim(flp, cfg.rim_thickness);
-
-			resize_thermal_model(model, flp->n_units);
-			#if VERBOSE > 2
-			print_flp(flp);
-			#endif
-			new_cost = flp_evaluate_metric(flp, model, tpower, cfg.lambdaA, cfg.lambdaT, cfg.lambdaW);
-			restore_dead_blocks(flp, flp_desc, compacted, wrap_l2, cfg.model_rim, rim_blocks);
-
-			#if VERBOSE > 1
-			fprintf(stdout, "count: %d\tdowns: %d\tcost: %g\t", 
-					i, downs, new_cost);
-			#endif
-
-			/* move accepted?	*/
-			if (new_cost < cost || 	/* downhill always accepted	*/
-				/* boltzmann probability function	*/
-			    rand_fraction() < exp(-(new_cost-cost)/T)) {
-
-				free_NPE(expr);
-				expr = next;
-
-				/* downhill move	*/
-				if (new_cost < cost) {
-					downs++;
-					/* found new best	*/
-					if (new_cost < best_cost) {
-						free_NPE(best);
-						best = NPE_duplicate(expr);
-						best_cost = new_cost;
-					}
-				}
-
-				#if VERBOSE > 1
-				fprintf(stdout, "accepted\n");
-				#endif
-				cost = new_cost;
-				sum_cost += cost;
-			} else {	/* rejected move	*/
-				rejects++;
-				free_NPE(next);
-				#if VERBOSE > 1
-				fprintf(stdout, "rejected\n");
-				#endif
-			}
-			i++;
-		}
-		#if VERBOSE > 0
-		fprintf(stdout, "step: %d\tT: %g\ttries: %d\taccepts: %d\trejects: %d\t", 
-				steps, T, i, (i-rejects), rejects);
-		fprintf(stdout, "avg. cost: %g\tbest cost: %g\n", 
-		 		(i-rejects)?(sum_cost / (i-rejects)):sum_cost, best_cost); 
-		#endif
-
-		/* stop annealing if there are too little accepts */
-		if(((double)rejects/i) > cfg.Rreject)
-			break;
-
-		/* annealing schedule	*/
-		T *= cfg.Rcool;
-		steps++;	
-	}
-
-	/* best floorplan found	*/
-	root = tree_from_NPE(flp_desc, stack, best);
-	#if VERBOSE > 0
-	{
-		int pos = min_area_pos(root->curve);
-		print_tree_relevant(root, pos, flp_desc);
-	}	
-	#endif
-	compacted = tree_to_flp(root, flp, TRUE, cfg.compact_ratio);
-	/* update the power vector according to the compaction	*/
-	trim_hotspot_vector(model, power, power, flp->n_units, compacted);
-	free_tree(root);
-	/*  restore L2 and rim */
-	if(wrap_l2) {
-		flp_wrap_l2(flp, flp_desc);
-		flp_desc->n_units++;
-	}
-	if(cfg.model_rim)
-		rim_blocks = flp_wrap_rim(flp, cfg.rim_thickness);
-	resize_thermal_model(model, flp->n_units);
-	#if VERBOSE > 2
-	print_flp(flp);
-	#endif
-
-	free_NPE(expr);
-	free_NPE(best);
-	free_tree_node_stack(stack);
-	free_dvector(tpower);
-
-	/* 
-	 * return the number of blocks compacted finally
-	 * so that any deallocator can take care of memory
-	 * accordingly. 
-	 */
-	return (original_n - flp->n_units);
-}
-
-/* functions duplicated from flp_desc.c */
-/* 
- * find the number of units from the 
- * floorplan file
- */
-int flp_count_units(FILE *fp)
-{
-    char str1[LINE_SIZE], str2[LINE_SIZE];
-	char name[STR_SIZE];
-	double leftx, bottomy, width, height;
-	char *ptr;
-    int count = 0;
-
-	fseek(fp, 0, SEEK_SET);
-	while(!feof(fp)) {
-		fgets(str1, LINE_SIZE, fp);
-		if (feof(fp))
-			break;
-		strcpy(str2, str1);
-		
-		/* ignore comments and empty lines	*/
-		ptr = strtok(str1, " \r\t\n");
-		if (!ptr || ptr[0] == '#')
-			continue;
-
-		/* functional block placement information	*/
-		if (sscanf(str2, "%s%lf%lf%lf%lf", name, &leftx, &bottomy,
-		  		   &width, &height) == 5)
-			count++;
-	}
-	return count;
-}
-
-flp_t *flp_alloc_init_mem(int count)
-{
-	int i;
-	flp_t *flp;
-	flp = (flp_t *) calloc (1, sizeof(flp_t));
-	if(!flp)
-		fatal("memory allocation error\n");
-	flp->units = (unit_t *) calloc(count, sizeof(unit_t));
-	flp->wire_density = (double **) calloc(count, sizeof(double *));
-	if (!flp->units || !flp->wire_density)
-		fatal("memory allocation error\n");
-	flp->n_units = count;
-
-	for (i=0; i < count; i++) {
-	  flp->wire_density[i] = (double *) calloc(count, sizeof(double));
-	  if (!flp->wire_density[i])
-	  	fatal("memory allocation error\n");
-	}
-	return flp;
-}
-
-/* populate block information	*/
-void flp_populate_blks(flp_t *flp, FILE *fp)
-{
-	int i=0;
-	char str[LINE_SIZE], copy[LINE_SIZE]; 
-	char name1[STR_SIZE], name2[STR_SIZE];
-	double width, height, leftx, bottomy;
-	double wire_density;
-	char *ptr;
-
-	fseek(fp, 0, SEEK_SET);
-	while(!feof(fp)) {		/* second pass	*/
-		fgets(str, LINE_SIZE, fp);
-		if (feof(fp))
-			break;
-		strcpy(copy, str);
-
-		/* ignore comments and empty lines	*/
-		ptr = strtok(str, " \r\t\n");
-		if (!ptr || ptr[0] == '#')
-			continue;
-
-		if (sscanf(copy, "%s%lf%lf%lf%lf", name1, &width, &height, 
-				   &leftx, &bottomy) == 5) {
-			strcpy(flp->units[i].name, name1);
-			flp->units[i].width = width;
-			flp->units[i].height = height;
-			flp->units[i].leftx = leftx;
-			flp->units[i].bottomy = bottomy;
-			i++;
-			/* skip connectivity info	*/
-		} else if (sscanf(copy, "%s%s%lf", name1, name2, &wire_density) != 3) 
-			fatal("invalid floorplan file format\n");
-	}
-	if (i != flp->n_units)
-	  fatal("mismatch of number of units\n");
-}
-
-/* populate connectivity info	*/
-void flp_populate_connects(flp_t *flp, FILE *fp)
-{
-	char str1[LINE_SIZE], str2[LINE_SIZE]; 
-	char name1[STR_SIZE], name2[STR_SIZE];
-	/* dummy fields	*/
-	double f1, f2, f3, f4, f5, f6;
-	double wire_density;
-	char *ptr;
-	int x, y, temp;
-
-	/* initialize wire_density	*/
-	for(x=0; x < flp->n_units; x++)
-		for(y=0; y < flp->n_units; y++)
-			flp->wire_density[x][y] = 0.0;
-
-	fseek(fp, 0, SEEK_SET);
-	while(!feof(fp)) {
-		fgets(str1, LINE_SIZE, fp);
-		if (feof(fp))
-			break;
-		strcpy(str2, str1);
-
-		/* ignore comments and empty lines	*/
-		ptr = strtok(str1, " \r\t\n");
-		if (!ptr || ptr[0] == '#')
-			continue;
-
-		/* lines with unit positions	*/
-		if (sscanf(str2, "%s%lf%lf%lf%lf%lf%lf", name1, &f1, &f2, &f3, &f4, &f5, &f6) == 7 ||
-		  	/* flp_desc like lines. ignore them	*/
-		  	sscanf(str2, "%s%lf%lf%lf%d", name1, &f1, &f2, &f3, &temp) == 5)
-			continue;
-
-		 /* lines with connectivity info	*/
-		else if (sscanf(str2, "%s%s%lf", name1, name2, &wire_density) == 3) {
-			x = get_blk_index(flp, name1);
-			y = get_blk_index(flp, name2);
-
-			if (x == y)
-				fatal("block connected to itself?\n");
-
-			if (!flp->wire_density[x][y] && !flp->wire_density[y][x])
-				flp->wire_density[x][y] = flp->wire_density[y][x] = wire_density;
-			else if((flp->wire_density[x][y] != flp->wire_density[y][x]) ||
-			        (flp->wire_density[x][y] != wire_density)) {
-				sprintf(str2, "wrong connectivity information for blocks %s and %s\n", 
-				        name1, name2);
-				fatal(str2);
-			}
-		} else 
-		  	fatal("invalid floorplan file format\n");
-	} /* end while	*/
-}
-
-flp_t *read_flp(char *file, int read_connects)
-{
-	char str[STR_SIZE];
-	FILE *fp;
-	flp_t *flp;
-	int count, i, j;
-
-	if (!strcasecmp(file, "stdin"))
-		fp = stdin;
-	else
-		fp = fopen (file, "r");
-
-	if (!fp) {
-		sprintf(str, "error opening file %s\n", file);
-		fatal(str);
-	}
-
-	/* 1st pass - find n_units	*/
-	count = flp_count_units(fp);
-	if(!count)
-		fatal("no units specified in the floorplan file\n");
-
-	/* allocate initial memory */
-	flp = flp_alloc_init_mem(count);
-
-	/* 2nd pass - populate block info	*/
-	flp_populate_blks(flp, fp);
-
-	/* 3rd pass - populate connectivity info    */
-	if (read_connects)
-		flp_populate_connects(flp, fp);
-	/* older version - no connectivity	*/	
-	else for (i=0; i < flp->n_units; i++)
-			for (j=0; j < flp->n_units; j++)
-				flp->wire_density[i][j] = 1.0;
-
-	if(fp != stdin)
-		fclose(fp);	
-
-	/* make sure the origin is (0,0)	*/
-	flp_translate(flp, 0, 0);	
-	return flp;
-}
-
-void dump_flp(flp_t *flp, char *file, int dump_connects)
-{
-	char str[STR_SIZE];
-	int i, j;
-	FILE *fp;
-
-	if (!strcasecmp(file, "stdout"))
-		fp = stdout;
-	else if (!strcasecmp(file, "stderr"))
-		fp = stderr;
-	else 	
-		fp = fopen (file, "w");
-
-	if (!fp) {
-		sprintf(str, "error opening file %s\n", file);
-		fatal(str);
-	}
-	/* functional unit placement info	*/
-	for(i=0; i < flp->n_units; i++)  {
-		fprintf(fp, "%s\t%.11f\t%.11f\t%.11f\t%.11f\n",
-				flp->units[i].name, flp->units[i].width, flp->units[i].height,
-				flp->units[i].leftx, flp->units[i].bottomy);
-	}
-
-	if (dump_connects) {
-		fprintf(fp, "\n");
-		/* connectivity information	*/
-		for(i=1; i < flp->n_units; i++)
-			for(j=0; j < i; j++)
-				if (flp->wire_density[i][j])
-					fprintf(fp, "%s\t%s\t%.3f\n", flp->units[i].name,
-							flp->units[j].name, flp->wire_density[i][j]);
-	}
-	
-	if(fp != stdout && fp != stderr)
-		fclose(fp);
-}
-
-void free_flp(flp_t *flp, int compacted)
-{
-	int i;
-	for (i=0; i < flp->n_units + compacted; i++) {
-		free(flp->wire_density[i]);
-	}
-	free(flp->units);
-	free(flp->wire_density);
-	free(flp);
-}
-
-void print_flp_fig (flp_t *flp)
-{
-	int i;
-	double leftx, bottomy, rightx, topy;
-
-	fprintf(stdout, "FIG starts\n");
-	for (i=0; i< flp->n_units; i++) {
-		leftx = flp->units[i].leftx;
-		bottomy = flp->units[i].bottomy;
-		rightx = flp->units[i].leftx + flp->units[i].width;
-		topy = flp->units[i].bottomy + flp->units[i].height;
-		fprintf(stdout, "%.5f %.5f %.5f %.5f %.5f %.5f %.5f %.5f %.5f %.5f\n", 
-			    leftx, bottomy, leftx, topy, rightx, topy, rightx, bottomy, 
-				leftx, bottomy);
-		fprintf(stdout, "%s\n", flp->units[i].name);
-	}
-	fprintf(stdout, "FIG ends\n");
-}
-
-/* debug print	*/
-void print_flp (flp_t *flp)
-{
-	int i, j;
-
-	fprintf(stdout, "printing floorplan information for %d blocks\n", flp->n_units);
-	fprintf(stdout, "name\tarea\twidth\theight\tleftx\tbottomy\trightx\ttopy\n");
-	for (i=0; i< flp->n_units; i++) {
-		double area, width, height, leftx, bottomy, rightx, topy;
-		char *name;
-		name = flp->units[i].name;
-		width = flp->units[i].width;
-		height = flp->units[i].height;
-		area = width * height;
-		leftx = flp->units[i].leftx;
-		bottomy = flp->units[i].bottomy;
-		rightx = flp->units[i].leftx + flp->units[i].width;
-		topy = flp->units[i].bottomy + flp->units[i].height;
-		fprintf(stdout, "%s\t%lg\t%lg\t%lg\t%lg\t%lg\t%lg\t%lg\n", 
-			    name, area, width, height, leftx, bottomy, rightx, topy);
-	}
-	fprintf(stdout, "printing connections:\n");
-	for (i=0; i< flp->n_units; i++)
-		for (j=i+1; j < flp->n_units; j++)
-			if (flp->wire_density[i][j])
-				fprintf(stdout, "%s\t%s\t%lg\n", flp->units[i].name, 
-						flp->units[j].name, flp->wire_density[i][j]);
-}
-
-/* print the statistics about this floorplan.
- * note that connects_file is NULL if wire 
- * information is already populated	
- */
-void print_flp_stats(flp_t *flp, RC_model_t *model, 
-					 char *l2_label, char *power_file, 
-					 char *connects_file)
-{
-	double core, total, occupied;	/* area	*/
-	double width, height, aspect, total_w, total_h;
-	double wire_metric;
-	double peak, avg;		/* temperature	*/
-	double *power, *temp;
-	FILE *fp = NULL;
-	char str[STR_SIZE];
-
-	if (connects_file) {
-		fp = fopen(connects_file, "r");
-		if (!fp) {
-			sprintf(str, "error opening file %s\n", connects_file);
-			fatal(str);
-		}
-		flp_populate_connects(flp, fp);
-	}
-
-	power = hotspot_vector(model);
-	temp = hotspot_vector(model);
-	read_power(model, power, power_file);
-
-	core = get_core_area(flp, l2_label);
-	total = get_total_area(flp);
-	total_w = get_total_width(flp);
-	total_h = get_total_height(flp);
-	occupied = get_core_occupied_area(flp, l2_label);
-	width = get_core_width(flp, l2_label);
-	height = get_core_height(flp, l2_label);
-	aspect = (height > width) ? (height/width) : (width/height);
-	wire_metric = get_wire_metric(flp);
-
-	populate_R_model(model, flp);
-	steady_state_temp(model, power, temp);
-	peak = find_max_temp(model, temp);
-	avg = find_avg_temp(model, temp);
-
-	fprintf(stdout, "printing summary statistics about the floorplan\n");
-	fprintf(stdout, "total area:\t%g\n", total);
-	fprintf(stdout, "total width:\t%g\n", total_w);
-	fprintf(stdout, "total height:\t%g\n", total_h);
-	fprintf(stdout, "core area:\t%g\n", core);
-	fprintf(stdout, "occupied area:\t%g\n", occupied);
-	fprintf(stdout, "area utilization:\t%.3f\n", occupied / core * 100.0);
-	fprintf(stdout, "core width:\t%g\n", width);
-	fprintf(stdout, "core height:\t%g\n", height);
-	fprintf(stdout, "core aspect ratio:\t%.3f\n", aspect);
-	fprintf(stdout, "wire length metric:\t%.3f\n", wire_metric);
-	fprintf(stdout, "peak temperature:\t%.3f\n", peak);
-	fprintf(stdout, "avg temperature:\t%.3f\n", avg);
-
-	free_dvector(power);
-	free_dvector(temp);
-	if (fp)
-		fclose(fp);
-}
-
-int get_blk_index(flp_t *flp, char *name)
-{
-	int i;
-	char msg[STR_SIZE];
-
-	if (!flp)
-		fatal("null pointer in get_blk_index\n");
-
-	for (i = 0; i < flp->n_units; i++) {
-		if (!strcasecmp(name, flp->units[i].name)) {
-			return i;
-		}
-	}
-
-	sprintf(msg, "block %s not found\n", name);
-	fatal(msg);
-	return -1;
-}
-
-int is_horiz_adj(flp_t *flp, int i, int j)
-{
-	double x1, x2, x3, x4;
-	double y1, y2, y3, y4;
-
-	if (i == j) 
-		return FALSE;
-
-	x1 = flp->units[i].leftx;
-	x2 = x1 + flp->units[i].width;
-	x3 = flp->units[j].leftx;
-	x4 = x3 + flp->units[j].width;
-
-	y1 = flp->units[i].bottomy;
-	y2 = y1 + flp->units[i].height;
-	y3 = flp->units[j].bottomy;
-	y4 = y3 + flp->units[j].height;
-
-	/* diagonally adjacent => not adjacent */
-	if (eq(x2,x3) && eq(y2,y3))
-		return FALSE;
-	if (eq(x1,x4) && eq(y1,y4))
-		return FALSE;
-	if (eq(x2,x3) && eq(y1,y4))
-		return FALSE;
-	if (eq(x1,x4) && eq(y2,y3))
-		return FALSE;
-
-	if (eq(x1,x4) || eq(x2,x3))
-		if ((y3 >= y1 && y3 <= y2) || (y4 >= y1 && y4 <= y2) ||
-		    (y1 >= y3 && y1 <= y4) || (y2 >= y3 && y2 <= y4))
-			return TRUE;
-
-	return FALSE;
-}
-
-int is_vert_adj (flp_t *flp, int i, int j)
-{
-	double x1, x2, x3, x4;
-	double y1, y2, y3, y4;
-
-	if (i == j)
-		return FALSE;
-
-	x1 = flp->units[i].leftx;
-	x2 = x1 + flp->units[i].width;
-	x3 = flp->units[j].leftx;
-	x4 = x3 + flp->units[j].width;
-
-	y1 = flp->units[i].bottomy;
-	y2 = y1 + flp->units[i].height;
-	y3 = flp->units[j].bottomy;
-	y4 = y3 + flp->units[j].height;
-
-	/* diagonally adjacent => not adjacent */
-	if (eq(x2,x3) && eq(y2,y3))
-		return FALSE;
-	if (eq(x1,x4) && eq(y1,y4))
-		return FALSE;
-	if (eq(x2,x3) && eq(y1,y4))
-		return FALSE;
-	if (eq(x1,x4) && eq(y2,y3))
-		return FALSE;
-
-	if (eq(y1,y4) || eq(y2,y3))
-		if ((x3 >= x1 && x3 <= x2) || (x4 >= x1 && x4 <= x2) ||
-		    (x1 >= x3 && x1 <= x4) || (x2 >= x3 && x2 <= x4))
-			return TRUE;
-
-	return FALSE;
-}
-
-double get_shared_len(flp_t *flp, int i, int j)
-{
-	double p11, p12, p21, p22;
-	p11 = p12 = p21 = p22 = 0.0;
-
-	if (i==j) 
-		return FALSE;
-
-	if (is_horiz_adj(flp, i, j)) {
-		p11 = flp->units[i].bottomy;
-		p12 = p11 + flp->units[i].height;
-		p21 = flp->units[j].bottomy;
-		p22 = p21 + flp->units[j].height;
-	}
-
-	if (is_vert_adj(flp, i, j)) {
-		p11 = flp->units[i].leftx;
-		p12 = p11 + flp->units[i].width;
-		p21 = flp->units[j].leftx;
-		p22 = p21 + flp->units[j].width;
-	}
-
-	return (MIN(p12, p22) - MAX(p11, p21));
-}
-
-double get_total_width(flp_t *flp)
-{	
-	int i;
-	double min_x = flp->units[0].leftx;
-	double max_x = flp->units[0].leftx + flp->units[0].width;
-	
-	for (i=1; i < flp->n_units; i++) {
-		if (flp->units[i].leftx < min_x)
-			min_x = flp->units[i].leftx;
-		if (flp->units[i].leftx + flp->units[i].width > max_x)
-			max_x = flp->units[i].leftx + flp->units[i].width;
-	}
-
-	return (max_x - min_x);
-}
-
-double get_total_height(flp_t *flp)
-{	
-	int i;
-	double min_y = flp->units[0].bottomy;
-	double max_y = flp->units[0].bottomy + flp->units[0].height;
-	
-	for (i=1; i < flp->n_units; i++) {
-		if (flp->units[i].bottomy < min_y)
-			min_y = flp->units[i].bottomy;
-		if (flp->units[i].bottomy + flp->units[i].height > max_y)
-			max_y = flp->units[i].bottomy + flp->units[i].height;
-	}
-
-	return (max_y - min_y);
-}
-
-double get_minx(flp_t *flp)
-{
-	int i;
-	double min_x = flp->units[0].leftx;
-	
-	for (i=1; i < flp->n_units; i++)
-		if (flp->units[i].leftx < min_x)
-			min_x = flp->units[i].leftx;
-
-	return min_x;
-}
-
-double get_miny(flp_t *flp)
-{
-	int i;
-	double min_y = flp->units[0].bottomy;
-	
-	for (i=1; i < flp->n_units; i++)
-		if (flp->units[i].bottomy < min_y)
-			min_y = flp->units[i].bottomy;
-
-	return min_y;
-}
-
-/* precondition: L2 should have been wrapped around	*/
-double get_core_width(flp_t *flp, char *l2_label)
-{
-	int i;
-	double min_x = LARGENUM;
-	double max_x = -LARGENUM;
-	
-	for (i=0; i < flp->n_units; i++) {
-		/* core is that part of the chip excluding the l2 and rim	*/
-		if (strstr(flp->units[i].name, l2_label) != flp->units[i].name &&
-			strstr(flp->units[i].name, RIM_PREFIX) != flp->units[i].name) {
-			if (flp->units[i].leftx < min_x)
-				min_x = flp->units[i].leftx;
-			if (flp->units[i].leftx + flp->units[i].width > max_x)
-				max_x = flp->units[i].leftx + flp->units[i].width;
-		}		
-	}
-
-	return (max_x - min_x);
-}
-
-/* precondition: L2 should have been wrapped around	*/
-double get_core_height(flp_t *flp, char *l2_label)
-{	
-	int i;
-	double min_y = LARGENUM;
-	double max_y = -LARGENUM;
-	
-	for (i=0; i < flp->n_units; i++) {
-		/* core is that part of the chip excluding the l2 and rim	*/
-		if (strstr(flp->units[i].name, l2_label) != flp->units[i].name &&
-			strstr(flp->units[i].name, RIM_PREFIX) != flp->units[i].name) {
-			if (flp->units[i].bottomy < min_y)
-				min_y = flp->units[i].bottomy;
-			if (flp->units[i].bottomy + flp->units[i].height > max_y)
-				max_y = flp->units[i].bottomy + flp->units[i].height;
-		}		
-	}
-
-	return (max_y - min_y);
-}
-
-double get_total_area(flp_t *flp)
-{
-	int i;
-	double area = 0.0;
-	for(i=0; i < flp->n_units; i++)
-		area += flp->units[i].width * flp->units[i].height;
-	return area;	
-}
-
-double get_core_area(flp_t *flp, char *l2_label)
-{
-	int i;
-	double area = 0.0;
-	for(i=0; i < flp->n_units; i++)
-		if (strstr(flp->units[i].name, l2_label) != flp->units[i].name &&
-			strstr(flp->units[i].name, RIM_PREFIX) != flp->units[i].name)
-			area += flp->units[i].width * flp->units[i].height;
-	return area;		
-}
-
-/* excluding the dead blocks	*/
-double get_core_occupied_area(flp_t *flp, char *l2_label)
-{
-	int i, num;
-	double dead_area = 0.0;
-	for(i=0; i < flp->n_units; i++) {
-		/* 
-		 * there can be a max of n-1 dead blocks where n is the
-		 * number of non-dead blocks (since each cut, vertical
-		 * or horizontal, can correspond to a maximum of one
-		 * dead block
-		 */
-		if ((sscanf(flp->units[i].name, DEAD_PREFIX"%d", &num) == 1) &&
-			(num < (flp->n_units-1) / 2))
-			dead_area += flp->units[i].width * flp->units[i].height;
-	}		
-	return get_core_area(flp, l2_label) - dead_area;	
-}
-
-double get_wire_metric(flp_t *flp)
-{
-	int i, j;
-	double w = 0.0, dist;
-
-	for (i=0; i < flp->n_units; i++)
-		for (j=0; j < flp->n_units; j++)
-			if (flp->wire_density[i][j]) {
-				dist = get_manhattan_dist(flp, i, j);
-				w += flp->wire_density[i][j] * dist;
-			}
-	return w;		
-}
-
-double get_manhattan_dist(flp_t *flp, int i, int j)
-{
-	double x1 = flp->units[i].leftx + flp->units[i].width / 2.0;
-	double y1 = flp->units[i].bottomy + flp->units[i].height / 2.0;
-	double x2 = flp->units[j].leftx + flp->units[j].width / 2.0;
-	double y2 = flp->units[j].bottomy + flp->units[j].height / 2.0;
-	return (fabs(x2-x1) + fabs(y2-y1));
-}
diff -Naur temp/flp.cc HotSpot/flp.cc
--- temp/flp.cc	1970-01-01 01:00:00.000000000 +0100
+++ HotSpot/flp.cc	2017-11-20 09:59:35.316820635 +0100
@@ -0,0 +1,1631 @@
+#include <stdio.h>
+#include <string.h>
+#include <string.h>
+#ifdef _MSC_VER
+#define strcasecmp    _stricmp
+#define strncasecmp   _strnicmp
+#else
+#include <strings.h>
+#endif
+#include <stdlib.h>
+#include <math.h>
+
+#include "flp.h"
+#include "npe.h"
+#include "shape.h"
+#include "util.h"
+#include "temperature.h"
+#include "temperature_block.h"
+
+/* 
+ * this is the metric function used for the floorplanning. 
+ * in order to enable a different metric, just change the 
+ * return statement of this function to return an appropriate
+ * metric. The current metric used is a linear function of
+ * area (A), temperature (T) and wire length (W):
+ * lambdaA * A + lambdaT * T  + lambdaW * W
+ * thermal model and power density are passed as parameters
+ * since temperature is used in the metric. 
+ */
+double flp_evaluate_metric(flp_t *flp, RC_model_t *model, double *power,
+						   double lambdaA, double lambdaT, double lambdaW)
+{
+	double tmax, area, wire_length;
+	//double width, height, aspect;
+	double *temp;
+
+	temp = hotspot_vector(model);
+	populate_R_model(model, flp);
+	steady_state_temp(model, power, temp);
+	tmax = find_max_temp(model, temp);
+	area = get_total_area(flp);
+	wire_length = get_wire_metric(flp);
+	//width = get_total_width(flp);
+	//height = get_total_height(flp);
+	//if (width > height)
+	//	aspect = width / height;
+	//else
+	//	aspect = height / width;
+	free_dvector(temp);
+
+	/* can return any arbitrary function of area, tmax and wire_length	*/
+	return (lambdaA * area + lambdaT * tmax + lambdaW * wire_length);
+}
+
+
+/* default flp_config	*/
+flp_config_t default_flp_config(void)
+{
+	flp_config_t config;
+
+	/* wrap around L2?	*/
+	config.wrap_l2 = TRUE;
+	strcpy(config.l2_label, "L2");
+	
+	/* model dead space around the rim of the chip? */
+	config.model_rim = FALSE;
+	config.rim_thickness = 50e-6;
+
+	/* area ratio below which to ignore dead space	*/
+	config.compact_ratio = 0.005;
+
+	/* 
+	 * no. of discrete orientations for a shape curve.
+	 * should be an even number greater than 1
+	 */
+	config.n_orients = 300;
+	
+	/* annealing parameters	*/
+	config.P0 = 0.99;		/* initial acceptance probability	*/
+	/* 
+	 * average change (delta) in cost. varies according to
+	 * the metric. need not be very accurate. just the right
+	 * order of magnitude is enough. for instance, if the
+	 * metric is flp area, this Davg is the average difference
+	 * in the area of successive slicing floorplan attempts.
+	 * since the areas are in the order of mm^2, the delta
+	 * is also in the same ball park. 
+	 */
+	config.Davg = 1.0;		/* for our a*A + b*T + c*W metric	*/
+	config.Kmoves = 7.0;	/* no. of moves to try in each step	*/
+	config.Rcool = 0.99;	/* ratio for the cooling schedule */
+	config.Rreject = 0.99;	/* ratio of rejects at which to stop annealing */
+	config.Nmax = 1000;		/* absolute max no. of annealing steps	*/
+
+	/* weights for the metric: lambdaA * A + lambdaT * T + lambdaW * W
+	 * the weights incorporate two things: 
+	 * 1) the conversion of A to mm^2, T to K and W to mm. 
+	 * 2) weighing the relative importance of A, T and K
+	 */
+	config.lambdaA = 5.0e+6;
+	config.lambdaT = 1.0;
+	config.lambdaW = 350;
+
+	return config;
+}
+
+/* 
+ * parse a table of name-value string pairs and add the configuration
+ * parameters to 'config'
+ */
+void flp_config_add_from_strs(flp_config_t *config, str_pair *table, int size)
+{
+	int idx;
+	if ((idx = get_str_index(table, size, (char*)"wrap_l2")) >= 0)
+		if(sscanf(table[idx].value, "%d", &config->wrap_l2) != 1)
+			fatal((char*)"invalid format for configuration  parameter wrap_l2\n");
+	if ((idx = get_str_index(table, size, (char*)"l2_label")) >= 0)
+		if(sscanf(table[idx].value, "%s", config->l2_label) != 1)
+			fatal((char*)"invalid format for configuration  parameter l2_label\n");
+	if ((idx = get_str_index(table, size, (char*)"model_rim")) >= 0)
+		if(sscanf(table[idx].value, "%d", &config->model_rim) != 1)
+			fatal((char*)"invalid format for configuration  parameter model_rim\n");
+	if ((idx = get_str_index(table, size, (char*)"rim_thickness")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->rim_thickness) != 1)
+			fatal((char*)"invalid format for configuration  parameter rim_thickness\n");
+	if ((idx = get_str_index(table, size, (char*)"compact_ratio")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->compact_ratio) != 1)
+			fatal((char*)"invalid format for configuration  parameter compact_ratio\n");
+	if ((idx = get_str_index(table, size, (char*)"n_orients")) >= 0)
+		if(sscanf(table[idx].value, "%d", &config->n_orients) != 1)
+			fatal((char*)"invalid format for configuration  parameter n_orients\n");
+	if ((idx = get_str_index(table, size, (char*)"P0")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->P0) != 1)
+			fatal((char*)"invalid format for configuration  parameter P0\n");
+	if ((idx = get_str_index(table, size, (char*)"Davg")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->Davg) != 1)
+			fatal((char*)"invalid format for configuration  parameter Davg\n");
+	if ((idx = get_str_index(table, size, (char*)"Kmoves")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->Kmoves) != 1)
+			fatal((char*)"invalid format for configuration  parameter Kmoves\n");
+	if ((idx = get_str_index(table, size, (char*)"Rcool")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->Rcool) != 1)
+			fatal((char*)"invalid format for configuration  parameter Rcool\n");
+	if ((idx = get_str_index(table, size, (char*)"Rreject")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->Rreject) != 1)
+			fatal((char*)"invalid format for configuration  parameter Rreject\n");
+	if ((idx = get_str_index(table, size, (char*)"Nmax")) >= 0)
+		if(sscanf(table[idx].value, "%d", &config->Nmax) != 1)
+			fatal((char*)"invalid format for configuration  parameter Nmax\n");
+	if ((idx = get_str_index(table, size, (char*)"lambdaA")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->lambdaA) != 1)
+			fatal((char*)"invalid format for configuration  parameter lambdaA\n");
+	if ((idx = get_str_index(table, size, (char*)"lambdaT")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->lambdaT) != 1)
+			fatal((char*)"invalid format for configuration  parameter lambdaT\n");
+	if ((idx = get_str_index(table, size, (char*)"lambdaW")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->lambdaW) != 1)
+			fatal((char*)"invalid format for configuration  parameter lambdaW\n");
+			
+	if (config->rim_thickness <= 0)
+		fatal((char*)"rim thickness should be greater than zero\n");
+	if ((config->compact_ratio < 0) || (config->compact_ratio > 1))
+		fatal((char*)"compact_ratio should be between 0 and 1\n");
+	if ((config->n_orients <= 1) || (config->n_orients & 1))
+		fatal((char*)"n_orients should be an even number greater than 1\n");
+	if (config->Kmoves < 0)
+		fatal((char*)"Kmoves should be non-negative\n");
+	if ((config->P0 < 0) || (config->P0 > 1))
+		fatal((char*)"P0 should be between 0 and 1\n");
+	if ((config->Rcool < 0) || (config->Rcool > 1))
+		fatal((char*)"Rcool should be between 0 and 1\n");
+	if ((config->Rreject < 0) || (config->Rreject > 1))
+		fatal((char*)"Rreject should be between 0 and 1\n");
+	if (config->Nmax < 0)
+		fatal((char*)"Nmax should be non-negative\n");
+}
+
+/* 
+ * convert config into a table of name-value pairs. returns the no.
+ * of parameters converted
+ */
+int flp_config_to_strs(flp_config_t *config, str_pair *table, int max_entries)
+{
+	if (max_entries < 15)
+		fatal((char*)"not enough entries in table\n");
+
+	sprintf(table[0].name, "wrap_l2");
+	sprintf(table[1].name, "l2_label");
+	sprintf(table[2].name, "model_rim");
+	sprintf(table[3].name, "rim_thickness");
+	sprintf(table[4].name, "compact_ratio");
+	sprintf(table[5].name, "n_orients");
+	sprintf(table[6].name, "P0");
+	sprintf(table[7].name, "Davg");
+	sprintf(table[8].name, "Kmoves");
+	sprintf(table[9].name, "Rcool");
+	sprintf(table[10].name, "Rreject");
+	sprintf(table[11].name, "Nmax");
+	sprintf(table[12].name, "lambdaA");
+	sprintf(table[13].name, "lambdaT");
+	sprintf(table[14].name, "lambdaW");
+
+	sprintf(table[0].value, "%d", config->wrap_l2);
+	sprintf(table[1].value, "%s", config->l2_label);
+	sprintf(table[2].value, "%d", config->model_rim);
+	sprintf(table[3].value, "%lg", config->rim_thickness);
+	sprintf(table[4].value, "%lg", config->compact_ratio);
+	sprintf(table[5].value, "%d", config->n_orients);
+	sprintf(table[6].value, "%lg", config->P0);
+	sprintf(table[7].value, "%lg", config->Davg);
+	sprintf(table[8].value, "%lg", config->Kmoves);
+	sprintf(table[9].value, "%lg", config->Rcool);
+	sprintf(table[10].value, "%lg", config->Rreject);
+	sprintf(table[11].value, "%d", config->Nmax);
+	sprintf(table[12].value, "%lg", config->lambdaA);
+	sprintf(table[13].value, "%lg", config->lambdaT);
+	sprintf(table[14].value, "%lg", config->lambdaW);
+
+	return 15;
+}
+
+/* 
+ * copy L2 connectivity from 'from' of flp_desc to 'to' 
+ * of flp. 'size' elements are copied. the arms are not 
+ * connected amidst themselves or with L2 base block
+ */
+void copy_l2_info (flp_t *flp, int to, flp_desc_t *flp_desc, int from, int size)
+{
+	int j, count;
+
+	for(count=0; count < L2_ARMS + 1; count++, to++) {
+		/* copy names */
+		strcpy(flp->units[to].name, flp_desc->units[from].name);
+		for(j=0; j < size; j++) {
+			/* rows	*/
+			flp->wire_density[to][j] = flp_desc->wire_density[from][j];
+			/* columns	*/	
+			flp->wire_density[j][to] = flp_desc->wire_density[j][from];
+		}
+	}
+	/* fix the names of the arms	*/
+	strcat(flp->units[to-L2_ARMS+L2_LEFT].name, L2_LEFT_STR);	
+	strcat(flp->units[to-L2_ARMS+L2_RIGHT].name, L2_RIGHT_STR);
+}
+
+
+/* create a floorplan placeholder from description	*/
+flp_t *flp_placeholder(flp_desc_t *flp_desc)
+{
+	int i, j, count, n_dead;
+	flp_t *flp;
+
+	/* wrap L2 around?	*/
+	int wrap_l2 = FALSE;
+	if (flp_desc->config.wrap_l2 && 
+		!strcasecmp(flp_desc->units[flp_desc->n_units-1].name, flp_desc->config.l2_label))
+		wrap_l2 = TRUE;
+
+	flp = (flp_t *) calloc (1, sizeof(flp_t));
+	if(!flp)
+		fatal((char*)"memory allocation error\n");
+	/* 
+	 * number of dead blocks = no. of core blocks - 1.
+	 * (one per vertical or horizontal cut). if L2 is 
+	 * wrapped around, core blocks = flp_desc->n_units-1
+	 */
+	n_dead = flp_desc->n_units - !!(wrap_l2) - 1; 
+	flp->n_units = flp_desc->n_units + n_dead;
+
+	/* wrap L2 around - extra arms are added */
+	if (wrap_l2)
+		flp->n_units += L2_ARMS;
+
+	/* 
+	 * model the dead space in the edge. let us make
+	 * one dead block per corner edge of a block. so, 
+	 * no. of rim blocks could be at most 2*n+2 where
+	 * n is the total no. of blocks (the worst case
+	 * is just all blocks lined up side-by-side)
+	 */
+	if (flp_desc->config.model_rim)
+		flp->n_units += (2*flp->n_units + 2);
+
+	flp->units = (unit_t *) calloc (flp->n_units, sizeof(unit_t));
+	flp->wire_density = (double **) calloc(flp->n_units, sizeof(double *));
+	if (!flp->units || !flp->wire_density)
+		fatal((char*)"memory allocation error\n");
+	for (i=0; i < flp->n_units; i++) {
+	  flp->wire_density[i] = (double *) calloc(flp->n_units, sizeof(double));
+	  if (!flp->wire_density[i])
+	  	fatal((char*)"memory allocation error\n");
+	}
+
+	/* copy connectivity (only for non-dead core blocks) */
+	for(i=0; i < flp_desc->n_units-!!(wrap_l2); i++) {
+	  strcpy(flp->units[i].name, flp_desc->units[i].name);
+	  for (j=0; j < flp_desc->n_units-!!(wrap_l2); j++) {
+	  	flp->wire_density[i][j] = flp_desc->wire_density[i][j];
+	  }
+	}
+
+	/* name the dead blocks	*/
+	for(count=0; count < n_dead; count++, i++)
+		sprintf(flp->units[i].name, DEAD_PREFIX"%d", count);
+
+	/* L2 connectivity info	*/
+	if (wrap_l2)
+		copy_l2_info(flp, i, flp_desc, flp_desc->n_units-1, flp_desc->n_units-1);
+
+	return flp;
+}
+
+/* 
+ * note that if wrap_l2 is true, L2 is beyond the boundary in flp_desc 
+ * but flp contains it within its boundaries.
+ */
+void restore_dead_blocks(flp_t *flp, flp_desc_t *flp_desc, 
+						 int compacted, int wrap_l2, 
+						 int model_rim, int rim_blocks)
+{
+	int i, j, idx=0;
+	/* remove L2 and rim blocks and restore the compacted blocks */
+	if(model_rim)
+		flp->n_units -= rim_blocks;
+	if (wrap_l2)
+		flp->n_units -= (L2_ARMS+1);
+	flp->n_units += compacted;
+
+	/* reinitialize the dead blocks	*/
+	for(i=0; i < flp_desc->n_units-1; i++) {
+		idx = flp_desc->n_units + i;
+		sprintf(flp->units[idx].name, DEAD_PREFIX"%d", i);
+		flp->units[idx].leftx = flp->units[idx].bottomy = 0;
+		flp->units[idx].width = flp->units[idx].height = 0;
+		for(j=0; j < flp->n_units; j++)
+			flp->wire_density[idx][j] = flp->wire_density[j][idx] = 0;
+	}
+}
+
+/* translate the floorplan to new origin (x,y)	*/
+void flp_translate(flp_t *flp, double x, double y)
+{
+	int i;
+	double minx = flp->units[0].leftx;
+	double miny = flp->units[0].bottomy;
+
+	for (i=1; i < flp->n_units; i++) {
+		if (minx > flp->units[i].leftx)
+			minx = flp->units[i].leftx;
+		if (miny > flp->units[i].bottomy)
+			miny = flp->units[i].bottomy;
+	}
+	for (i=0; i < flp->n_units; i++) {
+		flp->units[i].leftx += (x - minx);
+		flp->units[i].bottomy += (y - miny);
+	}
+}
+
+/* scale the floorplan by a factor 'factor'	*/
+void flp_scale(flp_t *flp, double factor)
+{
+	int i;
+	double minx = flp->units[0].leftx;
+	double miny = flp->units[0].bottomy;
+
+	for (i=1; i < flp->n_units; i++) {
+		if (minx > flp->units[i].leftx)
+			minx = flp->units[i].leftx;
+		if (miny > flp->units[i].bottomy)
+			miny = flp->units[i].bottomy;
+	}
+	for(i=0; i < flp->n_units; i++) {
+		flp->units[i].leftx = (flp->units[i].leftx - minx) * factor + minx;
+		flp->units[i].bottomy = (flp->units[i].bottomy - miny) * factor + miny;
+		flp->units[i].width *= factor;
+		flp->units[i].height *= factor;
+	}
+}
+
+/* 
+ * change the orientation of the floorplan by
+ * rotating and/or flipping. the target orientation
+ * is specified in 'target'. 'width', 'height', 'xorig'
+ * and 'yorig' are those of 'flp' respectively.
+ */
+void flp_change_orient(flp_t *flp, double xorig, double yorig,
+					   double width, double height, orient_t target)
+{
+	int i;
+
+	for(i=0; i < flp->n_units; i++) {
+		double leftx, bottomy, rightx, topy;
+		/* all co-ordinate calculations are 
+		 * done assuming (0,0) as the center. 
+		 * so, shift accordingly
+		 */
+		leftx = flp->units[i].leftx  - (xorig + width / 2.0);
+		bottomy = flp->units[i].bottomy - (yorig + height / 2.0);
+		rightx = leftx + flp->units[i].width;
+		topy = bottomy + flp->units[i].height;
+		/* when changing orientation, leftx and 
+		 * bottomy of a rectangle could change
+		 * to one of the other three corners. 
+		 * also, signs of the co-ordinates
+		 * change according to the rotation
+		 * or reflection. Further x & y are
+		 * swapped for rotations that are
+		 * odd multiples of 90 degrees
+		 */
+		switch(target) {
+			case ROT_0:
+					flp->units[i].leftx = leftx;
+					flp->units[i].bottomy = bottomy;
+					break;
+			case ROT_90:
+					flp->units[i].leftx = -topy;
+					flp->units[i].bottomy = leftx;
+					swap_dval(&(flp->units[i].width), &(flp->units[i].height));
+					break;
+			case ROT_180:
+					flp->units[i].leftx = -rightx;
+					flp->units[i].bottomy = -topy;
+					break;
+			case ROT_270:
+					flp->units[i].leftx = bottomy;
+					flp->units[i].bottomy = -rightx;
+					swap_dval(&(flp->units[i].width), &(flp->units[i].height));
+					break;
+			case FLIP_0:
+					flp->units[i].leftx = -rightx;
+					flp->units[i].bottomy = bottomy;
+					break;
+			case FLIP_90:
+					flp->units[i].leftx = bottomy;
+					flp->units[i].bottomy = leftx;
+					swap_dval(&(flp->units[i].width), &(flp->units[i].height));
+					break;
+			case FLIP_180:
+					flp->units[i].leftx = leftx;
+					flp->units[i].bottomy = -topy;
+					break;
+			case FLIP_270:
+					flp->units[i].leftx = -topy;
+					flp->units[i].bottomy = -rightx;
+					swap_dval(&(flp->units[i].width), &(flp->units[i].height));
+					break;
+			default:
+					fatal((char*)"unknown orientation\n");
+					break;
+		}
+		/* translate back to original origin	*/
+		flp->units[i].leftx += (xorig + width / 2.0);
+		flp->units[i].bottomy += (yorig + height / 2.0);
+	}
+}
+
+/* 
+ * create a non-uniform grid-like floorplan equivalent to this.
+ * this function is mainly useful when using the HotSpot block
+ * model to model floorplans of drastically differing aspect
+ * ratios and granularity. an example for such a floorplan
+ * would be the standard ev6 floorplan that comes with HotSpot,
+ * where the register file is subdivided into say 128 entries.
+ * the HotSpot block model could result in inaccuracies while
+ * trying to model such floorplans of differing granularity.
+ * if such inaccuracies occur, use this function to create an 
+ * equivalent floorplan that can be modeled accurately in 
+ * HotSpot. 'map', if non-NULL, is an output parameter to store 
+ * the 2-d array allocated by the function.
+ */
+flp_t *flp_create_grid(flp_t *flp, int ***map)
+{
+	double x[MAX_UNITS], y[MAX_UNITS];
+	int i, j, n, xsize=0, ysize=0, count=0, found, **ptr;
+	flp_t *grid;
+
+	/* sort the units' boundary co-ordinates	*/
+	for(i=0; i < flp->n_units; i++) {
+		double r, t;
+		r = flp->units[i].leftx + flp->units[i].width;
+		t = flp->units[i].bottomy + flp->units[i].height;
+		if(bsearch_insert_double(x, xsize, flp->units[i].leftx))
+			xsize++;
+		if(bsearch_insert_double(y, ysize, flp->units[i].bottomy))
+			ysize++;
+		if(bsearch_insert_double(x, xsize, r))
+			xsize++;
+		if(bsearch_insert_double(y, ysize, t))
+			ysize++;
+	}
+
+	/* 
+	 * the grid formed by the lines from x and y arrays
+	 * is our desired floorplan. allocate memory for it
+	 */
+	grid = (flp_t *) calloc (1, sizeof(flp_t));
+	if(!grid)
+		fatal((char*)"memory allocation error\n");
+	grid->n_units = (xsize-1) * (ysize-1);	
+	grid->units = (unit_t *) calloc (grid->n_units, sizeof(unit_t));
+	grid->wire_density = (double **) calloc(grid->n_units, sizeof(double *));
+	if (!grid->units || !grid->wire_density)
+		fatal((char*)"memory allocation error\n");
+	for (i=0; i < grid->n_units; i++) {
+	  grid->wire_density[i] = (double *) calloc(grid->n_units, sizeof(double));
+	  if (!grid->wire_density[i])
+	  	fatal((char*)"memory allocation error\n");
+	}
+	/* mapping between blocks of 'flp' to those of 'grid'	*/
+	ptr = (int **) calloc(flp->n_units, sizeof(int *));
+	if (!ptr)
+		fatal((char*)"memory allocation error\n");
+	/* 
+	 * ptr is a 2-d array with each row of possibly different
+	 * length. the size of each row is stored in its first element.
+	 * here, it is basically the mapping between 'flp' to 'grid'
+	 * i.e., for each flp->unit, it stores the set of grid->units
+	 * it maps to.
+	 */
+	for(i=0; i < flp->n_units; i++) {
+		ptr[i] = (int *) calloc(grid->n_units+1, sizeof(int));
+		if(!ptr[i])
+	  		fatal((char*)"memory allocation error\n");
+	}
+
+	/* 
+	 * now populate the 'grid' blocks and map the blocks 
+	 * from 'flp' to 'grid'. for each block, identify the 
+	 * intervening lines that chop it into grid cells and 
+	 * assign the names of those cells from that of the 
+	 * block
+	 */
+	for(i=0; i < flp->n_units; i++) {
+		double *xstart, *xend, *ystart, *yend;
+		double *ptr1, *ptr2;
+		int grid_num=0;
+		if (!bsearch_double(x, xsize, flp->units[i].leftx, &xstart))
+			fatal((char*)"invalid sorted arrays\n");
+		if (!bsearch_double(x, xsize, flp->units[i].leftx+flp->units[i].width, &xend))
+			fatal((char*)"invalid sorted arrays\n");
+		if (!bsearch_double(y, ysize, flp->units[i].bottomy, &ystart))
+			fatal((char*)"invalid sorted arrays\n");
+		if (!bsearch_double(y, ysize, flp->units[i].bottomy+flp->units[i].height, &yend))
+			fatal((char*)"invalid sorted arrays\n");
+		for(ptr1 = xstart; ptr1 < xend; ptr1++)
+			for(ptr2 = ystart; ptr2 < yend; ptr2++) {
+				/* add this grid block if it has not been added already	*/
+				for(n=0, found=FALSE; n < count; n++) {
+					if (grid->units[n].leftx == ptr1[0] && grid->units[n].bottomy == ptr2[0]) {
+						found = TRUE;
+						break;
+					}
+				}
+				if(!found) {
+					sprintf(grid->units[count].name, "%s_%d", flp->units[i].name, grid_num);
+					grid->units[count].leftx = ptr1[0];
+					grid->units[count].bottomy = ptr2[0];
+					grid->units[count].width = ptr1[1]-ptr1[0];
+					grid->units[count].height = ptr2[1]-ptr2[0];
+					/* map between position in 'flp' to that in 'grid'	*/
+					ptr[i][++ptr[i][0]] = count;
+					grid_num++;
+					count++;
+				}
+			}
+	}
+
+	/* sanity check	*/
+	if(count != (xsize-1) * (ysize-1))
+		fatal((char*)"mismatch in the no. of units\n");
+
+	/* fill-in the wire densities	*/
+	for(i=0; i < flp->n_units; i++)
+		for(j=0; j < flp->n_units; j++) {
+			int p, q;
+			for(p=1; p <= ptr[i][0]; p++)
+				for(q=1; q <= ptr[j][0]; q++)
+					grid->wire_density[ptr[i][p]][ptr[j][q]] = flp->wire_density[i][j];
+		}
+
+	/* output the map	*/
+	if (map)
+		(*map) = ptr;
+	else
+		free_blkgrid_map(flp, ptr);
+	
+	return grid;
+}
+
+/* free the map allocated by flp_create_grid	*/
+void free_blkgrid_map(flp_t *flp, int **map)
+{
+	int i;
+
+	for(i=0; i < flp->n_units; i++)
+		free(map[i]);
+	free(map);
+}
+
+/* translate power numbers to the grid created by flp_create_grid	*/
+void xlate_power_blkgrid(flp_t *flp, flp_t *grid, \
+						 double *bpower, double *gpower, int **map)
+{
+	int i, p;
+
+	for(i=0; i < flp->n_units; i++)
+		for(p=1; p <= map[i][0]; p++)
+			/* retain the power density	*/
+			gpower[map[i][p]] = bpower[i] / (flp->units[i].width * flp->units[i].height) *\
+								grid->units[map[i][p]].width * grid->units[map[i][p]].height;
+}
+
+/* 
+ * wrap the L2 around this floorplan. L2's area information 
+ * is obtained from flp_desc. memory for L2 and its arms has
+ * already been allocated in the flp. note that flp & flp_desc 
+ * have L2 hidden beyond the boundary at this point
+ */
+void flp_wrap_l2(flp_t *flp, flp_desc_t *flp_desc)
+{
+	/* 
+	 * x is the width of the L2 arms
+	 * y is the height of the bottom portion
+	 */
+	double x, y, core_width, core_height, total_side, core_area, l2_area;
+	unit_t *l2, *l2_left, *l2_right;
+
+	/* find L2 dimensions so that the total chip becomes a square	*/
+	core_area = get_total_area(flp);
+	core_width = get_total_width(flp);
+	core_height = get_total_height(flp);
+	/* flp_desc has L2 hidden beyond the boundary	*/
+	l2_area = flp_desc->units[flp_desc->n_units].area;
+	total_side = sqrt(core_area + l2_area);
+	/* 
+	 * width of the total chip after L2 wrapping is equal to 
+	 * the width of the core plus the width of the two arms
+	 */
+	x = (total_side - core_width) / 2.0;
+	y = total_side - core_height;
+	/* 
+	 * we are trying to solve the equation 
+	 * (2*x+core_width) * (y+core_height) 
+	 * = l2_area + core_area
+	 * for x and y. it is possible that the values 
+	 * turnout to be negative if we restrict the
+	 * total chip to be a square. in that case,
+	 * theoretically, any value of x in the range
+	 * (0, l2_area/(2*core_height)) and the 
+	 * corresponding value of y or any value of y
+	 * in the range (0, l2_area/core_width) and the
+	 * corresponding value of x would be a solution
+	 * we look for a solution with a reasonable 
+	 * aspect ratio. i.e., we constrain kx = y (or
+	 * ky = x  depending on the aspect ratio of the 
+	 * core) where k = WRAP_L2_RATIO. solving the equation 
+	 * with this constraint, we get the following
+	 */
+	if ( x <= 0 || y <= 0.0) {
+		double sum;
+		if (core_width >= core_height) {
+			sum = WRAP_L2_RATIO * core_width + 2 * core_height;
+			x = (sqrt(sum*sum + 8*WRAP_L2_RATIO*l2_area) - sum) / (4*WRAP_L2_RATIO);
+			y = WRAP_L2_RATIO * x;
+		} else {
+			sum = core_width + 2 * WRAP_L2_RATIO * core_height;
+			y = (sqrt(sum*sum + 8*WRAP_L2_RATIO*l2_area) - sum) / (4*WRAP_L2_RATIO);
+			x = WRAP_L2_RATIO * y;
+		}
+		total_side = 2 * x + core_width;
+	}
+	
+	/* fix the positions of core blocks	*/
+	flp_translate(flp, x, y);
+
+	/* restore the L2 blocks	*/
+	flp->n_units += (L2_ARMS+1);
+	/* copy L2 info again from flp_desc but from beyond the boundary	*/
+	copy_l2_info(flp, flp->n_units-L2_ARMS-1, flp_desc, 
+				 flp_desc->n_units, flp_desc->n_units);
+
+	/* fix the positions of the L2  blocks. connectivity
+	 * information has already been fixed (in flp_placeholder).
+	 * bottom L2 block - (leftx, bottomy) is already (0,0)
+	 */
+	l2 = &flp->units[flp->n_units-1-L2_ARMS];
+	l2->width = total_side;
+	l2->height = y;
+	l2->leftx = l2->bottomy = 0;
+
+	/* left L2 arm */
+	l2_left = &flp->units[flp->n_units-L2_ARMS+L2_LEFT];
+	l2_left->width = x;
+	l2_left->height = core_height;
+	l2_left->leftx = 0;
+	l2_left->bottomy = y;
+
+	/* right L2 arm */
+	l2_right = &flp->units[flp->n_units-L2_ARMS+L2_RIGHT];
+	l2_right->width = x;
+	l2_right->height = core_height;
+	l2_right->leftx = x + core_width;
+	l2_right->bottomy = y;
+}
+
+/*
+ * wrap the rim strips around. each edge has rim blocks
+ * equal to the number of blocks abutting that edge. at
+ * the four corners, the rim blocks are extended by the
+ * rim thickness in a clockwise fashion
+ */
+int flp_wrap_rim(flp_t *flp, double rim_thickness)
+{
+	double width, height;
+	int i, j = 0, k, n = flp->n_units;
+	unit_t *unit;
+
+	width = get_total_width(flp) + 2 * rim_thickness;
+	height = get_total_height(flp) + 2 * rim_thickness;
+	flp_translate(flp, rim_thickness, rim_thickness);
+
+	for (i = 0; i < n; i++) {
+		/* shortcut	*/
+		unit = &flp->units[i];
+
+		/* block is on the western border	*/
+		if (eq(unit->leftx, rim_thickness)) {
+			sprintf(flp->units[n+j].name, "%s_%s", 
+					RIM_LEFT_STR, unit->name);
+			flp->units[n+j].width = rim_thickness;
+			flp->units[n+j].height = unit->height;
+			flp->units[n+j].leftx = 0;
+			flp->units[n+j].bottomy = unit->bottomy;
+			/* northwest corner	*/
+			if (eq(unit->bottomy + unit->height, height-rim_thickness))
+				flp->units[n+j].height += rim_thickness;
+			j++;
+		}
+
+		/* block is on the eastern border	*/
+		if (eq(unit->leftx + unit->width, width-rim_thickness)) {
+			sprintf(flp->units[n+j].name, "%s_%s", 
+					RIM_RIGHT_STR, unit->name);
+			flp->units[n+j].width = rim_thickness;
+			flp->units[n+j].height = unit->height;
+			flp->units[n+j].leftx = unit->leftx + unit->width;
+			flp->units[n+j].bottomy = unit->bottomy;
+			/* southeast corner	*/
+			if (eq(unit->bottomy, rim_thickness)) {
+				flp->units[n+j].height += rim_thickness;
+				flp->units[n+j].bottomy = 0;
+			}	
+			j++;
+		}
+
+		/* block is on the northern border 	*/
+		if (eq(unit->bottomy + unit->height, height-rim_thickness)) {
+			sprintf(flp->units[n+j].name, "%s_%s", 
+					RIM_TOP_STR, unit->name);
+			flp->units[n+j].width = unit->width;
+			flp->units[n+j].height = rim_thickness;
+			flp->units[n+j].leftx = unit->leftx;
+			flp->units[n+j].bottomy = unit->bottomy + unit->height;
+			/* northeast corner	*/
+			if (eq(unit->leftx + unit->width, width-rim_thickness))
+				flp->units[n+j].width += rim_thickness;
+			j++;
+		}
+
+		/* block is on the southern border	*/
+		if (eq(unit->bottomy, rim_thickness)) {
+			sprintf(flp->units[n+j].name, "%s_%s", 
+					RIM_BOTTOM_STR, unit->name);
+			flp->units[n+j].width = unit->width;
+			flp->units[n+j].height = rim_thickness;
+			flp->units[n+j].leftx = unit->leftx;
+			flp->units[n+j].bottomy = 0;
+			/* southwest corner	*/
+			if (eq(unit->leftx, rim_thickness)) {
+				flp->units[n+j].width += rim_thickness;
+				flp->units[n+j].leftx = 0;
+			}	
+			j++;
+		}
+	}	
+
+	flp->n_units += j;
+
+	/* update all the rim wire densities */
+	for(i=n; i < n+j; i++)
+		for(k=0; k <= i; k++)
+			flp->wire_density[i][k] = flp->wire_density[k][i] = 0;
+
+	return j;
+}
+
+/* 
+ * floorplanning using simulated annealing.
+ * precondition: flp is a pre-allocated placeholder.
+ * returns the number of compacted blocks in the selected
+ * floorplan
+ */
+int floorplan(flp_t *flp, flp_desc_t *flp_desc, 
+			  RC_model_t *model, double *power)
+{
+	NPE_t *expr, *next, *best;	/* Normalized Polish Expressions */
+	tree_node_stack_t *stack;	/* for NPE evaluation	*/
+	tree_node_t *root;			/* shape curve tree	*/
+	double cost, new_cost, best_cost, sum_cost, T, Tcold;
+	int i, steps, downs, n, rejects, compacted, rim_blocks = 0;
+	int original_n = flp->n_units;
+	int wrap_l2;
+
+	/* to maintain the order of power values during
+	 * the compaction/shifting around of blocks
+	 */
+	double *tpower = hotspot_vector(model);
+
+	/* shortcut	*/
+	flp_config_t cfg = flp_desc->config;
+
+	/* 
+	 * make the rim strips disappear for slicing tree
+	 * purposes. can be restored at the end
+	 */
+	if (cfg.model_rim)
+		flp->n_units = (flp->n_units - 2) / 3;
+
+	/* wrap L2 around?	*/
+	wrap_l2 = FALSE;
+	if (cfg.wrap_l2 && 
+		!strcasecmp(flp_desc->units[flp_desc->n_units-1].name, cfg.l2_label)) {
+		wrap_l2 = TRUE;
+		/* make L2 disappear too */
+		flp_desc->n_units--;
+		flp->n_units -= (L2_ARMS+1);
+	}
+
+	/* initialization	*/
+	expr = NPE_get_initial(flp_desc);
+	stack = new_tree_node_stack();
+	init_rand();
+	
+	/* convert NPE to flp	*/
+	root = tree_from_NPE(flp_desc, stack, expr);
+	/* compacts too small dead blocks	*/
+	compacted = tree_to_flp(root, flp, TRUE, cfg.compact_ratio);
+	/* update the tpower vector according to the compaction	*/
+	trim_hotspot_vector(model, tpower, power, flp->n_units, compacted);
+	free_tree(root);
+	if(wrap_l2)
+		flp_wrap_l2(flp, flp_desc);
+	if(cfg.model_rim)
+		rim_blocks = flp_wrap_rim(flp, cfg.rim_thickness);
+
+	resize_thermal_model(model, flp->n_units);
+	#if VERBOSE > 2
+	print_flp(flp);
+	#endif
+	cost = flp_evaluate_metric(flp, model, tpower, cfg.lambdaA, cfg.lambdaT, cfg.lambdaW);
+	/* restore the compacted blocks	*/
+	restore_dead_blocks(flp, flp_desc, compacted, wrap_l2, cfg.model_rim, rim_blocks);
+
+	best = NPE_duplicate(expr);	/* best till now	*/
+	best_cost = cost;
+
+	/* simulated annealing	*/
+	steps = 0;
+	/* initial annealing temperature	*/
+	T = -cfg.Davg / log(cfg.P0);
+	/* 
+	 * final annealing temperature - we stop when there
+	 * are fewer than (1-cfg.Rreject) accepts.
+	 * of those accepts, assuming half are uphill moves,
+	 * we want the temperature so that the probability
+	 * of accepting uphill moves is as low as
+	 * (1-cfg.Rreject)/2.
+	 */
+	Tcold = -cfg.Davg / log ((1.0 - cfg.Rreject) / 2.0);
+	#if VERBOSE > 0
+	fprintf(stdout, "initial cost: %g\tinitial T: %g\tfinal T: %g\n", cost, T, Tcold);
+	#endif
+	/* 
+	 * stop annealing if temperature has cooled down enough or
+	 * max no. of iterations have been tried
+	 */
+	while (T >= Tcold && steps < cfg.Nmax) {
+		/* shortcut	*/
+		n = cfg.Kmoves * flp->n_units; 
+		i = downs = rejects = 0;
+		sum_cost = 0;
+		/* try enough total or downhill moves per T */
+		while ((i < 2 * n) && (downs < n)) {
+			next = make_random_move(expr);
+
+			/* convert NPE to flp	*/
+			root = tree_from_NPE(flp_desc, stack, next);
+			compacted = tree_to_flp(root, flp, TRUE, cfg.compact_ratio);
+			/* update the tpower vector according to the compaction	*/
+			trim_hotspot_vector(model, tpower, power, flp->n_units, compacted);
+			free_tree(root);
+			if(wrap_l2)
+				flp_wrap_l2(flp, flp_desc);
+			if(cfg.model_rim)
+				rim_blocks = flp_wrap_rim(flp, cfg.rim_thickness);
+
+			resize_thermal_model(model, flp->n_units);
+			#if VERBOSE > 2
+			print_flp(flp);
+			#endif
+			new_cost = flp_evaluate_metric(flp, model, tpower, cfg.lambdaA, cfg.lambdaT, cfg.lambdaW);
+			restore_dead_blocks(flp, flp_desc, compacted, wrap_l2, cfg.model_rim, rim_blocks);
+
+			#if VERBOSE > 1
+			fprintf(stdout, "count: %d\tdowns: %d\tcost: %g\t", 
+					i, downs, new_cost);
+			#endif
+
+			/* move accepted?	*/
+			if (new_cost < cost || 	/* downhill always accepted	*/
+				/* boltzmann probability function	*/
+			    rand_fraction() < exp(-(new_cost-cost)/T)) {
+
+				free_NPE(expr);
+				expr = next;
+
+				/* downhill move	*/
+				if (new_cost < cost) {
+					downs++;
+					/* found new best	*/
+					if (new_cost < best_cost) {
+						free_NPE(best);
+						best = NPE_duplicate(expr);
+						best_cost = new_cost;
+					}
+				}
+
+				#if VERBOSE > 1
+				fprintf(stdout, "accepted\n");
+				#endif
+				cost = new_cost;
+				sum_cost += cost;
+			} else {	/* rejected move	*/
+				rejects++;
+				free_NPE(next);
+				#if VERBOSE > 1
+				fprintf(stdout, "rejected\n");
+				#endif
+			}
+			i++;
+		}
+		#if VERBOSE > 0
+		fprintf(stdout, "step: %d\tT: %g\ttries: %d\taccepts: %d\trejects: %d\t", 
+				steps, T, i, (i-rejects), rejects);
+		fprintf(stdout, "avg. cost: %g\tbest cost: %g\n", 
+		 		(i-rejects)?(sum_cost / (i-rejects)):sum_cost, best_cost); 
+		#endif
+
+		/* stop annealing if there are too little accepts */
+		if(((double)rejects/i) > cfg.Rreject)
+			break;
+
+		/* annealing schedule	*/
+		T *= cfg.Rcool;
+		steps++;	
+	}
+
+	/* best floorplan found	*/
+	root = tree_from_NPE(flp_desc, stack, best);
+	#if VERBOSE > 0
+	{
+		int pos = min_area_pos(root->curve);
+		print_tree_relevant(root, pos, flp_desc);
+	}	
+	#endif
+	compacted = tree_to_flp(root, flp, TRUE, cfg.compact_ratio);
+	/* update the power vector according to the compaction	*/
+	trim_hotspot_vector(model, power, power, flp->n_units, compacted);
+	free_tree(root);
+	/*  restore L2 and rim */
+	if(wrap_l2) {
+		flp_wrap_l2(flp, flp_desc);
+		flp_desc->n_units++;
+	}
+	if(cfg.model_rim)
+		rim_blocks = flp_wrap_rim(flp, cfg.rim_thickness);
+	resize_thermal_model(model, flp->n_units);
+	#if VERBOSE > 2
+	print_flp(flp);
+	#endif
+
+	free_NPE(expr);
+	free_NPE(best);
+	free_tree_node_stack(stack);
+	free_dvector(tpower);
+
+	/* 
+	 * return the number of blocks compacted finally
+	 * so that any deallocator can take care of memory
+	 * accordingly. 
+	 */
+	return (original_n - flp->n_units);
+}
+
+/* functions duplicated from flp_desc.c */
+/* 
+ * find the number of units from the 
+ * floorplan file
+ */
+int flp_count_units(FILE *fp)
+{
+    char str1[LINE_SIZE], str2[LINE_SIZE];
+	char name[STR_SIZE];
+	double leftx, bottomy, width, height;
+	char *ptr;
+    int count = 0;
+
+	fseek(fp, 0, SEEK_SET);
+	while(!feof(fp)) {
+		ptr = fgets(str1, LINE_SIZE, fp);
+		if (feof(fp))
+			break;
+		strcpy(str2, str1);
+		
+		/* ignore comments and empty lines	*/
+		ptr = strtok(str1, " \r\t\n");
+		if (!ptr || ptr[0] == '#')
+			continue;
+
+		/* functional block placement information	*/
+		if (sscanf(str2, "%s%lf%lf%lf%lf", name, &leftx, &bottomy,
+		  		   &width, &height) == 5)
+			count++;
+	}
+	return count;
+}
+
+flp_t *flp_alloc_init_mem(int count)
+{
+	int i;
+	flp_t *flp;
+	flp = (flp_t *) calloc (1, sizeof(flp_t));
+	if(!flp)
+		fatal((char*)"memory allocation error\n");
+	flp->units = (unit_t *) calloc(count, sizeof(unit_t));
+	flp->wire_density = (double **) calloc(count, sizeof(double *));
+	if (!flp->units || !flp->wire_density)
+		fatal((char*)"memory allocation error\n");
+	flp->n_units = count;
+
+	for (i=0; i < count; i++) {
+	  flp->wire_density[i] = (double *) calloc(count, sizeof(double));
+	  if (!flp->wire_density[i])
+	  	fatal((char*)"memory allocation error\n");
+	}
+	return flp;
+}
+
+/* populate block information	*/
+void flp_populate_blks(flp_t *flp, FILE *fp)
+{
+	int i=0;
+	char str[LINE_SIZE], copy[LINE_SIZE]; 
+	char name1[STR_SIZE], name2[STR_SIZE];
+	double width, height, leftx, bottomy;
+	double wire_density;
+	char *ptr;
+
+	fseek(fp, 0, SEEK_SET);
+	while(!feof(fp)) {		/* second pass	*/
+		ptr = fgets(str, LINE_SIZE, fp);
+		if (feof(fp))
+			break;
+		strcpy(copy, str);
+
+		/* ignore comments and empty lines	*/
+		ptr = strtok(str, " \r\t\n");
+		if (!ptr || ptr[0] == '#')
+			continue;
+
+		if (sscanf(copy, "%s%lf%lf%lf%lf", name1, &width, &height, 
+				   &leftx, &bottomy) == 5) {
+			strcpy(flp->units[i].name, name1);
+			flp->units[i].width = width;
+			flp->units[i].height = height;
+			flp->units[i].leftx = leftx;
+			flp->units[i].bottomy = bottomy;
+			i++;
+			/* skip connectivity info	*/
+		} else if (sscanf(copy, "%s%s%lf", name1, name2, &wire_density) != 3) 
+			fatal((char*)"invalid floorplan file format\n");
+	}
+	if (i != flp->n_units)
+	  fatal((char*)"mismatch of number of units\n");
+}
+
+/* populate connectivity info	*/
+void flp_populate_connects(flp_t *flp, FILE *fp)
+{
+	char str1[LINE_SIZE], str2[LINE_SIZE]; 
+	char name1[STR_SIZE], name2[STR_SIZE];
+	/* dummy fields	*/
+	double f1, f2, f3, f4, f5, f6;
+	double wire_density;
+	char *ptr;
+	int x, y, temp;
+
+	/* initialize wire_density	*/
+	for(x=0; x < flp->n_units; x++)
+		for(y=0; y < flp->n_units; y++)
+			flp->wire_density[x][y] = 0.0;
+
+	fseek(fp, 0, SEEK_SET);
+	while(!feof(fp)) {
+		ptr = fgets(str1, LINE_SIZE, fp);
+		if (feof(fp))
+			break;
+		strcpy(str2, str1);
+
+		/* ignore comments and empty lines	*/
+		ptr = strtok(str1, " \r\t\n");
+		if (!ptr || ptr[0] == '#')
+			continue;
+
+		/* lines with unit positions	*/
+		if (sscanf(str2, "%s%lf%lf%lf%lf%lf%lf", name1, &f1, &f2, &f3, &f4, &f5, &f6) == 7 ||
+		  	/* flp_desc like lines. ignore them	*/
+		  	sscanf(str2, "%s%lf%lf%lf%d", name1, &f1, &f2, &f3, &temp) == 5)
+			continue;
+
+		 /* lines with connectivity info	*/
+		else if (sscanf(str2, "%s%s%lf", name1, name2, &wire_density) == 3) {
+			x = get_blk_index(flp, name1);
+			y = get_blk_index(flp, name2);
+
+			if (x == y)
+				fatal((char*)"block connected to itself?\n");
+
+			if (!flp->wire_density[x][y] && !flp->wire_density[y][x])
+				flp->wire_density[x][y] = flp->wire_density[y][x] = wire_density;
+			else if((flp->wire_density[x][y] != flp->wire_density[y][x]) ||
+			        (flp->wire_density[x][y] != wire_density)) {
+				sprintf(str2, "wrong connectivity information for blocks %s and %s\n", 
+				        name1, name2);
+				fatal(str2);
+			}
+		} else 
+		  	fatal((char*)"invalid floorplan file format\n");
+	} /* end while	*/
+}
+
+flp_t *read_flp(const char *file, int read_connects)
+{
+	char str[STR_SIZE];
+	FILE *fp;
+	flp_t *flp;
+	int count, i, j;
+
+	if (!strcasecmp(file, "stdin"))
+		fp = stdin;
+	else
+		fp = fopen (file, "r");
+
+	if (!fp) {
+		sprintf(str, "error opening file %s\n", file);
+		fatal(str);
+	}
+
+	/* 1st pass - find n_units	*/
+	count = flp_count_units(fp);
+	if(!count)
+		fatal((char*)"no units specified in the floorplan file\n");
+
+	/* allocate initial memory */
+	flp = flp_alloc_init_mem(count);
+
+	/* 2nd pass - populate block info	*/
+	flp_populate_blks(flp, fp);
+
+	/* 3rd pass - populate connectivity info    */
+	if (read_connects)
+		flp_populate_connects(flp, fp);
+	/* older version - no connectivity	*/	
+	else for (i=0; i < flp->n_units; i++)
+			for (j=0; j < flp->n_units; j++)
+				flp->wire_density[i][j] = 1.0;
+
+	if(fp != stdin)
+		fclose(fp);	
+
+	/* make sure the origin is (0,0)	*/
+	flp_translate(flp, 0, 0);	
+	return flp;
+}
+
+void dump_flp(flp_t *flp, char *file, int dump_connects)
+{
+	char str[STR_SIZE];
+	int i, j;
+	FILE *fp;
+
+	if (!strcasecmp(file, "stdout"))
+		fp = stdout;
+	else if (!strcasecmp(file, "stderr"))
+		fp = stderr;
+	else 	
+		fp = fopen (file, "w");
+
+	if (!fp) {
+		sprintf(str, "error opening file %s\n", file);
+		fatal(str);
+	}
+	/* functional unit placement info	*/
+	for(i=0; i < flp->n_units; i++)  {
+		fprintf(fp, "%s\t%.11f\t%.11f\t%.11f\t%.11f\n",
+				flp->units[i].name, flp->units[i].width, flp->units[i].height,
+				flp->units[i].leftx, flp->units[i].bottomy);
+	}
+
+	if (dump_connects) {
+		fprintf(fp, "\n");
+		/* connectivity information	*/
+		for(i=1; i < flp->n_units; i++)
+			for(j=0; j < i; j++)
+				if (flp->wire_density[i][j])
+					fprintf(fp, "%s\t%s\t%.3f\n", flp->units[i].name,
+							flp->units[j].name, flp->wire_density[i][j]);
+	}
+	
+	if(fp != stdout && fp != stderr)
+		fclose(fp);
+}
+
+void free_flp(flp_t *flp, int compacted)
+{
+	int i;
+	for (i=0; i < flp->n_units + compacted; i++) {
+		free(flp->wire_density[i]);
+	}
+	free(flp->units);
+	free(flp->wire_density);
+	free(flp);
+}
+
+void print_flp_fig (flp_t *flp)
+{
+	int i;
+	double leftx, bottomy, rightx, topy;
+
+	fprintf(stdout, "FIG starts\n");
+	for (i=0; i< flp->n_units; i++) {
+		leftx = flp->units[i].leftx;
+		bottomy = flp->units[i].bottomy;
+		rightx = flp->units[i].leftx + flp->units[i].width;
+		topy = flp->units[i].bottomy + flp->units[i].height;
+		fprintf(stdout, "%.5f %.5f %.5f %.5f %.5f %.5f %.5f %.5f %.5f %.5f\n", 
+			    leftx, bottomy, leftx, topy, rightx, topy, rightx, bottomy, 
+				leftx, bottomy);
+		fprintf(stdout, "%s\n", flp->units[i].name);
+	}
+	fprintf(stdout, "FIG ends\n");
+}
+
+/* debug print	*/
+void print_flp (flp_t *flp)
+{
+	int i, j;
+
+	fprintf(stdout, "printing floorplan information for %d blocks\n", flp->n_units);
+	fprintf(stdout, "name\tarea\twidth\theight\tleftx\tbottomy\trightx\ttopy\n");
+	for (i=0; i< flp->n_units; i++) {
+		double area, width, height, leftx, bottomy, rightx, topy;
+		char *name;
+		name = flp->units[i].name;
+		width = flp->units[i].width;
+		height = flp->units[i].height;
+		area = width * height;
+		leftx = flp->units[i].leftx;
+		bottomy = flp->units[i].bottomy;
+		rightx = flp->units[i].leftx + flp->units[i].width;
+		topy = flp->units[i].bottomy + flp->units[i].height;
+		fprintf(stdout, "%s\t%lg\t%lg\t%lg\t%lg\t%lg\t%lg\t%lg\n", 
+			    name, area, width, height, leftx, bottomy, rightx, topy);
+	}
+	fprintf(stdout, "printing connections:\n");
+	for (i=0; i< flp->n_units; i++)
+		for (j=i+1; j < flp->n_units; j++)
+			if (flp->wire_density[i][j])
+				fprintf(stdout, "%s\t%s\t%lg\n", flp->units[i].name, 
+						flp->units[j].name, flp->wire_density[i][j]);
+}
+
+/* print the statistics about this floorplan.
+ * note that connects_file is NULL if wire 
+ * information is already populated	
+ */
+void print_flp_stats(flp_t *flp, RC_model_t *model, 
+					 char *l2_label, char *power_file, 
+					 char *connects_file)
+{
+	double core, total, occupied;	/* area	*/
+	double width, height, aspect, total_w, total_h;
+	double wire_metric;
+	double peak, avg;		/* temperature	*/
+	double *power, *temp;
+	FILE *fp = NULL;
+	char str[STR_SIZE];
+
+	if (connects_file) {
+		fp = fopen(connects_file, "r");
+		if (!fp) {
+			sprintf(str, "error opening file %s\n", connects_file);
+			fatal(str);
+		}
+		flp_populate_connects(flp, fp);
+	}
+
+	power = hotspot_vector(model);
+	temp = hotspot_vector(model);
+	read_power(model, power, power_file);
+
+	core = get_core_area(flp, l2_label);
+	total = get_total_area(flp);
+	total_w = get_total_width(flp);
+	total_h = get_total_height(flp);
+	occupied = get_core_occupied_area(flp, l2_label);
+	width = get_core_width(flp, l2_label);
+	height = get_core_height(flp, l2_label);
+	aspect = (height > width) ? (height/width) : (width/height);
+	wire_metric = get_wire_metric(flp);
+
+	populate_R_model(model, flp);
+	steady_state_temp(model, power, temp);
+	peak = find_max_temp(model, temp);
+	avg = find_avg_temp(model, temp);
+
+	fprintf(stdout, "printing summary statistics about the floorplan\n");
+	fprintf(stdout, "total area:\t%g\n", total);
+	fprintf(stdout, "total width:\t%g\n", total_w);
+	fprintf(stdout, "total height:\t%g\n", total_h);
+	fprintf(stdout, "core area:\t%g\n", core);
+	fprintf(stdout, "occupied area:\t%g\n", occupied);
+	fprintf(stdout, "area utilization:\t%.3f\n", occupied / core * 100.0);
+	fprintf(stdout, "core width:\t%g\n", width);
+	fprintf(stdout, "core height:\t%g\n", height);
+	fprintf(stdout, "core aspect ratio:\t%.3f\n", aspect);
+	fprintf(stdout, "wire length metric:\t%.3f\n", wire_metric);
+	fprintf(stdout, "peak temperature:\t%.3f\n", peak);
+	fprintf(stdout, "avg temperature:\t%.3f\n", avg);
+
+	free_dvector(power);
+	free_dvector(temp);
+	if (fp)
+		fclose(fp);
+}
+
+int get_blk_index(flp_t *flp, char *name)
+{
+	int i;
+	char msg[STR_SIZE];
+
+	if (!flp)
+		fatal((char*)"null pointer in get_blk_index\n");
+
+	for (i = 0; i < flp->n_units; i++) {
+		if (!strcasecmp(name, flp->units[i].name)) {
+			return i;
+		}
+	}
+
+	sprintf(msg, "block %s not found\n", name);
+	fatal(msg);
+	return -1;
+}
+
+int is_horiz_adj(flp_t *flp, int i, int j)
+{
+	double x1, x2, x3, x4;
+	double y1, y2, y3, y4;
+
+	if (i == j) 
+		return FALSE;
+
+	x1 = flp->units[i].leftx;
+	x2 = x1 + flp->units[i].width;
+	x3 = flp->units[j].leftx;
+	x4 = x3 + flp->units[j].width;
+
+	y1 = flp->units[i].bottomy;
+	y2 = y1 + flp->units[i].height;
+	y3 = flp->units[j].bottomy;
+	y4 = y3 + flp->units[j].height;
+
+	/* diagonally adjacent => not adjacent */
+	if (eq(x2,x3) && eq(y2,y3))
+		return FALSE;
+	if (eq(x1,x4) && eq(y1,y4))
+		return FALSE;
+	if (eq(x2,x3) && eq(y1,y4))
+		return FALSE;
+	if (eq(x1,x4) && eq(y2,y3))
+		return FALSE;
+
+	if (eq(x1,x4) || eq(x2,x3))
+		if ((y3 >= y1 && y3 <= y2) || (y4 >= y1 && y4 <= y2) ||
+		    (y1 >= y3 && y1 <= y4) || (y2 >= y3 && y2 <= y4))
+			return TRUE;
+
+	return FALSE;
+}
+
+int is_vert_adj (flp_t *flp, int i, int j)
+{
+	double x1, x2, x3, x4;
+	double y1, y2, y3, y4;
+
+	if (i == j)
+		return FALSE;
+
+	x1 = flp->units[i].leftx;
+	x2 = x1 + flp->units[i].width;
+	x3 = flp->units[j].leftx;
+	x4 = x3 + flp->units[j].width;
+
+	y1 = flp->units[i].bottomy;
+	y2 = y1 + flp->units[i].height;
+	y3 = flp->units[j].bottomy;
+	y4 = y3 + flp->units[j].height;
+
+	/* diagonally adjacent => not adjacent */
+	if (eq(x2,x3) && eq(y2,y3))
+		return FALSE;
+	if (eq(x1,x4) && eq(y1,y4))
+		return FALSE;
+	if (eq(x2,x3) && eq(y1,y4))
+		return FALSE;
+	if (eq(x1,x4) && eq(y2,y3))
+		return FALSE;
+
+	if (eq(y1,y4) || eq(y2,y3))
+		if ((x3 >= x1 && x3 <= x2) || (x4 >= x1 && x4 <= x2) ||
+		    (x1 >= x3 && x1 <= x4) || (x2 >= x3 && x2 <= x4))
+			return TRUE;
+
+	return FALSE;
+}
+
+double get_shared_len(flp_t *flp, int i, int j)
+{
+	double p11, p12, p21, p22;
+	p11 = p12 = p21 = p22 = 0.0;
+
+	if (i==j) 
+		return FALSE;
+
+	if (is_horiz_adj(flp, i, j)) {
+		p11 = flp->units[i].bottomy;
+		p12 = p11 + flp->units[i].height;
+		p21 = flp->units[j].bottomy;
+		p22 = p21 + flp->units[j].height;
+	}
+
+	if (is_vert_adj(flp, i, j)) {
+		p11 = flp->units[i].leftx;
+		p12 = p11 + flp->units[i].width;
+		p21 = flp->units[j].leftx;
+		p22 = p21 + flp->units[j].width;
+	}
+
+	return (MIN(p12, p22) - MAX(p11, p21));
+}
+
+double get_total_width(flp_t *flp)
+{	
+	int i;
+	double min_x = flp->units[0].leftx;
+	double max_x = flp->units[0].leftx + flp->units[0].width;
+	
+	for (i=1; i < flp->n_units; i++) {
+		if (flp->units[i].leftx < min_x)
+			min_x = flp->units[i].leftx;
+		if (flp->units[i].leftx + flp->units[i].width > max_x)
+			max_x = flp->units[i].leftx + flp->units[i].width;
+	}
+
+	return (max_x - min_x);
+}
+
+double get_total_height(flp_t *flp)
+{	
+	int i;
+	double min_y = flp->units[0].bottomy;
+	double max_y = flp->units[0].bottomy + flp->units[0].height;
+	
+	for (i=1; i < flp->n_units; i++) {
+		if (flp->units[i].bottomy < min_y)
+			min_y = flp->units[i].bottomy;
+		if (flp->units[i].bottomy + flp->units[i].height > max_y)
+			max_y = flp->units[i].bottomy + flp->units[i].height;
+	}
+
+	return (max_y - min_y);
+}
+
+double get_minx(flp_t *flp)
+{
+	int i;
+	double min_x = flp->units[0].leftx;
+	
+	for (i=1; i < flp->n_units; i++)
+		if (flp->units[i].leftx < min_x)
+			min_x = flp->units[i].leftx;
+
+	return min_x;
+}
+
+double get_miny(flp_t *flp)
+{
+	int i;
+	double min_y = flp->units[0].bottomy;
+	
+	for (i=1; i < flp->n_units; i++)
+		if (flp->units[i].bottomy < min_y)
+			min_y = flp->units[i].bottomy;
+
+	return min_y;
+}
+
+/* precondition: L2 should have been wrapped around	*/
+double get_core_width(flp_t *flp, char *l2_label)
+{
+	int i;
+	double min_x = LARGENUM;
+	double max_x = -LARGENUM;
+	
+	for (i=0; i < flp->n_units; i++) {
+		/* core is that part of the chip excluding the l2 and rim	*/
+		if (strstr(flp->units[i].name, l2_label) != flp->units[i].name &&
+			strstr(flp->units[i].name, RIM_PREFIX) != flp->units[i].name) {
+			if (flp->units[i].leftx < min_x)
+				min_x = flp->units[i].leftx;
+			if (flp->units[i].leftx + flp->units[i].width > max_x)
+				max_x = flp->units[i].leftx + flp->units[i].width;
+		}		
+	}
+
+	return (max_x - min_x);
+}
+
+/* precondition: L2 should have been wrapped around	*/
+double get_core_height(flp_t *flp, char *l2_label)
+{	
+	int i;
+	double min_y = LARGENUM;
+	double max_y = -LARGENUM;
+	
+	for (i=0; i < flp->n_units; i++) {
+		/* core is that part of the chip excluding the l2 and rim	*/
+		if (strstr(flp->units[i].name, l2_label) != flp->units[i].name &&
+			strstr(flp->units[i].name, RIM_PREFIX) != flp->units[i].name) {
+			if (flp->units[i].bottomy < min_y)
+				min_y = flp->units[i].bottomy;
+			if (flp->units[i].bottomy + flp->units[i].height > max_y)
+				max_y = flp->units[i].bottomy + flp->units[i].height;
+		}		
+	}
+
+	return (max_y - min_y);
+}
+
+double get_total_area(flp_t *flp)
+{
+	int i;
+	double area = 0.0;
+	for(i=0; i < flp->n_units; i++)
+		area += flp->units[i].width * flp->units[i].height;
+	return area;	
+}
+
+double get_core_area(flp_t *flp, char *l2_label)
+{
+	int i;
+	double area = 0.0;
+	for(i=0; i < flp->n_units; i++)
+		if (strstr(flp->units[i].name, l2_label) != flp->units[i].name &&
+			strstr(flp->units[i].name, RIM_PREFIX) != flp->units[i].name)
+			area += flp->units[i].width * flp->units[i].height;
+	return area;		
+}
+
+/* excluding the dead blocks	*/
+double get_core_occupied_area(flp_t *flp, char *l2_label)
+{
+	int i, num;
+	double dead_area = 0.0;
+	for(i=0; i < flp->n_units; i++) {
+		/* 
+		 * there can be a max of n-1 dead blocks where n is the
+		 * number of non-dead blocks (since each cut, vertical
+		 * or horizontal, can correspond to a maximum of one
+		 * dead block
+		 */
+		if ((sscanf(flp->units[i].name, DEAD_PREFIX"%d", &num) == 1) &&
+			(num < (flp->n_units-1) / 2))
+			dead_area += flp->units[i].width * flp->units[i].height;
+	}		
+	return get_core_area(flp, l2_label) - dead_area;	
+}
+
+double get_wire_metric(flp_t *flp)
+{
+	int i, j;
+	double w = 0.0, dist;
+
+	for (i=0; i < flp->n_units; i++)
+		for (j=0; j < flp->n_units; j++)
+			if (flp->wire_density[i][j]) {
+				dist = get_manhattan_dist(flp, i, j);
+				w += flp->wire_density[i][j] * dist;
+			}
+	return w;		
+}
+
+double get_manhattan_dist(flp_t *flp, int i, int j)
+{
+	double x1 = flp->units[i].leftx + flp->units[i].width / 2.0;
+	double y1 = flp->units[i].bottomy + flp->units[i].height / 2.0;
+	double x2 = flp->units[j].leftx + flp->units[j].width / 2.0;
+	double y2 = flp->units[j].bottomy + flp->units[j].height / 2.0;
+	return (fabs(x2-x1) + fabs(y2-y1));
+}
diff -Naur temp/flp_desc.c HotSpot/flp_desc.c
--- temp/flp_desc.c	2017-11-20 10:04:24.517682836 +0100
+++ HotSpot/flp_desc.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,278 +0,0 @@
-#include <stdio.h>
-#ifdef _MSC_VER
-#define strcasecmp    _stricmp
-#define strncasecmp   _strnicmp
-#else
-#include <strings.h>
-#endif
-#include <string.h>
-#include <stdlib.h>
-
-#include "flp.h"
-#include "shape.h"
-#include "util.h"
-
-/* get unit index from its name */
-int desc_get_blk_index(flp_desc_t *flp_desc, char *name)
-{
-	int i;
-	char msg[STR_SIZE];
-
-	if (!flp_desc)
-		fatal("null pointer in get_desc_blk_index\n");
-
-	for (i = 0; i < flp_desc->n_units; i++) {
-		if (!strcasecmp(name, flp_desc->units[i].name)) {
-			return i;
-		}
-	}
-
-	sprintf(msg, "block %s not found\n", name);
-	fatal(msg);
-	return -1;
-}
-
-
-/* 
- * find the number of units from the 
- * floorplan description file
- */
-int desc_count_units(FILE *fp)
-{
-    char str1[LINE_SIZE], str2[LINE_SIZE];
-	char name[STR_SIZE];
-	double area, min, max;
-	int rotable;
-	char *ptr;
-    int count = 0;
-
-	fseek(fp, 0, SEEK_SET);
-	while(!feof(fp)) {
-		fgets(str1, LINE_SIZE, fp);
-		if (feof(fp))
-			break;
-		strcpy(str2, str1);
-
-		/* ignore comments and empty lines	*/
-		ptr = strtok(str1, " \r\t\n");
-		if (!ptr || ptr[0] == '#')
-			continue;
-
-		/* lines describing functional block size and aspect ratio	*/
-		if (sscanf(str2, "%s%lf%lf%lf%d", name, &area, &min, &max, &rotable) == 5)
-			count++;
-	}
-	return count;
-}
-
-flp_desc_t *desc_alloc_init_mem(int count, flp_config_t *config)
-{
-	int i;
-	flp_desc_t *flp_desc;
-	flp_desc = (flp_desc_t *) calloc (1, sizeof(flp_desc_t));
-	if(!flp_desc)
-		fatal("memory allocation error\n");
-	flp_desc->units = (unplaced_t *) calloc(count, sizeof(unplaced_t));
-	flp_desc->wire_density = (double **) calloc(count, sizeof(double *));
-	if (!flp_desc->units || !flp_desc->wire_density)
-		fatal("memory allocation error\n");
-	flp_desc->n_units = count;
-	flp_desc->config = *config;
-
-	for (i=0; i < count; i++) {
-	  flp_desc->wire_density[i] = (double *) calloc(count, sizeof(double));
-	  if (!flp_desc->wire_density[i])
-	  	fatal("memory allocation error\n");
-	}
-	return flp_desc;
-}
-
-/* populate block information	*/
-void desc_populate_blks(flp_desc_t *flp_desc, FILE *fp)
-{
-	int i=0;
-	char str1[LINE_SIZE], str2[LINE_SIZE]; 
-	char name1[STR_SIZE], name2[STR_SIZE];
-	double area, min, max, wire_density;
-	int rotable;
-	char *ptr;
-	int wrap_l2 = FALSE;
-
-	fseek(fp, 0, SEEK_SET);
-	while(!feof(fp)) {
-		fgets(str1, LINE_SIZE, fp);
-		if (feof(fp))
-			break;
-		strcpy(str2, str1);
-
-		/* ignore comments and empty lines	*/
-		ptr = strtok(str1, " \r\t\n");
-		if (!ptr || ptr[0] == '#')
-			continue;
-
-		/* lines describing functional block size and aspect ratio	*/
-		if (sscanf(str2, "%s%lf%lf%lf%d", name1, &area, &min, &max, &rotable) == 5) {
-			if (min > max)
-				fatal("minimum aspect ratio greater than maximum\n");
-			if (min <= 0 || max <= 0 || area <= 0)
-				fatal("invalid number in floorplan description\n");
-		  	/* L2 wrap around	*/
-		  	if (flp_desc->config.wrap_l2 && !strcasecmp(name1, flp_desc->config.l2_label)) {
-				wrap_l2 = TRUE;
-                /* min, max, rotable and shape curve have no meaning here   */
-                strcpy(flp_desc->units[flp_desc->n_units - 1].name, name1);
-                flp_desc->units[flp_desc->n_units - 1].area = area;
-			} else {
-		    	strcpy(flp_desc->units[i].name, name1);
-				flp_desc->units[i].area = area;
-				flp_desc->units[i].min_aspect = min;
-				flp_desc->units[i].max_aspect = max;
-				flp_desc->units[i].rotable = rotable;
-				flp_desc->units[i].shape = shape_from_aspect(area, min, max, rotable, 
-															 flp_desc->config.n_orients);
-		    	i++;
-			}
-		} else if (sscanf(str2, "%s%s%lf", name1, name2, &wire_density) != 3)
-				fatal("invalid floorplan description file format\n");
-	}
-
-	if((wrap_l2 && i != flp_desc->n_units - 1) ||
-	  (!wrap_l2 && i != flp_desc->n_units))
-		fatal("mismatch of number of units\n");
-}
-
-/* populate connectivity info	*/
-void desc_populate_connects(flp_desc_t *flp_desc, FILE *fp)
-{
-	char str1[LINE_SIZE], str2[LINE_SIZE]; 
-	char name1[STR_SIZE], name2[STR_SIZE];
-	double area, min, max, wire_density;
-	int rotable;
-	char *ptr;
-
-	fseek(fp, 0, SEEK_SET);
-	while(!feof(fp)) {
-		fgets(str1, LINE_SIZE, fp);
-		if (feof(fp))
-			break;
-		strcpy(str2, str1);
-
-		/* ignore comments and empty lines	*/
-		ptr = strtok(str1, " \r\t\n");
-		if (!ptr || ptr[0] == '#')
-			continue;
-			
-		/* ignore lines describing functional block size and aspect ratio	*/
-		if (sscanf(str2, "%s%lf%lf%lf%d", name1, &area, &min, &max, &rotable) == 5)
-			continue;
-
-		/* lines with connectivity info	*/
-		else if (sscanf(str2, "%s%s%lf", name1, name2, &wire_density) == 3) {
-			int x, y;
-			x = desc_get_blk_index(flp_desc, name1);
-			y = desc_get_blk_index(flp_desc, name2);
-
-			if (x == y)
-				fatal("block connected to itself?\n");
-
-			if (!flp_desc->wire_density[x][y] && !flp_desc->wire_density[y][x])
-				flp_desc->wire_density[x][y] = flp_desc->wire_density[y][x] = wire_density;
-			else if((flp_desc->wire_density[x][y] != flp_desc->wire_density[y][x]) ||
-			        (flp_desc->wire_density[x][y] != wire_density)) {
-				sprintf(str2, "wrong connectivity information for blocks %s and %s\n", 
-						name1, name2);
-				fatal(str2);
-			}
-		} else 
-		  	fatal("invalid floorplan description file format\n");
-	} /* end while	*/
-}
-
-/* read floorplan description and allocate memory	*/
-flp_desc_t *read_flp_desc(char *file, flp_config_t *config)
-{
-	char str[STR_SIZE];
-	FILE *fp = fopen(file, "r");
-	flp_desc_t *flp_desc;
-	int count;
-
-	if (!fp) {
-		sprintf(str, "error opening file %s\n", file);
-		fatal(str);
-	}
-
-	/* 1st pass - find n_units	*/
-	count = desc_count_units(fp);
-	if(!count)
-		fatal("no units specified in the floorplan description file\n");
-
-	/* allocate initial memory */
-	flp_desc = desc_alloc_init_mem(count, config);
-
-	/* 2nd pass - populate block info	*/
-	desc_populate_blks(flp_desc, fp);
-
-	/* 3rd pass - populate connectivity info	*/
-	desc_populate_connects(flp_desc, fp);
-
-	fclose(fp);	
-	return flp_desc;
-}
-
-void free_flp_desc(flp_desc_t *flp_desc)
-{
-	int i;
-	for (i=0; i < flp_desc->n_units; i++) {
-		/* wrapped L2 doesn't have a shape curve	*/
-		if (flp_desc->units[i].shape)
-			free_shape(flp_desc->units[i].shape);
-		free(flp_desc->wire_density[i]);
-	}
-	free(flp_desc->units);
-	free(flp_desc->wire_density);
-	free(flp_desc);
-}
-
-/* debug print	*/
-void print_unplaced(unplaced_t *unit)
-{
-	fprintf(stdout, "printing unit info for %s\n", unit->name);
-	fprintf(stdout, "area=%.5f\tmin=%.5f\tmax=%.5f\trotable=%d\n",
-	        unit->area, unit->min_aspect, unit->max_aspect, unit->rotable);
-	print_shape(unit->shape);
-	fprintf(stdout, "\n");
-}
-
-void desc_print_wire_density(flp_desc_t *flp_desc)
-{
-	int i, j;
-
-	fprintf(stdout, "printing wire density matrix\n\t");
-
-	/* header row	*/
-	for(i=0; i < flp_desc->n_units; i++)
-		fprintf(stdout, "%s\t", flp_desc->units[i].name);
-	fprintf(stdout, "\n");
-
-	for(i=0; i < flp_desc->n_units; i++) {
-		fprintf(stdout, "%s\t", flp_desc->units[i].name);
-		for(j=0; j < flp_desc->n_units; j++)
-			fprintf(stdout, "%.3f\t", flp_desc->wire_density[i][j]);
-		fprintf(stdout, "\n");
-	}
-	fprintf(stdout, "\n");
-}
-
-
-/* debug print	*/
-void print_flp_desc(flp_desc_t *flp_desc)
-{
-	int i;
-
-	for(i=0;  i < flp_desc->n_units; i++)
-		print_unplaced(&flp_desc->units[i]);
-
-	desc_print_wire_density(flp_desc);
-	fprintf(stdout, "\n");
-}
-
diff -Naur temp/flp_desc.cc HotSpot/flp_desc.cc
--- temp/flp_desc.cc	1970-01-01 01:00:00.000000000 +0100
+++ HotSpot/flp_desc.cc	2017-11-20 09:59:35.316820635 +0100
@@ -0,0 +1,278 @@
+#include <stdio.h>
+#ifdef _MSC_VER
+#define strcasecmp    _stricmp
+#define strncasecmp   _strnicmp
+#else
+#include <strings.h>
+#endif
+#include <string.h>
+#include <stdlib.h>
+
+#include "flp.h"
+#include "shape.h"
+#include "util.h"
+
+/* get unit index from its name */
+int desc_get_blk_index(flp_desc_t *flp_desc, char *name)
+{
+	int i;
+	char msg[STR_SIZE];
+
+	if (!flp_desc)
+		fatal((char*)"null pointer in get_desc_blk_index\n");
+
+	for (i = 0; i < flp_desc->n_units; i++) {
+		if (!strcasecmp(name, flp_desc->units[i].name)) {
+			return i;
+		}
+	}
+
+	sprintf(msg, "block %s not found\n", name);
+	fatal(msg);
+	return -1;
+}
+
+
+/* 
+ * find the number of units from the 
+ * floorplan description file
+ */
+int desc_count_units(FILE *fp)
+{
+    char str1[LINE_SIZE], str2[LINE_SIZE];
+	char name[STR_SIZE];
+	double area, min, max;
+	int rotable;
+	char *ptr;
+    int count = 0;
+
+	fseek(fp, 0, SEEK_SET);
+	while(!feof(fp)) {
+		fgets(str1, LINE_SIZE, fp);
+		if (feof(fp))
+			break;
+		strcpy(str2, str1);
+
+		/* ignore comments and empty lines	*/
+		ptr = strtok(str1, " \r\t\n");
+		if (!ptr || ptr[0] == '#')
+			continue;
+
+		/* lines describing functional block size and aspect ratio	*/
+		if (sscanf(str2, "%s%lf%lf%lf%d", name, &area, &min, &max, &rotable) == 5)
+			count++;
+	}
+	return count;
+}
+
+flp_desc_t *desc_alloc_init_mem(int count, flp_config_t *config)
+{
+	int i;
+	flp_desc_t *flp_desc;
+	flp_desc = (flp_desc_t *) calloc (1, sizeof(flp_desc_t));
+	if(!flp_desc)
+		fatal((char*)"memory allocation error\n");
+	flp_desc->units = (unplaced_t *) calloc(count, sizeof(unplaced_t));
+	flp_desc->wire_density = (double **) calloc(count, sizeof(double *));
+	if (!flp_desc->units || !flp_desc->wire_density)
+		fatal((char*)"memory allocation error\n");
+	flp_desc->n_units = count;
+	flp_desc->config = *config;
+
+	for (i=0; i < count; i++) {
+	  flp_desc->wire_density[i] = (double *) calloc(count, sizeof(double));
+	  if (!flp_desc->wire_density[i])
+	  	fatal((char*)"memory allocation error\n");
+	}
+	return flp_desc;
+}
+
+/* populate block information	*/
+void desc_populate_blks(flp_desc_t *flp_desc, FILE *fp)
+{
+	int i=0;
+	char str1[LINE_SIZE], str2[LINE_SIZE]; 
+	char name1[STR_SIZE], name2[STR_SIZE];
+	double area, min, max, wire_density;
+	int rotable;
+	char *ptr;
+	int wrap_l2 = FALSE;
+
+	fseek(fp, 0, SEEK_SET);
+	while(!feof(fp)) {
+		fgets(str1, LINE_SIZE, fp);
+		if (feof(fp))
+			break;
+		strcpy(str2, str1);
+
+		/* ignore comments and empty lines	*/
+		ptr = strtok(str1, " \r\t\n");
+		if (!ptr || ptr[0] == '#')
+			continue;
+
+		/* lines describing functional block size and aspect ratio	*/
+		if (sscanf(str2, "%s%lf%lf%lf%d", name1, &area, &min, &max, &rotable) == 5) {
+			if (min > max)
+				fatal((char*)"minimum aspect ratio greater than maximum\n");
+			if (min <= 0 || max <= 0 || area <= 0)
+				fatal((char*)"invalid number in floorplan description\n");
+		  	/* L2 wrap around	*/
+		  	if (flp_desc->config.wrap_l2 && !strcasecmp(name1, flp_desc->config.l2_label)) {
+				wrap_l2 = TRUE;
+                /* min, max, rotable and shape curve have no meaning here   */
+                strcpy(flp_desc->units[flp_desc->n_units - 1].name, name1);
+                flp_desc->units[flp_desc->n_units - 1].area = area;
+			} else {
+		    	strcpy(flp_desc->units[i].name, name1);
+				flp_desc->units[i].area = area;
+				flp_desc->units[i].min_aspect = min;
+				flp_desc->units[i].max_aspect = max;
+				flp_desc->units[i].rotable = rotable;
+				flp_desc->units[i].shape = shape_from_aspect(area, min, max, rotable, 
+															 flp_desc->config.n_orients);
+		    	i++;
+			}
+		} else if (sscanf(str2, "%s%s%lf", name1, name2, &wire_density) != 3)
+				fatal((char*)"invalid floorplan description file format\n");
+	}
+
+	if((wrap_l2 && i != flp_desc->n_units - 1) ||
+	  (!wrap_l2 && i != flp_desc->n_units))
+		fatal((char*)"mismatch of number of units\n");
+}
+
+/* populate connectivity info	*/
+void desc_populate_connects(flp_desc_t *flp_desc, FILE *fp)
+{
+	char str1[LINE_SIZE], str2[LINE_SIZE]; 
+	char name1[STR_SIZE], name2[STR_SIZE];
+	double area, min, max, wire_density;
+	int rotable;
+	char *ptr;
+
+	fseek(fp, 0, SEEK_SET);
+	while(!feof(fp)) {
+		fgets(str1, LINE_SIZE, fp);
+		if (feof(fp))
+			break;
+		strcpy(str2, str1);
+
+		/* ignore comments and empty lines	*/
+		ptr = strtok(str1, " \r\t\n");
+		if (!ptr || ptr[0] == '#')
+			continue;
+			
+		/* ignore lines describing functional block size and aspect ratio	*/
+		if (sscanf(str2, "%s%lf%lf%lf%d", name1, &area, &min, &max, &rotable) == 5)
+			continue;
+
+		/* lines with connectivity info	*/
+		else if (sscanf(str2, "%s%s%lf", name1, name2, &wire_density) == 3) {
+			int x, y;
+			x = desc_get_blk_index(flp_desc, name1);
+			y = desc_get_blk_index(flp_desc, name2);
+
+			if (x == y)
+				fatal((char*)"block connected to itself?\n");
+
+			if (!flp_desc->wire_density[x][y] && !flp_desc->wire_density[y][x])
+				flp_desc->wire_density[x][y] = flp_desc->wire_density[y][x] = wire_density;
+			else if((flp_desc->wire_density[x][y] != flp_desc->wire_density[y][x]) ||
+			        (flp_desc->wire_density[x][y] != wire_density)) {
+				sprintf(str2, "wrong connectivity information for blocks %s and %s\n", 
+						name1, name2);
+				fatal(str2);
+			}
+		} else 
+		  	fatal((char*)"invalid floorplan description file format\n");
+	} /* end while	*/
+}
+
+/* read floorplan description and allocate memory	*/
+flp_desc_t *read_flp_desc(char *file, flp_config_t *config)
+{
+	char str[STR_SIZE];
+	FILE *fp = fopen(file, "r");
+	flp_desc_t *flp_desc;
+	int count;
+
+	if (!fp) {
+		sprintf(str, "error opening file %s\n", file);
+		fatal(str);
+	}
+
+	/* 1st pass - find n_units	*/
+	count = desc_count_units(fp);
+	if(!count)
+		fatal((char*)"no units specified in the floorplan description file\n");
+
+	/* allocate initial memory */
+	flp_desc = desc_alloc_init_mem(count, config);
+
+	/* 2nd pass - populate block info	*/
+	desc_populate_blks(flp_desc, fp);
+
+	/* 3rd pass - populate connectivity info	*/
+	desc_populate_connects(flp_desc, fp);
+
+	fclose(fp);	
+	return flp_desc;
+}
+
+void free_flp_desc(flp_desc_t *flp_desc)
+{
+	int i;
+	for (i=0; i < flp_desc->n_units; i++) {
+		/* wrapped L2 doesn't have a shape curve	*/
+		if (flp_desc->units[i].shape)
+			free_shape(flp_desc->units[i].shape);
+		free(flp_desc->wire_density[i]);
+	}
+	free(flp_desc->units);
+	free(flp_desc->wire_density);
+	free(flp_desc);
+}
+
+/* debug print	*/
+void print_unplaced(unplaced_t *unit)
+{
+	fprintf(stdout, "printing unit info for %s\n", unit->name);
+	fprintf(stdout, "area=%.5f\tmin=%.5f\tmax=%.5f\trotable=%d\n",
+	        unit->area, unit->min_aspect, unit->max_aspect, unit->rotable);
+	print_shape(unit->shape);
+	fprintf(stdout, "\n");
+}
+
+void desc_print_wire_density(flp_desc_t *flp_desc)
+{
+	int i, j;
+
+	fprintf(stdout, "printing wire density matrix\n\t");
+
+	/* header row	*/
+	for(i=0; i < flp_desc->n_units; i++)
+		fprintf(stdout, "%s\t", flp_desc->units[i].name);
+	fprintf(stdout, "\n");
+
+	for(i=0; i < flp_desc->n_units; i++) {
+		fprintf(stdout, "%s\t", flp_desc->units[i].name);
+		for(j=0; j < flp_desc->n_units; j++)
+			fprintf(stdout, "%.3f\t", flp_desc->wire_density[i][j]);
+		fprintf(stdout, "\n");
+	}
+	fprintf(stdout, "\n");
+}
+
+
+/* debug print	*/
+void print_flp_desc(flp_desc_t *flp_desc)
+{
+	int i;
+
+	for(i=0;  i < flp_desc->n_units; i++)
+		print_unplaced(&flp_desc->units[i]);
+
+	desc_print_wire_density(flp_desc);
+	fprintf(stdout, "\n");
+}
+
diff -Naur temp/flp.h HotSpot/flp.h
--- temp/flp.h	2017-11-20 10:04:33.001703587 +0100
+++ HotSpot/flp.h	2017-11-20 09:59:35.316820635 +0100
@@ -166,7 +166,7 @@
 /* create a floorplan placeholder from description	*/
 flp_t *flp_placeholder(flp_desc_t *flp_desc);
 /* skip floorplanning and read floorplan directly from file */
-flp_t *read_flp(char *file, int read_connects);
+flp_t *read_flp(const char *file, int read_connects);
 /* 
  * main flooplanning routine - allocates 
  * memory internally. returns the number
diff -Naur temp/hotfloorplan.c HotSpot/hotfloorplan.c
--- temp/hotfloorplan.c	2017-11-20 10:04:24.517682836 +0100
+++ HotSpot/hotfloorplan.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,217 +0,0 @@
-/* 
- * HotFloorplan is a temperature-aware floorplanning tool 
- * that can be easily modified to optimize for any arbitrary 
- * metric. This program reads in a floorplan description
- * file that has the area, aspect ratio and connectivity 
- * information of a set of functional blocks. It also reads
- * in a file with the average power dissipation values for
- * those blocks and outputs the best floorplan it can find
- * that optimizes the specified metric.
- */
-#include <stdio.h>
-#include <string.h>
-#ifdef _MSC_VER
-#define strcasecmp    _stricmp
-#define strncasecmp   _strnicmp
-#else
-#include <strings.h>
-#endif
-
-#include "flp.h"
-#include "temperature.h"
-#include "wire.h"
-#include "util.h"
-#include "hotfloorplan.h"
-
-void usage(int argc, char **argv)
-{
-	fprintf(stdout, "Usage: %s -f <file> -p <file> -o <file> [-c <file>] [-d <file>] [options]\n", argv[0]);
-	fprintf(stdout, "Finds a thermally-aware floorplan for the given functional blocks.\n");
-	fprintf(stdout, "Options:(may be specified in any order, within \"[]\" means optional)\n");
-	fprintf(stdout, "   -f <file>\tfloorplan description input file (e.g. ev6.desc)\n");
-	fprintf(stdout, "   -p <file>\tpower input file (e.g. avg.p)\n");
-	fprintf(stdout, "   -o <file>\tfloorplan output file\n");
-	fprintf(stdout, "  [-c <file>]\tinput configuration parameters from file (e.g. hotspot.config)\n");
-	fprintf(stdout, "  [-d <file>]\toutput configuration parameters to file\n");
-	fprintf(stdout, "  [options]\tzero or more options of the form \"-<name> <value>\",\n");
-	fprintf(stdout, "           \toverride the options from config file\n");
-}
-
-/* 
- * parse a table of name-value string pairs and add the configuration
- * parameters to 'config'
- */
-void global_config_from_strs(global_config_t *config, str_pair *table, int size)
-{
-	int idx;
-	if ((idx = get_str_index(table, size, "f")) >= 0) {
-		if(sscanf(table[idx].value, "%s", config->flp_desc) != 1)
-			fatal("invalid format for configuration  parameter flp_desc\n");
-	} else {
-		fatal("required parameter flp_desc missing. check usage\n");
-	}
-	if ((idx = get_str_index(table, size, "p")) >= 0) {
-		if(sscanf(table[idx].value, "%s", config->power_in) != 1)
-			fatal("invalid format for configuration  parameter power_in\n");
-	} else {
-		fatal("required parameter power_in missing. check usage\n");
-	}
-	if ((idx = get_str_index(table, size, "o")) >= 0) {
-		if(sscanf(table[idx].value, "%s", config->flp_out) != 1)
-			fatal("invalid format for configuration  parameter flp_out\n");
-	} else {
-		fatal("required parameter flp_out missing. check usage\n");
-	}
-	if ((idx = get_str_index(table, size, "c")) >= 0) {
-		if(sscanf(table[idx].value, "%s", config->config) != 1)
-			fatal("invalid format for configuration  parameter config\n");
-	} else {
-		strcpy(config->config, NULLFILE);
-	}
-	if ((idx = get_str_index(table, size, "d")) >= 0) {
-		if(sscanf(table[idx].value, "%s", config->dump_config) != 1)
-			fatal("invalid format for configuration  parameter dump_config\n");
-	} else {
-		strcpy(config->dump_config, NULLFILE);
-	}
-}
-
-/* 
- * convert config into a table of name-value pairs. returns the no.
- * of parameters converted
- */
-int global_config_to_strs(global_config_t *config, str_pair *table, int max_entries)
-{
-	if (max_entries < 5)
-		fatal("not enough entries in table\n");
-
-	sprintf(table[0].name, "f");
-	sprintf(table[1].name, "p");
-	sprintf(table[2].name, "o");
-	sprintf(table[3].name, "c");
-	sprintf(table[4].name, "d");
-
-	sprintf(table[0].value, "%s", config->flp_desc);
-	sprintf(table[1].value, "%s", config->power_in);
-	sprintf(table[2].value, "%s", config->flp_out);
-	sprintf(table[3].value, "%s", config->config);
-	sprintf(table[4].value, "%s", config->dump_config);
-
-	return 5;
-}
-
-void print_wire_delays(flp_t *flp, double frequency)
-{
-	int i, j;
-	double delay_g, delay_i;
-	fprintf(stdout, "printing wire delay between blocks for global and intermediate metal layers:\n");
-	fprintf(stdout, "(in %.1f GHz cycles)\n", frequency / 1.0e9);
-	fprintf(stdout, "name1\tname2\tglobal\tintermediate\n");
-	for (i=0; i < flp->n_units-1; i++)
-		for (j=i+1; j < flp->n_units; j++) 
-			if (flp->wire_density[i][j]) {
-				delay_g = wire_length2delay(get_manhattan_dist(flp, i, j), WIRE_GLOBAL);
-				delay_i = wire_length2delay(get_manhattan_dist(flp, i, j), WIRE_INTER);
-				fprintf(stdout, "%s\t%s\t%.3f\t%.3f\n", flp->units[i].name, flp->units[j].name, 
-						frequency * delay_g, frequency * delay_i);
-			}
-}
-
-/* main function for the floorplanner	*/
-int main(int argc, char **argv)
-{
-	flp_desc_t *flp_desc;
-	flp_t *flp;
-	RC_model_t *model;
-	double *power;
-	thermal_config_t thermal_config;
-	flp_config_t flp_config;
-	global_config_t global_config;
-	str_pair table[MAX_ENTRIES];
-	int size, compacted;
-
-	if (!(argc >= 7 && argc % 2)) {
-		usage(argc, argv);
-		return 1;
-	}
-	
-	size = parse_cmdline(table, MAX_ENTRIES, argc, argv);
-	global_config_from_strs(&global_config, table, size);
-
-	/* read configuration file	*/
-	if (strcmp(global_config.config, NULLFILE))
-		size += read_str_pairs(&table[size], MAX_ENTRIES, global_config.config);
-
-	/* 
-	 * in the str_pair 'table', earlier entries override later ones.
-	 * so, command line options have priority over config file 
-	 */
-	size = str_pairs_remove_duplicates(table, size);
-
-	/* get defaults */
-	thermal_config = default_thermal_config();
-	flp_config = default_flp_config();
-	/* modify according to command line / config file	*/
-	thermal_config_add_from_strs(&thermal_config, table, size);
-	flp_config_add_from_strs(&flp_config, table, size);
-
-	/* dump configuration if specified	*/
-	if (strcmp(global_config.dump_config, NULLFILE)) {
-		size = global_config_to_strs(&global_config, table, MAX_ENTRIES);
-		size += thermal_config_to_strs(&thermal_config, &table[size], MAX_ENTRIES-size);
-		size += flp_config_to_strs(&flp_config, &table[size], MAX_ENTRIES-size);
-		/* prefix the name of the variable with a '-'	*/
-		dump_str_pairs(table, size, global_config.dump_config, "-");
-	}
-
-	/* If the grid model is used, things could be really slow!
-	 * Also make sure it is not in the 3-d chip mode (specified 
-	 * with the layer configuration file)
-	 */
-	if (!strcmp(thermal_config.model_type, GRID_MODEL_STR)) {
-		if (strcmp(thermal_config.grid_layer_file, NULLFILE))
-			fatal("lcf file specified with the grid model. 3-d chips not supported\n");
-		warning("grid model is used. HotFloorplan could be REALLY slow\n");
-	}
-
-	/* description of the functional blocks to be floorplanned	*/
-	flp_desc = read_flp_desc(global_config.flp_desc, &flp_config);
-	/* 
-	 * just an empty frame with blocks' names.
-	 * block positions not known yet.
-	 */
-	flp = flp_placeholder(flp_desc);
-	/* temperature model	*/
-	model = alloc_RC_model(&thermal_config, flp);
-	/* input power vector	*/
-	power = hotspot_vector(model);
-	read_power(model, power, global_config.power_in);
-
-	/* main floorplanning routine	*/
-	compacted = floorplan(flp, flp_desc, model, power);
-	/* 
-	 * print the finally selected floorplan in a format that can 
-	 * be understood by tofig.pl (which converts it to a FIG file)
-	 */
-	print_flp_fig(flp);
-	/* print the floorplan statistics	*/
-	if (flp_config.wrap_l2 &&
-		!strcasecmp(flp_desc->units[flp_desc->n_units-1].name, flp_config.l2_label))
-		print_flp_stats(flp, model, flp_config.l2_label, 
-						global_config.power_in, global_config.flp_desc);
-	
-	/* print the wire delays between blocks	*/
-	print_wire_delays(flp, thermal_config.base_proc_freq);
-
-	/* also output the floorplan to a file readable by hotspot	*/
-	dump_flp(flp, global_config.flp_out, FALSE);
-
-	free_flp_desc(flp_desc);
-	delete_RC_model(model);
-	free_dvector(power);
-
-	/* while deallocating, free the compacted blocks too	*/
-	free_flp(flp, compacted);
-
-	return 0;
-}
diff -Naur temp/hotfloorplan.h HotSpot/hotfloorplan.h
--- temp/hotfloorplan.h	2017-11-20 10:04:33.005703597 +0100
+++ HotSpot/hotfloorplan.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,32 +0,0 @@
-#ifndef __HOTFLOORPLAN_H_
-#define __HOTFLOORPLAN_H_
-
-#include "util.h"
-
-/* global configuration parameters for HotFloorplan	*/
-typedef struct global_config_t_st
-{
-	/* floorplan description input file	*/
-	char flp_desc[STR_SIZE];
-	/* power input file	*/
-	char power_in[STR_SIZE];
-	/* floorplan output file */
-	char flp_out[STR_SIZE];
-	/* input configuration parameters from file	*/
-	char config[STR_SIZE];
-	/* output configuration parameters to file	*/
-	char dump_config[STR_SIZE];
-}global_config_t;
-
-/* 
- * parse a table of name-value string pairs and add the configuration
- * parameters to 'config'
- */
-void global_config_from_strs(global_config_t *config, str_pair *table, int size);
-/* 
- * convert config into a table of name-value pairs. returns the no.
- * of parameters converted
- */
-int global_config_to_strs(global_config_t *config, str_pair *table, int max_entries);
-
-#endif
diff -Naur temp/hotspot.c HotSpot/hotspot.c
--- temp/hotspot.c	2017-11-20 10:04:24.517682836 +0100
+++ HotSpot/hotspot.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,580 +0,0 @@
-/* 
- * This is a trace-level thermal simulator. It reads power values 
- * from an input trace file and outputs the corresponding instantaneous 
- * temperature values to an output trace file. It also outputs the steady 
- * state temperature values to stdout.
- */
-#include <stdio.h>
-#include <stdlib.h>
-#include <assert.h>
-#include <string.h>
-#include <ctype.h>
-#include <math.h>
-
-#include "flp.h"
-#include "package.h"
-#include "temperature.h"
-#include "temperature_block.h"
-#include "temperature_grid.h"
-#include "util.h"
-#include "hotspot.h"
-
-/* HotSpot thermal model is offered in two flavours - the block
- * version and the grid version. The block model models temperature
- * per functional block of the floorplan while the grid model
- * chops the chip up into a matrix of grid cells and models the 
- * temperature of each cell. It is also capable of modeling a
- * 3-d chip with multiple floorplans stacked on top of each
- * other. The choice of which model to choose is done through
- * a command line or configuration file parameter model_type. 
- * "-model_type block" chooses the block model while "-model_type grid"
- * chooses the grid model. 
- */
-
-/* Guidelines for choosing the block or the grid model	*/
-
-/**************************************************************************/
-/* This version of HotSpot contains two methods for solving temperatures: */
-/* 	1) Block Model -- the same as HotSpot 2.0							  */
-/*	2) Grid Model -- the die is divided into regular grid cells (NEW!) 	  */
-/**************************************************************************/
-/* How the grid model works: 											  */
-/* 	The grid model first reads in floorplan and maps block-based power	  */
-/* to each grid cell, then solves the temperatures for all the grid cells,*/
-/* finally, converts the resulting grid temperatures back to block-based  */
-/* temperatures.														  */
-/**************************************************************************/
-/* The grid model is useful when 										  */
-/* 	1) More detailed temperature distribution inside a functional unit    */
-/*     is desired.														  */
-/*  2) Too many functional units are included in the floorplan, resulting */
-/*		 in extremely long computation time if using the Block Model      */
-/*	3) If temperature information is desired for many tiny units,		  */ 
-/* 		 such as individual register file entry.						  */
-/**************************************************************************/
-/*	Comparisons between Grid Model and Block Model:						  */
-/*		In general, the grid model is more accurate, because it can deal  */
-/*	with various floorplans and it provides temperature gradient across	  */
-/*	each functional unit. The block model models essentially the center	  */
-/*	temperature of each functional unit. But the block model is typically */
-/*	faster because there are less nodes to solve.						  */
-/*		Therefore, unless it is the case where the grid model is 		  */
-/*	definitely	needed, we suggest using the block model for computation  */
-/*  efficiency.															  */
-/**************************************************************************/
-/* Other features of the grid model:									  */
-/*	1) Multi-layer -- the grid model supports multilayer structures, such */
-/* 		 as 3D integration where multiple silicon layers with 			  */
-/*		 different floorplans and dissipating power,					  */
-/* 		 or multilayer of on-chip interconnects dissipating self-heating  */
-/*		 power, etc. To enable this feature, the user needs to provide a  */
-/*		 layer config file (.lcf). An example layer.lcf file is provided  */
-/*       with this release.	                                              */
-/**************************************************************************/
-
-void usage(int argc, char **argv)
-{
-	fprintf(stdout, "Usage: %s -f <file> -p <file> [-o <file>] [-c <file>] [-d <file>] [options]\n", argv[0]);
-	fprintf(stdout, "A thermal simulator that reads power trace from a file and outputs temperatures.\n");
-	fprintf(stdout, "Options:(may be specified in any order, within \"[]\" means optional)\n");
-	fprintf(stdout, "   -f <file>\tfloorplan input file (e.g. ev6.flp) - overridden by the\n");
-	fprintf(stdout, "            \tlayer configuration file (e.g. layer.lcf) when the\n");
-	fprintf(stdout, "            \tlatter is specified\n");
-	fprintf(stdout, "   -p <file>\tpower trace input file (e.g. gcc.ptrace)\n");
-	fprintf(stdout, "  [-o <file>]\ttransient temperature trace output file - if not provided, only\n");
-	fprintf(stdout, "            \tsteady state temperatures are output to stdout\n");
-	fprintf(stdout, "  [-c <file>]\tinput configuration parameters from file (e.g. hotspot.config)\n");
-	fprintf(stdout, "  [-d <file>]\toutput configuration parameters to file\n");
-	fprintf(stdout, "  [options]\tzero or more options of the form \"-<name> <value>\",\n");
-	fprintf(stdout, "           \toverride the options from config file. e.g. \"-model_type block\" selects\n");
-	fprintf(stdout, "           \tthe block model while \"-model_type grid\" selects the grid model\n");
-}
-
-/* 
- * parse a table of name-value string pairs and add the configuration
- * parameters to 'config'
- */
-void global_config_from_strs(global_config_t *config, str_pair *table, int size)
-{
-	int idx;
-	if ((idx = get_str_index(table, size, "f")) >= 0) {
-		if(sscanf(table[idx].value, "%s", config->flp_file) != 1)
-			fatal("invalid format for configuration  parameter flp_file\n");
-	} else {
-		fatal("required parameter flp_file missing. check usage\n");
-	}
-	if ((idx = get_str_index(table, size, "p")) >= 0) {
-		if(sscanf(table[idx].value, "%s", config->p_infile) != 1)
-			fatal("invalid format for configuration  parameter p_infile\n");
-	} else {
-		fatal("required parameter p_infile missing. check usage\n");
-	}
-	if ((idx = get_str_index(table, size, "o")) >= 0) {
-		if(sscanf(table[idx].value, "%s", config->t_outfile) != 1)
-			fatal("invalid format for configuration  parameter t_outfile\n");
-	} else {
-		strcpy(config->t_outfile, NULLFILE);
-	}
-	if ((idx = get_str_index(table, size, "c")) >= 0) {
-		if(sscanf(table[idx].value, "%s", config->config) != 1)
-			fatal("invalid format for configuration  parameter config\n");
-	} else {
-		strcpy(config->config, NULLFILE);
-	}
-	if ((idx = get_str_index(table, size, "d")) >= 0) {
-		if(sscanf(table[idx].value, "%s", config->dump_config) != 1)
-			fatal("invalid format for configuration  parameter dump_config\n");
-	} else {
-		strcpy(config->dump_config, NULLFILE);
-	}
-}
-
-/* 
- * convert config into a table of name-value pairs. returns the no.
- * of parameters converted
- */
-int global_config_to_strs(global_config_t *config, str_pair *table, int max_entries)
-{
-	if (max_entries < 5)
-		fatal("not enough entries in table\n");
-
-	sprintf(table[0].name, "f");
-	sprintf(table[1].name, "p");
-	sprintf(table[2].name, "o");
-	sprintf(table[3].name, "c");
-	sprintf(table[4].name, "d");
-
-	sprintf(table[0].value, "%s", config->flp_file);
-	sprintf(table[1].value, "%s", config->p_infile);
-	sprintf(table[2].value, "%s", config->t_outfile);
-	sprintf(table[3].value, "%s", config->config);
-	sprintf(table[4].value, "%s", config->dump_config);
-
-	return 5;
-}
-
-/* 
- * read a single line of trace file containing names
- * of functional blocks
- */
-int read_names(FILE *fp, char **names)
-{
-	char line[LINE_SIZE], temp[LINE_SIZE], *src;
-	int i;
-
-	/* skip empty lines	*/
-	do {
-		/* read the entire line	*/
-		fgets(line, LINE_SIZE, fp);
-		if (feof(fp))
-			fatal("not enough names in trace file\n");
-		strcpy(temp, line);
-		src = strtok(temp, " \r\t\n");
-	} while (!src);
-
-	/* new line not read yet	*/	
-	if(line[strlen(line)-1] != '\n')
-		fatal("line too long\n");
-
-	/* chop the names from the line read	*/
-	for(i=0,src=line; *src && i < MAX_UNITS; i++) {
-		if(!sscanf(src, "%s", names[i]))
-			fatal("invalid format of names\n");
-		src += strlen(names[i]);
-		while (isspace((int)*src))
-			src++;
-	}
-	if(*src && i == MAX_UNITS)
-		fatal("no. of units exceeded limit\n");
-
-	return i;
-}
-
-/* read a single line of power trace numbers	*/
-int read_vals(FILE *fp, double *vals)
-{
-	char line[LINE_SIZE], temp[LINE_SIZE], *src;
-	int i;
-
-	/* skip empty lines	*/
-	do {
-		/* read the entire line	*/
-		fgets(line, LINE_SIZE, fp);
-		if (feof(fp))
-			return 0;
-		strcpy(temp, line);
-		src = strtok(temp, " \r\t\n");
-	} while (!src);
-
-	/* new line not read yet	*/	
-	if(line[strlen(line)-1] != '\n')
-		fatal("line too long\n");
-
-	/* chop the power values from the line read	*/
-	for(i=0,src=line; *src && i < MAX_UNITS; i++) {
-		if(!sscanf(src, "%s", temp) || !sscanf(src, "%lf", &vals[i]))
-			fatal("invalid format of values\n");
-		src += strlen(temp);
-		while (isspace((int)*src))
-			src++;
-	}
-	if(*src && i == MAX_UNITS)
-		fatal("no. of entries exceeded limit\n");
-
-	return i;
-}
-
-/* write a single line of functional unit names	*/
-void write_names(FILE *fp, char **names, int size)
-{
-	int i;
-	for(i=0; i < size-1; i++)
-		fprintf(fp, "%s\t", names[i]);
-	fprintf(fp, "%s\n", names[i]);
-}
-
-/* write a single line of temperature trace(in degree C)	*/
-void write_vals(FILE *fp, double *vals, int size)
-{
-	int i;
-	for(i=0; i < size-1; i++)
-		fprintf(fp, "%.2f\t", vals[i]-273.15);
-	fprintf(fp, "%.2f\n", vals[i]-273.15);
-}
-
-char **alloc_names(int nr, int nc)
-{
-	int i;
-	char **m;
-
-	m = (char **) calloc (nr, sizeof(char *));
-	assert(m != NULL);
-	m[0] = (char *) calloc (nr * nc, sizeof(char));
-	assert(m[0] != NULL);
-
-	for (i = 1; i < nr; i++)
-    	m[i] =  m[0] + nc * i;
-
-	return m;
-}
-
-void free_names(char **m)
-{
-	free(m[0]);
-	free(m);
-}
-
-/* 
- * main function - reads instantaneous power values (in W) from a trace
- * file (e.g. "gcc.ptrace") and outputs instantaneous temperature values (in C) to
- * a trace file("gcc.ttrace"). also outputs steady state temperature values
- * (including those of the internal nodes of the model) onto stdout. the
- * trace files are 2-d matrices with each column representing a functional
- * functional block and each row representing a time unit(sampling_intvl).
- * columns are tab-separated and each row is a separate line. the first
- * line contains the names of the functional blocks. the order in which
- * the columns are specified doesn't have to match that of the floorplan 
- * file.
- */
-int main(int argc, char **argv)
-{
-	int i, j, idx, base = 0, count = 0, n = 0;
-	int num, size, lines = 0, do_transient = TRUE;
-	char **names;
-	double *vals;
-	/* trace file pointers	*/
-	FILE *pin, *tout = NULL;
-	/* floorplan	*/
-	flp_t *flp;
-	/* hotspot temperature model	*/
-	RC_model_t *model;
-	/* instantaneous temperature and power values	*/
-	double *temp = NULL, *power;
-	double total_power = 0.0;
-	
-	/* steady state temperature and power values	*/
-	double *overall_power, *steady_temp;
-	/* thermal model configuration parameters	*/
-	thermal_config_t thermal_config;
-	/* global configuration parameters	*/
-	global_config_t global_config;
-	/* table to hold options and configuration */
-	str_pair table[MAX_ENTRIES];
-	
-	/* variables for natural convection iterations */
-	int natural = 0; 
-	double avg_sink_temp = 0;
-	int natural_convergence = 0;
-	double r_convec_old;
-
-	if (!(argc >= 5 && argc % 2)) {
-		usage(argc, argv);
-		return 1;
-	}
-	
-	size = parse_cmdline(table, MAX_ENTRIES, argc, argv);
-	global_config_from_strs(&global_config, table, size);
-
-	/* no transient simulation, only steady state	*/
-	if(!strcmp(global_config.t_outfile, NULLFILE))
-		do_transient = FALSE;
-
-	/* read configuration file	*/
-	if (strcmp(global_config.config, NULLFILE))
-		size += read_str_pairs(&table[size], MAX_ENTRIES, global_config.config);
-
-	/* 
-	 * earlier entries override later ones. so, command line options 
-	 * have priority over config file 
-	 */
-	size = str_pairs_remove_duplicates(table, size);
-
-	/* get defaults */
-	thermal_config = default_thermal_config();
-	/* modify according to command line / config file	*/
-	thermal_config_add_from_strs(&thermal_config, table, size);
-	
-	/* if package model is used, run package model */
-	if (((idx = get_str_index(table, size, "package_model_used")) >= 0) && !(table[idx].value==0)) {
-		if (thermal_config.package_model_used) {
-			avg_sink_temp = thermal_config.ambient + SMALL_FOR_CONVEC;
-			natural = package_model(&thermal_config, table, size, avg_sink_temp);
-			if (thermal_config.r_convec<R_CONVEC_LOW || thermal_config.r_convec>R_CONVEC_HIGH)
-				printf("Warning: Heatsink convection resistance is not realistic, double-check your package settings...\n"); 
-		}
-	}
-
-	/* dump configuration if specified	*/
-	if (strcmp(global_config.dump_config, NULLFILE)) {
-		size = global_config_to_strs(&global_config, table, MAX_ENTRIES);
-		size += thermal_config_to_strs(&thermal_config, &table[size], MAX_ENTRIES-size);
-		/* prefix the name of the variable with a '-'	*/
-		dump_str_pairs(table, size, global_config.dump_config, "-");
-	}
-
-	/* initialization: the flp_file global configuration 
-	 * parameter is overridden by the layer configuration 
-	 * file in the grid model when the latter is specified.
-	 */
-	flp = read_flp(global_config.flp_file, FALSE);
-
-	/* allocate and initialize the RC model	*/
-	model = alloc_RC_model(&thermal_config, flp);
-	populate_R_model(model, flp);
-	
-	if (do_transient)
-		populate_C_model(model, flp);
-
-	#if VERBOSE > 2
-	debug_print_model(model);
-	#endif
-
-	/* allocate the temp and power arrays	*/
-	/* using hotspot_vector to internally allocate any extra nodes needed	*/
-	if (do_transient)
-		temp = hotspot_vector(model);
-	power = hotspot_vector(model);
-	steady_temp = hotspot_vector(model);
-	overall_power = hotspot_vector(model);
-	
-	/* set up initial instantaneous temperatures */
-	if (do_transient && strcmp(model->config->init_file, NULLFILE)) {
-		if (!model->config->dtm_used)	/* initial T = steady T for no DTM	*/
-			read_temp(model, temp, model->config->init_file, FALSE);
-		else	/* initial T = clipped steady T with DTM	*/
-			read_temp(model, temp, model->config->init_file, TRUE);
-	} else if (do_transient)	/* no input file - use init_temp as the common temperature	*/
-		set_temp(model, temp, model->config->init_temp);
-
-	/* n is the number of functional blocks in the block model
-	 * while it is the sum total of the number of functional blocks
-	 * of all the floorplans in the power dissipating layers of the 
-	 * grid model. 
-	 */
-	if (model->type == BLOCK_MODEL)
-		n = model->block->flp->n_units;
-	else if (model->type == GRID_MODEL) {
-		for(i=0; i < model->grid->n_layers; i++)
-			if (model->grid->layers[i].has_power)
-				n += model->grid->layers[i].flp->n_units;
-	} else 
-		fatal("unknown model type\n");
-
-	if(!(pin = fopen(global_config.p_infile, "r")))
-		fatal("unable to open power trace input file\n");
-	if(do_transient && !(tout = fopen(global_config.t_outfile, "w")))
-		fatal("unable to open temperature trace file for output\n");
-
-	/* names of functional units	*/
-	names = alloc_names(MAX_UNITS, STR_SIZE);
-	if(read_names(pin, names) != n)
-		fatal("no. of units in floorplan and trace file differ\n");
-
-	/* header line of temperature trace	*/
-	if (do_transient)
-		write_names(tout, names, n);
-
-	/* read the instantaneous power trace	*/
-	vals = dvector(MAX_UNITS);
-	while ((num=read_vals(pin, vals)) != 0) {
-		if(num != n)
-			fatal("invalid trace file format\n");
-
-		/* permute the power numbers according to the floorplan order	*/
-		if (model->type == BLOCK_MODEL)
-			for(i=0; i < n; i++)
-				power[get_blk_index(flp, names[i])] = vals[i];
-		else
-			for(i=0, base=0, count=0; i < model->grid->n_layers; i++) {
-				if(model->grid->layers[i].has_power) {
-					for(j=0; j < model->grid->layers[i].flp->n_units; j++) {
-						idx = get_blk_index(model->grid->layers[i].flp, names[count+j]);
-						power[base+idx] = vals[count+j];
-					}
-					count += model->grid->layers[i].flp->n_units;
-				}	
-				base += model->grid->layers[i].flp->n_units;	
-			}
-
-		/* compute temperature	*/
-		if (do_transient) {
-			/* if natural convection is considered, update transient convection resistance first */
-			if (natural) {
-				avg_sink_temp = calc_sink_temp(model, temp);
-				natural = package_model(model->config, table, size, avg_sink_temp);
-				populate_R_model(model, flp);
-			}
-			/* for the grid model, only the first call to compute_temp
-			 * passes a non-null 'temp' array. if 'temp' is  NULL, 
-			 * compute_temp remembers it from the last non-null call. 
-			 * this is used to maintain the internal grid temperatures 
-			 * across multiple calls of compute_temp
-			 */
-			if (model->type == BLOCK_MODEL || lines == 0)
-				compute_temp(model, power, temp, model->config->sampling_intvl);
-			else
-				compute_temp(model, power, NULL, model->config->sampling_intvl);
-	
-			/* permute back to the trace file order	*/
-			if (model->type == BLOCK_MODEL)
-				for(i=0; i < n; i++)
-					vals[i] = temp[get_blk_index(flp, names[i])];
-			else
-				for(i=0, base=0, count=0; i < model->grid->n_layers; i++) {
-					if(model->grid->layers[i].has_power) {
-						for(j=0; j < model->grid->layers[i].flp->n_units; j++) {
-							idx = get_blk_index(model->grid->layers[i].flp, names[count+j]);
-							vals[count+j] = temp[base+idx];
-						}
-						count += model->grid->layers[i].flp->n_units;	
-					}	
-					base += model->grid->layers[i].flp->n_units;	
-				}
-		
-			/* output instantaneous temperature trace	*/
-			write_vals(tout, vals, n);
-		}		
-	
-		/* for computing average	*/
-		if (model->type == BLOCK_MODEL)
-			for(i=0; i < n; i++)
-				overall_power[i] += power[i];
-		else
-			for(i=0, base=0; i < model->grid->n_layers; i++) {
-				if(model->grid->layers[i].has_power)
-					for(j=0; j < model->grid->layers[i].flp->n_units; j++)
-						overall_power[base+j] += power[base+j];
-				base += model->grid->layers[i].flp->n_units;	
-			}
-
-		lines++;
-	}
-
-	if(!lines)
-		fatal("no power numbers in trace file\n");
-		
-	/* for computing average	*/
-	if (model->type == BLOCK_MODEL)
-		for(i=0; i < n; i++) {
-			overall_power[i] /= lines;
-			//overall_power[i] /=150; //reduce input power for natural convection
-			total_power += overall_power[i];
-		}
-	else
-		for(i=0, base=0; i < model->grid->n_layers; i++) {
-			if(model->grid->layers[i].has_power)
-				for(j=0; j < model->grid->layers[i].flp->n_units; j++) {
-					overall_power[base+j] /= lines;
-					total_power += overall_power[base+j];
-				}
-			base += model->grid->layers[i].flp->n_units;	
-		}
-		
-	/* natural convection r_convec iteration, for steady-state only */ 		
-	natural_convergence = 0;
-	if (natural) { /* natural convection is used */
-		while (!natural_convergence) {
-			r_convec_old = model->config->r_convec;
-			/* steady state temperature	*/
-			steady_state_temp(model, overall_power, steady_temp);
-			avg_sink_temp = calc_sink_temp(model, steady_temp) + SMALL_FOR_CONVEC;
-			natural = package_model(model->config, table, size, avg_sink_temp);
-			populate_R_model(model, flp);
-			if (avg_sink_temp > MAX_SINK_TEMP)
-				fatal("too high power for a natural convection package -- possible thermal runaway\n");
-			if (fabs(model->config->r_convec-r_convec_old)<NATURAL_CONVEC_TOL) 
-				natural_convergence = 1;
-		}
-	}	else /* natural convection is not used, no need for iterations */
-	/* steady state temperature	*/
-	steady_state_temp(model, overall_power, steady_temp);
-
-	/* print steady state results	*/
-	fprintf(stdout, "Unit\tSteady(Kelvin)\n");
-	dump_temp(model, steady_temp, "stdout");
-
-	/* dump steady state temperatures on to file if needed	*/
-	if (strcmp(model->config->steady_file, NULLFILE))
-		dump_temp(model, steady_temp, model->config->steady_file);
-
-	/* for the grid model, optionally dump the most recent 
-	 * steady state temperatures of the grid cells	
-	 */
-	if (model->type == GRID_MODEL &&
-		strcmp(model->config->grid_steady_file, NULLFILE))
-		dump_steady_temp_grid(model->grid, model->config->grid_steady_file);
-
-	#if VERBOSE > 2
-	if (model->type == BLOCK_MODEL) {
-		if (do_transient) {
-			fprintf(stdout, "printing temp...\n");
-			dump_dvector(temp, model->block->n_nodes);
-		}
-		fprintf(stdout, "printing steady_temp...\n");
-		dump_dvector(steady_temp, model->block->n_nodes);
-	} else {
-		if (do_transient) {
-			fprintf(stdout, "printing temp...\n");
-			dump_dvector(temp, model->grid->total_n_blocks + EXTRA);
-		}
-		fprintf(stdout, "printing steady_temp...\n");
-		dump_dvector(steady_temp, model->grid->total_n_blocks + EXTRA);
-	}
-	#endif
-
-	/* cleanup	*/
-	fclose(pin);
-	if (do_transient)
-		fclose(tout);
-	delete_RC_model(model);
-	free_flp(flp, FALSE);
-	if (do_transient)
-		free_dvector(temp);
-	free_dvector(power);
-	free_dvector(steady_temp);
-	free_dvector(overall_power);
-	free_names(names);
-	free_dvector(vals);
-
-	return 0;
-}
diff -Naur temp/hotspot.h HotSpot/hotspot.h
--- temp/hotspot.h	2017-11-20 10:04:33.005703597 +0100
+++ HotSpot/hotspot.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,32 +0,0 @@
-#ifndef __HOTSPOT_H_
-#define __HOTSPOT_H_
-
-#include "util.h"
-
-/* global configuration parameters for HotSpot	*/
-typedef struct global_config_t_st
-{
-	/* floorplan input file */
-	char flp_file[STR_SIZE];
-	/* input power trace file */
-	char p_infile[STR_SIZE];
-	/* output file for the temperature trace */
-	char t_outfile[STR_SIZE];
-	/* input configuration parameters from file	*/
-	char config[STR_SIZE];
-	/* output configuration parameters to file	*/
-	char dump_config[STR_SIZE];
-}global_config_t;
-
-/* 
- * parse a table of name-value string pairs and add the configuration
- * parameters to 'config'
- */
-void global_config_from_strs(global_config_t *config, str_pair *table, int size);
-/* 
- * convert config into a table of name-value pairs. returns the no.
- * of parameters converted
- */
-int global_config_to_strs(global_config_t *config, str_pair *table, int max_entries);
-
-#endif
diff -Naur temp/hotspot-iface.h HotSpot/hotspot-iface.h
--- temp/hotspot-iface.h	2017-11-20 10:04:33.005703597 +0100
+++ HotSpot/hotspot-iface.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,160 +0,0 @@
-#ifndef __HOTSPOT_IFACE_H_
-#define __HOTSPOT_IFACE_H_
-
-#define STR_SIZE	512
-#define MAX_UNITS	8192
-#define NULLFILE	"(null)"
-#define BLOCK_MODEL		0
-#define GRID_MODEL		1
-
-/* floorplan structure	*/
-typedef struct unit_t_st
-{
-	char name[STR_SIZE];
-	double width;
-	double height;
-	double leftx;
-	double bottomy;
-}unit_t;
-typedef struct flp_t_st
-{
-	unit_t *units;
-	int n_units;
-  	double **wire_density;
-} flp_t;
-
-/* floorplan routines	*/
-
-/* reads the floorplan from a file and allocates memory. 
- * 'read_connects' is a boolean flag indicating if 
- * connectivity information should also be read (usually 
- * set to FALSE).
- */ 
-flp_t *read_flp(char *file, int read_connects);
-
-/* deletes floorplan from memory. 'compacted' is a 
- * boolean flag indicating if this is a floorplan
- * compacted by HotFloorplan (usually set to FALSE).
- */ 
-void free_flp(flp_t *flp, int compacted);
-
-/* thermal model configuration structure	*/
-typedef struct thermal_config_t_st
-{
-	double t_chip;
-	double thermal_threshold;
-	double c_convec;
-	double r_convec;
-	double s_sink;
-	double t_sink;
-	double s_spreader;
-	double t_spreader;
-	double t_interface;
-	double ambient;
-	char init_file[STR_SIZE];
-	double init_temp;
-	char steady_file[STR_SIZE];
-	double sampling_intvl;
-	double base_proc_freq;
-	int dtm_used;
-	char model_type[STR_SIZE];
-	int block_omit_lateral;
-	int grid_rows;
-	int grid_cols;
-	char grid_layer_file[STR_SIZE];
-	char grid_steady_file[STR_SIZE];
-	char grid_map_mode[STR_SIZE];
-}thermal_config_t;
-
-/* thermal configuration routines */
-
-/* returns a thermal configuration structure with
- * the default set of parameters
- */ 
-thermal_config_t default_thermal_config(void);
-
-/* thermal model structure	*/
-struct block_model_t_st;
-struct grid_model_t_st;
-typedef struct RC_model_t_st
-{
-	union
-	{
-		struct block_model_t_st *block;
-		struct grid_model_t_st *grid;
-	};
-	int type;
-	thermal_config_t *config;
-}RC_model_t;
-
-/* thermal model routines */
-
-/* creates a new thermal model. 'config' can be obtained 
- * from the 'default_thermal_config' function and 
- * 'placeholder' can be obtained from the 'read_flp' 
- * function
- */ 
-RC_model_t *alloc_RC_model(thermal_config_t *config, flp_t *placeholder);
-
-/* deletes the thermal model and frees up memory	*/
-void delete_RC_model(RC_model_t *model);
-
-/* populates the thermal resistances of the model. This is
- * a prerequisite for computing transient or steady state
- * temperatures.
- */ 
-void populate_R_model(RC_model_t *model, flp_t *flp);
-
-/* populates the thermal capacitances of the model. This is
- * a prerequisite for computing transient temperatures.
- */ 
-void populate_C_model(RC_model_t *model, flp_t *flp);
-
-/* memory allocator for the power and temperature vectors	*/
-double *hotspot_vector(RC_model_t *model);
-
-/* destructor for a vector allocated using 'hotspot_vector'	*/
-void free_dvector(double *v);
-
-/* outputs the 'temp' vector onto 'file'. 'temp' must
- * be allocated using ' hotspot_vector'.
- */
-void dump_temp (RC_model_t *model, double *temp, char *file);
-
-/* sets all the temperatures of the 'temp' vector to the
- * value 'val'. 'temp' must be allocated using '
- * hotspot_vector'.
- */
-void set_temp (RC_model_t *model, double *temp, double val);
-
-/* read the 'temp' vector from 'file'. The format of the 
- * file should be the same as the one output by the 
- * 'dump_temp' function. 'temp' must be allocated using 
- * 'hotspot_vector'. 'clip' is a boolean flag indicating
- * whether to clip the peak temperature of the vector to
- * the thermal threshold 'model->config->thermal_threshold'
- * (usually set to FALSE).
- */
-void read_temp (RC_model_t *model, double *temp, char *file, int clip);
-
-/* computation of the steady state temperatures. 'power'
- * and 'temp' must be allocated using 'hotspot_vector'.
- * 'populate_R_model' must be called before this.
- * 'power' should contain the input power numbers. 'temp'
- * will contain the output temperature numbers after the 
- * call.
- */ 
-void steady_state_temp(RC_model_t *model, double *power, double *temp);
-
-/* computation of the transient temperatures. 'power'
- * and 'temp' must be allocated using 'hotspot_vector'.
- * 'populate_R_model' and 'populate_C_model' must be
- * called before this. 'power' should  contain the 
- * input power numbers and 'temp' should contain the 
- * current temperatures. 'time_elapsed' is the duration
- * of the transient simulation. 'temp' will contain the
- * output temperature numbers after the call.
- */ 
-void compute_temp(RC_model_t *model, double *power, double *temp, double time_elapsed);
-
-#endif
diff -Naur temp/npe.c HotSpot/npe.c
--- temp/npe.c	2017-11-20 10:04:24.517682836 +0100
+++ HotSpot/npe.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,357 +0,0 @@
-#include <stdio.h>
-#ifdef _MSC_VER
-#define strcasecmp    _stricmp
-#define strncasecmp   _strnicmp
-#else
-#include <strings.h>
-#endif
-#include <string.h>
-#include <stdlib.h>
-#include <math.h>
-
-#include "npe.h"
-#include "flp.h"
-#include "util.h"
-
-void fill_unit_pos(NPE_t *expr)
-{
-	int i, j=0; 
-	for (i=0; i < expr->size; i++)
-		if (expr->elements[i] >= 0) {
-			expr->unit_pos[j] = i;
-			j++;
-		}
-	expr->n_units = j;		
-}
-
-void fill_flip_pos(NPE_t *expr)
-{
-	int i, j=0; 
-	for (i=0; i < expr->size - 1; i++)
-		if ((expr->elements[i] < 0 && expr->elements[i+1] >= 0) ||
-			(expr->elements[i] >= 0 && expr->elements[i+1] < 0)) {
-			expr->flip_pos[j] = i;
-			j++;
-		}
-	expr->n_flips = j;		
-}
-
-void fill_chain_pos(NPE_t *expr)
-{
-	int i=0, j=0, prev; 
-
-	while (i < expr->size) {
-		if (expr->elements[i] < 0) {
-			expr->chain_pos[j] = i;
-			j++;
-
-			/* skip this chain of successive cuts	*/
-			prev = expr->elements[i];
-			i++;
-			while(i < expr->size && expr->elements[i] < 0) {
-				if (expr->elements[i] == prev)
-					fatal("NPE not normalized\n");
-				prev = expr->elements[i];	
-				i++;
-			}
-		} else
-			i++;
-	}
-	expr->n_chains = j;		
-}
-
-void fill_ballot_count(NPE_t *expr)
-{
-	int i, ballot_count = 0;
-
-	for (i=0; i < expr->size; i++) {
-		if (expr->elements[i] < 0)
-			ballot_count++;
-		expr->ballot_count[i] = ballot_count;	
-	}
-}
-
-/* the starting solution for simulated annealing	*/
-NPE_t *NPE_get_initial(flp_desc_t *flp_desc)
-{
-	int i;
-	NPE_t *expr = (NPE_t *) calloc(1, sizeof(NPE_t));
-	if (!expr)
-		fatal("memory allocation error\n");
-	expr->size = 2 * flp_desc->n_units - 1;
-	expr->elements = (int *) calloc(expr->size, sizeof(int));
-	expr->unit_pos = (int *) calloc(flp_desc->n_units, sizeof(int));
-	expr->flip_pos = (int *) calloc(expr->size, sizeof(int));
-	expr->chain_pos = (int *) calloc(flp_desc->n_units-1, sizeof(int));
-	expr->ballot_count = (int *) calloc(expr->size, sizeof(int));
-
-	if(!expr->elements || !expr->unit_pos || !expr->flip_pos 
-	   || !expr->chain_pos || !expr->ballot_count)
-	   fatal("memory allocation error\n");
-
-	/* starting solution - 0, 1, V, 2, V, ..., n-1, V	*/
-	expr->elements[0] = 0;
-	for (i=1; i < expr->size; i+=2) {
-		expr->elements[i] = (i+1) / 2;
-		expr->elements[i+1] = CUT_VERTICAL;
-	}
-
-	fill_unit_pos(expr);
-	fill_flip_pos(expr);
-	fill_chain_pos(expr);
-	fill_ballot_count(expr);
-
-	return expr;
-}
-
-void free_NPE(NPE_t *expr)
-{
-	free(expr->elements);
-	free(expr->unit_pos);
-	free(expr->flip_pos);
-	free(expr->chain_pos);
-	free(expr->ballot_count);
-	free(expr);
-}
-
-/* debug print	*/
-void print_NPE(NPE_t *expr, flp_desc_t *flp_desc)
-{
-	int i;
-
-	fprintf(stdout, "printing normalized polish expression ");
-	fprintf(stdout, "of size %d\n", expr->size);
-	fprintf(stdout, "%s", flp_desc->units[expr->elements[0]].name);
-
-	for(i=1; i < expr->size; i++) {
-		if (expr->elements[i] >= 0)
-			fprintf(stdout, ", %s", flp_desc->units[expr->elements[i]].name);
-		else if (expr->elements[i] == CUT_VERTICAL)
-			fprintf(stdout, ", V");
-		else if (expr->elements[i] == CUT_HORIZONTAL)
-			fprintf(stdout, ", H");
-		else
-			fprintf(stdout, ", X");
-	}
-	fprintf(stdout, "\n");
-
-	fprintf(stdout, "unit_pos:\n");
-	for(i=0; i < expr->n_units; i++)
-		fprintf(stdout, "%d\t", expr->unit_pos[i]);
-	fprintf(stdout, "\nflip_pos:\n");
-	for(i=0; i < expr->n_flips; i++)
-		fprintf(stdout, "%d\t", expr->flip_pos[i]);
-	fprintf(stdout, "\nchain_pos:\n");
-	for(i=0; i < expr->n_chains; i++)
-		fprintf(stdout, "%d\t", expr->chain_pos[i]);
-	fprintf(stdout, "\nballot_count:\n");
-	for(i=0; i < expr->size; i++)
-		fprintf(stdout, "%d\t", expr->ballot_count[i]);
-	fprintf(stdout, "\n");
-}
-
-/* 
- * move M1 of the floorplan paper 
- * swap two units adjacent in the NPE	
- */
-void NPE_swap_units(NPE_t *expr, int pos)
-{
-	int i, t;
-	
-	/* find adjacent unit	*/
-	for (i=pos+1; i < expr->size; i++)
-		if (expr->elements[i] >= 0)
-			break;
-	if (i >= expr->size)
-		fatal("unable to find adjacent unit\n");
-
-	/* swap	*/
-	t = expr->elements[pos];
-	expr->elements[pos] = expr->elements[i]; 
-	expr->elements[i] = t;
-}
-
-/* move M2 - invert a chain of cut_types in the NPE	*/
-void NPE_invert_chain(NPE_t *expr, int pos)
-{
-	int i = pos+1, prev = expr->elements[pos];
-
-	if (expr->elements[pos] == CUT_VERTICAL)
-		expr->elements[pos] = CUT_HORIZONTAL;
-	else if (expr->elements[pos] == CUT_HORIZONTAL)
-		expr->elements[pos] = CUT_VERTICAL;
-	else
-		fatal("invalid NPE in invert_chain\n");
-
-	while(i < expr->size && expr->elements[i] < 0) {
-		if (expr->elements[i] == prev)
-			fatal("NPE not normalized\n");
-		prev = expr->elements[i];
-		if (expr->elements[i] == CUT_VERTICAL)
-			expr->elements[i] = CUT_HORIZONTAL;
-		else if (expr->elements[i] == CUT_HORIZONTAL)
-			expr->elements[i] = CUT_VERTICAL;
-		else
-			fatal("unknown cut type\n");
-		i++;	
-	}
-}
-
-/* binary search and increment the unit position by delta	*/
-int update_unit_pos(NPE_t *expr, int pos, int delta,
-					int start, int end)
-{
-	int mid;
-
-	if (start > end)
-		return FALSE;
-
-	mid = (start + end) / 2;
-	
-	if (expr->unit_pos[mid] == pos) {
-		expr->unit_pos[mid] += delta;
-		return TRUE;
-	} else if (expr->unit_pos[mid] > pos)
-		return update_unit_pos(expr, pos, delta, start, mid-1);
-	else
-		return update_unit_pos(expr, pos, delta, mid+1, end);
-}
-
-/* 
- * move M3 - swap adjacent cut_type and unit in the NPE	
- * - could result in a non-allowable move. hence returns
- * if the move is legal or not
- */
-int NPE_swap_cut_unit(NPE_t *expr, int pos)
-{
-	int t;
-
-	if (pos <= 0 || pos >= expr->size -1)
-		fatal("invalid position in NPE_swap_cut_unit\n");
-
-	/* unit, cut_type swap	*/
-	if (expr->elements[pos] >= 0) {
-		/* swap leads to consecutive cut_types that are identical?	*/
-		if (expr->elements[pos-1] ==  expr->elements[pos+1])
-			return FALSE;
-		/* move should not violate the balloting property	*/
-		if (2 * expr->ballot_count[pos+1] >= pos+1)
-			return FALSE;
-		/* unit's position is advanced by 1	*/
-		if (!update_unit_pos(expr, pos, 1, 0, expr->n_units-1))
-			fatal("unit position not found\n");
-		expr->ballot_count[pos]++;
-	} else {	/* cut_type, unit swap	*/
-		/* swap leads to consecutive cut_types that are identical?	*/
-		if ((pos < expr->size - 2) && (expr->elements[pos] ==  expr->elements[pos+2]))
-			return FALSE;
-		/* unit's position is reduced by 1	*/
-		if (!update_unit_pos(expr, pos+1, -1, 0, expr->n_units-1))
-			fatal("unit position not found\n");
-		expr->ballot_count[pos]--;
-	}
-	
-	/* swap O.K	*/
-	t = expr->elements[pos];
-	expr->elements[pos] = expr->elements[pos+1];
-	expr->elements[pos+1] = t;
-
-	/* flip and chain positions altered. recompute them	*/
-	fill_flip_pos(expr);
-	fill_chain_pos(expr);
-
-	return TRUE;
-}
-
-/* make a random move out of the above	*/
-NPE_t *make_random_move(NPE_t *expr)
-{
-	int i, move, count = 0, done = FALSE, m3_count;
-	NPE_t *copy = NPE_duplicate(expr);
-
-	while (!done && count < MAX_MOVES) {
-		/* choose one of three moves	*/
-		move = rand_upto(3);
-		switch(move) {
-			case 0:	/* swap adjacent units	*/
-				/* leave the unit last in the NPE	*/
-				i = rand_upto(expr->n_units-1);
-				#if VERBOSE > 2
-				fprintf(stdout, "making M1 at %d\n", expr->unit_pos[i]);
-				#endif
-				NPE_swap_units(copy, expr->unit_pos[i]);
-				done = TRUE;
-				break;
-
-			case 1:	/* invert an arbitrary chain	*/
-				i = rand_upto(expr->n_chains);
-				#if VERBOSE > 2
-				fprintf(stdout, "making M2 at %d\n", expr->chain_pos[i]);
-				#endif
-				NPE_invert_chain(copy, expr->chain_pos[i]);
-				done = TRUE;
-				break;
-
-			case 2:	/* swap a unit and an adjacent cut_type	*/
-				m3_count = 0; 
-				while (!done && m3_count < MAX_MOVES) {
-					i = rand_upto(expr->n_flips);
-					#if VERBOSE > 2
-					fprintf(stdout, "making M3 at %d\n", expr->flip_pos[i]);
-					#endif
-					done = NPE_swap_cut_unit(copy, expr->flip_pos[i]);
-					m3_count++;
-				}
-				break;
-
-			default:
-				fatal("unknown move type\n");
-				break;
-		}
-		count++;
-	}
-
-	if (count == MAX_MOVES) {
-		char msg[STR_SIZE];
-		sprintf(msg, "tried %d moves, now giving up\n", MAX_MOVES); 
-		fatal(msg);
-	}
-
-	return copy;
-}
-
-/* make a copy of this NPE	*/
-NPE_t *NPE_duplicate(NPE_t *expr)
-{
-	int i;
-	NPE_t *copy = (NPE_t *) calloc(1, sizeof(NPE_t));
-	if (!copy)
-		fatal("memory allocation error\n");
-	copy->elements = (int *) calloc(expr->size, sizeof(int));
-	copy->unit_pos = (int *) calloc(expr->n_units, sizeof(int));
-	copy->flip_pos = (int *) calloc(expr->size, sizeof(int));
-	copy->chain_pos = (int *) calloc(expr->n_units-1, sizeof(int));
-	copy->ballot_count = (int *) calloc(expr->size, sizeof(int));
-
-	if(!copy->elements || !copy->unit_pos || !copy->flip_pos 
-	   || !copy->chain_pos || !copy->ballot_count)
-	   fatal("memory allocation error\n");
-
-	copy->size = expr->size;
-	for (i=0; i < expr->size; i++)
-		copy->elements[i] = expr->elements[i];
-	copy->n_units = expr->n_units;
-	for (i=0; i < expr->n_units; i++)
-		copy->unit_pos[i] = expr->unit_pos[i];
-	copy->n_flips = expr->n_flips;
-	for (i=0; i < expr->n_flips; i++)
-		copy->flip_pos[i] = expr->flip_pos[i];
-	copy->n_chains = expr->n_chains;
-	for (i=0; i < expr->n_chains; i++)
-		copy->chain_pos[i] = expr->chain_pos[i];
-	for (i=0; i < expr->size; i++)
-		copy->ballot_count[i] = expr->ballot_count[i];
-	
-	return copy;
-}
-
diff -Naur temp/npe.cc HotSpot/npe.cc
--- temp/npe.cc	1970-01-01 01:00:00.000000000 +0100
+++ HotSpot/npe.cc	2017-11-20 09:59:35.316820635 +0100
@@ -0,0 +1,357 @@
+#include <stdio.h>
+#ifdef _MSC_VER
+#define strcasecmp    _stricmp
+#define strncasecmp   _strnicmp
+#else
+#include <strings.h>
+#endif
+#include <string.h>
+#include <stdlib.h>
+#include <math.h>
+
+#include "npe.h"
+#include "flp.h"
+#include "util.h"
+
+void fill_unit_pos(NPE_t *expr)
+{
+	int i, j=0; 
+	for (i=0; i < expr->size; i++)
+		if (expr->elements[i] >= 0) {
+			expr->unit_pos[j] = i;
+			j++;
+		}
+	expr->n_units = j;		
+}
+
+void fill_flip_pos(NPE_t *expr)
+{
+	int i, j=0; 
+	for (i=0; i < expr->size - 1; i++)
+		if ((expr->elements[i] < 0 && expr->elements[i+1] >= 0) ||
+			(expr->elements[i] >= 0 && expr->elements[i+1] < 0)) {
+			expr->flip_pos[j] = i;
+			j++;
+		}
+	expr->n_flips = j;		
+}
+
+void fill_chain_pos(NPE_t *expr)
+{
+	int i=0, j=0, prev; 
+
+	while (i < expr->size) {
+		if (expr->elements[i] < 0) {
+			expr->chain_pos[j] = i;
+			j++;
+
+			/* skip this chain of successive cuts	*/
+			prev = expr->elements[i];
+			i++;
+			while(i < expr->size && expr->elements[i] < 0) {
+				if (expr->elements[i] == prev)
+					fatal((char*)"NPE not normalized\n");
+				prev = expr->elements[i];	
+				i++;
+			}
+		} else
+			i++;
+	}
+	expr->n_chains = j;		
+}
+
+void fill_ballot_count(NPE_t *expr)
+{
+	int i, ballot_count = 0;
+
+	for (i=0; i < expr->size; i++) {
+		if (expr->elements[i] < 0)
+			ballot_count++;
+		expr->ballot_count[i] = ballot_count;	
+	}
+}
+
+/* the starting solution for simulated annealing	*/
+NPE_t *NPE_get_initial(flp_desc_t *flp_desc)
+{
+	int i;
+	NPE_t *expr = (NPE_t *) calloc(1, sizeof(NPE_t));
+	if (!expr)
+		fatal((char*)"memory allocation error\n");
+	expr->size = 2 * flp_desc->n_units - 1;
+	expr->elements = (int *) calloc(expr->size, sizeof(int));
+	expr->unit_pos = (int *) calloc(flp_desc->n_units, sizeof(int));
+	expr->flip_pos = (int *) calloc(expr->size, sizeof(int));
+	expr->chain_pos = (int *) calloc(flp_desc->n_units-1, sizeof(int));
+	expr->ballot_count = (int *) calloc(expr->size, sizeof(int));
+
+	if(!expr->elements || !expr->unit_pos || !expr->flip_pos 
+	   || !expr->chain_pos || !expr->ballot_count)
+	   fatal((char*)"memory allocation error\n");
+
+	/* starting solution - 0, 1, V, 2, V, ..., n-1, V	*/
+	expr->elements[0] = 0;
+	for (i=1; i < expr->size; i+=2) {
+		expr->elements[i] = (i+1) / 2;
+		expr->elements[i+1] = CUT_VERTICAL;
+	}
+
+	fill_unit_pos(expr);
+	fill_flip_pos(expr);
+	fill_chain_pos(expr);
+	fill_ballot_count(expr);
+
+	return expr;
+}
+
+void free_NPE(NPE_t *expr)
+{
+	free(expr->elements);
+	free(expr->unit_pos);
+	free(expr->flip_pos);
+	free(expr->chain_pos);
+	free(expr->ballot_count);
+	free(expr);
+}
+
+/* debug print	*/
+void print_NPE(NPE_t *expr, flp_desc_t *flp_desc)
+{
+	int i;
+
+	fprintf(stdout, "printing normalized polish expression ");
+	fprintf(stdout, "of size %d\n", expr->size);
+	fprintf(stdout, "%s", flp_desc->units[expr->elements[0]].name);
+
+	for(i=1; i < expr->size; i++) {
+		if (expr->elements[i] >= 0)
+			fprintf(stdout, ", %s", flp_desc->units[expr->elements[i]].name);
+		else if (expr->elements[i] == CUT_VERTICAL)
+			fprintf(stdout, ", V");
+		else if (expr->elements[i] == CUT_HORIZONTAL)
+			fprintf(stdout, ", H");
+		else
+			fprintf(stdout, ", X");
+	}
+	fprintf(stdout, "\n");
+
+	fprintf(stdout, "unit_pos:\n");
+	for(i=0; i < expr->n_units; i++)
+		fprintf(stdout, "%d\t", expr->unit_pos[i]);
+	fprintf(stdout, "\nflip_pos:\n");
+	for(i=0; i < expr->n_flips; i++)
+		fprintf(stdout, "%d\t", expr->flip_pos[i]);
+	fprintf(stdout, "\nchain_pos:\n");
+	for(i=0; i < expr->n_chains; i++)
+		fprintf(stdout, "%d\t", expr->chain_pos[i]);
+	fprintf(stdout, "\nballot_count:\n");
+	for(i=0; i < expr->size; i++)
+		fprintf(stdout, "%d\t", expr->ballot_count[i]);
+	fprintf(stdout, "\n");
+}
+
+/* 
+ * move M1 of the floorplan paper 
+ * swap two units adjacent in the NPE	
+ */
+void NPE_swap_units(NPE_t *expr, int pos)
+{
+	int i, t;
+	
+	/* find adjacent unit	*/
+	for (i=pos+1; i < expr->size; i++)
+		if (expr->elements[i] >= 0)
+			break;
+	if (i >= expr->size)
+		fatal((char*)"unable to find adjacent unit\n");
+
+	/* swap	*/
+	t = expr->elements[pos];
+	expr->elements[pos] = expr->elements[i]; 
+	expr->elements[i] = t;
+}
+
+/* move M2 - invert a chain of cut_types in the NPE	*/
+void NPE_invert_chain(NPE_t *expr, int pos)
+{
+	int i = pos+1, prev = expr->elements[pos];
+
+	if (expr->elements[pos] == CUT_VERTICAL)
+		expr->elements[pos] = CUT_HORIZONTAL;
+	else if (expr->elements[pos] == CUT_HORIZONTAL)
+		expr->elements[pos] = CUT_VERTICAL;
+	else
+		fatal((char*)"invalid NPE in invert_chain\n");
+
+	while(i < expr->size && expr->elements[i] < 0) {
+		if (expr->elements[i] == prev)
+			fatal((char*)"NPE not normalized\n");
+		prev = expr->elements[i];
+		if (expr->elements[i] == CUT_VERTICAL)
+			expr->elements[i] = CUT_HORIZONTAL;
+		else if (expr->elements[i] == CUT_HORIZONTAL)
+			expr->elements[i] = CUT_VERTICAL;
+		else
+			fatal((char*)"unknown cut type\n");
+		i++;	
+	}
+}
+
+/* binary search and increment the unit position by delta	*/
+int update_unit_pos(NPE_t *expr, int pos, int delta,
+					int start, int end)
+{
+	int mid;
+
+	if (start > end)
+		return FALSE;
+
+	mid = (start + end) / 2;
+	
+	if (expr->unit_pos[mid] == pos) {
+		expr->unit_pos[mid] += delta;
+		return TRUE;
+	} else if (expr->unit_pos[mid] > pos)
+		return update_unit_pos(expr, pos, delta, start, mid-1);
+	else
+		return update_unit_pos(expr, pos, delta, mid+1, end);
+}
+
+/* 
+ * move M3 - swap adjacent cut_type and unit in the NPE	
+ * - could result in a non-allowable move. hence returns
+ * if the move is legal or not
+ */
+int NPE_swap_cut_unit(NPE_t *expr, int pos)
+{
+	int t;
+
+	if (pos <= 0 || pos >= expr->size -1)
+		fatal((char*)"invalid position in NPE_swap_cut_unit\n");
+
+	/* unit, cut_type swap	*/
+	if (expr->elements[pos] >= 0) {
+		/* swap leads to consecutive cut_types that are identical?	*/
+		if (expr->elements[pos-1] ==  expr->elements[pos+1])
+			return FALSE;
+		/* move should not violate the balloting property	*/
+		if (2 * expr->ballot_count[pos+1] >= pos+1)
+			return FALSE;
+		/* unit's position is advanced by 1	*/
+		if (!update_unit_pos(expr, pos, 1, 0, expr->n_units-1))
+			fatal((char*)"unit position not found\n");
+		expr->ballot_count[pos]++;
+	} else {	/* cut_type, unit swap	*/
+		/* swap leads to consecutive cut_types that are identical?	*/
+		if ((pos < expr->size - 2) && (expr->elements[pos] ==  expr->elements[pos+2]))
+			return FALSE;
+		/* unit's position is reduced by 1	*/
+		if (!update_unit_pos(expr, pos+1, -1, 0, expr->n_units-1))
+			fatal((char*)"unit position not found\n");
+		expr->ballot_count[pos]--;
+	}
+	
+	/* swap O.K	*/
+	t = expr->elements[pos];
+	expr->elements[pos] = expr->elements[pos+1];
+	expr->elements[pos+1] = t;
+
+	/* flip and chain positions altered. recompute them	*/
+	fill_flip_pos(expr);
+	fill_chain_pos(expr);
+
+	return TRUE;
+}
+
+/* make a random move out of the above	*/
+NPE_t *make_random_move(NPE_t *expr)
+{
+	int i, move, count = 0, done = FALSE, m3_count;
+	NPE_t *copy = NPE_duplicate(expr);
+
+	while (!done && count < MAX_MOVES) {
+		/* choose one of three moves	*/
+		move = rand_upto(3);
+		switch(move) {
+			case 0:	/* swap adjacent units	*/
+				/* leave the unit last in the NPE	*/
+				i = rand_upto(expr->n_units-1);
+				#if VERBOSE > 2
+				fprintf(stdout, "making M1 at %d\n", expr->unit_pos[i]);
+				#endif
+				NPE_swap_units(copy, expr->unit_pos[i]);
+				done = TRUE;
+				break;
+
+			case 1:	/* invert an arbitrary chain	*/
+				i = rand_upto(expr->n_chains);
+				#if VERBOSE > 2
+				fprintf(stdout, "making M2 at %d\n", expr->chain_pos[i]);
+				#endif
+				NPE_invert_chain(copy, expr->chain_pos[i]);
+				done = TRUE;
+				break;
+
+			case 2:	/* swap a unit and an adjacent cut_type	*/
+				m3_count = 0; 
+				while (!done && m3_count < MAX_MOVES) {
+					i = rand_upto(expr->n_flips);
+					#if VERBOSE > 2
+					fprintf(stdout, "making M3 at %d\n", expr->flip_pos[i]);
+					#endif
+					done = NPE_swap_cut_unit(copy, expr->flip_pos[i]);
+					m3_count++;
+				}
+				break;
+
+			default:
+				fatal((char*)"unknown move type\n");
+				break;
+		}
+		count++;
+	}
+
+	if (count == MAX_MOVES) {
+		char msg[STR_SIZE];
+		sprintf(msg, "tried %d moves, now giving up\n", MAX_MOVES); 
+		fatal(msg);
+	}
+
+	return copy;
+}
+
+/* make a copy of this NPE	*/
+NPE_t *NPE_duplicate(NPE_t *expr)
+{
+	int i;
+	NPE_t *copy = (NPE_t *) calloc(1, sizeof(NPE_t));
+	if (!copy)
+		fatal((char*)"memory allocation error\n");
+	copy->elements = (int *) calloc(expr->size, sizeof(int));
+	copy->unit_pos = (int *) calloc(expr->n_units, sizeof(int));
+	copy->flip_pos = (int *) calloc(expr->size, sizeof(int));
+	copy->chain_pos = (int *) calloc(expr->n_units-1, sizeof(int));
+	copy->ballot_count = (int *) calloc(expr->size, sizeof(int));
+
+	if(!copy->elements || !copy->unit_pos || !copy->flip_pos 
+	   || !copy->chain_pos || !copy->ballot_count)
+	   fatal((char*)"memory allocation error\n");
+
+	copy->size = expr->size;
+	for (i=0; i < expr->size; i++)
+		copy->elements[i] = expr->elements[i];
+	copy->n_units = expr->n_units;
+	for (i=0; i < expr->n_units; i++)
+		copy->unit_pos[i] = expr->unit_pos[i];
+	copy->n_flips = expr->n_flips;
+	for (i=0; i < expr->n_flips; i++)
+		copy->flip_pos[i] = expr->flip_pos[i];
+	copy->n_chains = expr->n_chains;
+	for (i=0; i < expr->n_chains; i++)
+		copy->chain_pos[i] = expr->chain_pos[i];
+	for (i=0; i < expr->size; i++)
+		copy->ballot_count[i] = expr->ballot_count[i];
+	
+	return copy;
+}
+
diff -Naur temp/package.c HotSpot/package.c
--- temp/package.c	2017-11-20 10:04:24.517682836 +0100
+++ HotSpot/package.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,397 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#ifdef _MSC_VER
-#define strcasecmp    _stricmp
-#define strncasecmp   _strnicmp
-#else
-#include <strings.h>
-#endif
-#include <math.h>
-
-#include "package.h"
-#include "temperature.h"
-#include "flp.h"
-#include "util.h"
-
-/* default package configuration parameters	*/
-package_config_t default_package_config(void)
-{
-	package_config_t config;
-	/* 0: forced convection, 1: natural convection */
-	config.natural_convec = 0;
-	
-	/* airflow type - 0: lateral airflow from sink side, 1: impinging airflow	from sink top*/
-	config.flow_type = 0;
-	
-	/* heatsink type - 0: fin-channel sink, 1: pin-fin sink */
-	config.sink_type = 0;
-	
-	/* default sink specs */
-		/* sink base size is defined in thermal_config
-		 * 1) fin-channel sink 
-		 */
-	config.fin_height = 0.03;
-	config.fin_width = 0.001;
-	config.channel_width = 0.002; 
-		/* 2) pin-fin sink */
-	config.pin_height = 0.02;
-	config.pin_diam = 0.002;
-	config.pin_dist = 0.005;
-	
-	/* fan specs */
-	config.fan_radius = 0.03;
-	config.motor_radius = 0.01;
-	config.rpm = 1000;
-	
-	return config;
-}
-
-/* 
- * parse a table of name-value string pairs and add the configuration
- * parameters to package 'config'
- */
-void package_config_add_from_strs(package_config_t *config, str_pair *table, int size)
-{
-	int idx;
-	if ((idx = get_str_index(table, size, "natural_convec")) >= 0)
-		if(sscanf(table[idx].value, "%d", &config->natural_convec) != 1)
-			fatal("invalid format for heatsink configuration parameter natural_convec\n");
-	if ((idx = get_str_index(table, size, "flow_type")) >= 0)
-		if(sscanf(table[idx].value, "%d", &config->flow_type) != 1)
-			fatal("invalid format for heatsink configuration parameter flow_type\n");
-	if ((idx = get_str_index(table, size, "sink_type")) >= 0)
-		if(sscanf(table[idx].value, "%d", &config->sink_type) != 1)
-			fatal("invalid format for heatsink configuration parameter sink_type\n");
-	if ((idx = get_str_index(table, size, "fin_height")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->fin_height) != 1)
-			fatal("invalid format for heatsink configuration parameter fin_height\n");
-	if ((idx = get_str_index(table, size, "fin_width")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->fin_width) != 1)
-			fatal("invalid format for heatsink configuration parameter fin_width\n");
-	if ((idx = get_str_index(table, size, "channel_width")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->channel_width) != 1)
-			fatal("invalid format for heatsink configuration parameter channel_width\n");
-	if ((idx = get_str_index(table, size, "pin_height")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->pin_height) != 1)
-			fatal("invalid format for heatsink configuration parameter pin_height\n");
-	if ((idx = get_str_index(table, size, "pin_diam")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->pin_diam) != 1)
-			fatal("invalid format for heatsink configuration parameter pin_diam\n");
-	if ((idx = get_str_index(table, size, "pin_dist")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->pin_dist) != 1)
-			fatal("invalid format for heatsink configuration parameter pin_dist\n");
-	if ((idx = get_str_index(table, size, "fan_radius")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->fan_radius) != 1)
-			fatal("invalid format for fan configuration parameter fan_radius\n");
-	if ((idx = get_str_index(table, size, "motor_radius")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->motor_radius) != 1)
-			fatal("invalid format for fan configuration parameter motor_radius\n");
-	if ((idx = get_str_index(table, size, "rpm")) >= 0)
-		if(sscanf(table[idx].value, "%d", &config->rpm) != 1)
-			fatal("invalid format for configuration  parameter rpm\n");
-	
-	if ((config->fin_height <= 0) || (config->fin_width <= 0) || (config->channel_width <= 0) || 
-		(config->pin_height <= 0) || (config->pin_diam <= 0) || (config->pin_dist <= 0) || 
-		(config->fan_radius <= 0) || (config->motor_radius <= 0) || (config->rpm <= 0))
-		fatal("heatsink/fan dimensions and fan speed should be greater than zero\n");
-	if ((config->natural_convec != 0) && (config->natural_convec != 1))
-		fatal("invalid convection mode\n");
-	if ((config->flow_type != 0) && (config->flow_type != 1))
-		fatal("invalid air flow type\n");
-	if ((config->sink_type != 0) && (config->sink_type != 1))
-		fatal("invalid heatsink type\n");
-}
-
-/* 
- * convert config into a table of name-value pairs. returns the no.
- * of parameters converted
- */
-int package_config_to_strs(package_config_t *package_config, str_pair *package_table, int max_entries)
-{
-	if (max_entries < 12)
-		fatal("not enough entries in table\n");
-	
-	sprintf(package_table[0].name, "natural_convec");
-	sprintf(package_table[1].name, "flow_type");
-	sprintf(package_table[2].name, "sink_type");
-	sprintf(package_table[3].name, "fin_height");
-	sprintf(package_table[4].name, "fin_width");
-	sprintf(package_table[5].name, "channel_width");
-	sprintf(package_table[6].name, "pin_height");
-	sprintf(package_table[7].name, "pin_diam");
-	sprintf(package_table[8].name, "pin_dist");
-	sprintf(package_table[9].name, "fan_radius");
-	sprintf(package_table[10].name, "motor_radius");
-	sprintf(package_table[11].name, "rpm");
-
-	sprintf(package_table[0].value, "%d", package_config->natural_convec);
-	sprintf(package_table[1].value, "%d", package_config->flow_type);
-	sprintf(package_table[2].value, "%d", package_config->sink_type);
-	sprintf(package_table[3].value, "%lg", package_config->fin_height);
-	sprintf(package_table[4].value, "%lg", package_config->fin_width);
-	sprintf(package_table[5].value, "%lg", package_config->channel_width);
-	sprintf(package_table[6].value, "%lg", package_config->pin_height);
-	sprintf(package_table[7].value, "%lg", package_config->pin_diam);
-	sprintf(package_table[8].value, "%lg", package_config->pin_dist);
-	sprintf(package_table[9].value, "%lg", package_config->fan_radius);
-	sprintf(package_table[10].value, "%lg", package_config->motor_radius);
-	sprintf(package_table[11].value, "%d", package_config->rpm);
-
-	return 12;
-}
-
-/* calculate forced air flow and package thermal parameters	
- * references:															
- * 1-1	lateral flow, fin-channel heat sinks:		
- *			-laminar flow: P. terrtstra et al. "Analytical Forced Convection Modeling of Plate-Fin Heat Sinks". IEEE SEMI-THERM, pp 34-41, 1999
- *			-turbulent flow: Y. A. Cengel. "Heat and Mass Transfer: A Practical Approach", Mcgraw-Hill Inc. New York 2007 
- * 1-2	lateral flow, pin-fin heat sinks:					
- * 			R. Ribando et al. "Estimating the Convection Coefficient for Flow Through Banks of Fins on a Heat Sink". U.Va. MAE314 Course Notes, Spring 2007
- * 2-1	impinging flow for both fin-channel and pin-fin heat sinks:
- *			H. A. El-Sheikh et al. "Heat Transfer from Pin-Fin Heat Sinks under Multiple Impinging Jets", IEEE Trans. on Adv. Packaging, 23(1):113-120, Feb. 2000
- * 3-1	fan model:
- *			F. P. Bleier. "Fan Handbook: Selection, Application and Design". McGraw-Hill Inc. New York, 1998
- * 3-2	motor model of the fan:
- * 			Y. Zhang et al. "SODA: Sensitivity-Based Optimization of Disk Architecture". IEEE/ACM DAC, pp. 865-870, 2007 
- */
- 
-void calculate_flow(convection_t *p, package_config_t *config, thermal_config_t *thermal_config)
-{
-	/* local variables */
-	double n_fin, n_pin;
-	double sur_area_fin, sur_area_pin;
-	double reynolds, nusselt, h_coeff, v, r_th;
-	double dh, a_fan, dr, r_approx, vol_v, rey_star, m, eta, f, c1, c2, a_hs;
-	double t1, t2; /* temporary variables for long formulas*/
-	
-	double s_sink = thermal_config->s_sink;
-	double k_sink = thermal_config->k_sink;
-	
-	int flow_type = config->flow_type;
-	int sink_type = config->sink_type;
-	double fin_height = config->fin_height;
-	double fin_width = config->fin_width;
-	double channel_width = config->channel_width;
-	double pin_height = config->pin_height;
-	double pin_diam = config->pin_diam;
-	double pin_dist = config->pin_dist;
-	double fan_radius = config->fan_radius;
-	double motor_radius = config->motor_radius;
-	double rpm = config->rpm;
-	
-	double temp_val = (s_sink-pin_diam)/(pin_diam+pin_dist);
-	
-	n_fin = ceil((s_sink-fin_width)/(fin_width+channel_width)-0.5);
-	sur_area_fin = s_sink*(s_sink+2.0*n_fin*fin_height);
-	n_pin = ceil(temp_val*temp_val-0.5);
-	sur_area_pin = s_sink*s_sink+PI*pin_diam*pin_height*n_pin;
-		
-	/* calculate volumetric air speed out of the fan */
-	dr = sqrt(fan_radius * fan_radius - motor_radius * motor_radius);
-	r_approx = motor_radius + dr; /* approximated average fan radius */
-	a_fan = PI * dr * dr; /* total fan blade area */
-	
-	/* refer to DAC'07 SODA paper by Zhang, Gurumurthi and Stan 
-	 * crudely approximating an IC fan motor with a hard drive spindle motor model
-	 * the principle is that the dragging momentum on the blades from the air equals to the torque of the motor at steady state
-	 * so, torque=b*(omega^alpha)=drag_force*radius (1)
-	 * where b=0.5*pi*air_density*C_d*(radius^beta)
-	 * drag coeff C_d=drag_force/(0.5*air_density*air_velocity^2*total_blade_area)
-	 * manipulate both side of (1), derive volmetric velocity from the fan as... 
-	 */
-	vol_v = a_fan * sqrt(0.25 * PI * pow(r_approx,FAN_BETA-1) * pow(rpm * RPM_TO_RAD,FAN_ALPHA) / a_fan);
-	
-	/* calculate the actual air velocity through heatsink: vol_velocity/area_duct_sink */
-	if (flow_type==0) { /* lateral airflow */
-		dh = 2.0*channel_width*s_sink/(channel_width+s_sink); /* hydraulic diameter */
-		if (sink_type==0) { /* fin-channel sink */
-			v = vol_v / ((n_fin-1)*channel_width*fin_height);
-		}
-		else { /* pin-fin sink */
-			v = vol_v / ((sqrt(n_pin)-1)*pin_dist*pin_height);
-		}
-	}
-	else { /* impinging flow */
-		dh = 2.0 * s_sink / sqrt(PI); /* equivalent air nozzle diameter */ 
-		v = vol_v / (s_sink*s_sink-n_pin*PI*(pin_diam*0.5)*(pin_diam*0.5));
-	}
-	
-	/* Reynolds number */
-	reynolds = AIR_DSTY * v * dh / AIR_DYNVISC;
-	
-	/* calculate nusselt number, heat transfer coeff
-	 * and equivalent overall lumped convection resistance 
-	 */
-	if (flow_type==0) { /* lateral airflow */
-		if (sink_type==0) { /* fin-channel sink */
-			if (reynolds <= REY_THRESHOLD) { /* laminar flow */
-				rey_star = AIR_DSTY*v*channel_width*channel_width/(AIR_DYNVISC*s_sink);
-				t1 = pow(rey_star*PRANTDL_NUM*0.5,-3);
-				t2 = pow(0.664*sqrt(rey_star)*pow(PRANTDL_NUM,0.33)*sqrt(1+3.65/sqrt(rey_star)),-3);
-				nusselt = pow(t1+t2,-0.33); /* nusselt number */
-				h_coeff = nusselt*AIR_COND/channel_width; /* heat transfer coefficient */
-				m = sqrt(2*h_coeff/(k_sink*fin_width)); /* fin parameter */
-				eta = tanh(m*s_sink)/(m*s_sink); /* fin efficiency */
-				r_th = 1.0/(h_coeff*(channel_width+2*eta*s_sink)*n_fin*s_sink);
-			}
-			else { /* turbulent flow */
-				f = 1.0/pow((0.79*log(reynolds)-1.64),2.0);
-				nusselt = 0.125*f*reynolds*pow(PRANTDL_NUM,0.33);
-				h_coeff = nusselt*AIR_COND/dh;
-				m = sqrt(2*h_coeff/(k_sink*fin_width)); /* fin parameter */
-				eta = tanh(m*s_sink)/(m*s_sink); /* fin efficiency */
-				r_th = 1.0/(h_coeff*(channel_width+2*eta*s_sink)*n_fin*s_sink);
-			}
-		}				
-		else { /* pin-fin sink */
-			c1 = 0.6;
-			c2 = 0.8+0.8333*sqrt(sqrt(n_pin)-1)/pow((1+0.03*pow((sqrt(n_pin)-1),2.0)),0.25);
-		  nusselt = 0.4+0.9*(1.25*c2*c1*sqrt(reynolds)+0.001*reynolds)*pow(PRANTDL_NUM,0.33);
-			h_coeff = nusselt*AIR_COND/pin_diam;
-			r_th = 1.0/(h_coeff*sur_area_pin);
-		}
-	}
-	else { /* impinging flow */
-		if (sink_type==0) { /* fin-channel sink */
-			a_hs = sur_area_fin;
-		}
-		else { /* pin-fin sink */
-			a_hs = sur_area_pin;
-		}
-		dh = 2.0 * s_sink / sqrt(PI);
-		nusselt = 1.92*pow(reynolds,0.716)*pow(PRANTDL_NUM,0.4)*pow(a_hs/(s_sink*s_sink),-0.698);
-		h_coeff = nusselt*AIR_COND/dh;
-		r_th = 1.0/(h_coeff*a_hs);
-	}
-	p->n_fin = n_fin;
-	p->sur_area_fin = sur_area_fin;
-	p->n_pin = n_pin;
-	p->sur_area_pin = sur_area_pin;
-	p->reynolds = reynolds;
-	p->nusselt = nusselt;
-	p->h_coeff = h_coeff;
-	p->v = v;
-	p->r_th = r_th;
-}
-
-/* calculate convection parameters for natural convection.
- * reference: Y. A. Cengel. "Heat and Mass Transfer: A Practical Approach", Mcgraw-Hill Inc. New York 2007 
- */
-void calc_natural_convec(convection_t *p, package_config_t *config, thermal_config_t *thermal_config, double sink_temp) 
-{
-	/* local variables */
-	double rayleigh;
-	double n_fin, n_pin;
-	double w;
-	double sur_area, sur_area_fin, sur_area_pin;
-	double nusselt, h_coeff, r_th, r_th_rad;
-	
-	double s_sink = thermal_config->s_sink;
-	double ambient = thermal_config->ambient;
-	
-	int sink_type = config->sink_type;
-	double fin_height = config->fin_height;
-	double fin_width = config->fin_width;
-	double channel_width = config->channel_width;
-	double pin_height = config->pin_height;
-	double pin_diam = config->pin_diam;
-	double pin_dist = config->pin_dist;
-	
-	double temp_val = (s_sink-pin_diam)/(pin_diam+pin_dist);
-	
-	n_fin = ceil((s_sink-fin_width)/(fin_width+channel_width)-0.5);
-	sur_area_fin = s_sink*(s_sink+2.0*n_fin*fin_height);
-	n_pin = ceil(temp_val*temp_val-0.5);
-	sur_area_pin = s_sink*s_sink+PI*pin_diam*pin_height*n_pin;
-	
-	if (sink_type==0) { /* fin-channel sink */
-		sur_area = sur_area_fin;
-		w = channel_width;
-	} else { /* pin-fin heatsink */
-		sur_area = sur_area_pin;
-		w = pin_dist;
-	}
-	
-	/* CAUTION: equations are derived for fin-channel heatsink, not validated for pin-fin heatsink */
-	rayleigh = GRAVITY*VOL_EXP_COEFF*(sink_temp-ambient)*pow(w,3.0)*PRANTDL_NUM/(AIR_KINVISC*AIR_KINVISC);
-	nusselt = pow((576/((rayleigh*w/s_sink)*(rayleigh*w/s_sink))+2.873/sqrt(rayleigh*w/s_sink)),-0.5);
-	h_coeff = nusselt*AIR_COND/w;
-	r_th = 1.0/(h_coeff*sur_area);
-	
-	/* thermal radiation*/
-	r_th_rad = (sink_temp-ambient)/(EMISSIVITY*STEFAN*(pow(sink_temp,4.0)-pow(ambient,4.0))*sur_area);
-	
-	/* overall thermal resistance = natural convection in parallel with thermal radiation */
-	r_th = r_th*r_th_rad/(r_th+r_th_rad);
-	
-	p->n_fin = n_fin;
-	p->sur_area_fin = sur_area_fin;
-	p->n_pin = n_pin;
-	p->sur_area_pin = sur_area_pin;
-	p->nusselt = nusselt;
-	p->h_coeff = h_coeff;
-	p->r_th = r_th;
-}
-
-/* debug print	*/
-void debug_print_convection(convection_t *p)
-{
-	fprintf(stdout, "printing airflow information...\n");
-	fprintf(stdout, "n_fin: %f\n", p->n_fin);
-	fprintf(stdout, "sur_area_fin: %f\n", p->sur_area_fin);
-	fprintf(stdout, "n_pin: %f\n", p->n_pin);
-	fprintf(stdout, "sur_area_pin: %f\n", p->sur_area_pin);
-	fprintf(stdout, "reynolds: %f\n", p->reynolds);
-	fprintf(stdout, "nusselt: %f\n", p->nusselt);
-	fprintf(stdout, "h_coeff: %f\n", p->h_coeff);
-	fprintf(stdout, "v: %f\n", p->v);
-	fprintf(stdout, "r_th: %f\n", p->r_th);
-}
-
-/* initialize and calculate package parameters and update r_convec */
-int package_model(thermal_config_t *thermal_config, str_pair *table, int size, double sink_temp)
-{
-	int idx;
-	int natural_convec;
-	
-	str_pair package_table[MAX_ENTRIES];
-	int package_size;
-	
-	/* package config parameters */
-	package_config_t package_config;
-	convection_t p;
-	
-	package_size = 0;
-	
-	/* get defaults */
-	package_config = default_package_config();
-	/* parse the package config file name */
-	if ((idx = get_str_index(table, size, "package_config_file")) >= 0) {
-		if(sscanf(table[idx].value, "%s", thermal_config->package_config_file) != 1)
-			fatal("invalid format for configuration  parameter package_config_file\n");
-	}
-	/* read package config file	*/
-	if (strcmp(thermal_config->package_config_file, NULLFILE)) 
-		package_size += read_str_pairs(&package_table[package_size], MAX_ENTRIES, thermal_config->package_config_file);
-			
-	/* modify according to package config file	*/
-	package_config_add_from_strs(&package_config, package_table, package_size);
-	
-	natural_convec = package_config.natural_convec; 
-		
-	/* calculate flow parameters into p */
-	if (!natural_convec) /* forced convection */
-		calculate_flow(&p, &package_config, thermal_config);
-	else /* natural convection */
-		calc_natural_convec(&p, &package_config, thermal_config, sink_temp);
-		
-	/* print flow parameters for debug */
-	#if VERBOSE > 1
-	debug_print_convection(&p);
-	#endif
-	/* assign new r_convec calculated from the package model */
-	thermal_config->r_convec = p.r_th;
-	
-	return natural_convec;
-}
diff -Naur temp/package.cc HotSpot/package.cc
--- temp/package.cc	1970-01-01 01:00:00.000000000 +0100
+++ HotSpot/package.cc	2017-11-20 09:59:35.312820617 +0100
@@ -0,0 +1,397 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#ifdef _MSC_VER
+#define strcasecmp    _stricmp
+#define strncasecmp   _strnicmp
+#else
+#include <strings.h>
+#endif
+#include <math.h>
+
+#include "package.h"
+#include "temperature.h"
+#include "flp.h"
+#include "util.h"
+
+/* default package configuration parameters	*/
+package_config_t default_package_config(void)
+{
+	package_config_t config;
+	/* 0: forced convection, 1: natural convection */
+	config.natural_convec = 0;
+	
+	/* airflow type - 0: lateral airflow from sink side, 1: impinging airflow	from sink top*/
+	config.flow_type = 0;
+	
+	/* heatsink type - 0: fin-channel sink, 1: pin-fin sink */
+	config.sink_type = 0;
+	
+	/* default sink specs */
+		/* sink base size is defined in thermal_config
+		 * 1) fin-channel sink 
+		 */
+	config.fin_height = 0.03;
+	config.fin_width = 0.001;
+	config.channel_width = 0.002; 
+		/* 2) pin-fin sink */
+	config.pin_height = 0.02;
+	config.pin_diam = 0.002;
+	config.pin_dist = 0.005;
+	
+	/* fan specs */
+	config.fan_radius = 0.03;
+	config.motor_radius = 0.01;
+	config.rpm = 1000;
+	
+	return config;
+}
+
+/* 
+ * parse a table of name-value string pairs and add the configuration
+ * parameters to package 'config'
+ */
+void package_config_add_from_strs(package_config_t *config, str_pair *table, int size)
+{
+	int idx;
+	if ((idx = get_str_index(table, size, (char*)"natural_convec")) >= 0)
+		if(sscanf(table[idx].value, "%d", &config->natural_convec) != 1)
+			fatal((char*)"invalid format for heatsink configuration parameter natural_convec\n");
+	if ((idx = get_str_index(table, size, (char*)"flow_type")) >= 0)
+		if(sscanf(table[idx].value, "%d", &config->flow_type) != 1)
+			fatal((char*)"invalid format for heatsink configuration parameter flow_type\n");
+	if ((idx = get_str_index(table, size, (char*)"sink_type")) >= 0)
+		if(sscanf(table[idx].value, "%d", &config->sink_type) != 1)
+			fatal((char*)"invalid format for heatsink configuration parameter sink_type\n");
+	if ((idx = get_str_index(table, size, (char*)"fin_height")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->fin_height) != 1)
+			fatal((char*)"invalid format for heatsink configuration parameter fin_height\n");
+	if ((idx = get_str_index(table, size, (char*)"fin_width")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->fin_width) != 1)
+			fatal((char*)"invalid format for heatsink configuration parameter fin_width\n");
+	if ((idx = get_str_index(table, size, (char*)"channel_width")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->channel_width) != 1)
+			fatal((char*)"invalid format for heatsink configuration parameter channel_width\n");
+	if ((idx = get_str_index(table, size, (char*)"pin_height")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->pin_height) != 1)
+			fatal((char*)"invalid format for heatsink configuration parameter pin_height\n");
+	if ((idx = get_str_index(table, size, (char*)"pin_diam")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->pin_diam) != 1)
+			fatal((char*)"invalid format for heatsink configuration parameter pin_diam\n");
+	if ((idx = get_str_index(table, size, (char*)"pin_dist")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->pin_dist) != 1)
+			fatal((char*)"invalid format for heatsink configuration parameter pin_dist\n");
+	if ((idx = get_str_index(table, size, (char*)"fan_radius")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->fan_radius) != 1)
+			fatal((char*)"invalid format for fan configuration parameter fan_radius\n");
+	if ((idx = get_str_index(table, size, (char*)"motor_radius")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->motor_radius) != 1)
+			fatal((char*)"invalid format for fan configuration parameter motor_radius\n");
+	if ((idx = get_str_index(table, size, (char*)"rpm")) >= 0)
+		if(sscanf(table[idx].value, "%d", &config->rpm) != 1)
+			fatal((char*)"invalid format for configuration  parameter rpm\n");
+	
+	if ((config->fin_height <= 0) || (config->fin_width <= 0) || (config->channel_width <= 0) || 
+		(config->pin_height <= 0) || (config->pin_diam <= 0) || (config->pin_dist <= 0) || 
+		(config->fan_radius <= 0) || (config->motor_radius <= 0) || (config->rpm <= 0))
+		fatal((char*)"heatsink/fan dimensions and fan speed should be greater than zero\n");
+	if ((config->natural_convec != 0) && (config->natural_convec != 1))
+		fatal((char*)"invalid convection mode\n");
+	if ((config->flow_type != 0) && (config->flow_type != 1))
+		fatal((char*)"invalid air flow type\n");
+	if ((config->sink_type != 0) && (config->sink_type != 1))
+		fatal((char*)"invalid heatsink type\n");
+}
+
+/* 
+ * convert config into a table of name-value pairs. returns the no.
+ * of parameters converted
+ */
+int package_config_to_strs(package_config_t *package_config, str_pair *package_table, int max_entries)
+{
+	if (max_entries < 12)
+		fatal((char*)"not enough entries in table\n");
+	
+	sprintf(package_table[0].name, "natural_convec");
+	sprintf(package_table[1].name, "flow_type");
+	sprintf(package_table[2].name, "sink_type");
+	sprintf(package_table[3].name, "fin_height");
+	sprintf(package_table[4].name, "fin_width");
+	sprintf(package_table[5].name, "channel_width");
+	sprintf(package_table[6].name, "pin_height");
+	sprintf(package_table[7].name, "pin_diam");
+	sprintf(package_table[8].name, "pin_dist");
+	sprintf(package_table[9].name, "fan_radius");
+	sprintf(package_table[10].name, "motor_radius");
+	sprintf(package_table[11].name, "rpm");
+
+	sprintf(package_table[0].value, "%d", package_config->natural_convec);
+	sprintf(package_table[1].value, "%d", package_config->flow_type);
+	sprintf(package_table[2].value, "%d", package_config->sink_type);
+	sprintf(package_table[3].value, "%lg", package_config->fin_height);
+	sprintf(package_table[4].value, "%lg", package_config->fin_width);
+	sprintf(package_table[5].value, "%lg", package_config->channel_width);
+	sprintf(package_table[6].value, "%lg", package_config->pin_height);
+	sprintf(package_table[7].value, "%lg", package_config->pin_diam);
+	sprintf(package_table[8].value, "%lg", package_config->pin_dist);
+	sprintf(package_table[9].value, "%lg", package_config->fan_radius);
+	sprintf(package_table[10].value, "%lg", package_config->motor_radius);
+	sprintf(package_table[11].value, "%d", package_config->rpm);
+
+	return 12;
+}
+
+/* calculate forced air flow and package thermal parameters	
+ * references:															
+ * 1-1	lateral flow, fin-channel heat sinks:		
+ *			-laminar flow: P. terrtstra et al. "Analytical Forced Convection Modeling of Plate-Fin Heat Sinks". IEEE SEMI-THERM, pp 34-41, 1999
+ *			-turbulent flow: Y. A. Cengel. "Heat and Mass Transfer: A Practical Approach", Mcgraw-Hill Inc. New York 2007 
+ * 1-2	lateral flow, pin-fin heat sinks:					
+ * 			R. Ribando et al. "Estimating the Convection Coefficient for Flow Through Banks of Fins on a Heat Sink". U.Va. MAE314 Course Notes, Spring 2007
+ * 2-1	impinging flow for both fin-channel and pin-fin heat sinks:
+ *			H. A. El-Sheikh et al. "Heat Transfer from Pin-Fin Heat Sinks under Multiple Impinging Jets", IEEE Trans. on Adv. Packaging, 23(1):113-120, Feb. 2000
+ * 3-1	fan model:
+ *			F. P. Bleier. "Fan Handbook: Selection, Application and Design". McGraw-Hill Inc. New York, 1998
+ * 3-2	motor model of the fan:
+ * 			Y. Zhang et al. "SODA: Sensitivity-Based Optimization of Disk Architecture". IEEE/ACM DAC, pp. 865-870, 2007 
+ */
+ 
+void calculate_flow(convection_t *p, package_config_t *config, thermal_config_t *thermal_config)
+{
+	/* local variables */
+	double n_fin, n_pin;
+	double sur_area_fin, sur_area_pin;
+	double reynolds, nusselt, h_coeff, v, r_th;
+	double dh, a_fan, dr, r_approx, vol_v, rey_star, m, eta, f, c1, c2, a_hs;
+	double t1, t2; /* temporary variables for long formulas*/
+	
+	double s_sink = thermal_config->s_sink;
+	double k_sink = thermal_config->k_sink;
+	
+	int flow_type = config->flow_type;
+	int sink_type = config->sink_type;
+	double fin_height = config->fin_height;
+	double fin_width = config->fin_width;
+	double channel_width = config->channel_width;
+	double pin_height = config->pin_height;
+	double pin_diam = config->pin_diam;
+	double pin_dist = config->pin_dist;
+	double fan_radius = config->fan_radius;
+	double motor_radius = config->motor_radius;
+	double rpm = config->rpm;
+	
+	double temp_val = (s_sink-pin_diam)/(pin_diam+pin_dist);
+	
+	n_fin = ceil((s_sink-fin_width)/(fin_width+channel_width)-0.5);
+	sur_area_fin = s_sink*(s_sink+2.0*n_fin*fin_height);
+	n_pin = ceil(temp_val*temp_val-0.5);
+	sur_area_pin = s_sink*s_sink+PI*pin_diam*pin_height*n_pin;
+		
+	/* calculate volumetric air speed out of the fan */
+	dr = sqrt(fan_radius * fan_radius - motor_radius * motor_radius);
+	r_approx = motor_radius + dr; /* approximated average fan radius */
+	a_fan = PI * dr * dr; /* total fan blade area */
+	
+	/* refer to DAC'07 SODA paper by Zhang, Gurumurthi and Stan 
+	 * crudely approximating an IC fan motor with a hard drive spindle motor model
+	 * the principle is that the dragging momentum on the blades from the air equals to the torque of the motor at steady state
+	 * so, torque=b*(omega^alpha)=drag_force*radius (1)
+	 * where b=0.5*pi*air_density*C_d*(radius^beta)
+	 * drag coeff C_d=drag_force/(0.5*air_density*air_velocity^2*total_blade_area)
+	 * manipulate both side of (1), derive volmetric velocity from the fan as... 
+	 */
+	vol_v = a_fan * sqrt(0.25 * PI * pow(r_approx,FAN_BETA-1) * pow(rpm * RPM_TO_RAD,FAN_ALPHA) / a_fan);
+	
+	/* calculate the actual air velocity through heatsink: vol_velocity/area_duct_sink */
+	if (flow_type==0) { /* lateral airflow */
+		dh = 2.0*channel_width*s_sink/(channel_width+s_sink); /* hydraulic diameter */
+		if (sink_type==0) { /* fin-channel sink */
+			v = vol_v / ((n_fin-1)*channel_width*fin_height);
+		}
+		else { /* pin-fin sink */
+			v = vol_v / ((sqrt(n_pin)-1)*pin_dist*pin_height);
+		}
+	}
+	else { /* impinging flow */
+		dh = 2.0 * s_sink / sqrt(PI); /* equivalent air nozzle diameter */ 
+		v = vol_v / (s_sink*s_sink-n_pin*PI*(pin_diam*0.5)*(pin_diam*0.5));
+	}
+	
+	/* Reynolds number */
+	reynolds = AIR_DSTY * v * dh / AIR_DYNVISC;
+	
+	/* calculate nusselt number, heat transfer coeff
+	 * and equivalent overall lumped convection resistance 
+	 */
+	if (flow_type==0) { /* lateral airflow */
+		if (sink_type==0) { /* fin-channel sink */
+			if (reynolds <= REY_THRESHOLD) { /* laminar flow */
+				rey_star = AIR_DSTY*v*channel_width*channel_width/(AIR_DYNVISC*s_sink);
+				t1 = pow(rey_star*PRANTDL_NUM*0.5,-3);
+				t2 = pow(0.664*sqrt(rey_star)*pow(PRANTDL_NUM,0.33)*sqrt(1+3.65/sqrt(rey_star)),-3);
+				nusselt = pow(t1+t2,-0.33); /* nusselt number */
+				h_coeff = nusselt*AIR_COND/channel_width; /* heat transfer coefficient */
+				m = sqrt(2*h_coeff/(k_sink*fin_width)); /* fin parameter */
+				eta = tanh(m*s_sink)/(m*s_sink); /* fin efficiency */
+				r_th = 1.0/(h_coeff*(channel_width+2*eta*s_sink)*n_fin*s_sink);
+			}
+			else { /* turbulent flow */
+				f = 1.0/pow((0.79*log(reynolds)-1.64),2.0);
+				nusselt = 0.125*f*reynolds*pow(PRANTDL_NUM,0.33);
+				h_coeff = nusselt*AIR_COND/dh;
+				m = sqrt(2*h_coeff/(k_sink*fin_width)); /* fin parameter */
+				eta = tanh(m*s_sink)/(m*s_sink); /* fin efficiency */
+				r_th = 1.0/(h_coeff*(channel_width+2*eta*s_sink)*n_fin*s_sink);
+			}
+		}				
+		else { /* pin-fin sink */
+			c1 = 0.6;
+			c2 = 0.8+0.8333*sqrt(sqrt(n_pin)-1)/pow((1+0.03*pow((sqrt(n_pin)-1),2.0)),0.25);
+		  nusselt = 0.4+0.9*(1.25*c2*c1*sqrt(reynolds)+0.001*reynolds)*pow(PRANTDL_NUM,0.33);
+			h_coeff = nusselt*AIR_COND/pin_diam;
+			r_th = 1.0/(h_coeff*sur_area_pin);
+		}
+	}
+	else { /* impinging flow */
+		if (sink_type==0) { /* fin-channel sink */
+			a_hs = sur_area_fin;
+		}
+		else { /* pin-fin sink */
+			a_hs = sur_area_pin;
+		}
+		dh = 2.0 * s_sink / sqrt(PI);
+		nusselt = 1.92*pow(reynolds,0.716)*pow(PRANTDL_NUM,0.4)*pow(a_hs/(s_sink*s_sink),-0.698);
+		h_coeff = nusselt*AIR_COND/dh;
+		r_th = 1.0/(h_coeff*a_hs);
+	}
+	p->n_fin = n_fin;
+	p->sur_area_fin = sur_area_fin;
+	p->n_pin = n_pin;
+	p->sur_area_pin = sur_area_pin;
+	p->reynolds = reynolds;
+	p->nusselt = nusselt;
+	p->h_coeff = h_coeff;
+	p->v = v;
+	p->r_th = r_th;
+}
+
+/* calculate convection parameters for natural convection.
+ * reference: Y. A. Cengel. "Heat and Mass Transfer: A Practical Approach", Mcgraw-Hill Inc. New York 2007 
+ */
+void calc_natural_convec(convection_t *p, package_config_t *config, thermal_config_t *thermal_config, double sink_temp) 
+{
+	/* local variables */
+	double rayleigh;
+	double n_fin, n_pin;
+	double w;
+	double sur_area, sur_area_fin, sur_area_pin;
+	double nusselt, h_coeff, r_th, r_th_rad;
+	
+	double s_sink = thermal_config->s_sink;
+	double ambient = thermal_config->ambient;
+	
+	int sink_type = config->sink_type;
+	double fin_height = config->fin_height;
+	double fin_width = config->fin_width;
+	double channel_width = config->channel_width;
+	double pin_height = config->pin_height;
+	double pin_diam = config->pin_diam;
+	double pin_dist = config->pin_dist;
+	
+	double temp_val = (s_sink-pin_diam)/(pin_diam+pin_dist);
+	
+	n_fin = ceil((s_sink-fin_width)/(fin_width+channel_width)-0.5);
+	sur_area_fin = s_sink*(s_sink+2.0*n_fin*fin_height);
+	n_pin = ceil(temp_val*temp_val-0.5);
+	sur_area_pin = s_sink*s_sink+PI*pin_diam*pin_height*n_pin;
+	
+	if (sink_type==0) { /* fin-channel sink */
+		sur_area = sur_area_fin;
+		w = channel_width;
+	} else { /* pin-fin heatsink */
+		sur_area = sur_area_pin;
+		w = pin_dist;
+	}
+	
+	/* CAUTION: equations are derived for fin-channel heatsink, not validated for pin-fin heatsink */
+	rayleigh = GRAVITY*VOL_EXP_COEFF*(sink_temp-ambient)*pow(w,3.0)*PRANTDL_NUM/(AIR_KINVISC*AIR_KINVISC);
+	nusselt = pow((576/((rayleigh*w/s_sink)*(rayleigh*w/s_sink))+2.873/sqrt(rayleigh*w/s_sink)),-0.5);
+	h_coeff = nusselt*AIR_COND/w;
+	r_th = 1.0/(h_coeff*sur_area);
+	
+	/* thermal radiation*/
+	r_th_rad = (sink_temp-ambient)/(EMISSIVITY*STEFAN*(pow(sink_temp,4.0)-pow(ambient,4.0))*sur_area);
+	
+	/* overall thermal resistance = natural convection in parallel with thermal radiation */
+	r_th = r_th*r_th_rad/(r_th+r_th_rad);
+	
+	p->n_fin = n_fin;
+	p->sur_area_fin = sur_area_fin;
+	p->n_pin = n_pin;
+	p->sur_area_pin = sur_area_pin;
+	p->nusselt = nusselt;
+	p->h_coeff = h_coeff;
+	p->r_th = r_th;
+}
+
+/* debug print	*/
+void debug_print_convection(convection_t *p)
+{
+	fprintf(stdout, "printing airflow information...\n");
+	fprintf(stdout, "n_fin: %f\n", p->n_fin);
+	fprintf(stdout, "sur_area_fin: %f\n", p->sur_area_fin);
+	fprintf(stdout, "n_pin: %f\n", p->n_pin);
+	fprintf(stdout, "sur_area_pin: %f\n", p->sur_area_pin);
+	fprintf(stdout, "reynolds: %f\n", p->reynolds);
+	fprintf(stdout, "nusselt: %f\n", p->nusselt);
+	fprintf(stdout, "h_coeff: %f\n", p->h_coeff);
+	fprintf(stdout, "v: %f\n", p->v);
+	fprintf(stdout, "r_th: %f\n", p->r_th);
+}
+
+/* initialize and calculate package parameters and update r_convec */
+int package_model(thermal_config_t *thermal_config, str_pair *table, int size, double sink_temp)
+{
+	int idx;
+	int natural_convec;
+	
+	str_pair package_table[MAX_ENTRIES];
+	int package_size;
+	
+	/* package config parameters */
+	package_config_t package_config;
+	convection_t p;
+	
+	package_size = 0;
+	
+	/* get defaults */
+	package_config = default_package_config();
+	/* parse the package config file name */
+	if ((idx = get_str_index(table, size, (char*)"package_config_file")) >= 0) {
+		if(sscanf(table[idx].value, "%s", thermal_config->package_config_file) != 1)
+			fatal((char*)"invalid format for configuration  parameter package_config_file\n");
+	}
+	/* read package config file	*/
+	if (strcmp(thermal_config->package_config_file, NULLFILE)) 
+		package_size += read_str_pairs(&package_table[package_size], MAX_ENTRIES, thermal_config->package_config_file);
+			
+	/* modify according to package config file	*/
+	package_config_add_from_strs(&package_config, package_table, package_size);
+	
+	natural_convec = package_config.natural_convec; 
+		
+	/* calculate flow parameters into p */
+	if (!natural_convec) /* forced convection */
+		calculate_flow(&p, &package_config, thermal_config);
+	else /* natural convection */
+		calc_natural_convec(&p, &package_config, thermal_config, sink_temp);
+		
+	/* print flow parameters for debug */
+	#if VERBOSE > 1
+	debug_print_convection(&p);
+	#endif
+	/* assign new r_convec calculated from the package model */
+	thermal_config->r_convec = p.r_th;
+	
+	return natural_convec;
+}
diff -Naur temp/RCutil.c HotSpot/RCutil.c
--- temp/RCutil.c	2017-11-20 10:04:24.517682836 +0100
+++ HotSpot/RCutil.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,608 +0,0 @@
-/* 
- * Thanks to Greg Link from Penn State University
- * for his math acceleration engine. Where available,
- * the modified version of the engine found here, uses 
- * the fast, vendor-provided linear algebra routines 
- * from the BLAS and LAPACK packages in  lieu of
- * the vanilla C code present in the matrix functions 
- * of the previous versions of HotSpot. 
- */
-#include <stdio.h>
-#include <stdlib.h>
-#include <assert.h>
-#include <math.h>
-
-#include "temperature.h"
-#include "flp.h"
-#include "util.h"
-
-/* thermal resistance calculation	*/
-double getr(double conductivity, double thickness, double area)
-{
-	return thickness / (conductivity * area);
-}
-
-/* thermal capacitance calculation	*/
-double getcap(double sp_heat, double thickness, double area)
-{
-	/* include lumped vs. distributed correction	*/
-	return C_FACTOR * sp_heat * thickness * area;
-}
-
-/*
- * LUP decomposition from the pseudocode given in the CLR 
- * 'Introduction to Algorithms' textbook. The matrix 'a' is
- * transformed into an in-place lower/upper triangular matrix
- * and the vector'p' carries the permutation vector such that
- * Pa = lu, where 'P' is the matrix form of 'p'. The 'spd' flag 
- * indicates that 'a' is symmetric and positive definite 
- */
- 
-void lupdcmp(double**a, int n, int *p, int spd)
-{
-	#if(MATHACCEL == MA_INTEL)
-	int info = 0;
-	if (!spd)
-		dgetrf(&n, &n, a[0], &n, p, &info);
-	else	
-		dpotrf("U", &n, a[0], &n, &info);
-	assert(info == 0);	
-	#elif(MATHACCEL == MA_AMD)
-	int info = 0;
-	if (!spd)
-		dgetrf_(&n, &n, a[0], &n, p, &info);
-	else	
-		dpotrf_("U", &n, a[0], &n, &info, 1);
-	assert(info == 0);	
-	#elif(MATHACCEL == MA_APPLE)
-	int info = 0;
-	if (!spd)
-		dgetrf_((__CLPK_integer *)&n, (__CLPK_integer *)&n, a[0],
-				(__CLPK_integer *)&n, (__CLPK_integer *)p,
-				(__CLPK_integer *)&info);
-	else	
-		dpotrf_("U", (__CLPK_integer *)&n, a[0], (__CLPK_integer *)&n,
-				(__CLPK_integer *)&info);
-	assert(info == 0);	
-	#elif(MATHACCEL == MA_SUN)
-	int info = 0;
-	if (!spd)
-		dgetrf_(&n, &n, a[0], &n, p, &info);
-	else	
-		dpotrf_("U", &n, a[0], &n, &info);
-	assert(info == 0);	
-	#else
-	int i, j, k, pivot=0;
-	double max = 0;
-
-	/* start with identity permutation	*/
-	for (i=0; i < n; i++)
-		p[i] = i;
-
-	for (k=0; k < n-1; k++)	 {
-		max = 0;
-		for (i = k; i < n; i++)	{
-			if (fabs(a[i][k]) > max) {
-				max = fabs(a[i][k]);
-				pivot = i;
-			}
-		}	
-		if (eq (max, 0))
-			fatal ("singular matrix in lupdcmp\n");
-
-		/* bring pivot element to position	*/
-		swap_ival (&p[k], &p[pivot]);
-		for (i=0; i < n; i++)
-			swap_dval (&a[k][i], &a[pivot][i]);
-
-		for (i=k+1; i < n; i++) {
-			a[i][k] /= a[k][k];
-			for (j=k+1; j < n; j++)
-				a[i][j] -= a[i][k] * a[k][j];
-		}
-	}
-	#endif
-}
-
-/* 
- * the matrix a is an in-place lower/upper triangular matrix
- * the following macros split them into their constituents
- */
-
-#define LOWER(a, i, j)		((i > j) ? a[i][j] : 0)
-#define UPPER(a, i, j)		((i <= j) ? a[i][j] : 0)
-
-/* 
- * LU forward and backward substitution from the pseudocode given
- * in the CLR 'Introduction to Algorithms' textbook. It solves ax = b
- * where, 'a' is an in-place lower/upper triangular matrix. The vector
- * 'x' carries the solution vector. 'p' is the permutation vector. The
- * 'spd' flag indicates that 'a' is symmetric and positive definite
- */
-
-void lusolve(double **a, int n, int *p, double *b, double *x, int spd)
-{
-	#if(MATHACCEL == MA_INTEL)
-	int one = 1, info = 0;
-	cblas_dcopy(n, b, 1, x, 1);
-	if (!spd)
-		dgetrs("T", &n, &one, a[0], &n, p, x, &n, &info);
-	else	
-		dpotrs("U", &n, &one, a[0], &n, x, &n, &info);
-	assert(info == 0);	
-	#elif(MATHACCEL == MA_AMD)
-	int one = 1, info = 0;
-	dcopy(n, b, 1, x, 1);
-	if (!spd)
-		dgetrs_("T", &n, &one, a[0], &n, p, x, &n, &info, 1);
-	else	
-		dpotrs_("U", &n, &one, a[0], &n, x, &n, &info, 1);
-	assert(info == 0);	
-	#elif(MATHACCEL == MA_APPLE)
-	int one = 1, info = 0;
-	cblas_dcopy(n, b, 1, x, 1);
-	if (!spd)
-		dgetrs_("T", (__CLPK_integer *)&n, (__CLPK_integer *)&one, a[0],
-				(__CLPK_integer *)&n, (__CLPK_integer *)p, x,
-				(__CLPK_integer *)&n, (__CLPK_integer *)&info);
-	else	
-		dpotrs_("U", (__CLPK_integer *)&n, (__CLPK_integer *)&one, a[0],
-				(__CLPK_integer *)&n, x, (__CLPK_integer *)&n,
-				(__CLPK_integer *)&info);
-	assert(info == 0);	
-	#elif(MATHACCEL == MA_SUN)
-	int one = 1, info = 0;
-	dcopy(n, b, 1, x, 1);
-	if (!spd)
-		dgetrs_("T", &n, &one, a[0], &n, p, x, &n, &info);
-	else	
-		dpotrs_("U", &n, &one, a[0], &n, x, &n, &info);
-	assert(info == 0);	
-	#else
-	int i, j;
-	double *y = dvector (n);
-	double sum;
-
-	/* forward substitution	- solves ly = pb	*/
-	for (i=0; i < n; i++) {
-		for (j=0, sum=0; j < i; j++)
-			sum += y[j] * LOWER(a, i, j);
-		y[i] = b[p[i]] - sum;
-	}
-
-	/* backward substitution - solves ux = y	*/
-	for (i=n-1; i >= 0; i--) {
-		for (j=i+1, sum=0; j < n; j++)
-			sum += x[j] * UPPER(a, i, j);
-		x[i] = (y[i] - sum) / UPPER(a, i, i);
-	}
-
-	free_dvector(y);
-	#endif
-}
-
-/* core of the 4th order Runge-Kutta method, where the Euler step
- * (y(n+1) = y(n) + h * k1 where k1 = dydx(n)) is provided as an input.
- * to evaluate dydx at different points, a call back function f (slope
- * function) is also passed as a parameter. Given values for y, and k1, 
- * this function advances the solution over an interval h, and returns
- * the solution in yout. For details, see the discussion in "Numerical 
- * Recipes in C", Chapter 16, from 
- * http://www.nrbook.com/a/bookcpdf/c16-1.pdf
- */
-void rk4_core(void *model, double *y, double *k1, void *p, int n, double h, double *yout, slope_fn_ptr f)
-{
-	int i;
-	double *t, *k2, *k3, *k4;
-	k2 = dvector(n);
-	k3 = dvector(n);
-	k4 = dvector(n);
-	t = dvector(n);
-
-	/* k2 is the slope at the trial midpoint (t) found using 
-	 * slope k1 (which is at the starting point).
-	 */
-	/* t = y + h/2 * k1 (t = y; t += h/2 * k1) */
-	#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
-	cblas_dcopy(n, y, 1, t, 1);
-	cblas_daxpy(n, h/2.0, k1, 1, t, 1);
-	#elif (MATHACCEL == MA_AMD || MATHACCEL == MA_SUN)
-	dcopy(n, y, 1, t, 1);
-	daxpy(n, h/2.0, k1, 1, t, 1);
-	#else
-	for(i=0; i < n; i++)
-		t[i] = y[i] + h/2.0 * k1[i];
-	#endif	
-	/* k2 = slope at t */
-	(*f)(model, t, p, k2); 
-
-	/* k3 is the slope at the trial midpoint (t) found using
-	 * slope k2 found above.
-	 */
-	/* t =  y + h/2 * k2 (t = y; t += h/2 * k2) */
-	#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
-	cblas_dcopy(n, y, 1, t, 1);
-	cblas_daxpy(n, h/2.0, k2, 1, t, 1);
-	#elif (MATHACCEL == MA_AMD || MATHACCEL == MA_SUN)
-	dcopy(n, y, 1, t, 1);
-	daxpy(n, h/2.0, k2, 1, t, 1);
-	#else
-	for(i=0; i < n; i++)
-		t[i] = y[i] + h/2.0 * k2[i];
-	#endif	
-	/* k3 = slope at t */
-	(*f)(model, t, p, k3);
-
-	/* k4 is the slope at trial endpoint (t) found using
-	 * slope k3 found above.
-	 */
-	/* t =  y + h * k3 (t = y; t += h * k3) */
-	#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
-	cblas_dcopy(n, y, 1, t, 1);
-	cblas_daxpy(n, h, k3, 1, t, 1);
-	#elif (MATHACCEL == MA_AMD || MATHACCEL == MA_SUN)
-	dcopy(n, y, 1, t, 1);
-	daxpy(n, h, k3, 1, t, 1);
-	#else
-	for(i=0; i < n; i++)
-		t[i] = y[i] + h * k3[i];
-	#endif	
-	/* k4 = slope at t */
-	(*f)(model, t, p, k4);
-
-	/* yout = y + h*(k1/6 + k2/3 + k3/3 + k4/6)	*/
-	#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
-	/* yout = y	*/			
-	cblas_dcopy(n, y, 1, yout, 1);
-	/* yout += h*k1/6	*/
-	cblas_daxpy(n, h/6.0, k1, 1, yout, 1);
-	/* yout += h*k2/3	*/
-	cblas_daxpy(n, h/3.0, k2, 1, yout, 1);
-	/* yout += h*k3/3	*/
-	cblas_daxpy(n, h/3.0, k3, 1, yout, 1);
-	/* yout += h*k4/6	*/
-	cblas_daxpy(n, h/6.0, k4, 1, yout, 1);
-	#elif (MATHACCEL == MA_AMD || MATHACCEL == MA_SUN)
-	dcopy(n, y, 1, yout, 1);
-	/* yout += h*k1/6	*/
-	daxpy(n, h/6.0, k1, 1, yout, 1);
-	/* yout += h*k2/3	*/
-	daxpy(n, h/3.0, k2, 1, yout, 1);
-	/* yout += h*k3/3	*/
-	daxpy(n, h/3.0, k3, 1, yout, 1);
-	/* yout += h*k4/6	*/
-	daxpy(n, h/6.0, k4, 1, yout, 1);
-	#else
-	for (i =0; i < n; i++) 
-		yout[i] = y[i] + h * (k1[i] + 2*k2[i] + 2*k3[i] + k4[i])/6.0;
-	#endif
-
-	free_dvector(k2);
-	free_dvector(k3);
-	free_dvector(k4);
-	free_dvector(t);
-}
-
-/* 
- * 4th order Runge Kutta solver	with adaptive step sizing.
- * It integrates and solves the ODE dy + cy = p between
- * t and t+h. It returns the correct step size to be used 
- * next time. slope function f is the call back used to 
- * evaluate the derivative at each point
- */
-#define RK4_SAFETY		0.95
-#define RK4_MAXUP		5.0
-#define RK4_MAXDOWN		10.0
-#define RK4_PRECISION	0.01
-double rk4(void *model, double *y, void *p, int n, double *h, double *yout, slope_fn_ptr f)
-{
-	int i;
-	double *k1, *t1, *t2, *ytemp, max, new_h = (*h);
-
-	k1 = dvector(n);
-	t1 = dvector(n);
-	t2 = dvector(n);
-	ytemp = dvector(n); 
-
-	/* evaluate the slope k1 at the beginning */
-	(*f)(model, y, p, k1);
-
-	/* try until accuracy is achieved	*/
-	do {
-		(*h) = new_h;
-
-		/* try RK4 once with normal step size	*/
-		rk4_core(model, y, k1, p, n, (*h), ytemp, f);
-
-		/* repeat it with two half-steps	*/
-		rk4_core(model, y, k1, p, n, (*h)/2.0, t1, f);
-
-		/* y after 1st half-step is in t1. re-evaluate k1 for this	*/
-		(*f)(model, t1, p, k1);
-
-		/* get output of the second half-step in t2	*/	
-		rk4_core(model, t1, k1, p, n, (*h)/2.0, t2, f);
-
-		/* find the max diff between these two results:
-		 * use t1 to store the diff
-		 */
-		#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
-		/* t1 = ytemp	*/
-		cblas_dcopy(n, ytemp, 1, t1, 1);
-		/* t1 = -1 * t2 + t1 = ytemp - t2	*/
-		cblas_daxpy(n, -1.0, t2, 1, t1, 1);
-		/* max = |t1[max_abs_index]|	*/
-		max = fabs(t1[cblas_idamax(n, t1, 1)]);
-		#elif (MATHACCEL == MA_AMD || MATHACCEL == MA_SUN)
-		/* t1 = ytemp	*/
-		dcopy(n, ytemp, 1, t1, 1);
-		/* t1 = -1 * t2 + t1 = ytemp - t2	*/
-		daxpy(n, -1.0, t2, 1, t1, 1);
-		/* 
-		 * max = |t1[max_abs_index]| note: FORTRAN BLAS
-		 * indices start from 1 as opposed to CBLAS where
-		 * indices start from 0
-		 */
-		max = fabs(t1[idamax(n, t1, 1)-1]);
-		#else
-		for(i=0; i < n; i++)
-			t1[i] = fabs(ytemp[i] - t2[i]);
-		max = t1[0];
-		for(i=1; i < n; i++)
-			if (max < t1[i])
-				max = t1[i];
-		#endif
-
-		/* 
-		 * compute the correct step size: see equation 
-		 * 16.2.10  in chapter 16 of "Numerical Recipes
-		 * in C"
-		 */
-		/* accuracy OK. increase step size	*/
-		if (max <= RK4_PRECISION) {
-			new_h = RK4_SAFETY * (*h) * pow(fabs(RK4_PRECISION/max), 0.2);
-			if (new_h > RK4_MAXUP * (*h))
-				new_h = RK4_MAXUP * (*h);
-		/* inaccuracy error. decrease step size	and compute again */
-		} else {
-			new_h = RK4_SAFETY * (*h) * pow(fabs(RK4_PRECISION/max), 0.25);
-			if (new_h < (*h) / RK4_MAXDOWN)
-				new_h = (*h) / RK4_MAXDOWN;
-		}
-
-	} while (new_h < (*h));
-
-	/* commit ytemp to yout	*/
-	#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
-	cblas_dcopy(n, ytemp, 1, yout, 1);
-	#elif (MATHACCEL == MA_AMD || MATHACCEL == MA_SUN)
-	dcopy(n, ytemp, 1, yout, 1);
-	#else
-	copy_dvector(yout, ytemp, n);
-	#endif
-
-	/* clean up */
-	free_dvector(k1);
-	free_dvector(t1);
-	free_dvector(t2);
-	free_dvector(ytemp);
-
-	/* return the step-size	*/
-	return new_h;
-}
-
-/* matmult: C = AB, A, B are n x n square matrices	*/
-void matmult(double **c, double **a, double **b, int n) 
-{
-	#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
-	cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
-				n, n, n, 1.0, a[0], n, b[0], n, 0.0, c[0], n);
-	#elif (MATHACCEL == MA_AMD  || MATHACCEL == MA_SUN)
-	/* B^T * A^T = (A * B)^T	*/
-	dgemm('N', 'N', n, n, n, 1.0, b[0], n, a[0], n, 0.0, c[0], n);
-	#else
-	int i, j, k;
-
-	for (i = 0; i < n; i++)
-		for (j = 0; j < n; j++) {
-			c[i][j] = 0;
-			for (k = 0; k < n; k++)
-				c[i][j] += a[i][k] * b[k][j];
-		}
-	#endif	
-}
-
-/* same as above but 'a' is a diagonal matrix stored as a 1-d array	*/
-void diagmatmult(double **c, double *a, double **b, int n) 
-{
-	int i;
-	#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
-	zero_dmatrix(c, n, n);
-	for(i=0; i < n; i++)
-		cblas_daxpy(n, a[i], b[i], 1, c[i], 1);
-	#elif (MATHACCEL == MA_AMD  || MATHACCEL == MA_SUN)
-	zero_dmatrix(c, n, n);
-	for(i=0; i < n; i++)
-		daxpy(n, a[i], b[i], 1, c[i], 1);
-	#else
-	int j;
-
-	for (i = 0; i < n; i++)
-		for (j = 0; j < n; j++)
-			c[i][j] = a[i] * b[i][j];
-	#endif		
-}
-
-/* mult of an n x n matrix and an n x 1 column vector	*/
-void matvectmult(double *vout, double **m, double *vin, int n)
-{
-	#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
-	cblas_dgemv(CblasRowMajor, CblasNoTrans, n, n, 1.0, m[0],
-				n, vin, 1, 0.0, vout, 1);
-	#elif (MATHACCEL == MA_AMD  || MATHACCEL == MA_SUN)
-	dgemv('T', n, n, 1.0, m[0], n, vin, 1, 0.0, vout, 1);
-	#else
-	int i, j;
-
-	for (i = 0; i < n; i++) {
-		vout[i] = 0;
-		for (j = 0; j < n; j++)
-			vout[i] += m[i][j] * vin[j];
-	}
-	#endif
-}
-
-/* same as above but 'm' is a diagonal matrix stored as a 1-d array	*/
-void diagmatvectmult(double *vout, double *m, double *vin, int n)
-{
-	#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
-	cblas_dsbmv(CblasRowMajor, CblasUpper, n, 0, 1.0, m, 1, vin,
-				1, 0.0, vout, 1);
-	#elif (MATHACCEL == MA_AMD  || MATHACCEL == MA_SUN)
-	dsbmv('U', n, 0, 1.0, m, 1, vin, 1, 0.0, vout, 1);
-	#else
-	int i;
-
-	for (i = 0; i < n; i++)
-		vout[i] = m[i] * vin[i];
-	#endif
-}
-
-/* 
- * inv = m^-1, inv, m are n by n matrices.
- * the spd flag indicates that m is symmetric 
- * and positive definite 
- */
-#define BLOCK_SIZE		256
-void matinv(double **inv, double **m, int n, int spd)
-{
-	int *p, lwork;
-	double *work;
-	int i, j;
-	#if (MATHACCEL != MA_NONE)
-	int info;
-	#endif
-	double *col;
-
-	p = ivector(n);
-	lwork = n * BLOCK_SIZE;
-	work = dvector(lwork);
-
-	#if (MATHACCEL == MA_INTEL)
-	info = 0;
-	cblas_dcopy(n*n, m[0], 1, inv[0], 1);
-	if (!spd) {
-		dgetrf(&n, &n, inv[0], &n, p, &info);
-		assert(info == 0);
-		dgetri(&n, inv[0], &n, p, work, &lwork, &info);
-		assert(info == 0);
-	} else {
-		dpotrf("U", &n, inv[0], &n, &info);
-		assert(info == 0);
-		dpotri("U", &n, inv[0], &n, &info);
-		assert(info == 0);
-		mirror_dmatrix(inv, n);
-	}	
-	#elif(MATHACCEL == MA_AMD)
-	info = 0;
-	dcopy(n*n, m[0], 1, inv[0], 1);
-	if (!spd) {
-		dgetrf_(&n, &n, inv[0], &n, p, &info);
-		assert(info == 0);
-		dgetri_(&n, inv[0], &n, p, work, &lwork, &info);
-		assert(info == 0);
-	} else {
-		dpotrf_("U", &n, inv[0], &n, &info, 1);
-		assert(info == 0);
-		dpotri_("U", &n, inv[0], &n, &info, 1);
-		assert(info == 0);
-		mirror_dmatrix(inv, n);
-	}	
-	#elif (MATHACCEL == MA_APPLE)
-	info = 0;
-	cblas_dcopy(n*n, m[0], 1, inv[0], 1);
-	if (!spd) {
-		dgetrf_((__CLPK_integer *)&n, (__CLPK_integer *)&n,
-				inv[0], (__CLPK_integer *)&n, (__CLPK_integer *)p,
-				(__CLPK_integer *)&info);
-		assert(info == 0);
-		dgetri_((__CLPK_integer *)&n, inv[0], (__CLPK_integer *)&n,
-				(__CLPK_integer *)p, work, (__CLPK_integer *)&lwork,
-				(__CLPK_integer *)&info);
-		assert(info == 0);
-	} else {
-		dpotrf_("U", (__CLPK_integer *)&n, inv[0], (__CLPK_integer *)&n,
-				(__CLPK_integer *)&info);
-		assert(info == 0);
-		dpotri_("U", (__CLPK_integer *)&n, inv[0], (__CLPK_integer *)&n,
-				(__CLPK_integer *)&info);
-		assert(info == 0);
-		mirror_dmatrix(inv, n);
-	}
-	#elif(MATHACCEL == MA_SUN)
-	info = 0;
-	dcopy(n*n, m[0], 1, inv[0], 1);
-	if (!spd) {
-		dgetrf_(&n, &n, inv[0], &n, p, &info);
-		assert(info == 0);
-		dgetri_(&n, inv[0], &n, p, work, &lwork, &info);
-		assert(info == 0);
-	} else {
-		dpotrf_("U", &n, inv[0], &n, &info);
-		assert(info == 0);
-		dpotri_("U", &n, inv[0], &n, &info);
-		assert(info == 0);
-		mirror_dmatrix(inv, n);
-	}
-	#else
-	col = dvector(n);
-
-	lupdcmp(m, n, p, spd);
-
-	for (j = 0; j < n; j++) {
-		for (i = 0; i < n; i++) col[i]=0.0;
-		col[j] = 1.0;
-		lusolve(m, n, p, col, work, spd);
-		for (i = 0; i < n; i++) inv[i][j]=work[i];
-	}
-
-	free_dvector(col);
-	#endif
-
-	free_ivector(p);
-	free_dvector(work);
-}
-
-/* dst = src1 + scale * src2	*/
-void scaleadd_dvector (double *dst, double *src1, double *src2, int n, double scale)
-{
-	#if (MATHACCEL == MA_NONE)
-	int i;
-	for(i=0; i < n; i++)
-		dst[i] = src1[i] + scale * src2[i];
-	#else
-	/* dst == src2. so, dst *= scale, dst += src1	*/
-	if (dst == src2 && dst != src1) {
-		#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
-		cblas_dscal(n, scale, dst, 1);
-		cblas_daxpy(n, 1.0, src1, 1, dst, 1);
-		#elif (MATHACCEL == MA_AMD || MATHACCEL == MA_SUN)
-		dscal(n, scale, dst, 1);
-		daxpy(n, 1.0, src1, 1, dst, 1);
-		#else
-		fatal("unknown math acceleration\n");
-		#endif
-	/* dst = src1; dst += scale * src2	*/
-	} else {
-		#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
-		cblas_dcopy(n, src1, 1, dst, 1);
-		cblas_daxpy(n, scale, src2, 1, dst, 1);
-		#elif (MATHACCEL == MA_AMD || MATHACCEL == MA_SUN)
-		dcopy(n, src1, 1, dst, 1);
-		daxpy(n, scale, src2, 1, dst, 1);
-		#else
-		fatal("unknown math acceleration\n");
-		#endif
-	} 
-	#endif
-}
diff -Naur temp/RCutil.cc HotSpot/RCutil.cc
--- temp/RCutil.cc	1970-01-01 01:00:00.000000000 +0100
+++ HotSpot/RCutil.cc	2017-11-20 09:59:35.316820635 +0100
@@ -0,0 +1,608 @@
+/* 
+ * Thanks to Greg Link from Penn State University
+ * for his math acceleration engine. Where available,
+ * the modified version of the engine found here, uses 
+ * the fast, vendor-provided linear algebra routines 
+ * from the BLAS and LAPACK packages in  lieu of
+ * the vanilla C code present in the matrix functions 
+ * of the previous versions of HotSpot. 
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <math.h>
+
+#include "temperature.h"
+#include "flp.h"
+#include "util.h"
+
+/* thermal resistance calculation	*/
+double getr(double conductivity, double thickness, double area)
+{
+	return thickness / (conductivity * area);
+}
+
+/* thermal capacitance calculation	*/
+double getcap(double sp_heat, double thickness, double area)
+{
+	/* include lumped vs. distributed correction	*/
+	return C_FACTOR * sp_heat * thickness * area;
+}
+
+/*
+ * LUP decomposition from the pseudocode given in the CLR 
+ * 'Introduction to Algorithms' textbook. The matrix 'a' is
+ * transformed into an in-place lower/upper triangular matrix
+ * and the vector'p' carries the permutation vector such that
+ * Pa = lu, where 'P' is the matrix form of 'p'. The 'spd' flag 
+ * indicates that 'a' is symmetric and positive definite 
+ */
+ 
+void lupdcmp(double**a, int n, int *p, int spd)
+{
+	#if(MATHACCEL == MA_INTEL)
+	int info = 0;
+	if (!spd)
+		dgetrf(&n, &n, a[0], &n, p, &info);
+	else	
+		dpotrf("U", &n, a[0], &n, &info);
+	assert(info == 0);	
+	#elif(MATHACCEL == MA_AMD)
+	int info = 0;
+	if (!spd)
+		dgetrf_(&n, &n, a[0], &n, p, &info);
+	else	
+		dpotrf_("U", &n, a[0], &n, &info, 1);
+	assert(info == 0);	
+	#elif(MATHACCEL == MA_APPLE)
+	int info = 0;
+	if (!spd)
+		dgetrf_((__CLPK_integer *)&n, (__CLPK_integer *)&n, a[0],
+				(__CLPK_integer *)&n, (__CLPK_integer *)p,
+				(__CLPK_integer *)&info);
+	else	
+		dpotrf_("U", (__CLPK_integer *)&n, a[0], (__CLPK_integer *)&n,
+				(__CLPK_integer *)&info);
+	assert(info == 0);	
+	#elif(MATHACCEL == MA_SUN)
+	int info = 0;
+	if (!spd)
+		dgetrf_(&n, &n, a[0], &n, p, &info);
+	else	
+		dpotrf_("U", &n, a[0], &n, &info);
+	assert(info == 0);	
+	#else
+	int i, j, k, pivot=0;
+	double max = 0;
+
+	/* start with identity permutation	*/
+	for (i=0; i < n; i++)
+		p[i] = i;
+
+	for (k=0; k < n-1; k++)	 {
+		max = 0;
+		for (i = k; i < n; i++)	{
+			if (fabs(a[i][k]) > max) {
+				max = fabs(a[i][k]);
+				pivot = i;
+			}
+		}	
+		if (eq (max, 0))
+			fatal ((char*)"singular matrix in lupdcmp\n");
+
+		/* bring pivot element to position	*/
+		swap_ival (&p[k], &p[pivot]);
+		for (i=0; i < n; i++)
+			swap_dval (&a[k][i], &a[pivot][i]);
+
+		for (i=k+1; i < n; i++) {
+			a[i][k] /= a[k][k];
+			for (j=k+1; j < n; j++)
+				a[i][j] -= a[i][k] * a[k][j];
+		}
+	}
+	#endif
+}
+
+/* 
+ * the matrix a is an in-place lower/upper triangular matrix
+ * the following macros split them into their constituents
+ */
+
+#define LOWER(a, i, j)		((i > j) ? a[i][j] : 0)
+#define UPPER(a, i, j)		((i <= j) ? a[i][j] : 0)
+
+/* 
+ * LU forward and backward substitution from the pseudocode given
+ * in the CLR 'Introduction to Algorithms' textbook. It solves ax = b
+ * where, 'a' is an in-place lower/upper triangular matrix. The vector
+ * 'x' carries the solution vector. 'p' is the permutation vector. The
+ * 'spd' flag indicates that 'a' is symmetric and positive definite
+ */
+
+void lusolve(double **a, int n, int *p, double *b, double *x, int spd)
+{
+	#if(MATHACCEL == MA_INTEL)
+	int one = 1, info = 0;
+	cblas_dcopy(n, b, 1, x, 1);
+	if (!spd)
+		dgetrs("T", &n, &one, a[0], &n, p, x, &n, &info);
+	else	
+		dpotrs("U", &n, &one, a[0], &n, x, &n, &info);
+	assert(info == 0);	
+	#elif(MATHACCEL == MA_AMD)
+	int one = 1, info = 0;
+	dcopy(n, b, 1, x, 1);
+	if (!spd)
+		dgetrs_("T", &n, &one, a[0], &n, p, x, &n, &info, 1);
+	else	
+		dpotrs_("U", &n, &one, a[0], &n, x, &n, &info, 1);
+	assert(info == 0);	
+	#elif(MATHACCEL == MA_APPLE)
+	int one = 1, info = 0;
+	cblas_dcopy(n, b, 1, x, 1);
+	if (!spd)
+		dgetrs_("T", (__CLPK_integer *)&n, (__CLPK_integer *)&one, a[0],
+				(__CLPK_integer *)&n, (__CLPK_integer *)p, x,
+				(__CLPK_integer *)&n, (__CLPK_integer *)&info);
+	else	
+		dpotrs_("U", (__CLPK_integer *)&n, (__CLPK_integer *)&one, a[0],
+				(__CLPK_integer *)&n, x, (__CLPK_integer *)&n,
+				(__CLPK_integer *)&info);
+	assert(info == 0);	
+	#elif(MATHACCEL == MA_SUN)
+	int one = 1, info = 0;
+	dcopy(n, b, 1, x, 1);
+	if (!spd)
+		dgetrs_("T", &n, &one, a[0], &n, p, x, &n, &info);
+	else	
+		dpotrs_("U", &n, &one, a[0], &n, x, &n, &info);
+	assert(info == 0);	
+	#else
+	int i, j;
+	double *y = dvector (n);
+	double sum;
+
+	/* forward substitution	- solves ly = pb	*/
+	for (i=0; i < n; i++) {
+		for (j=0, sum=0; j < i; j++)
+			sum += y[j] * LOWER(a, i, j);
+		y[i] = b[p[i]] - sum;
+	}
+
+	/* backward substitution - solves ux = y	*/
+	for (i=n-1; i >= 0; i--) {
+		for (j=i+1, sum=0; j < n; j++)
+			sum += x[j] * UPPER(a, i, j);
+		x[i] = (y[i] - sum) / UPPER(a, i, i);
+	}
+
+	free_dvector(y);
+	#endif
+}
+
+/* core of the 4th order Runge-Kutta method, where the Euler step
+ * (y(n+1) = y(n) + h * k1 where k1 = dydx(n)) is provided as an input.
+ * to evaluate dydx at different points, a call back function f (slope
+ * function) is also passed as a parameter. Given values for y, and k1, 
+ * this function advances the solution over an interval h, and returns
+ * the solution in yout. For details, see the discussion in "Numerical 
+ * Recipes in C", Chapter 16, from 
+ * http://www.nrbook.com/a/bookcpdf/c16-1.pdf
+ */
+void rk4_core(void *model, double *y, double *k1, void *p, int n, double h, double *yout, slope_fn_ptr f)
+{
+	int i;
+	double *t, *k2, *k3, *k4;
+	k2 = dvector(n);
+	k3 = dvector(n);
+	k4 = dvector(n);
+	t = dvector(n);
+
+	/* k2 is the slope at the trial midpoint (t) found using 
+	 * slope k1 (which is at the starting point).
+	 */
+	/* t = y + h/2 * k1 (t = y; t += h/2 * k1) */
+	#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
+	cblas_dcopy(n, y, 1, t, 1);
+	cblas_daxpy(n, h/2.0, k1, 1, t, 1);
+	#elif (MATHACCEL == MA_AMD || MATHACCEL == MA_SUN)
+	dcopy(n, y, 1, t, 1);
+	daxpy(n, h/2.0, k1, 1, t, 1);
+	#else
+	for(i=0; i < n; i++)
+		t[i] = y[i] + h/2.0 * k1[i];
+	#endif	
+	/* k2 = slope at t */
+	(*f)(model, t, p, k2); 
+
+	/* k3 is the slope at the trial midpoint (t) found using
+	 * slope k2 found above.
+	 */
+	/* t =  y + h/2 * k2 (t = y; t += h/2 * k2) */
+	#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
+	cblas_dcopy(n, y, 1, t, 1);
+	cblas_daxpy(n, h/2.0, k2, 1, t, 1);
+	#elif (MATHACCEL == MA_AMD || MATHACCEL == MA_SUN)
+	dcopy(n, y, 1, t, 1);
+	daxpy(n, h/2.0, k2, 1, t, 1);
+	#else
+	for(i=0; i < n; i++)
+		t[i] = y[i] + h/2.0 * k2[i];
+	#endif	
+	/* k3 = slope at t */
+	(*f)(model, t, p, k3);
+
+	/* k4 is the slope at trial endpoint (t) found using
+	 * slope k3 found above.
+	 */
+	/* t =  y + h * k3 (t = y; t += h * k3) */
+	#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
+	cblas_dcopy(n, y, 1, t, 1);
+	cblas_daxpy(n, h, k3, 1, t, 1);
+	#elif (MATHACCEL == MA_AMD || MATHACCEL == MA_SUN)
+	dcopy(n, y, 1, t, 1);
+	daxpy(n, h, k3, 1, t, 1);
+	#else
+	for(i=0; i < n; i++)
+		t[i] = y[i] + h * k3[i];
+	#endif	
+	/* k4 = slope at t */
+	(*f)(model, t, p, k4);
+
+	/* yout = y + h*(k1/6 + k2/3 + k3/3 + k4/6)	*/
+	#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
+	/* yout = y	*/			
+	cblas_dcopy(n, y, 1, yout, 1);
+	/* yout += h*k1/6	*/
+	cblas_daxpy(n, h/6.0, k1, 1, yout, 1);
+	/* yout += h*k2/3	*/
+	cblas_daxpy(n, h/3.0, k2, 1, yout, 1);
+	/* yout += h*k3/3	*/
+	cblas_daxpy(n, h/3.0, k3, 1, yout, 1);
+	/* yout += h*k4/6	*/
+	cblas_daxpy(n, h/6.0, k4, 1, yout, 1);
+	#elif (MATHACCEL == MA_AMD || MATHACCEL == MA_SUN)
+	dcopy(n, y, 1, yout, 1);
+	/* yout += h*k1/6	*/
+	daxpy(n, h/6.0, k1, 1, yout, 1);
+	/* yout += h*k2/3	*/
+	daxpy(n, h/3.0, k2, 1, yout, 1);
+	/* yout += h*k3/3	*/
+	daxpy(n, h/3.0, k3, 1, yout, 1);
+	/* yout += h*k4/6	*/
+	daxpy(n, h/6.0, k4, 1, yout, 1);
+	#else
+	for (i =0; i < n; i++) 
+		yout[i] = y[i] + h * (k1[i] + 2*k2[i] + 2*k3[i] + k4[i])/6.0;
+	#endif
+
+	free_dvector(k2);
+	free_dvector(k3);
+	free_dvector(k4);
+	free_dvector(t);
+}
+
+/* 
+ * 4th order Runge Kutta solver	with adaptive step sizing.
+ * It integrates and solves the ODE dy + cy = p between
+ * t and t+h. It returns the correct step size to be used 
+ * next time. slope function f is the call back used to 
+ * evaluate the derivative at each point
+ */
+#define RK4_SAFETY		0.95
+#define RK4_MAXUP		5.0
+#define RK4_MAXDOWN		10.0
+#define RK4_PRECISION	0.01
+double rk4(void *model, double *y, void *p, int n, double *h, double *yout, slope_fn_ptr f)
+{
+	int i;
+	double *k1, *t1, *t2, *ytemp, max, new_h = (*h);
+
+	k1 = dvector(n);
+	t1 = dvector(n);
+	t2 = dvector(n);
+	ytemp = dvector(n); 
+
+	/* evaluate the slope k1 at the beginning */
+	(*f)(model, y, p, k1);
+
+	/* try until accuracy is achieved	*/
+	do {
+		(*h) = new_h;
+
+		/* try RK4 once with normal step size	*/
+		rk4_core(model, y, k1, p, n, (*h), ytemp, f);
+
+		/* repeat it with two half-steps	*/
+		rk4_core(model, y, k1, p, n, (*h)/2.0, t1, f);
+
+		/* y after 1st half-step is in t1. re-evaluate k1 for this	*/
+		(*f)(model, t1, p, k1);
+
+		/* get output of the second half-step in t2	*/	
+		rk4_core(model, t1, k1, p, n, (*h)/2.0, t2, f);
+
+		/* find the max diff between these two results:
+		 * use t1 to store the diff
+		 */
+		#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
+		/* t1 = ytemp	*/
+		cblas_dcopy(n, ytemp, 1, t1, 1);
+		/* t1 = -1 * t2 + t1 = ytemp - t2	*/
+		cblas_daxpy(n, -1.0, t2, 1, t1, 1);
+		/* max = |t1[max_abs_index]|	*/
+		max = fabs(t1[cblas_idamax(n, t1, 1)]);
+		#elif (MATHACCEL == MA_AMD || MATHACCEL == MA_SUN)
+		/* t1 = ytemp	*/
+		dcopy(n, ytemp, 1, t1, 1);
+		/* t1 = -1 * t2 + t1 = ytemp - t2	*/
+		daxpy(n, -1.0, t2, 1, t1, 1);
+		/* 
+		 * max = |t1[max_abs_index]| note: FORTRAN BLAS
+		 * indices start from 1 as opposed to CBLAS where
+		 * indices start from 0
+		 */
+		max = fabs(t1[idamax(n, t1, 1)-1]);
+		#else
+		for(i=0; i < n; i++)
+			t1[i] = fabs(ytemp[i] - t2[i]);
+		max = t1[0];
+		for(i=1; i < n; i++)
+			if (max < t1[i])
+				max = t1[i];
+		#endif
+
+		/* 
+		 * compute the correct step size: see equation 
+		 * 16.2.10  in chapter 16 of "Numerical Recipes
+		 * in C"
+		 */
+		/* accuracy OK. increase step size	*/
+		if (max <= RK4_PRECISION) {
+			new_h = RK4_SAFETY * (*h) * pow(fabs(RK4_PRECISION/max), 0.2);
+			if (new_h > RK4_MAXUP * (*h))
+				new_h = RK4_MAXUP * (*h);
+		/* inaccuracy error. decrease step size	and compute again */
+		} else {
+			new_h = RK4_SAFETY * (*h) * pow(fabs(RK4_PRECISION/max), 0.25);
+			if (new_h < (*h) / RK4_MAXDOWN)
+				new_h = (*h) / RK4_MAXDOWN;
+		}
+
+	} while (new_h < (*h));
+
+	/* commit ytemp to yout	*/
+	#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
+	cblas_dcopy(n, ytemp, 1, yout, 1);
+	#elif (MATHACCEL == MA_AMD || MATHACCEL == MA_SUN)
+	dcopy(n, ytemp, 1, yout, 1);
+	#else
+	copy_dvector(yout, ytemp, n);
+	#endif
+
+	/* clean up */
+	free_dvector(k1);
+	free_dvector(t1);
+	free_dvector(t2);
+	free_dvector(ytemp);
+
+	/* return the step-size	*/
+	return new_h;
+}
+
+/* matmult: C = AB, A, B are n x n square matrices	*/
+void matmult(double **c, double **a, double **b, int n) 
+{
+	#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
+	cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
+				n, n, n, 1.0, a[0], n, b[0], n, 0.0, c[0], n);
+	#elif (MATHACCEL == MA_AMD  || MATHACCEL == MA_SUN)
+	/* B^T * A^T = (A * B)^T	*/
+	dgemm('N', 'N', n, n, n, 1.0, b[0], n, a[0], n, 0.0, c[0], n);
+	#else
+	int i, j, k;
+
+	for (i = 0; i < n; i++)
+		for (j = 0; j < n; j++) {
+			c[i][j] = 0;
+			for (k = 0; k < n; k++)
+				c[i][j] += a[i][k] * b[k][j];
+		}
+	#endif	
+}
+
+/* same as above but 'a' is a diagonal matrix stored as a 1-d array	*/
+void diagmatmult(double **c, double *a, double **b, int n) 
+{
+	int i;
+	#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
+	zero_dmatrix(c, n, n);
+	for(i=0; i < n; i++)
+		cblas_daxpy(n, a[i], b[i], 1, c[i], 1);
+	#elif (MATHACCEL == MA_AMD  || MATHACCEL == MA_SUN)
+	zero_dmatrix(c, n, n);
+	for(i=0; i < n; i++)
+		daxpy(n, a[i], b[i], 1, c[i], 1);
+	#else
+	int j;
+
+	for (i = 0; i < n; i++)
+		for (j = 0; j < n; j++)
+			c[i][j] = a[i] * b[i][j];
+	#endif		
+}
+
+/* mult of an n x n matrix and an n x 1 column vector	*/
+void matvectmult(double *vout, double **m, double *vin, int n)
+{
+	#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
+	cblas_dgemv(CblasRowMajor, CblasNoTrans, n, n, 1.0, m[0],
+				n, vin, 1, 0.0, vout, 1);
+	#elif (MATHACCEL == MA_AMD  || MATHACCEL == MA_SUN)
+	dgemv('T', n, n, 1.0, m[0], n, vin, 1, 0.0, vout, 1);
+	#else
+	int i, j;
+
+	for (i = 0; i < n; i++) {
+		vout[i] = 0;
+		for (j = 0; j < n; j++)
+			vout[i] += m[i][j] * vin[j];
+	}
+	#endif
+}
+
+/* same as above but 'm' is a diagonal matrix stored as a 1-d array	*/
+void diagmatvectmult(double *vout, double *m, double *vin, int n)
+{
+	#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
+	cblas_dsbmv(CblasRowMajor, CblasUpper, n, 0, 1.0, m, 1, vin,
+				1, 0.0, vout, 1);
+	#elif (MATHACCEL == MA_AMD  || MATHACCEL == MA_SUN)
+	dsbmv('U', n, 0, 1.0, m, 1, vin, 1, 0.0, vout, 1);
+	#else
+	int i;
+
+	for (i = 0; i < n; i++)
+		vout[i] = m[i] * vin[i];
+	#endif
+}
+
+/* 
+ * inv = m^-1, inv, m are n by n matrices.
+ * the spd flag indicates that m is symmetric 
+ * and positive definite 
+ */
+#define BLOCK_SIZE		256
+void matinv(double **inv, double **m, int n, int spd)
+{
+	int *p, lwork;
+	double *work;
+	int i, j;
+	#if (MATHACCEL != MA_NONE)
+	int info;
+	#endif
+	double *col;
+
+	p = ivector(n);
+	lwork = n * BLOCK_SIZE;
+	work = dvector(lwork);
+
+	#if (MATHACCEL == MA_INTEL)
+	info = 0;
+	cblas_dcopy(n*n, m[0], 1, inv[0], 1);
+	if (!spd) {
+		dgetrf(&n, &n, inv[0], &n, p, &info);
+		assert(info == 0);
+		dgetri(&n, inv[0], &n, p, work, &lwork, &info);
+		assert(info == 0);
+	} else {
+		dpotrf("U", &n, inv[0], &n, &info);
+		assert(info == 0);
+		dpotri("U", &n, inv[0], &n, &info);
+		assert(info == 0);
+		mirror_dmatrix(inv, n);
+	}	
+	#elif(MATHACCEL == MA_AMD)
+	info = 0;
+	dcopy(n*n, m[0], 1, inv[0], 1);
+	if (!spd) {
+		dgetrf_(&n, &n, inv[0], &n, p, &info);
+		assert(info == 0);
+		dgetri_(&n, inv[0], &n, p, work, &lwork, &info);
+		assert(info == 0);
+	} else {
+		dpotrf_("U", &n, inv[0], &n, &info, 1);
+		assert(info == 0);
+		dpotri_("U", &n, inv[0], &n, &info, 1);
+		assert(info == 0);
+		mirror_dmatrix(inv, n);
+	}	
+	#elif (MATHACCEL == MA_APPLE)
+	info = 0;
+	cblas_dcopy(n*n, m[0], 1, inv[0], 1);
+	if (!spd) {
+		dgetrf_((__CLPK_integer *)&n, (__CLPK_integer *)&n,
+				inv[0], (__CLPK_integer *)&n, (__CLPK_integer *)p,
+				(__CLPK_integer *)&info);
+		assert(info == 0);
+		dgetri_((__CLPK_integer *)&n, inv[0], (__CLPK_integer *)&n,
+				(__CLPK_integer *)p, work, (__CLPK_integer *)&lwork,
+				(__CLPK_integer *)&info);
+		assert(info == 0);
+	} else {
+		dpotrf_("U", (__CLPK_integer *)&n, inv[0], (__CLPK_integer *)&n,
+				(__CLPK_integer *)&info);
+		assert(info == 0);
+		dpotri_("U", (__CLPK_integer *)&n, inv[0], (__CLPK_integer *)&n,
+				(__CLPK_integer *)&info);
+		assert(info == 0);
+		mirror_dmatrix(inv, n);
+	}
+	#elif(MATHACCEL == MA_SUN)
+	info = 0;
+	dcopy(n*n, m[0], 1, inv[0], 1);
+	if (!spd) {
+		dgetrf_(&n, &n, inv[0], &n, p, &info);
+		assert(info == 0);
+		dgetri_(&n, inv[0], &n, p, work, &lwork, &info);
+		assert(info == 0);
+	} else {
+		dpotrf_("U", &n, inv[0], &n, &info);
+		assert(info == 0);
+		dpotri_("U", &n, inv[0], &n, &info);
+		assert(info == 0);
+		mirror_dmatrix(inv, n);
+	}
+	#else
+	col = dvector(n);
+
+	lupdcmp(m, n, p, spd);
+
+	for (j = 0; j < n; j++) {
+		for (i = 0; i < n; i++) col[i]=0.0;
+		col[j] = 1.0;
+		lusolve(m, n, p, col, work, spd);
+		for (i = 0; i < n; i++) inv[i][j]=work[i];
+	}
+
+	free_dvector(col);
+	#endif
+
+	free_ivector(p);
+	free_dvector(work);
+}
+
+/* dst = src1 + scale * src2	*/
+void scaleadd_dvector (double *dst, double *src1, double *src2, int n, double scale)
+{
+	#if (MATHACCEL == MA_NONE)
+	int i;
+	for(i=0; i < n; i++)
+		dst[i] = src1[i] + scale * src2[i];
+	#else
+	/* dst == src2. so, dst *= scale, dst += src1	*/
+	if (dst == src2 && dst != src1) {
+		#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
+		cblas_dscal(n, scale, dst, 1);
+		cblas_daxpy(n, 1.0, src1, 1, dst, 1);
+		#elif (MATHACCEL == MA_AMD || MATHACCEL == MA_SUN)
+		dscal(n, scale, dst, 1);
+		daxpy(n, 1.0, src1, 1, dst, 1);
+		#else
+		fatal("unknown math acceleration\n");
+		#endif
+	/* dst = src1; dst += scale * src2	*/
+	} else {
+		#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
+		cblas_dcopy(n, src1, 1, dst, 1);
+		cblas_daxpy(n, scale, src2, 1, dst, 1);
+		#elif (MATHACCEL == MA_AMD || MATHACCEL == MA_SUN)
+		dcopy(n, src1, 1, dst, 1);
+		daxpy(n, scale, src2, 1, dst, 1);
+		#else
+		fatal("unknown math acceleration\n");
+		#endif
+	} 
+	#endif
+}
diff -Naur temp/shape.c HotSpot/shape.c
--- temp/shape.c	2017-11-20 10:04:24.517682836 +0100
+++ HotSpot/shape.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,570 +0,0 @@
-#include <stdio.h>
-#ifdef _MSC_VER
-#define strcasecmp    _stricmp
-#define strncasecmp   _strnicmp
-#else
-#include <strings.h>
-#endif
-#include <string.h>
-#include <stdlib.h>
-#include <math.h>
-
-#include "shape.h"
-#include "flp.h"
-#include "util.h"
-
-/* make a shape curve from area and aspect ratios	*/
-shape_t *shape_from_aspect(double area, double min, 
-                           double max, int rotable,
-						   int n_orients)
-{
-	shape_t *shape;
-	double r=1, minx, maxx, tmin, tmax;
-	int i, overlap = 0;
-
-	/* rotatable blocks have 2n no. of orients	*/
-	if (n_orients <= 1 || (n_orients & 1))
-		fatal("n_orients should be an even number greater than 1\n");
-
-	shape = (shape_t *) calloc(1, sizeof(shape_t));
-	if (!shape)
-		fatal("memory allocation error\n");
-	if (min == max)	
-		shape->size = 1 + (!!rotable);
-	else
-		shape->size = n_orients;
-
-	shape->x = (double *) calloc(shape->size, sizeof(double));
-	shape->y = (double *) calloc(shape->size, sizeof(double));
-	if (!shape->x || !shape->y)
-		fatal("memory allocation error\n");
-
-	/* overlapping regions of aspect ratios */
-	if (rotable && min <= 1.0 && max >= 1.0) {
-		overlap = 1;
-		tmin = MIN4(min, max, 1.0/min, 1.0/max);
-		tmax = MAX4(min, max, 1.0/min, 1.0/max);
-		min = tmin;
-		max = tmax;
-	}
-
-	if (!rotable || overlap) {
-		minx = sqrt(area * min);
-		maxx = sqrt(area * max);
-		if (shape->size > 1)
-			r = pow((maxx / minx) , 1.0/(shape->size-1));
-		for (i = 0; i < shape->size; i++) {
-			shape->x[i] = minx * pow(r, i);
-			shape->y[i] = area / shape->x[i];
-		}
-	/* rotable but no overlap, hence two sets of orientations	*/		
-	} else {
-		int n = shape->size / 2;
-		/* orientations with aspect ratios < 1	*/
-		tmin = MIN(min, 1.0/min);
-		tmax = MIN(max, 1.0/max);
-		minx = sqrt(area * MIN(tmin, tmax));
-		maxx = sqrt(area * MAX(tmin, tmax));
-		if ( n > 1)
-			r = pow((maxx / minx) , 1.0/(n-1));
-		for (i = 0; i < n; i++) {
-			shape->x[i] = minx * pow(r, i);
-			shape->y[i] = area / shape->x[i];
-		}
-		/* orientations with aspect ratios > 1	*/
-		tmin = MAX(min, 1.0/min);
-		tmax = MAX(max, 1.0/max);
-		minx = sqrt(area * MIN(tmin, tmax));
-		maxx = sqrt(area * MAX(tmin, tmax));
-		if ( n > 1)
-			r = pow((maxx / minx) , 1.0/(n-1));
-		for (i = 0; i < n; i++) {
-			shape->x[n+i] = minx * pow(r, i);
-			shape->y[n+i] = area / shape->x[n+i];
-		}
-	}
-	return shape;
-}
-
-void free_shape(shape_t *shape)
-{
-	free (shape->x);
-	free (shape->y);
-	if(shape->left_pos) {
-		free(shape->left_pos);
-		free(shape->right_pos);
-		free(shape->median);
-	}	
-	free(shape);
-}
-
-void print_shape_entry(shape_t *shape, int i)
-{
-	fprintf(stdout, "%g\t%g", shape->x[i], shape->y[i]);
-	if (shape->left_pos)
-		fprintf(stdout, "\t%d\t%d\t%g", shape->left_pos[i], 
-		        shape->right_pos[i], shape->median[i]);
-	fprintf(stdout, "\n");
-}
-
-/* debug print  */
-void print_shape(shape_t *shape)
-{
-	int i;
-	if (!shape) {
-		fprintf(stdout, "printing shape curve: NULL\n");
-		return;
-	}
-	fprintf(stdout, "printing shape curve with %d elements\n", shape->size);
-	for (i=0; i < shape->size; i++) 
-		print_shape_entry(shape, i);
-	fprintf(stdout, "\n");	
-}
-
-/* shape curve arithmetic	*/
-shape_t *shape_add(shape_t *shape1, shape_t *shape2, int cut_type)
-{
-	int i=0, j=0, k=0, total=0, m, n;
-	shape_t *sum;
-
-	sum = (shape_t *) calloc(1, sizeof(shape_t));
-	if (!sum)
-		fatal("memory allocation error\n");
-
-	/* shortcuts	*/	
-	m = shape1->size;
-	n = shape2->size;
-
-	/* determine result size	*/
-	while(i < m && j < n) {
-		if (cut_type == CUT_VERTICAL) {
-			if (shape1->y[i] >= shape2->y[j])
-				i++;
-			else
-				j++;
-		} else {
-			if (shape1->x[m-1-i] >= shape2->x[n-1-j])
-				i++;
-			else
-				j++;
-		}
-		total++;
-	}
-
-	sum->x = (double *) calloc(total, sizeof(double));
-	sum->y = (double *) calloc(total, sizeof(double));
-	sum->left_pos = (int *) calloc(total, sizeof(int));
-	sum->right_pos = (int *) calloc(total, sizeof(int));
-	sum->median = (double *) calloc(total, sizeof(double));
-	if (!sum->x || !sum->y || !sum->left_pos || 
-	    !sum->right_pos || !sum->median)
-		fatal("memory allocation error\n");
-	sum->size = total;	
-
-	i=j=0;
-	while(i < m && j < n) {
-		/* vertical add	*/
-		if (cut_type == CUT_VERTICAL) {
-			sum->x[k] = shape1->x[i] + shape2->x[j];
-			sum->y[k] = MAX(shape1->y[i], shape2->y[j]);
-			sum->left_pos[k] = i;
-			sum->right_pos[k] = j;
-			sum->median[k] = shape1->x[i];
-			if (shape1->y[i] >= shape2->y[j])
-				i++;
-			else
-				j++;
-		/* horizontal add */
-		} else {
-			/* 
-			 * direction of increasing 'y' is the reverse of the
-			 * regular direction of the shape curve. hence reverse
-			 * the curve before adding
-			 */
-			sum->x[total-1-k] = MAX(shape1->x[m-1-i], shape2->x[n-1-j]);
-			sum->y[total-1-k] =  shape1->y[m-1-i] + shape2->y[n-1-j];
-			sum->left_pos[total-1-k] = m-1-i;
-			sum->right_pos[total-1-k] = n-1-j;
-			sum->median[total-1-k] = shape1->y[m-1-i];
-			if (shape1->x[m-1-i] >= shape2->x[n-1-j])
-				i++;
-			else
-				j++;
-		}
-		k++;
-	}
-
-	return sum;
-}
-
-/* copy a shape curve	*/
-shape_t *shape_duplicate(shape_t *shape)
-{
-	shape_t *copy;
-	int i;
-	copy = (shape_t *) calloc(1, sizeof(shape_t));
-	if (!copy)
-		fatal("memory allocation error\n");
-	copy->size = shape->size;
-	copy->x = (double *) calloc(copy->size, sizeof(double));
-	copy->y = (double *) calloc(copy->size, sizeof(double));
-	if (!copy->x || !copy->y)
-		fatal("memory allocation error\n");
-	if (shape->left_pos) {
-		copy->left_pos = (int *) calloc(copy->size, sizeof(int));
-		copy->right_pos = (int *) calloc(copy->size, sizeof(int));
-		copy->median = (double *) calloc(copy->size, sizeof(double));
-		if(!copy->left_pos || !copy->right_pos || !copy->median)
-			fatal("memory allocation error\n");
-	}
-	for(i=0; i < shape->size; i++) {
-		copy->x[i] = shape->x[i];
-		copy->y[i] = shape->y[i];
-		if (shape->left_pos) {
-			copy->left_pos[i] = shape->left_pos[i];
-			copy->right_pos[i] = shape->right_pos[i];
-			copy->median[i] = shape->median[i];
-		}
-	}
-	return copy;
-}
-
-/* tree node stack operations	*/
-
-/* constructor	*/
-tree_node_stack_t *new_tree_node_stack(void)
-{
-	tree_node_stack_t *stack;
-	stack = (tree_node_stack_t *)calloc(1, sizeof(tree_node_stack_t));
-	if (!stack)
-		fatal("memory allocation error\n");
-	/* first free location	*/	
-	stack->top = 0;
-	return stack;
-}
-
-/* destructor	*/
-void free_tree_node_stack(tree_node_stack_t *stack)
-{
-	free(stack);
-}
-
-/* is empty?	*/
-int tree_node_stack_isempty(tree_node_stack_t *stack)
-{
-	if (stack->top <= 0)
-		return TRUE;
-	return FALSE;
-}
-
-/* is full?	*/
-int tree_node_stack_isfull(tree_node_stack_t *stack)
-{
-	if (stack->top >= MAX_STACK)
-		return TRUE;
-	return FALSE;
-}
-
-/* push	*/
-void tree_node_stack_push(tree_node_stack_t *stack, tree_node_t *node)
-{
-	if (!tree_node_stack_isfull(stack)) {
-		stack->array[stack->top] = node;
-		stack->top++;
-	} else
-		fatal("attempting to push into an already full stack\n");
-}
-
-/* pop	*/
-tree_node_t *tree_node_stack_pop(tree_node_stack_t *stack)
-{
-	if (!tree_node_stack_isempty(stack)) {
-		stack->top--;
-		return stack->array[stack->top];
-	} else {
-		fatal("attempting to pop from an already empty stack\n");
-		return NULL;
-	}	
-}
-
-/* clear	*/
-void tree_node_stack_clear(tree_node_stack_t *stack)
-{
-	stack->top = 0;
-}
-
-/* slicing tree routines	*/
-
-/* construct floorplan slicing tree from NPE	*/
-tree_node_t *tree_from_NPE(flp_desc_t *flp_desc,
-						   tree_node_stack_t *stack,
-						   NPE_t *expr)
-{
-	int i;
-	tree_node_t *node = NULL, *left, *right;
-	
-	if (!tree_node_stack_isempty(stack))
-		fatal("stack not empty\n");
-
-	for (i=0; i < expr->size; i++) {
-		node = (tree_node_t *) calloc(1, sizeof(tree_node_t));
-		if (!node)
-			fatal("memory allocation error\n");
-		/* leaf */
-		if (expr->elements[i] >= 0) {
-			node->curve = shape_duplicate(flp_desc->units[expr->elements[i]].shape);
-			node->left = node->right = NULL;
-			node->label.unit = expr->elements[i];
-		/*	internal node denoting a cut	*/
-		} else {
-			right = tree_node_stack_pop(stack);
-			left = tree_node_stack_pop(stack);
-			node->curve = shape_add(left->curve, right->curve, expr->elements[i]);
-			node->left = left;
-			node->right = right;
-			node->label.cut_type = expr->elements[i];
-		}
-		tree_node_stack_push(stack, node);
-	}
-
-	tree_node_stack_clear(stack);
-	return node;
-}
-
-void free_tree(tree_node_t *root)
-{
-	if (root->left != NULL)
-		free_tree(root->left);
-	if (root->right != NULL)
-		free_tree(root->right);
-	free_shape(root->curve);
-	free(root);
-}
-
-/* debug print	*/
-void print_tree(tree_node_t *root, flp_desc_t *flp_desc)
-{
-	if(root->left != NULL)
-		print_tree(root->left, flp_desc);
-	if (root->right != NULL)
-		print_tree(root->right, flp_desc);
-		
-	if (root->label.unit >= 0)
-		fprintf(stdout, "printing shape curve for %s\n", flp_desc->units[root->label.unit].name);
-	else if (root->label.cut_type == CUT_VERTICAL)	
-		fprintf(stdout, "printing shape curve for VERTICAL CUT\n");
-	else if (root->label.cut_type == CUT_HORIZONTAL)
-		fprintf(stdout, "printing shape curve for HORIZONTAL CUT\n");
-	else
-		fprintf(stdout, "unknown cut type\n");
-	
-	print_shape(root->curve);
-}
-
-/* 
- * print only the portion of the shape curves 
- * corresponding to the `pos'th entry of root->curve
- */
-void print_tree_relevant(tree_node_t *root, int pos, flp_desc_t *flp_desc)
-{
-	if(root->left != NULL)
-		print_tree_relevant(root->left, root->curve->left_pos[pos], flp_desc);
-	if (root->right != NULL)
-		print_tree_relevant(root->right, root->curve->right_pos[pos], flp_desc);
-		
-	if (root->label.unit >= 0)
-		fprintf(stdout, "printing orientation for %s:\t", flp_desc->units[root->label.unit].name);
-	else if (root->label.cut_type == CUT_VERTICAL)	
-		fprintf(stdout, "printing orientation for VERTICAL CUT:\t");
-	else if (root->label.cut_type == CUT_HORIZONTAL)
-		fprintf(stdout, "printing orientation for HORIZONTAL CUT:\t");
-	else
-		fprintf(stdout, "unknown cut type\n");
-	
-	print_shape_entry(root->curve, pos);
-}
-
-int min_area_pos(shape_t *curve)
-{
-	int i = 1, pos = 0;
-	double min = curve->x[0] * curve->y[0];
-	for (; i < curve->size; i++)
-		if (min > curve->x[i] * curve->y[i]) {
-			min = curve->x[i] * curve->y[i];
-			pos = i;
-		}
-	return pos;	
-}
-
-/* 
- * recursive sizing - given the slicing tree containing
- * the added up shape curves. 'pos' denotes the current
- * added up orientation. 'leftx' & 'bottomy' denote the
- * left and bottom ends of the current bounding rectangle
- */
-int recursive_sizing (tree_node_t *node, int pos, 
-					   double leftx, double bottomy,
-					   int dead_count, int compact_dead,
-					   double compact_ratio,
-#if VERBOSE > 1					   
-					   double *compacted_area, 
-#endif					   
-					   flp_t *flp)
-{
-	/* shortcut	*/
-	shape_t *self = node->curve;
-
-	/* leaf node. fill the placeholder	*/
-	if (node->label.unit >= 0) {
-		flp->units[node->label.unit].width = self->x[pos];
-		flp->units[node->label.unit].height = self->y[pos];
-		flp->units[node->label.unit].leftx = leftx;
-		flp->units[node->label.unit].bottomy = bottomy;
-	} else {
-		/* shortcuts */
-		int idx;
-		double x1, x2, y1, y2;
-		shape_t *left = node->left->curve;
-		shape_t *right = node->right->curve;
-
-		/* location of the first dead block	+ offset */
-		idx = (flp->n_units + 1) / 2 + dead_count;
-
-		x1 = left->x[self->left_pos[pos]];
-		x2 = right->x[self->right_pos[pos]];
-		y1 = left->y[self->left_pos[pos]];
-		y2 = right->y[self->right_pos[pos]];
-
-		/* add a dead block - possibly of zero area	*/
-		if (node->label.unit == CUT_VERTICAL) {
-			/* 
-			 * if a dead block has been previously compacted away from this
-			 * bounding rectangle, absorb that area into the child also
-			 */
-			if(self->y[pos] > MAX(y1, y2)) {
-				left->y[self->left_pos[pos]] += (self->y[pos] - MAX(y1, y2));
-				right->y[self->right_pos[pos]] += (self->y[pos] - MAX(y1, y2));
-				y1 = left->y[self->left_pos[pos]];
-				y2 = right->y[self->right_pos[pos]];
-			}	
-			if(self->x[pos] > (x1+x2)) {
-				right->x[self->right_pos[pos]] += self->x[pos]-(x1+x2);
-				x2 = right->x[self->right_pos[pos]];
-			}	
-
-			flp->units[idx].width = (y2 >= y1) ? x1 : x2;
-			flp->units[idx].height = fabs(y2 - y1);
-			flp->units[idx].leftx = leftx + ((y2 >= y1) ? 0 : x1);
-			flp->units[idx].bottomy = bottomy + MIN(y1, y2);
-
-			/* 
-			 * ignore dead blocks smaller than compact_ratio times the area
-			 * of the smaller of the constituent rectangles. instead, increase
-			 * the size of the rectangle by that amount
-			 */
-			if (compact_dead && fabs(y2-y1) / MIN(y1, y2) <= compact_ratio) {
-				#if VERBOSE > 1
-				*compacted_area += (flp->units[idx].width * flp->units[idx].height);
-				#endif
-				if (y2 >= y1) 
-					left->y[self->left_pos[pos]] = y2;
-				else
-					right->y[self->right_pos[pos]] = y1;
-			} else {
-				dead_count++;
-			}
-
-			/* left and bottom don't change for the left child	*/
-			dead_count = recursive_sizing(node->left, self->left_pos[pos],
-										 leftx, bottomy, dead_count, compact_dead, 
-										 compact_ratio,
-			#if VERBOSE > 1
-										 compacted_area,
-			#endif
-										 flp);
-			dead_count = recursive_sizing(node->right, self->right_pos[pos],
-										 leftx + self->median[pos], bottomy, 
-										 dead_count, compact_dead, compact_ratio,
-			#if VERBOSE > 1
-										 compacted_area,
-			#endif
-										 flp);
-		} else {
-			if(self->x[pos] > MAX(x1, x2)) {
-				left->x[self->left_pos[pos]] += (self->x[pos] - MAX(x1, x2));
-				right->x[self->right_pos[pos]] += (self->x[pos] - MAX(x1, x2));
-				x1 = left->x[self->left_pos[pos]];
-				x2 = right->x[self->right_pos[pos]];
-			}	
-			if(self->y[pos] > (y1+y2)) {
-				right->y[self->right_pos[pos]] += self->y[pos]-(y1+y2);
-				y2 = right->y[self->right_pos[pos]];
-			}	
-
-			flp->units[idx].width = fabs(x2 - x1);
-			flp->units[idx].height = (x2 >= x1) ? y1 : y2;
-			flp->units[idx].leftx = leftx + MIN(x1, x2);
-			flp->units[idx].bottomy = bottomy + ((x2 >= x1) ? 0 : y1);
-
-			if (compact_dead && fabs(x2-x1) / MIN(x1, x2) <= compact_ratio) {
-				#if VERBOSE > 1
-				*compacted_area += (flp->units[idx].width * flp->units[idx].height);
-				#endif
-				if (x2 >= x1) 
-					left->x[self->left_pos[pos]] = x2;
-				else
-					right->x[self->right_pos[pos]] = x1;
-			} else {
-				dead_count++;
-			}
-
-			/* left and bottom don't change for the left child	*/
-			dead_count = recursive_sizing(node->left, self->left_pos[pos],
-										 leftx, bottomy, dead_count, compact_dead, 
-										 compact_ratio,
-			#if VERBOSE > 1
-										 compacted_area,
-			#endif
-										 flp);
-			dead_count = recursive_sizing(node->right, self->right_pos[pos],
-							 			 leftx, bottomy + self->median[pos], 
-										 dead_count, compact_dead, compact_ratio,
-			#if VERBOSE > 1
-										 compacted_area,
-			#endif
-										 flp);
-		}
-	}
-	return dead_count;
-}
-
-/* 
- * convert slicing tree into actual floorplan
- * returns the number of dead blocks compacted
- */
-int tree_to_flp(tree_node_t *root, flp_t *flp, int compact_dead, 
-				double compact_ratio)
-{
-	/* for now, only choose the floorplan with
-	 * the minimum area regardless of the overall
-	 * aspect ratio
-	 */
-	int pos = min_area_pos(root->curve);
-	#if VERBOSE > 1									  
-	double compacted_area = 0.0;
-	#endif								  
-	int dead_count = recursive_sizing(root, pos, 0.0, 0.0, 0, 
-					 				  compact_dead, compact_ratio,
-	#if VERBOSE > 1									  
-									  &compacted_area,
-	#endif								  
-									  flp);
-					 
-	int compacted = (flp->n_units - 1) / 2 - dead_count;
-	flp->n_units -= compacted;
-	#if VERBOSE > 1
-	fprintf(stdout, "%d dead blocks, %.2f%% of the core compacted\n", compacted, 
-			compacted_area / (get_total_area(flp)-compacted_area) * 100);
-	#endif
-	return compacted;
-}
diff -Naur temp/shape.cc HotSpot/shape.cc
--- temp/shape.cc	1970-01-01 01:00:00.000000000 +0100
+++ HotSpot/shape.cc	2017-11-20 09:59:35.312820617 +0100
@@ -0,0 +1,570 @@
+#include <stdio.h>
+#ifdef _MSC_VER
+#define strcasecmp    _stricmp
+#define strncasecmp   _strnicmp
+#else
+#include <strings.h>
+#endif
+#include <string.h>
+#include <stdlib.h>
+#include <math.h>
+
+#include "shape.h"
+#include "flp.h"
+#include "util.h"
+
+/* make a shape curve from area and aspect ratios	*/
+shape_t *shape_from_aspect(double area, double min, 
+                           double max, int rotable,
+						   int n_orients)
+{
+	shape_t *shape;
+	double r=1, minx, maxx, tmin, tmax;
+	int i, overlap = 0;
+
+	/* rotatable blocks have 2n no. of orients	*/
+	if (n_orients <= 1 || (n_orients & 1))
+		fatal((char*)"n_orients should be an even number greater than 1\n");
+
+	shape = (shape_t *) calloc(1, sizeof(shape_t));
+	if (!shape)
+		fatal((char*)"memory allocation error\n");
+	if (min == max)	
+		shape->size = 1 + (!!rotable);
+	else
+		shape->size = n_orients;
+
+	shape->x = (double *) calloc(shape->size, sizeof(double));
+	shape->y = (double *) calloc(shape->size, sizeof(double));
+	if (!shape->x || !shape->y)
+		fatal((char*)"memory allocation error\n");
+
+	/* overlapping regions of aspect ratios */
+	if (rotable && min <= 1.0 && max >= 1.0) {
+		overlap = 1;
+		tmin = MIN4(min, max, 1.0/min, 1.0/max);
+		tmax = MAX4(min, max, 1.0/min, 1.0/max);
+		min = tmin;
+		max = tmax;
+	}
+
+	if (!rotable || overlap) {
+		minx = sqrt(area * min);
+		maxx = sqrt(area * max);
+		if (shape->size > 1)
+			r = pow((maxx / minx) , 1.0/(shape->size-1));
+		for (i = 0; i < shape->size; i++) {
+			shape->x[i] = minx * pow(r, i);
+			shape->y[i] = area / shape->x[i];
+		}
+	/* rotable but no overlap, hence two sets of orientations	*/		
+	} else {
+		int n = shape->size / 2;
+		/* orientations with aspect ratios < 1	*/
+		tmin = MIN(min, 1.0/min);
+		tmax = MIN(max, 1.0/max);
+		minx = sqrt(area * MIN(tmin, tmax));
+		maxx = sqrt(area * MAX(tmin, tmax));
+		if ( n > 1)
+			r = pow((maxx / minx) , 1.0/(n-1));
+		for (i = 0; i < n; i++) {
+			shape->x[i] = minx * pow(r, i);
+			shape->y[i] = area / shape->x[i];
+		}
+		/* orientations with aspect ratios > 1	*/
+		tmin = MAX(min, 1.0/min);
+		tmax = MAX(max, 1.0/max);
+		minx = sqrt(area * MIN(tmin, tmax));
+		maxx = sqrt(area * MAX(tmin, tmax));
+		if ( n > 1)
+			r = pow((maxx / minx) , 1.0/(n-1));
+		for (i = 0; i < n; i++) {
+			shape->x[n+i] = minx * pow(r, i);
+			shape->y[n+i] = area / shape->x[n+i];
+		}
+	}
+	return shape;
+}
+
+void free_shape(shape_t *shape)
+{
+	free (shape->x);
+	free (shape->y);
+	if(shape->left_pos) {
+		free(shape->left_pos);
+		free(shape->right_pos);
+		free(shape->median);
+	}	
+	free(shape);
+}
+
+void print_shape_entry(shape_t *shape, int i)
+{
+	fprintf(stdout, "%g\t%g", shape->x[i], shape->y[i]);
+	if (shape->left_pos)
+		fprintf(stdout, "\t%d\t%d\t%g", shape->left_pos[i], 
+		        shape->right_pos[i], shape->median[i]);
+	fprintf(stdout, "\n");
+}
+
+/* debug print  */
+void print_shape(shape_t *shape)
+{
+	int i;
+	if (!shape) {
+		fprintf(stdout, "printing shape curve: NULL\n");
+		return;
+	}
+	fprintf(stdout, "printing shape curve with %d elements\n", shape->size);
+	for (i=0; i < shape->size; i++) 
+		print_shape_entry(shape, i);
+	fprintf(stdout, "\n");	
+}
+
+/* shape curve arithmetic	*/
+shape_t *shape_add(shape_t *shape1, shape_t *shape2, int cut_type)
+{
+	int i=0, j=0, k=0, total=0, m, n;
+	shape_t *sum;
+
+	sum = (shape_t *) calloc(1, sizeof(shape_t));
+	if (!sum)
+		fatal((char*)"memory allocation error\n");
+
+	/* shortcuts	*/	
+	m = shape1->size;
+	n = shape2->size;
+
+	/* determine result size	*/
+	while(i < m && j < n) {
+		if (cut_type == CUT_VERTICAL) {
+			if (shape1->y[i] >= shape2->y[j])
+				i++;
+			else
+				j++;
+		} else {
+			if (shape1->x[m-1-i] >= shape2->x[n-1-j])
+				i++;
+			else
+				j++;
+		}
+		total++;
+	}
+
+	sum->x = (double *) calloc(total, sizeof(double));
+	sum->y = (double *) calloc(total, sizeof(double));
+	sum->left_pos = (int *) calloc(total, sizeof(int));
+	sum->right_pos = (int *) calloc(total, sizeof(int));
+	sum->median = (double *) calloc(total, sizeof(double));
+	if (!sum->x || !sum->y || !sum->left_pos || 
+	    !sum->right_pos || !sum->median)
+		fatal((char*)"memory allocation error\n");
+	sum->size = total;	
+
+	i=j=0;
+	while(i < m && j < n) {
+		/* vertical add	*/
+		if (cut_type == CUT_VERTICAL) {
+			sum->x[k] = shape1->x[i] + shape2->x[j];
+			sum->y[k] = MAX(shape1->y[i], shape2->y[j]);
+			sum->left_pos[k] = i;
+			sum->right_pos[k] = j;
+			sum->median[k] = shape1->x[i];
+			if (shape1->y[i] >= shape2->y[j])
+				i++;
+			else
+				j++;
+		/* horizontal add */
+		} else {
+			/* 
+			 * direction of increasing 'y' is the reverse of the
+			 * regular direction of the shape curve. hence reverse
+			 * the curve before adding
+			 */
+			sum->x[total-1-k] = MAX(shape1->x[m-1-i], shape2->x[n-1-j]);
+			sum->y[total-1-k] =  shape1->y[m-1-i] + shape2->y[n-1-j];
+			sum->left_pos[total-1-k] = m-1-i;
+			sum->right_pos[total-1-k] = n-1-j;
+			sum->median[total-1-k] = shape1->y[m-1-i];
+			if (shape1->x[m-1-i] >= shape2->x[n-1-j])
+				i++;
+			else
+				j++;
+		}
+		k++;
+	}
+
+	return sum;
+}
+
+/* copy a shape curve	*/
+shape_t *shape_duplicate(shape_t *shape)
+{
+	shape_t *copy;
+	int i;
+	copy = (shape_t *) calloc(1, sizeof(shape_t));
+	if (!copy)
+		fatal((char*)"memory allocation error\n");
+	copy->size = shape->size;
+	copy->x = (double *) calloc(copy->size, sizeof(double));
+	copy->y = (double *) calloc(copy->size, sizeof(double));
+	if (!copy->x || !copy->y)
+		fatal((char*)"memory allocation error\n");
+	if (shape->left_pos) {
+		copy->left_pos = (int *) calloc(copy->size, sizeof(int));
+		copy->right_pos = (int *) calloc(copy->size, sizeof(int));
+		copy->median = (double *) calloc(copy->size, sizeof(double));
+		if(!copy->left_pos || !copy->right_pos || !copy->median)
+			fatal((char*)"memory allocation error\n");
+	}
+	for(i=0; i < shape->size; i++) {
+		copy->x[i] = shape->x[i];
+		copy->y[i] = shape->y[i];
+		if (shape->left_pos) {
+			copy->left_pos[i] = shape->left_pos[i];
+			copy->right_pos[i] = shape->right_pos[i];
+			copy->median[i] = shape->median[i];
+		}
+	}
+	return copy;
+}
+
+/* tree node stack operations	*/
+
+/* constructor	*/
+tree_node_stack_t *new_tree_node_stack(void)
+{
+	tree_node_stack_t *stack;
+	stack = (tree_node_stack_t *)calloc(1, sizeof(tree_node_stack_t));
+	if (!stack)
+		fatal((char*)"memory allocation error\n");
+	/* first free location	*/	
+	stack->top = 0;
+	return stack;
+}
+
+/* destructor	*/
+void free_tree_node_stack(tree_node_stack_t *stack)
+{
+	free(stack);
+}
+
+/* is empty?	*/
+int tree_node_stack_isempty(tree_node_stack_t *stack)
+{
+	if (stack->top <= 0)
+		return TRUE;
+	return FALSE;
+}
+
+/* is full?	*/
+int tree_node_stack_isfull(tree_node_stack_t *stack)
+{
+	if (stack->top >= MAX_STACK)
+		return TRUE;
+	return FALSE;
+}
+
+/* push	*/
+void tree_node_stack_push(tree_node_stack_t *stack, tree_node_t *node)
+{
+	if (!tree_node_stack_isfull(stack)) {
+		stack->array[stack->top] = node;
+		stack->top++;
+	} else
+		fatal((char*)"attempting to push into an already full stack\n");
+}
+
+/* pop	*/
+tree_node_t *tree_node_stack_pop(tree_node_stack_t *stack)
+{
+	if (!tree_node_stack_isempty(stack)) {
+		stack->top--;
+		return stack->array[stack->top];
+	} else {
+		fatal((char*)"attempting to pop from an already empty stack\n");
+		return NULL;
+	}	
+}
+
+/* clear	*/
+void tree_node_stack_clear(tree_node_stack_t *stack)
+{
+	stack->top = 0;
+}
+
+/* slicing tree routines	*/
+
+/* construct floorplan slicing tree from NPE	*/
+tree_node_t *tree_from_NPE(flp_desc_t *flp_desc,
+						   tree_node_stack_t *stack,
+						   NPE_t *expr)
+{
+	int i;
+	tree_node_t *node = NULL, *left, *right;
+	
+	if (!tree_node_stack_isempty(stack))
+		fatal((char*)"stack not empty\n");
+
+	for (i=0; i < expr->size; i++) {
+		node = (tree_node_t *) calloc(1, sizeof(tree_node_t));
+		if (!node)
+			fatal((char*)"memory allocation error\n");
+		/* leaf */
+		if (expr->elements[i] >= 0) {
+			node->curve = shape_duplicate(flp_desc->units[expr->elements[i]].shape);
+			node->left = node->right = NULL;
+			node->label.unit = expr->elements[i];
+		/*	internal node denoting a cut	*/
+		} else {
+			right = tree_node_stack_pop(stack);
+			left = tree_node_stack_pop(stack);
+			node->curve = shape_add(left->curve, right->curve, expr->elements[i]);
+			node->left = left;
+			node->right = right;
+			node->label.cut_type = expr->elements[i];
+		}
+		tree_node_stack_push(stack, node);
+	}
+
+	tree_node_stack_clear(stack);
+	return node;
+}
+
+void free_tree(tree_node_t *root)
+{
+	if (root->left != NULL)
+		free_tree(root->left);
+	if (root->right != NULL)
+		free_tree(root->right);
+	free_shape(root->curve);
+	free(root);
+}
+
+/* debug print	*/
+void print_tree(tree_node_t *root, flp_desc_t *flp_desc)
+{
+	if(root->left != NULL)
+		print_tree(root->left, flp_desc);
+	if (root->right != NULL)
+		print_tree(root->right, flp_desc);
+		
+	if (root->label.unit >= 0)
+		fprintf(stdout, "printing shape curve for %s\n", flp_desc->units[root->label.unit].name);
+	else if (root->label.cut_type == CUT_VERTICAL)	
+		fprintf(stdout, "printing shape curve for VERTICAL CUT\n");
+	else if (root->label.cut_type == CUT_HORIZONTAL)
+		fprintf(stdout, "printing shape curve for HORIZONTAL CUT\n");
+	else
+		fprintf(stdout, "unknown cut type\n");
+	
+	print_shape(root->curve);
+}
+
+/* 
+ * print only the portion of the shape curves 
+ * corresponding to the `pos'th entry of root->curve
+ */
+void print_tree_relevant(tree_node_t *root, int pos, flp_desc_t *flp_desc)
+{
+	if(root->left != NULL)
+		print_tree_relevant(root->left, root->curve->left_pos[pos], flp_desc);
+	if (root->right != NULL)
+		print_tree_relevant(root->right, root->curve->right_pos[pos], flp_desc);
+		
+	if (root->label.unit >= 0)
+		fprintf(stdout, "printing orientation for %s:\t", flp_desc->units[root->label.unit].name);
+	else if (root->label.cut_type == CUT_VERTICAL)	
+		fprintf(stdout, "printing orientation for VERTICAL CUT:\t");
+	else if (root->label.cut_type == CUT_HORIZONTAL)
+		fprintf(stdout, "printing orientation for HORIZONTAL CUT:\t");
+	else
+		fprintf(stdout, "unknown cut type\n");
+	
+	print_shape_entry(root->curve, pos);
+}
+
+int min_area_pos(shape_t *curve)
+{
+	int i = 1, pos = 0;
+	double min = curve->x[0] * curve->y[0];
+	for (; i < curve->size; i++)
+		if (min > curve->x[i] * curve->y[i]) {
+			min = curve->x[i] * curve->y[i];
+			pos = i;
+		}
+	return pos;	
+}
+
+/* 
+ * recursive sizing - given the slicing tree containing
+ * the added up shape curves. 'pos' denotes the current
+ * added up orientation. 'leftx' & 'bottomy' denote the
+ * left and bottom ends of the current bounding rectangle
+ */
+int recursive_sizing (tree_node_t *node, int pos, 
+					   double leftx, double bottomy,
+					   int dead_count, int compact_dead,
+					   double compact_ratio,
+#if VERBOSE > 1					   
+					   double *compacted_area, 
+#endif					   
+					   flp_t *flp)
+{
+	/* shortcut	*/
+	shape_t *self = node->curve;
+
+	/* leaf node. fill the placeholder	*/
+	if (node->label.unit >= 0) {
+		flp->units[node->label.unit].width = self->x[pos];
+		flp->units[node->label.unit].height = self->y[pos];
+		flp->units[node->label.unit].leftx = leftx;
+		flp->units[node->label.unit].bottomy = bottomy;
+	} else {
+		/* shortcuts */
+		int idx;
+		double x1, x2, y1, y2;
+		shape_t *left = node->left->curve;
+		shape_t *right = node->right->curve;
+
+		/* location of the first dead block	+ offset */
+		idx = (flp->n_units + 1) / 2 + dead_count;
+
+		x1 = left->x[self->left_pos[pos]];
+		x2 = right->x[self->right_pos[pos]];
+		y1 = left->y[self->left_pos[pos]];
+		y2 = right->y[self->right_pos[pos]];
+
+		/* add a dead block - possibly of zero area	*/
+		if (node->label.unit == CUT_VERTICAL) {
+			/* 
+			 * if a dead block has been previously compacted away from this
+			 * bounding rectangle, absorb that area into the child also
+			 */
+			if(self->y[pos] > MAX(y1, y2)) {
+				left->y[self->left_pos[pos]] += (self->y[pos] - MAX(y1, y2));
+				right->y[self->right_pos[pos]] += (self->y[pos] - MAX(y1, y2));
+				y1 = left->y[self->left_pos[pos]];
+				y2 = right->y[self->right_pos[pos]];
+			}	
+			if(self->x[pos] > (x1+x2)) {
+				right->x[self->right_pos[pos]] += self->x[pos]-(x1+x2);
+				x2 = right->x[self->right_pos[pos]];
+			}	
+
+			flp->units[idx].width = (y2 >= y1) ? x1 : x2;
+			flp->units[idx].height = fabs(y2 - y1);
+			flp->units[idx].leftx = leftx + ((y2 >= y1) ? 0 : x1);
+			flp->units[idx].bottomy = bottomy + MIN(y1, y2);
+
+			/* 
+			 * ignore dead blocks smaller than compact_ratio times the area
+			 * of the smaller of the constituent rectangles. instead, increase
+			 * the size of the rectangle by that amount
+			 */
+			if (compact_dead && fabs(y2-y1) / MIN(y1, y2) <= compact_ratio) {
+				#if VERBOSE > 1
+				*compacted_area += (flp->units[idx].width * flp->units[idx].height);
+				#endif
+				if (y2 >= y1) 
+					left->y[self->left_pos[pos]] = y2;
+				else
+					right->y[self->right_pos[pos]] = y1;
+			} else {
+				dead_count++;
+			}
+
+			/* left and bottom don't change for the left child	*/
+			dead_count = recursive_sizing(node->left, self->left_pos[pos],
+										 leftx, bottomy, dead_count, compact_dead, 
+										 compact_ratio,
+			#if VERBOSE > 1
+										 compacted_area,
+			#endif
+										 flp);
+			dead_count = recursive_sizing(node->right, self->right_pos[pos],
+										 leftx + self->median[pos], bottomy, 
+										 dead_count, compact_dead, compact_ratio,
+			#if VERBOSE > 1
+										 compacted_area,
+			#endif
+										 flp);
+		} else {
+			if(self->x[pos] > MAX(x1, x2)) {
+				left->x[self->left_pos[pos]] += (self->x[pos] - MAX(x1, x2));
+				right->x[self->right_pos[pos]] += (self->x[pos] - MAX(x1, x2));
+				x1 = left->x[self->left_pos[pos]];
+				x2 = right->x[self->right_pos[pos]];
+			}	
+			if(self->y[pos] > (y1+y2)) {
+				right->y[self->right_pos[pos]] += self->y[pos]-(y1+y2);
+				y2 = right->y[self->right_pos[pos]];
+			}	
+
+			flp->units[idx].width = fabs(x2 - x1);
+			flp->units[idx].height = (x2 >= x1) ? y1 : y2;
+			flp->units[idx].leftx = leftx + MIN(x1, x2);
+			flp->units[idx].bottomy = bottomy + ((x2 >= x1) ? 0 : y1);
+
+			if (compact_dead && fabs(x2-x1) / MIN(x1, x2) <= compact_ratio) {
+				#if VERBOSE > 1
+				*compacted_area += (flp->units[idx].width * flp->units[idx].height);
+				#endif
+				if (x2 >= x1) 
+					left->x[self->left_pos[pos]] = x2;
+				else
+					right->x[self->right_pos[pos]] = x1;
+			} else {
+				dead_count++;
+			}
+
+			/* left and bottom don't change for the left child	*/
+			dead_count = recursive_sizing(node->left, self->left_pos[pos],
+										 leftx, bottomy, dead_count, compact_dead, 
+										 compact_ratio,
+			#if VERBOSE > 1
+										 compacted_area,
+			#endif
+										 flp);
+			dead_count = recursive_sizing(node->right, self->right_pos[pos],
+							 			 leftx, bottomy + self->median[pos], 
+										 dead_count, compact_dead, compact_ratio,
+			#if VERBOSE > 1
+										 compacted_area,
+			#endif
+										 flp);
+		}
+	}
+	return dead_count;
+}
+
+/* 
+ * convert slicing tree into actual floorplan
+ * returns the number of dead blocks compacted
+ */
+int tree_to_flp(tree_node_t *root, flp_t *flp, int compact_dead, 
+				double compact_ratio)
+{
+	/* for now, only choose the floorplan with
+	 * the minimum area regardless of the overall
+	 * aspect ratio
+	 */
+	int pos = min_area_pos(root->curve);
+	#if VERBOSE > 1									  
+	double compacted_area = 0.0;
+	#endif								  
+	int dead_count = recursive_sizing(root, pos, 0.0, 0.0, 0, 
+					 				  compact_dead, compact_ratio,
+	#if VERBOSE > 1									  
+									  &compacted_area,
+	#endif								  
+									  flp);
+					 
+	int compacted = (flp->n_units - 1) / 2 - dead_count;
+	flp->n_units -= compacted;
+	#if VERBOSE > 1
+	fprintf(stdout, "%d dead blocks, %.2f%% of the core compacted\n", compacted, 
+			compacted_area / (get_total_area(flp)-compacted_area) * 100);
+	#endif
+	return compacted;
+}
diff -Naur temp/sim-template.c HotSpot/sim-template.c
--- temp/sim-template.c	2017-11-20 10:04:24.517682836 +0100
+++ HotSpot/sim-template.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,221 +0,0 @@
-/* 
- * A dummy simulator template file to illustrate the use of
- * HotSpot in a cycle-accurate simulator like Simplescalar. 
- * This file contains the following sample routines:
- * 	a) Model initialization	(sim_init)
- *	b) Model use in a cycle-by-cycle power model (sim_main)
- *	c) Model uninitialization (sim_exit)
- *  Please note that all of these routines are just instructional
- *  templates and not full-fledged code. Hence they are not used
- *  anywhere else in the distribution.
- */
-#include <string.h>
-
-#include "temperature.h"
-#include "temperature_grid.h"	/* for dump_steady_temp_grid	*/
-#include "flp.h"
-#include "util.h"
-
-/* input and output files	*/
-static char *flp_file;		/* has the floorplan configuration	*/
-static char *init_file;		/* initial temperatures	from file	*/
-static char *steady_file;	/* steady state temperatures to file	*/
-
-/* floorplan	*/
-static flp_t *flp;
-/* hotspot temperature model	*/
-static RC_model_t *model;
-/* instantaneous temperature and power values	*/
-static double *temp, *power;
-/* steady state temperature and power values	*/
-static double *overall_power, *steady_temp;
-
-/* sample model initialization	*/
-void sim_init()
-{
-	/* initialize flp, get adjacency matrix */
-	flp = read_flp(flp_file, FALSE);
-
-	/* 
-	 * configure thermal model parameters. default_thermal_config 
-	 * returns a set of default parameters. only those configuration
-	 * parameters (config.*) that need to be changed are set explicitly. 
-	 */
-	thermal_config_t config = default_thermal_config();
-	strcpy(config.init_file, init_file);
-	strcpy(config.steady_file, steady_file);
-
-	/* default_thermal_config selects block model as the default.
-	 * in case grid model is needed, select it explicitly and
-	 * set the grid model parameters (grid_rows, grid_cols, 
-	 * grid_steady_file etc.) appropriately. for e.g., in the
-	 * following commented line, we just choose the grid model 
-	 * and let everything else to be the default. 
-	 * NOTE: for modeling 3-D chips, it is essential to set
-	 * the layer configuration file (grid_layer_file) parameter.
-	 */
-	/* strcpy(config->model_type, GRID_MODEL_STR); */
-
-	/* allocate and initialize the RC model	*/
-	model = alloc_RC_model(&config, flp);
-	populate_R_model(model, flp);
-	populate_C_model(model, flp);
-
-	/* allocate the temp and power arrays	*/
-	/* using hotspot_vector to internally allocate any extra nodes needed	*/
-	temp = hotspot_vector(model);
-	power = hotspot_vector(model);
-	steady_temp = hotspot_vector(model);
-	overall_power = hotspot_vector(model);
-	
-	/* set up initial instantaneous temperatures */
-	if (strcmp(model->config->init_file, NULLFILE)) {
-		if (!model->config->dtm_used)	/* initial T = steady T for no DTM	*/
-			read_temp(model, temp, model->config->init_file, FALSE);
-		else	/* initial T = clipped steady T with DTM	*/
-			read_temp(model, temp, model->config->init_file, TRUE);
-	}
-	else	/* no input file - use init_temp as the common temperature	*/
-		set_temp(model, temp, model->config->init_temp);
-}
-
-/* 
- * sample routine to illustrate the possible use of hotspot in a 
- * cycle-by-cycle power model. note that this is just a stub 
- * function and is not called anywhere in this file	
- */
-void sim_main()
-{
-	static double cur_time, prev_time;
-	static int first_call = TRUE;
-	int i, j, base, idx;
-
-	/* the main simulator loop */
-	while (1) {
-		/* set the per cycle power values as returned by Wattch/power simulator	*/
-		if (model->type == BLOCK_MODEL) {
-			power[get_blk_index(flp, "Icache")] +=  0;	/* set the power numbers instead of '0'	*/
-			power[get_blk_index(flp, "Dcache")] +=  0;	
-			power[get_blk_index(flp, "Bpred")] +=  0;	
-			/* ... more functional units ...	*/
-		
-		/* for the grid model, set the power numbers for all power dissipating layers	*/
-		} else
-			for(i=0, base=0; i < model->grid->n_layers; i++) {
-				if(model->grid->layers[i].has_power) {
-					idx = get_blk_index(model->grid->layers[i].flp, "Icache");
-					power[base+idx] += 0;	/* set the power numbers instead of '0'	*/
-					idx = get_blk_index(model->grid->layers[i].flp, "Dcache");
-					power[base+idx] += 0;
-					idx = get_blk_index(model->grid->layers[i].flp, "Bpred");
-					power[base+idx] += 0;
-					/* ... more functional units ...	*/
-
-				}	
-				base += model->grid->layers[i].flp->n_units;	
-			}
-
-		/* call compute_temp at regular intervals */
-		if ((cur_time - prev_time) >= model->config->sampling_intvl) {
-			double elapsed_time = (cur_time - prev_time);
-			prev_time = cur_time;
-
-			/* find the average power dissipated in the elapsed time */
-			if (model->type == BLOCK_MODEL) {
-				for (i = 0; i < flp->n_units; i++) {
-					/* for steady state temperature calculation	*/
-					overall_power[i] += power[i];
-					/* 
-					 * 'power' array is an aggregate of per cycle numbers over 
-					 * the sampling_intvl. so, compute the average power 
-					 */
-					power[i] /= (elapsed_time * model->config->base_proc_freq);
-				}
-			/* for the grid model, account for all the power dissipating layers	*/	
-			} else
-				for(i=0, base=0; i < model->grid->n_layers; i++) {
-					if(model->grid->layers[i].has_power)
-						for(j=0; j < model->grid->layers[i].flp->n_units; j++) {
-							/* for steady state temperature calculation	*/
-							overall_power[base+j] += power[base+j];
-							/* compute average power	*/
-							power[base+j] /= (elapsed_time * model->config->base_proc_freq);
-						}
-					base += model->grid->layers[i].flp->n_units;
-				}
-
-			/* calculate the current temp given the previous temp, time
-			 * elapsed since then, and the average power dissipated during 
-			 * that interval. for the grid model, only the first call to 
-			 * compute_temp passes a non-null 'temp' array. if 'temp' is  NULL, 
-			 * compute_temp remembers it from the last non-null call. 
-			 * this is used to maintain the internal grid temperatures 
-			 * across multiple calls of compute_temp
-			 */
-			if (model->type == BLOCK_MODEL || first_call)
-				compute_temp(model, power, temp, elapsed_time);
-			else
-				compute_temp(model, power, NULL, elapsed_time);
-			
-			/* make sure to record the first call	*/
-			first_call = FALSE;
-	
-			/* reset the power array */
-			if (model->type == BLOCK_MODEL)
-				for (i = 0; i < flp->n_units; i++)
-					power[i] = 0;
-			else
-				for(i=0, base=0; i < model->grid->n_layers; i++) {
-					if(model->grid->layers[i].has_power)
-						for(j=0; j < model->grid->layers[i].flp->n_units; j++)
-							power[base+j] = 0;
-					base += model->grid->layers[i].flp->n_units;
-				}
-		}
-	}
-}
-
-/* 
- * sample uninitialization routine to illustrate the possible use of hotspot in a 
- * cycle-by-cycle power model. note that this is just a stub 
- * function and is not called anywhere in this file	
- */
-void sim_exit()
-{
-	double total_elapsed_cycles = 0; 	/* set this to be the correct time elapsed  (in cycles) */
-	int i, j, base;
-
-	/* find the average power dissipated in the elapsed time */
-	if (model->type == BLOCK_MODEL)
-		for (i = 0; i < flp->n_units; i++)
-			overall_power[i] /= total_elapsed_cycles;
-	else		
-		for(i=0, base=0; i < model->grid->n_layers; i++) {
-			if(model->grid->layers[i].has_power)
-				for(j=0; j < model->grid->layers[i].flp->n_units; j++)
-					overall_power[base+j] /= total_elapsed_cycles;
-			base += model->grid->layers[i].flp->n_units;
-		}
-
-	/* get steady state temperatures */
-	steady_state_temp(model, overall_power, steady_temp);
-
-	/* dump temperatures if needed	*/
-	if (strcmp(model->config->steady_file, NULLFILE))
-		dump_temp(model, steady_temp, model->config->steady_file);
-
-	/* for the grid model, optionally dump the internal 
-	 * temperatures of the grid cells	
-	 */
-	if (model->type == GRID_MODEL &&
-		strcmp(model->config->grid_steady_file, NULLFILE))
-		dump_steady_temp_grid(model->grid, model->config->grid_steady_file);
-
-	/* cleanup */
-	delete_RC_model(model);
-	free_flp(flp, FALSE);
-	free_dvector(temp);
-	free_dvector(power);
-	free_dvector(steady_temp);
-	free_dvector(overall_power);
-}
diff -Naur temp/temperature_block.c HotSpot/temperature_block.c
--- temp/temperature_block.c	2017-11-20 10:04:24.517682836 +0100
+++ HotSpot/temperature_block.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,883 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#ifdef _MSC_VER
-#define strcasecmp    _stricmp
-#define strncasecmp   _strnicmp
-#else
-#include <strings.h>
-#endif
-
-#include "temperature_block.h"
-#include "flp.h"
-#include "util.h"
-
-/* 
- * allocate memory for the matrices. placeholder can be an empty 
- * floorplan frame with only the names of the functional units
- */
-block_model_t *alloc_block_model(thermal_config_t *config, flp_t *placeholder)
-{
-	/* shortcuts	*/
-	int n = placeholder->n_units;
-	int m = NL*n+EXTRA;
-
-	block_model_t *model = (block_model_t *) calloc (1, sizeof(block_model_t));
-	if (!model)
-		fatal("memory allocation error\n");
-	model->config = *config;
-	model->n_units = model->base_n_units = n;
-	model->n_nodes = m;
-
-	model->border = imatrix(n, 4);
-	model->len = dmatrix(n, n);	/* len[i][j] = length of shared edge bet. i & j	*/
-	model->g = dmatrix(m, m);	/* g[i][j] = conductance bet. nodes i & j */
-	model->gx = dvector(n);		/* lumped conductances in x direction	*/
-	model->gy = dvector(n);		/* lumped conductances in y direction	*/
-	model->gx_int = dvector(n);	/* lateral conductances in the interface layer	*/
-	model->gy_int = dvector(n);
-	model->gx_sp = dvector(n);	/* lateral conductances in the spreader	layer */
-	model->gy_sp = dvector(n);
-	model->gx_hs = dvector(n);	/* lateral conductances in the heatsink	layer */
-	model->gy_hs = dvector(n);
-	/* vertical conductances to ambient	*/
-	model->g_amb = dvector(n+EXTRA);
-	model->t_vector = dvector(m);/* scratch pad	*/
-	model->p = ivector(m);		/* permutation vector for b's LUP decomposition	*/
-
-	model->a = dvector(m);		/* vertical Cs - diagonal matrix stored as a 1-d vector	*/
-	model->inva = dvector(m);	/* inverse of the above 	*/
-	/* B, C and LU are (NL*n+EXTRA)x(NL*n+EXTRA) matrices	*/
-	model->b = dmatrix(m, m);
-	model->c = dmatrix(m, m);
-	model->lu = dmatrix(m, m);
-
-	model->flp = placeholder;
-	return model;
-}
-
-/* creates matrices  B and invB: BT = Power in the steady state. 
- * NOTE: EXTRA nodes: 4 heat spreader peripheral nodes, 4 heat 
- * sink inner peripheral nodes, 4 heat sink outer peripheral 
- * nodes(north, south, east and west) and 1 ambient node.
- */
-void populate_R_model_block(block_model_t *model, flp_t *flp)
-{
-	/*	shortcuts	*/
-	double **b = model->b;
-	double *gx = model->gx, *gy = model->gy;
-	double *gx_int = model->gx_int, *gy_int = model->gy_int;
-	double *gx_sp = model->gx_sp, *gy_sp = model->gy_sp;
-	double *gx_hs = model->gx_hs, *gy_hs = model->gy_hs;
-	double *g_amb = model->g_amb;
-	double **len = model->len, **g = model->g, **lu = model->lu;
-	int **border = model->border;
-	int *p = model->p;
-	double t_chip = model->config.t_chip;
-	double r_convec = model->config.r_convec;
-	double s_sink = model->config.s_sink;
-	double t_sink = model->config.t_sink;
-	double s_spreader = model->config.s_spreader;
-	double t_spreader = model->config.t_spreader;
-	double t_interface = model->config.t_interface;
-	double k_chip = model->config.k_chip;
-	double k_sink = model->config.k_sink;
-	double k_spreader = model->config.k_spreader;
-	double k_interface = model->config.k_interface;
-	
-	int i, j, n = flp->n_units;
-	double gn_sp=0, gs_sp=0, ge_sp=0, gw_sp=0;
-	double gn_hs=0, gs_hs=0, ge_hs=0, gw_hs=0;
-	double r_amb;
-
-	double w_chip = get_total_width (flp);	/* x-axis	*/
-	double l_chip = get_total_height (flp);	/* y-axis	*/
-	
-	/* sanity check on floorplan sizes	*/
-	if (w_chip > s_sink || l_chip > s_sink || 
-		w_chip > s_spreader || l_chip > s_spreader) {
-		print_flp(flp);
-		print_flp_fig(flp);
-		fatal("inordinate floorplan size!\n");
-	}
-	if(model->flp != flp || model->n_units != flp->n_units ||
-	   model->n_nodes != NL * flp->n_units + EXTRA)
-	   fatal("mismatch between the floorplan and the thermal model\n");
-
-	/* gx's and gy's of blocks	*/
-	for (i = 0; i < n; i++) {
-		/* at the silicon layer	*/
-		if (model->config.block_omit_lateral) {
-			gx[i] = gy[i] = 0;
-		}
-		else {
-			gx[i] = 1.0/getr(k_chip, flp->units[i].width / 2.0, flp->units[i].height * t_chip);
-			gy[i] = 1.0/getr(k_chip, flp->units[i].height / 2.0, flp->units[i].width * t_chip);
-		}
-
-		/* at the interface layer	*/
-		gx_int[i] = 1.0/getr(k_interface, flp->units[i].width / 2.0, flp->units[i].height * t_interface);
-		gy_int[i] = 1.0/getr(k_interface, flp->units[i].height / 2.0, flp->units[i].width * t_interface);
-
-		/* at the spreader layer	*/
-		gx_sp[i] = 1.0/getr(k_spreader, flp->units[i].width / 2.0, flp->units[i].height * t_spreader);
-		gy_sp[i] = 1.0/getr(k_spreader, flp->units[i].height / 2.0, flp->units[i].width * t_spreader);
-
-		/* at the heatsink layer	*/
-		gx_hs[i] = 1.0/getr(k_sink, flp->units[i].width / 2.0, flp->units[i].height * t_sink);
-		gy_hs[i] = 1.0/getr(k_sink, flp->units[i].height / 2.0, flp->units[i].width * t_sink);
-	}
-
-	/* shared lengths between blocks	*/
-	for (i = 0; i < n; i++) 
-		for (j = i; j < n; j++) 
-			len[i][j] = len[j][i] = get_shared_len(flp, i, j);
-
-	/* package R's	*/
-	populate_package_R(&model->pack, &model->config, w_chip, l_chip);
-
-	/* short the R's from block centers to a particular chip edge	*/
-	for (i = 0; i < n; i++) {
-		if (eq(flp->units[i].bottomy + flp->units[i].height, l_chip)) {
-			gn_sp += gy_sp[i];
-			gn_hs += gy_hs[i];
-			border[i][2] = 1;	/* block is on northern border 	*/
-		} else
-			border[i][2] = 0;
-
-		if (eq(flp->units[i].bottomy, 0)) {
-			gs_sp += gy_sp[i];
-			gs_hs += gy_hs[i];
-			border[i][3] = 1;	/* block is on southern border	*/
-		} else
-			border[i][3] = 0;
-
-		if (eq(flp->units[i].leftx + flp->units[i].width, w_chip)) {
-			ge_sp += gx_sp[i];
-			ge_hs += gx_hs[i];
-			border[i][1] = 1;	/* block is on eastern border	*/
-		} else 
-			border[i][1] = 0;
-
-		if (eq(flp->units[i].leftx, 0)) {
-			gw_sp += gx_sp[i];
-			gw_hs += gx_hs[i];
-			border[i][0] = 1;	/* block is on western border	*/
-		} else
-			border[i][0] = 0;
-	}
-
-	/* initialize g	*/
-	zero_dmatrix(g, NL*n+EXTRA, NL*n+EXTRA);
-	zero_dvector(g_amb, n+EXTRA);
-
-	/* overall Rs between nodes */
-	for (i = 0; i < n; i++) {
-		double area = (flp->units[i].height * flp->units[i].width);
-		/* amongst functional units	in the various layers	*/
-		for (j = 0; j < n; j++) {
-			double part = 0, part_int = 0, part_sp = 0, part_hs = 0;
-			if (is_horiz_adj(flp, i, j)) {
-				part = gx[i] / flp->units[i].height;
-				part_int = gx_int[i] / flp->units[i].height;
-				part_sp = gx_sp[i] / flp->units[i].height;
-				part_hs = gx_hs[i] / flp->units[i].height;
-			}
-			else if (is_vert_adj(flp, i,j))  {
-				part = gy[i] / flp->units[i].width;
-				part_int = gy_int[i] / flp->units[i].width;
-				part_sp = gy_sp[i] / flp->units[i].width;
-				part_hs = gy_hs[i] / flp->units[i].width;
-			}
-			g[i][j] = part * len[i][j];
-			g[IFACE*n+i][IFACE*n+j] = part_int * len[i][j];
-			g[HSP*n+i][HSP*n+j] = part_sp * len[i][j];
-			g[HSINK*n+i][HSINK*n+j] = part_hs * len[i][j];
-		}
-		/* the 2.0 factor in the following equations is 
-		 * explained during the calculation of the B matrix
-		 */
- 		/* vertical g's in the silicon layer	*/
-		g[i][IFACE*n+i]=g[IFACE*n+i][i]=2.0/getr(k_chip, t_chip, area);
- 		/* vertical g's in the interface layer	*/
-		g[IFACE*n+i][HSP*n+i]=g[HSP*n+i][IFACE*n+i]=2.0/getr(k_interface, t_interface, area);
-		/* vertical g's in the spreader layer	*/
-		g[HSP*n+i][HSINK*n+i]=g[HSINK*n+i][HSP*n+i]=2.0/getr(k_spreader, t_spreader, area);
-		/* vertical g's in the heatsink core layer	*/
-		/* vertical R to ambient: divide r_convec proportional to area	*/
-		r_amb = r_convec * (s_sink * s_sink) / area;
-		g_amb[i] = 1.0 / (getr(k_sink, t_sink, area) + r_amb);
-
-		/* lateral g's from block center (spreader layer) to peripheral (n,s,e,w) spreader nodes	*/
-		g[HSP*n+i][NL*n+SP_N]=g[NL*n+SP_N][HSP*n+i]=2.0*border[i][2] /
-							  ((1.0/gy_sp[i])+model->pack.r_sp1_y*gn_sp/gy_sp[i]);
-		g[HSP*n+i][NL*n+SP_S]=g[NL*n+SP_S][HSP*n+i]=2.0*border[i][3] /
-							  ((1.0/gy_sp[i])+model->pack.r_sp1_y*gs_sp/gy_sp[i]);
-		g[HSP*n+i][NL*n+SP_E]=g[NL*n+SP_E][HSP*n+i]=2.0*border[i][1] /
-							  ((1.0/gx_sp[i])+model->pack.r_sp1_x*ge_sp/gx_sp[i]);
-		g[HSP*n+i][NL*n+SP_W]=g[NL*n+SP_W][HSP*n+i]=2.0*border[i][0] /
-							  ((1.0/gx_sp[i])+model->pack.r_sp1_x*gw_sp/gx_sp[i]);
-		
-		/* lateral g's from block center (heatsink layer) to peripheral (n,s,e,w) heatsink nodes	*/
-		g[HSINK*n+i][NL*n+SINK_C_N]=g[NL*n+SINK_C_N][HSINK*n+i]=2.0*border[i][2] /
-									((1.0/gy_hs[i])+model->pack.r_hs1_y*gn_hs/gy_hs[i]);
-		g[HSINK*n+i][NL*n+SINK_C_S]=g[NL*n+SINK_C_S][HSINK*n+i]=2.0*border[i][3] /
-									((1.0/gy_hs[i])+model->pack.r_hs1_y*gs_hs/gy_hs[i]);
-		g[HSINK*n+i][NL*n+SINK_C_E]=g[NL*n+SINK_C_E][HSINK*n+i]=2.0*border[i][1] /
-									((1.0/gx_hs[i])+model->pack.r_hs1_x*ge_hs/gx_hs[i]);
-		g[HSINK*n+i][NL*n+SINK_C_W]=g[NL*n+SINK_C_W][HSINK*n+i]=2.0*border[i][0] /
-									((1.0/gx_hs[i])+model->pack.r_hs1_x*gw_hs/gx_hs[i]);
-	}
-
-	/* g's from peripheral(n,s,e,w) nodes	*/
-	/* vertical g's between peripheral spreader nodes and center peripheral heatsink nodes */
-	g[NL*n+SP_N][NL*n+SINK_C_N]=g[NL*n+SINK_C_N][NL*n+SP_N]=2.0/model->pack.r_sp_per_y;
-	g[NL*n+SP_S][NL*n+SINK_C_S]=g[NL*n+SINK_C_S][NL*n+SP_S]=2.0/model->pack.r_sp_per_y;
-	g[NL*n+SP_E][NL*n+SINK_C_E]=g[NL*n+SINK_C_E][NL*n+SP_E]=2.0/model->pack.r_sp_per_x;
-	g[NL*n+SP_W][NL*n+SINK_C_W]=g[NL*n+SINK_C_W][NL*n+SP_W]=2.0/model->pack.r_sp_per_x;
-	/* lateral g's between peripheral outer sink nodes and center peripheral sink nodes	*/
-	g[NL*n+SINK_C_N][NL*n+SINK_N]=g[NL*n+SINK_N][NL*n+SINK_C_N]=2.0/(model->pack.r_hs + model->pack.r_hs2_y);
-	g[NL*n+SINK_C_S][NL*n+SINK_S]=g[NL*n+SINK_S][NL*n+SINK_C_S]=2.0/(model->pack.r_hs + model->pack.r_hs2_y);
-	g[NL*n+SINK_C_E][NL*n+SINK_E]=g[NL*n+SINK_E][NL*n+SINK_C_E]=2.0/(model->pack.r_hs + model->pack.r_hs2_x);
-	g[NL*n+SINK_C_W][NL*n+SINK_W]=g[NL*n+SINK_W][NL*n+SINK_C_W]=2.0/(model->pack.r_hs + model->pack.r_hs2_x);
-	/* vertical g's between inner peripheral sink nodes and ambient	*/
-	g_amb[n+SINK_C_N] = g_amb[n+SINK_C_S] = 1.0 / (model->pack.r_hs_c_per_y+model->pack.r_amb_c_per_y);
-	g_amb[n+SINK_C_E] = g_amb[n+SINK_C_W] = 1.0 / (model->pack.r_hs_c_per_x+model->pack.r_amb_c_per_x);
-	/* vertical g's between outer peripheral sink nodes and ambient	*/
-	g_amb[n+SINK_N] = g_amb[n+SINK_S] = g_amb[n+SINK_E] =
-					  g_amb[n+SINK_W] = 1.0 / (model->pack.r_hs_per+model->pack.r_amb_per);
-
-	/* calculate matrix B such that BT = POWER in steady state */
-	/* non-diagonal elements	*/
-	for (i = 0; i < NL*n+EXTRA; i++)
-		for (j = 0; j < i; j++)
-			if ((g[i][j] == 0.0) || (g[j][i] == 0.0))
-				b[i][j] = b[j][i] = 0.0;
-			else
-				/* here is why the 2.0 factor comes when calculating g[][]	*/
-				b[i][j] = b[j][i] = -1.0/((1.0/g[i][j])+(1.0/g[j][i]));
-	/* diagonal elements	*/			
-	for (i = 0; i < NL*n+EXTRA; i++) {
-		/* functional blocks in the heat sink layer	*/
-		if (i >= HSINK*n && i < NL*n) 
-			b[i][i] = g_amb[i%n];
-		/* heat sink peripheral nodes	*/
-		else if (i >= NL*n+SINK_C_W)
-			b[i][i] = g_amb[n+i-NL*n];
-		/* all other nodes that are not connected to the ambient	*/	
-		else
-			b[i][i] = 0.0;
-		/* sum up the conductances	*/	
-		for(j=0; j < NL*n+EXTRA; j++)
-			if (i != j)
-				b[i][i] -= b[i][j];
-	}
-
-	/* compute the LUP decomposition of B and store it too	*/
-	copy_dmatrix(lu, b, NL*n+EXTRA, NL*n+EXTRA);
-	/* 
-	 * B is a symmetric positive definite matrix. It is
-	 * symmetric because if a node A is connected to B, 
-	 * then B is also connected to A with the same R value.
-	 * It is positive definite because of the following
-	 * informal argument from Professor Lieven Vandenberghe's
-	 * lecture slides for the spring 2004-2005 EE 103 class 
-	 * at UCLA: http://www.ee.ucla.edu/~vandenbe/103/chol.pdf
-	 * x^T*B*x = voltage^T * (B*x) = voltage^T * current
-	 * = total power dissipated in the resistors > 0 
-	 * for x != 0. 
-	 */
-	lupdcmp(lu, NL*n+EXTRA, p, 1);
-
-	/* done	*/
-	model->flp = flp;
-	model->r_ready = TRUE;
-}
-
-/* creates 2 matrices: invA, C: dT + A^-1*BT = A^-1*Power, 
- * C = A^-1 * B. note that A is a diagonal matrix (no lateral
- * capacitances. all capacitances are to ground). also note that
- * it is stored as a 1-d vector. so, for computing the inverse, 
- * inva[i] = 1/a[i] is just enough. 
- */
-void populate_C_model_block(block_model_t *model, flp_t *flp)
-{
-	/*	shortcuts	*/
-	double *inva = model->inva, **c = model->c;
-	double **b = model->b;
-	double *a = model->a;
-	double t_chip = model->config.t_chip;
-	double c_convec = model->config.c_convec;
-	double s_sink = model->config.s_sink;
-	double t_sink = model->config.t_sink;
-	double t_spreader = model->config.t_spreader;
-	double t_interface = model->config.t_interface;
-	double p_chip = model->config.p_chip;
-	double p_sink = model->config.p_sink;
-	double p_spreader = model->config.p_spreader;
-	double p_interface = model->config.p_interface;
-	double c_amb;
-	double w_chip, l_chip;
-
-	int i, n = flp->n_units;
-
-	if (!model->r_ready)
-		fatal("R model not ready\n");
-	if (model->flp != flp || model->n_units != flp->n_units ||
-		model->n_nodes != NL * flp->n_units + EXTRA)
-		fatal("different floorplans for R and C models!\n");
-		
-	w_chip = get_total_width (flp);	/* x-axis	*/
-	l_chip = get_total_height (flp);	/* y-axis	*/
-
-	/* package C's	*/
-	populate_package_C(&model->pack, &model->config, w_chip, l_chip);
-	
-	/* functional block C's */
-	for (i = 0; i < n; i++) {
-		double area = (flp->units[i].height * flp->units[i].width);
-		/* C's from functional units to ground	*/
-		a[i] = getcap(p_chip, t_chip, area);
-		/* C's from interface portion of the functional units to ground	*/
-		a[IFACE*n+i] = getcap(p_interface, t_interface, area);
-		/* C's from spreader portion of the functional units to ground	*/
-		a[HSP*n+i] = getcap(p_spreader, t_spreader, area);
-		/* C's from heatsink portion of the functional units to ground	*/
-		/* vertical C to ambient: divide c_convec proportional to area	*/
-		c_amb = C_FACTOR * c_convec / (s_sink * s_sink) * area;
-		a[HSINK*n+i] = getcap(p_sink, t_sink, area) + c_amb;
-	}
-
-	/* C's from peripheral(n,s,e,w) nodes	*/
- 	/* from peripheral spreader nodes to ground	*/
-	a[NL*n+SP_N] = a[NL*n+SP_S] = model->pack.c_sp_per_y;
-	a[NL*n+SP_E] = a[NL*n+SP_W] = model->pack.c_sp_per_x;
- 	/* from center peripheral sink nodes to ground
-	 * NOTE: this treatment of capacitances (and 
-	 * the corresponding treatment of resistances 
-	 * in populate_R_model) as parallel (series)
-	 * is only approximate and is done in order
-	 * to avoid creating an extra layer of nodes
-	 */
-	a[NL*n+SINK_C_N] = a[NL*n+SINK_C_S] = model->pack.c_hs_c_per_y + 
-										  model->pack.c_amb_c_per_y;
-	a[NL*n+SINK_C_E] = a[NL*n+SINK_C_W] = model->pack.c_hs_c_per_x + 
-										  model->pack.c_amb_c_per_x; 
-	/* from outer peripheral sink nodes to ground	*/
-	a[NL*n+SINK_N] = a[NL*n+SINK_S] = a[NL*n+SINK_E] = a[NL*n+SINK_W] = 
-					 model->pack.c_hs_per + model->pack.c_amb_per;
-	
-	/* calculate A^-1 (for diagonal matrix A) such that A(dT) + BT = POWER */
-	for (i = 0; i < NL*n+EXTRA; i++)
-		inva[i] = 1.0/a[i];
-
-	/* we are always going to use the eqn dT + A^-1 * B T = A^-1 * POWER. so, store  C = A^-1 * B	*/
-	diagmatmult(c, inva, b, NL*n+EXTRA);
-
-	/*	done	*/
-	model->c_ready = TRUE;
-}
-
-/* setting package nodes' power numbers	*/
-void set_internal_power_block(block_model_t *model, double *power)
-{
-	int i;
-	zero_dvector(&power[IFACE*model->n_units], model->n_units);
-	zero_dvector(&power[HSP*model->n_units], model->n_units);
-	for(i=0; i < model->n_units + EXTRA; i++)
-		power[HSINK*model->n_units+i] = model->config.ambient * model->g_amb[i];
-}
-
-/* power and temp should both be alloced using hotspot_vector. 
- * 'b' is the 'thermal conductance' matrix. i.e, b * temp = power
- *  => temp = invb * power. instead of computing invb, we have
- * stored the LUP decomposition of B in 'lu' and 'p'. Using
- * forward and backward substitution, we can then solve the 
- * equation b * temp = power.
- */
-void steady_state_temp_block(block_model_t *model, double *power, double *temp) 
-{
-	if (!model->r_ready)
-		fatal("R model not ready\n");
-
-	/* set power numbers for the virtual nodes */
-	set_internal_power_block(model, power);
-
-	/* 
-	 * find temperatures (spd flag is set to 1 by the same argument
-	 * as mentioned in the populate_R_model_block function)
-	 */
-	lusolve(model->lu, model->n_nodes, model->p, power, temp, 1);
-}
-
-/* compute the slope vector dy for the transient equation 
- * dy + cy = p. useful in the transient solver
- */
-void slope_fn_block(block_model_t *model, double *y, double *p, double *dy)
-{
-	/* shortcuts	*/
-	int n = model->n_nodes;
-	double **c = model->c;
-
-	/* for our equation, dy = p - cy */
-	#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
-	/* dy = p	*/
-	cblas_dcopy(n, p, 1, dy, 1);
-	/* dy = dy - c*y = p - c*y */
-	cblas_dgemv(CblasRowMajor, CblasNoTrans, n, n, -1, c[0],
-				n, y, 1, 1, dy, 1);
-	#elif (MATHACCEL == MA_AMD || MATHACCEL == MA_SUN)
-	/* dy = p	*/
-	dcopy(n, p, 1, dy, 1);
-	/* dy = dy - c*y = p - c*y */
-	dgemv('T', n, n, -1, c[0], n, y, 1, 1, dy, 1);
-	#else
-	int i;
-	double *t = dvector(n);
-	matvectmult(t, c, y, n);
-	for (i = 0; i < n; i++)
-		dy[i] = p[i]-t[i];
-	free_dvector(t);
-	#endif
-}
-
-/* compute_temp: solve for temperature from the equation dT + CT = inv_A * Power 
- * Given the temperature (temp) at time t, the power dissipation per cycle during the 
- * last interval (time_elapsed), find the new temperature at time t+time_elapsed.
- * power and temp should both be alloced using hotspot_vector
- */
-void compute_temp_block(block_model_t *model, double *power, double *temp, double time_elapsed)
-{
-	double t, h, new_h;
-
-	#if VERBOSE > 1
-	unsigned int i = 0;
-	#endif
-
-	if (!model->r_ready || !model->c_ready)
-		fatal("block model not ready\n");
-	if (temp == model->t_vector)
-		fatal("output same as scratch pad\n");
-
-	/* set power numbers for the virtual nodes */
-	set_internal_power_block(model, power);
-
-	/* use the scratch pad vector to find (inv_A)*POWER */
-	diagmatvectmult(model->t_vector, model->inva, power, model->n_nodes);
-
-	/* Obtain temp at time (t+time_elapsed). 
-	 * Instead of getting the temperature at t+time_elapsed directly, we do it 
-	 * in multiple steps with the correct step size at each time 
-	 * provided by rk4
-	 */
-	for (t = 0, new_h = MIN_STEP; t < time_elapsed && new_h >= MIN_STEP*DELTA; t+=h) {
-		h = new_h;
-		new_h = rk4(model, temp, model->t_vector, model->n_nodes, &h, 
-		/* the slope function callback is typecast accordingly */
-					temp, (slope_fn_ptr) slope_fn_block);
-		new_h = MIN(new_h, time_elapsed-t-h);
-		#if VERBOSE > 1
-		i++;
-		#endif
-	}
-	#if VERBOSE > 1
-	fprintf(stdout, "no. of rk4 calls during compute_temp: %d\n", i+1);
-	#endif
-}
-
-/* differs from 'dvector()' in that memory for internal nodes is also allocated	*/
-double *hotspot_vector_block(block_model_t *model)
-{
-	return dvector(model->n_nodes);
-}
-
-/* copy 'src' to 'dst' except for a window of 'size'
- * elements starting at 'at'. useful in floorplan
- * compaction
- */
-void trim_hotspot_vector_block(block_model_t *model, double *dst, double *src, 
-						 	   int at, int size)
-{
-	int i;
-
-	for (i=0; i < at && i < model->n_nodes; i++)
-		dst[i] = src[i];
-	for(i=at+size; i < model->n_nodes; i++)
-		dst[i-size] = src[i];
-}
-
-/* update the model's node count	*/						 
-void resize_thermal_model_block(block_model_t *model, int n_units)
-{
-	if (n_units > model->base_n_units)
-		fatal("resizing block model to more than the allocated space\n");
-	model->n_units = n_units;
-	model->n_nodes = NL * n_units + EXTRA;
-	/* resize the 2-d matrices whose no. of columns changes	*/
-	resize_dmatrix(model->len, model->n_units, model->n_units);
-	resize_dmatrix(model->g, model->n_nodes, model->n_nodes);
-	resize_dmatrix(model->b, model->n_nodes, model->n_nodes);
-	resize_dmatrix(model->c, model->n_nodes, model->n_nodes);
-	resize_dmatrix(model->lu, model->n_nodes, model->n_nodes);
-}
-
-/* sets the temperature of a vector 'temp' allocated using 'hotspot_vector'	*/
-void set_temp_block(block_model_t *model, double *temp, double val)
-{
-	int i;
-	for(i=0; i < model->n_nodes; i++)
-		temp[i] = val;
-}
-
-/* dump temperature vector alloced using 'hotspot_vector' to 'file' */ 
-void dump_temp_block(block_model_t *model, double *temp, char *file)
-{
-	flp_t *flp = model->flp;
-	int i;
-	char str[STR_SIZE];
-	FILE *fp;
-
-	if (!strcasecmp(file, "stdout"))
-		fp = stdout;
-	else if (!strcasecmp(file, "stderr"))
-		fp = stderr;
-	else 	
-		fp = fopen (file, "w");
-
-	if (!fp) {
-		sprintf (str,"error: %s could not be opened for writing\n", file);
-		fatal(str);
-	}
-	/* on chip temperatures	*/
-	for (i=0; i < flp->n_units; i++)
-		fprintf(fp, "%s\t%.2f\n", flp->units[i].name, temp[i]);
-
-	/* interface temperatures	*/
-	for (i=0; i < flp->n_units; i++)
-		fprintf(fp, "iface_%s\t%.2f\n", flp->units[i].name, temp[IFACE*flp->n_units+i]);
-
-	/* spreader temperatures	*/
-	for (i=0; i < flp->n_units; i++)
-		fprintf(fp, "hsp_%s\t%.2f\n", flp->units[i].name, temp[HSP*flp->n_units+i]);
-
-	/* heatsink temperatures	*/
-	for (i=0; i < flp->n_units; i++)
-		fprintf(fp, "hsink_%s\t%.2f\n", flp->units[i].name, temp[HSINK*flp->n_units+i]);
-
-	/* internal node temperatures	*/
-	for (i=0; i < EXTRA; i++) {
-		sprintf(str, "inode_%d", i);
-		fprintf(fp, "%s\t%.2f\n", str, temp[i+NL*flp->n_units]);
-	}
-
-	if(fp != stdout && fp != stderr)
-		fclose(fp);	
-}
-
-void copy_temp_block(block_model_t *model, double *dst, double *src)
-{
-	copy_dvector(dst, src, NL*model->flp->n_units+EXTRA);
-}
-
-/* 
- * read temperature vector alloced using 'hotspot_vector' from 'file'
- * which was dumped using 'dump_temp'. values are clipped to thermal
- * threshold based on 'clip'
- */ 
-void read_temp_block(block_model_t *model, double *temp, char *file, int clip)
-{
-	/*	shortcuts	*/
-	flp_t *flp = model->flp;
-	double thermal_threshold = model->config.thermal_threshold;
-	double ambient = model->config.ambient;
-
-	int i, n, idx;
-	double max=0, val;
-	char *ptr, str1[LINE_SIZE], str2[LINE_SIZE];
-	char name[STR_SIZE], format[STR_SIZE];
-	FILE *fp;
-
-	if (!strcasecmp(file, "stdin"))
-		fp = stdin;
-	else
-		fp = fopen (file, "r");
-
-	if (!fp) {
-		sprintf (str1,"error: %s could not be opened for reading\n", file);
-		fatal(str1);
-	}	
-
-	/* temperatures of the different layers	*/
-	for (n=0; n < NL; n++) {
-		switch(n)
-		{
-			case 0:
-					strcpy(format,"%s%lf");
-					break;
-			case IFACE:
-					strcpy(format,"iface_%s%lf");
-					break;
-			case HSP:
-					strcpy(format,"hsp_%s%lf");
-					break;
-			case HSINK:
-					strcpy(format,"hsink_%s%lf");
-					break;
-			default:
-					fatal("unknown layer\n");
-					break;
-		}
-		for (i=0; i < flp->n_units; i++) {
-			fgets(str1, LINE_SIZE, fp);
-			if (feof(fp))
-				fatal("not enough lines in temperature file\n");
-			strcpy(str2, str1);
-
-			/* ignore comments and empty lines	*/
-			ptr = strtok(str1, " \r\t\n");
-			if (!ptr || ptr[0] == '#') {
-				i--;
-				continue;
-			}
-
-			if (sscanf(str2, format, name, &val) != 2)
-				fatal("invalid temperature file format\n");
-			idx = get_blk_index(flp, name);
-			if (idx >= 0)
-				temp[idx + n*flp->n_units] = val;
-			else	/* since get_blk_index calls fatal, the line below cannot be reached	*/
-				fatal ("unit in temperature file not found in floorplan\n");
-
-			/* find max temp on the chip	*/
-			if (n == 0 && temp[idx] > max)
-				max = temp[idx];
-		}
-	}
-
-	/* internal node temperatures	*/	
-	for (i=0; i < EXTRA; i++) {
-		fgets(str1, LINE_SIZE, fp);
-		if (feof(fp))
-			fatal("not enough lines in temperature file\n");
-		strcpy(str2, str1);
-		/* ignore comments and empty lines	*/
-		ptr = strtok(str1, " \r\t\n");
-		if (!ptr || ptr[0] == '#') {
-			i--;
-			continue;
-		}
-		if (sscanf(str2, "%s%lf", name, &val) != 2)
-			fatal("invalid temperature file format\n");
-		sprintf(str1, "inode_%d", i);
-		if (strcasecmp(str1, name))
-			fatal("invalid temperature file format\n");
-		temp[i+NL*flp->n_units] = val;	
-	}
-
-	fgets(str1, LINE_SIZE, fp);
-	if (!feof(fp))
-		fatal("too many lines in temperature file\n");
-
-	if(fp != stdin)
-		fclose(fp);	
-
-	/* clipping	*/
-	if (clip && (max > thermal_threshold)) {
-		/* if max has to be brought down to thermal_threshold, 
-		 * (w.r.t the ambient) what is the scale down factor?
-		 */
-		double factor = (thermal_threshold - ambient) / (max - ambient);
-	
-		/* scale down all temperature differences (from ambient) by the same factor	*/
-		for (i=0; i < NL*flp->n_units + EXTRA; i++)
-			temp[i] = (temp[i]-ambient)*factor + ambient;
-	}
-}
-
-/* dump power numbers to file	*/
-void dump_power_block(block_model_t *model, double *power, char *file)
-{
-	flp_t *flp = model->flp;
-	int i;
-	char str[STR_SIZE];
-	FILE *fp;
-
-	if (!strcasecmp(file, "stdout"))
-		fp = stdout;
-	else if (!strcasecmp(file, "stderr"))
-		fp = stderr;
-	else 	
-		fp = fopen (file, "w");
-
-	if (!fp) {
-		sprintf (str,"error: %s could not be opened for writing\n", file);
-		fatal(str);
-	}
-	for (i=0; i < flp->n_units; i++)
-		fprintf(fp, "%s\t%.6f\n", flp->units[i].name, power[i]);
-	if(fp != stdout && fp != stderr)
-		fclose(fp);	
-}
-
-/* 
- * read power vector alloced using 'hotspot_vector' from 'file'
- * which was dumped using 'dump_power'. 
- */ 
-void read_power_block (block_model_t *model, double *power, char *file)
-{
-	flp_t *flp = model->flp;
-	int idx;
-	double val;
-	char *ptr, str1[LINE_SIZE], str2[LINE_SIZE], name[STR_SIZE];
-	FILE *fp;
-
-	if (!strcasecmp(file, "stdin"))
-		fp = stdin;
-	else
-		fp = fopen (file, "r");
-
-	if (!fp) {
-		sprintf (str1,"error: %s could not be opened for reading\n", file);
-		fatal(str1);
-	}
-	while(!feof(fp)) {
-		fgets(str1, LINE_SIZE, fp);
-		if (feof(fp))
-			break;
-		strcpy(str2, str1);
-
-		/* ignore comments and empty lines	*/
-		ptr = strtok(str1, " \r\t\n");
-		if (!ptr || ptr[0] == '#')
-			continue;
-
-		if (sscanf(str2, "%s%lf", name, &val) != 2)
-			fatal("invalid power file format\n");
-		idx = get_blk_index(flp, name);
-		if (idx >= 0)
-			power[idx] = val;
-		else	/* since get_blk_index calls fatal, the line below cannot be reached	*/
-			fatal ("unit in power file not found in floorplan\n");
-	}
-	if(fp != stdin)
-		fclose(fp);
-}
-
-double find_max_temp_block(block_model_t *model, double *temp)
-{
-	int i;
-	double max = 0.0;
-	for(i=0; i < model->n_units; i++) {
-		if (temp[i] < 0)
-			fatal("negative temperature!\n");
-		else if (max < temp[i])
-			max = temp[i];
-	}
-
-	return max;
-}
-
-double find_avg_temp_block(block_model_t *model, double *temp)
-{
-	int i;
-	double sum = 0.0;
-	for(i=0; i < model->n_units; i++) {
-		if (temp[i] < 0)
-			fatal("negative temperature!\n");
-		else 
-			sum += temp[i];
-	}
-
-	return (sum / model->n_units);
-}
-
-/* calculate avg sink temp for natural convection package model */
-double calc_sink_temp_block(block_model_t *model, double *temp, thermal_config_t *config)
-{
-	flp_t *flp = model->flp;
-	int i;
-	double sum = 0.0;
-	double width = get_total_width(flp);
-	double height = get_total_height(flp);
-	double spr_size = config->s_spreader*config->s_spreader;
-	double sink_size = config->s_sink*config->s_sink;
-	
-	/* heatsink temperatures	*/
-	for (i=0; i < flp->n_units; i++)
-		if (temp[HSINK*flp->n_units+i] < 0)
-			fatal("negative temperature!\n");
-		else  /* area-weighted average */
-			sum += temp[HSINK*flp->n_units+i]*(flp->units[i].width*flp->units[i].height);
-			
-	for(i=SINK_C_W; i <= SINK_C_E; i++)
-		if (temp[i+NL*flp->n_units] < 0)
-			fatal("negative temperature!\n");
-		else
-			sum += temp[i+NL*flp->n_units]*0.25*(config->s_spreader+height)*(config->s_spreader-width);
-
-	for(i=SINK_C_N; i <= SINK_C_S; i++)
-		if (temp[i+NL*flp->n_units] < 0)
-			fatal("negative temperature!\n");
-		else
-			sum += temp[i+NL*flp->n_units]*0.25*(config->s_spreader+width)*(config->s_spreader-height);
-
-	for(i=SINK_W; i <= SINK_S; i++)
-		if (temp[i+NL*flp->n_units] < 0)
-			fatal("negative temperature!\n");
-		else
-			sum += temp[i+NL*flp->n_units]*0.25*(sink_size-spr_size);
-	
-	return (sum / sink_size);
-}
-
-void delete_block_model(block_model_t *model)
-{
-	free_dvector(model->a);
-	free_dvector(model->inva);
-	free_dmatrix(model->b);
-	free_dmatrix(model->c);
-
-	free_dvector(model->gx);
-	free_dvector(model->gy);
-	free_dvector(model->gx_int);
-	free_dvector(model->gy_int);
-	free_dvector(model->gx_sp);
-	free_dvector(model->gy_sp);
-	free_dvector(model->gx_hs);
-	free_dvector(model->gy_hs);
-	free_dvector(model->g_amb);
-	free_dvector(model->t_vector);
-	free_ivector(model->p);
-
-	free_dmatrix(model->len);
-	free_dmatrix(model->g);
-	free_dmatrix(model->lu);
-
-	free_imatrix(model->border);
-
-	free(model);
-}
-
-void debug_print_block(block_model_t *model)
-{
-	fprintf(stdout, "printing block model information...\n");
-	fprintf(stdout, "n_nodes: %d\n", model->n_nodes);
-	fprintf(stdout, "n_units: %d\n", model->n_units);
-	fprintf(stdout, "base_n_units: %d\n", model->base_n_units);
-	fprintf(stdout, "r_ready: %d\n", model->r_ready);
-	fprintf(stdout, "c_ready: %d\n", model->c_ready);
-
-	debug_print_package_RC(&model->pack);
-
-	fprintf(stdout, "printing matrix b:\n");
-	dump_dmatrix(model->b, model->n_nodes, model->n_nodes);
-	fprintf(stdout, "printing vector a:\n");
-	dump_dvector(model->a, model->n_nodes);
-	fprintf(stdout, "printing vector inva:\n");
-	dump_dvector(model->inva, model->n_nodes);
-	fprintf(stdout, "printing matrix c:\n");
-	dump_dmatrix(model->c, model->n_nodes, model->n_nodes);
-	fprintf(stdout, "printing vector g_amb:\n");
-	dump_dvector(model->g_amb, model->n_units+EXTRA);
-}
-
diff -Naur temp/temperature_block.cc HotSpot/temperature_block.cc
--- temp/temperature_block.cc	1970-01-01 01:00:00.000000000 +0100
+++ HotSpot/temperature_block.cc	2017-11-20 09:59:35.316820635 +0100
@@ -0,0 +1,883 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#ifdef _MSC_VER
+#define strcasecmp    _stricmp
+#define strncasecmp   _strnicmp
+#else
+#include <strings.h>
+#endif
+
+#include "temperature_block.h"
+#include "flp.h"
+#include "util.h"
+
+/* 
+ * allocate memory for the matrices. placeholder can be an empty 
+ * floorplan frame with only the names of the functional units
+ */
+block_model_t *alloc_block_model(thermal_config_t *config, flp_t *placeholder)
+{
+	/* shortcuts	*/
+	int n = placeholder->n_units;
+	int m = NL*n+EXTRA;
+
+	block_model_t *model = (block_model_t *) calloc (1, sizeof(block_model_t));
+	if (!model)
+		fatal((char*)"memory allocation error\n");
+	model->config = *config;
+	model->n_units = model->base_n_units = n;
+	model->n_nodes = m;
+
+	model->border = imatrix(n, 4);
+	model->len = dmatrix(n, n);	/* len[i][j] = length of shared edge bet. i & j	*/
+	model->g = dmatrix(m, m);	/* g[i][j] = conductance bet. nodes i & j */
+	model->gx = dvector(n);		/* lumped conductances in x direction	*/
+	model->gy = dvector(n);		/* lumped conductances in y direction	*/
+	model->gx_int = dvector(n);	/* lateral conductances in the interface layer	*/
+	model->gy_int = dvector(n);
+	model->gx_sp = dvector(n);	/* lateral conductances in the spreader	layer */
+	model->gy_sp = dvector(n);
+	model->gx_hs = dvector(n);	/* lateral conductances in the heatsink	layer */
+	model->gy_hs = dvector(n);
+	/* vertical conductances to ambient	*/
+	model->g_amb = dvector(n+EXTRA);
+	model->t_vector = dvector(m);/* scratch pad	*/
+	model->p = ivector(m);		/* permutation vector for b's LUP decomposition	*/
+
+	model->a = dvector(m);		/* vertical Cs - diagonal matrix stored as a 1-d vector	*/
+	model->inva = dvector(m);	/* inverse of the above 	*/
+	/* B, C and LU are (NL*n+EXTRA)x(NL*n+EXTRA) matrices	*/
+	model->b = dmatrix(m, m);
+	model->c = dmatrix(m, m);
+	model->lu = dmatrix(m, m);
+
+	model->flp = placeholder;
+	return model;
+}
+
+/* creates matrices  B and invB: BT = Power in the steady state. 
+ * NOTE: EXTRA nodes: 4 heat spreader peripheral nodes, 4 heat 
+ * sink inner peripheral nodes, 4 heat sink outer peripheral 
+ * nodes(north, south, east and west) and 1 ambient node.
+ */
+void populate_R_model_block(block_model_t *model, flp_t *flp)
+{
+	/*	shortcuts	*/
+	double **b = model->b;
+	double *gx = model->gx, *gy = model->gy;
+	double *gx_int = model->gx_int, *gy_int = model->gy_int;
+	double *gx_sp = model->gx_sp, *gy_sp = model->gy_sp;
+	double *gx_hs = model->gx_hs, *gy_hs = model->gy_hs;
+	double *g_amb = model->g_amb;
+	double **len = model->len, **g = model->g, **lu = model->lu;
+	int **border = model->border;
+	int *p = model->p;
+	double t_chip = model->config.t_chip;
+	double r_convec = model->config.r_convec;
+	double s_sink = model->config.s_sink;
+	double t_sink = model->config.t_sink;
+	double s_spreader = model->config.s_spreader;
+	double t_spreader = model->config.t_spreader;
+	double t_interface = model->config.t_interface;
+	double k_chip = model->config.k_chip;
+	double k_sink = model->config.k_sink;
+	double k_spreader = model->config.k_spreader;
+	double k_interface = model->config.k_interface;
+	
+	int i, j, n = flp->n_units;
+	double gn_sp=0, gs_sp=0, ge_sp=0, gw_sp=0;
+	double gn_hs=0, gs_hs=0, ge_hs=0, gw_hs=0;
+	double r_amb;
+
+	double w_chip = get_total_width (flp);	/* x-axis	*/
+	double l_chip = get_total_height (flp);	/* y-axis	*/
+	
+	/* sanity check on floorplan sizes	*/
+	if (w_chip > s_sink || l_chip > s_sink || 
+		w_chip > s_spreader || l_chip > s_spreader) {
+		print_flp(flp);
+		print_flp_fig(flp);
+		fatal((char*)"inordinate floorplan size!\n");
+	}
+	if(model->flp != flp || model->n_units != flp->n_units ||
+	   model->n_nodes != NL * flp->n_units + EXTRA)
+	   fatal((char*)"mismatch between the floorplan and the thermal model\n");
+
+	/* gx's and gy's of blocks	*/
+	for (i = 0; i < n; i++) {
+		/* at the silicon layer	*/
+		if (model->config.block_omit_lateral) {
+			gx[i] = gy[i] = 0;
+		}
+		else {
+			gx[i] = 1.0/getr(k_chip, flp->units[i].width / 2.0, flp->units[i].height * t_chip);
+			gy[i] = 1.0/getr(k_chip, flp->units[i].height / 2.0, flp->units[i].width * t_chip);
+		}
+
+		/* at the interface layer	*/
+		gx_int[i] = 1.0/getr(k_interface, flp->units[i].width / 2.0, flp->units[i].height * t_interface);
+		gy_int[i] = 1.0/getr(k_interface, flp->units[i].height / 2.0, flp->units[i].width * t_interface);
+
+		/* at the spreader layer	*/
+		gx_sp[i] = 1.0/getr(k_spreader, flp->units[i].width / 2.0, flp->units[i].height * t_spreader);
+		gy_sp[i] = 1.0/getr(k_spreader, flp->units[i].height / 2.0, flp->units[i].width * t_spreader);
+
+		/* at the heatsink layer	*/
+		gx_hs[i] = 1.0/getr(k_sink, flp->units[i].width / 2.0, flp->units[i].height * t_sink);
+		gy_hs[i] = 1.0/getr(k_sink, flp->units[i].height / 2.0, flp->units[i].width * t_sink);
+	}
+
+	/* shared lengths between blocks	*/
+	for (i = 0; i < n; i++) 
+		for (j = i; j < n; j++) 
+			len[i][j] = len[j][i] = get_shared_len(flp, i, j);
+
+	/* package R's	*/
+	populate_package_R(&model->pack, &model->config, w_chip, l_chip);
+
+	/* short the R's from block centers to a particular chip edge	*/
+	for (i = 0; i < n; i++) {
+		if (eq(flp->units[i].bottomy + flp->units[i].height, l_chip)) {
+			gn_sp += gy_sp[i];
+			gn_hs += gy_hs[i];
+			border[i][2] = 1;	/* block is on northern border 	*/
+		} else
+			border[i][2] = 0;
+
+		if (eq(flp->units[i].bottomy, 0)) {
+			gs_sp += gy_sp[i];
+			gs_hs += gy_hs[i];
+			border[i][3] = 1;	/* block is on southern border	*/
+		} else
+			border[i][3] = 0;
+
+		if (eq(flp->units[i].leftx + flp->units[i].width, w_chip)) {
+			ge_sp += gx_sp[i];
+			ge_hs += gx_hs[i];
+			border[i][1] = 1;	/* block is on eastern border	*/
+		} else 
+			border[i][1] = 0;
+
+		if (eq(flp->units[i].leftx, 0)) {
+			gw_sp += gx_sp[i];
+			gw_hs += gx_hs[i];
+			border[i][0] = 1;	/* block is on western border	*/
+		} else
+			border[i][0] = 0;
+	}
+
+	/* initialize g	*/
+	zero_dmatrix(g, NL*n+EXTRA, NL*n+EXTRA);
+	zero_dvector(g_amb, n+EXTRA);
+
+	/* overall Rs between nodes */
+	for (i = 0; i < n; i++) {
+		double area = (flp->units[i].height * flp->units[i].width);
+		/* amongst functional units	in the various layers	*/
+		for (j = 0; j < n; j++) {
+			double part = 0, part_int = 0, part_sp = 0, part_hs = 0;
+			if (is_horiz_adj(flp, i, j)) {
+				part = gx[i] / flp->units[i].height;
+				part_int = gx_int[i] / flp->units[i].height;
+				part_sp = gx_sp[i] / flp->units[i].height;
+				part_hs = gx_hs[i] / flp->units[i].height;
+			}
+			else if (is_vert_adj(flp, i,j))  {
+				part = gy[i] / flp->units[i].width;
+				part_int = gy_int[i] / flp->units[i].width;
+				part_sp = gy_sp[i] / flp->units[i].width;
+				part_hs = gy_hs[i] / flp->units[i].width;
+			}
+			g[i][j] = part * len[i][j];
+			g[IFACE*n+i][IFACE*n+j] = part_int * len[i][j];
+			g[HSP*n+i][HSP*n+j] = part_sp * len[i][j];
+			g[HSINK*n+i][HSINK*n+j] = part_hs * len[i][j];
+		}
+		/* the 2.0 factor in the following equations is 
+		 * explained during the calculation of the B matrix
+		 */
+ 		/* vertical g's in the silicon layer	*/
+		g[i][IFACE*n+i]=g[IFACE*n+i][i]=2.0/getr(k_chip, t_chip, area);
+ 		/* vertical g's in the interface layer	*/
+		g[IFACE*n+i][HSP*n+i]=g[HSP*n+i][IFACE*n+i]=2.0/getr(k_interface, t_interface, area);
+		/* vertical g's in the spreader layer	*/
+		g[HSP*n+i][HSINK*n+i]=g[HSINK*n+i][HSP*n+i]=2.0/getr(k_spreader, t_spreader, area);
+		/* vertical g's in the heatsink core layer	*/
+		/* vertical R to ambient: divide r_convec proportional to area	*/
+		r_amb = r_convec * (s_sink * s_sink) / area;
+		g_amb[i] = 1.0 / (getr(k_sink, t_sink, area) + r_amb);
+
+		/* lateral g's from block center (spreader layer) to peripheral (n,s,e,w) spreader nodes	*/
+		g[HSP*n+i][NL*n+SP_N]=g[NL*n+SP_N][HSP*n+i]=2.0*border[i][2] /
+							  ((1.0/gy_sp[i])+model->pack.r_sp1_y*gn_sp/gy_sp[i]);
+		g[HSP*n+i][NL*n+SP_S]=g[NL*n+SP_S][HSP*n+i]=2.0*border[i][3] /
+							  ((1.0/gy_sp[i])+model->pack.r_sp1_y*gs_sp/gy_sp[i]);
+		g[HSP*n+i][NL*n+SP_E]=g[NL*n+SP_E][HSP*n+i]=2.0*border[i][1] /
+							  ((1.0/gx_sp[i])+model->pack.r_sp1_x*ge_sp/gx_sp[i]);
+		g[HSP*n+i][NL*n+SP_W]=g[NL*n+SP_W][HSP*n+i]=2.0*border[i][0] /
+							  ((1.0/gx_sp[i])+model->pack.r_sp1_x*gw_sp/gx_sp[i]);
+		
+		/* lateral g's from block center (heatsink layer) to peripheral (n,s,e,w) heatsink nodes	*/
+		g[HSINK*n+i][NL*n+SINK_C_N]=g[NL*n+SINK_C_N][HSINK*n+i]=2.0*border[i][2] /
+									((1.0/gy_hs[i])+model->pack.r_hs1_y*gn_hs/gy_hs[i]);
+		g[HSINK*n+i][NL*n+SINK_C_S]=g[NL*n+SINK_C_S][HSINK*n+i]=2.0*border[i][3] /
+									((1.0/gy_hs[i])+model->pack.r_hs1_y*gs_hs/gy_hs[i]);
+		g[HSINK*n+i][NL*n+SINK_C_E]=g[NL*n+SINK_C_E][HSINK*n+i]=2.0*border[i][1] /
+									((1.0/gx_hs[i])+model->pack.r_hs1_x*ge_hs/gx_hs[i]);
+		g[HSINK*n+i][NL*n+SINK_C_W]=g[NL*n+SINK_C_W][HSINK*n+i]=2.0*border[i][0] /
+									((1.0/gx_hs[i])+model->pack.r_hs1_x*gw_hs/gx_hs[i]);
+	}
+
+	/* g's from peripheral(n,s,e,w) nodes	*/
+	/* vertical g's between peripheral spreader nodes and center peripheral heatsink nodes */
+	g[NL*n+SP_N][NL*n+SINK_C_N]=g[NL*n+SINK_C_N][NL*n+SP_N]=2.0/model->pack.r_sp_per_y;
+	g[NL*n+SP_S][NL*n+SINK_C_S]=g[NL*n+SINK_C_S][NL*n+SP_S]=2.0/model->pack.r_sp_per_y;
+	g[NL*n+SP_E][NL*n+SINK_C_E]=g[NL*n+SINK_C_E][NL*n+SP_E]=2.0/model->pack.r_sp_per_x;
+	g[NL*n+SP_W][NL*n+SINK_C_W]=g[NL*n+SINK_C_W][NL*n+SP_W]=2.0/model->pack.r_sp_per_x;
+	/* lateral g's between peripheral outer sink nodes and center peripheral sink nodes	*/
+	g[NL*n+SINK_C_N][NL*n+SINK_N]=g[NL*n+SINK_N][NL*n+SINK_C_N]=2.0/(model->pack.r_hs + model->pack.r_hs2_y);
+	g[NL*n+SINK_C_S][NL*n+SINK_S]=g[NL*n+SINK_S][NL*n+SINK_C_S]=2.0/(model->pack.r_hs + model->pack.r_hs2_y);
+	g[NL*n+SINK_C_E][NL*n+SINK_E]=g[NL*n+SINK_E][NL*n+SINK_C_E]=2.0/(model->pack.r_hs + model->pack.r_hs2_x);
+	g[NL*n+SINK_C_W][NL*n+SINK_W]=g[NL*n+SINK_W][NL*n+SINK_C_W]=2.0/(model->pack.r_hs + model->pack.r_hs2_x);
+	/* vertical g's between inner peripheral sink nodes and ambient	*/
+	g_amb[n+SINK_C_N] = g_amb[n+SINK_C_S] = 1.0 / (model->pack.r_hs_c_per_y+model->pack.r_amb_c_per_y);
+	g_amb[n+SINK_C_E] = g_amb[n+SINK_C_W] = 1.0 / (model->pack.r_hs_c_per_x+model->pack.r_amb_c_per_x);
+	/* vertical g's between outer peripheral sink nodes and ambient	*/
+	g_amb[n+SINK_N] = g_amb[n+SINK_S] = g_amb[n+SINK_E] =
+					  g_amb[n+SINK_W] = 1.0 / (model->pack.r_hs_per+model->pack.r_amb_per);
+
+	/* calculate matrix B such that BT = POWER in steady state */
+	/* non-diagonal elements	*/
+	for (i = 0; i < NL*n+EXTRA; i++)
+		for (j = 0; j < i; j++)
+			if ((g[i][j] == 0.0) || (g[j][i] == 0.0))
+				b[i][j] = b[j][i] = 0.0;
+			else
+				/* here is why the 2.0 factor comes when calculating g[][]	*/
+				b[i][j] = b[j][i] = -1.0/((1.0/g[i][j])+(1.0/g[j][i]));
+	/* diagonal elements	*/			
+	for (i = 0; i < NL*n+EXTRA; i++) {
+		/* functional blocks in the heat sink layer	*/
+		if (i >= HSINK*n && i < NL*n) 
+			b[i][i] = g_amb[i%n];
+		/* heat sink peripheral nodes	*/
+		else if (i >= NL*n+SINK_C_W)
+			b[i][i] = g_amb[n+i-NL*n];
+		/* all other nodes that are not connected to the ambient	*/	
+		else
+			b[i][i] = 0.0;
+		/* sum up the conductances	*/	
+		for(j=0; j < NL*n+EXTRA; j++)
+			if (i != j)
+				b[i][i] -= b[i][j];
+	}
+
+	/* compute the LUP decomposition of B and store it too	*/
+	copy_dmatrix(lu, b, NL*n+EXTRA, NL*n+EXTRA);
+	/* 
+	 * B is a symmetric positive definite matrix. It is
+	 * symmetric because if a node A is connected to B, 
+	 * then B is also connected to A with the same R value.
+	 * It is positive definite because of the following
+	 * informal argument from Professor Lieven Vandenberghe's
+	 * lecture slides for the spring 2004-2005 EE 103 class 
+	 * at UCLA: http://www.ee.ucla.edu/~vandenbe/103/chol.pdf
+	 * x^T*B*x = voltage^T * (B*x) = voltage^T * current
+	 * = total power dissipated in the resistors > 0 
+	 * for x != 0. 
+	 */
+	lupdcmp(lu, NL*n+EXTRA, p, 1);
+
+	/* done	*/
+	model->flp = flp;
+	model->r_ready = TRUE;
+}
+
+/* creates 2 matrices: invA, C: dT + A^-1*BT = A^-1*Power, 
+ * C = A^-1 * B. note that A is a diagonal matrix (no lateral
+ * capacitances. all capacitances are to ground). also note that
+ * it is stored as a 1-d vector. so, for computing the inverse, 
+ * inva[i] = 1/a[i] is just enough. 
+ */
+void populate_C_model_block(block_model_t *model, flp_t *flp)
+{
+	/*	shortcuts	*/
+	double *inva = model->inva, **c = model->c;
+	double **b = model->b;
+	double *a = model->a;
+	double t_chip = model->config.t_chip;
+	double c_convec = model->config.c_convec;
+	double s_sink = model->config.s_sink;
+	double t_sink = model->config.t_sink;
+	double t_spreader = model->config.t_spreader;
+	double t_interface = model->config.t_interface;
+	double p_chip = model->config.p_chip;
+	double p_sink = model->config.p_sink;
+	double p_spreader = model->config.p_spreader;
+	double p_interface = model->config.p_interface;
+	double c_amb;
+	double w_chip, l_chip;
+
+	int i, n = flp->n_units;
+
+	if (!model->r_ready)
+		fatal((char*)"R model not ready\n");
+	if (model->flp != flp || model->n_units != flp->n_units ||
+		model->n_nodes != NL * flp->n_units + EXTRA)
+		fatal((char*)"different floorplans for R and C models!\n");
+		
+	w_chip = get_total_width (flp);	/* x-axis	*/
+	l_chip = get_total_height (flp);	/* y-axis	*/
+
+	/* package C's	*/
+	populate_package_C(&model->pack, &model->config, w_chip, l_chip);
+	
+	/* functional block C's */
+	for (i = 0; i < n; i++) {
+		double area = (flp->units[i].height * flp->units[i].width);
+		/* C's from functional units to ground	*/
+		a[i] = getcap(p_chip, t_chip, area);
+		/* C's from interface portion of the functional units to ground	*/
+		a[IFACE*n+i] = getcap(p_interface, t_interface, area);
+		/* C's from spreader portion of the functional units to ground	*/
+		a[HSP*n+i] = getcap(p_spreader, t_spreader, area);
+		/* C's from heatsink portion of the functional units to ground	*/
+		/* vertical C to ambient: divide c_convec proportional to area	*/
+		c_amb = C_FACTOR * c_convec / (s_sink * s_sink) * area;
+		a[HSINK*n+i] = getcap(p_sink, t_sink, area) + c_amb;
+	}
+
+	/* C's from peripheral(n,s,e,w) nodes	*/
+ 	/* from peripheral spreader nodes to ground	*/
+	a[NL*n+SP_N] = a[NL*n+SP_S] = model->pack.c_sp_per_y;
+	a[NL*n+SP_E] = a[NL*n+SP_W] = model->pack.c_sp_per_x;
+ 	/* from center peripheral sink nodes to ground
+	 * NOTE: this treatment of capacitances (and 
+	 * the corresponding treatment of resistances 
+	 * in populate_R_model) as parallel (series)
+	 * is only approximate and is done in order
+	 * to avoid creating an extra layer of nodes
+	 */
+	a[NL*n+SINK_C_N] = a[NL*n+SINK_C_S] = model->pack.c_hs_c_per_y + 
+										  model->pack.c_amb_c_per_y;
+	a[NL*n+SINK_C_E] = a[NL*n+SINK_C_W] = model->pack.c_hs_c_per_x + 
+										  model->pack.c_amb_c_per_x; 
+	/* from outer peripheral sink nodes to ground	*/
+	a[NL*n+SINK_N] = a[NL*n+SINK_S] = a[NL*n+SINK_E] = a[NL*n+SINK_W] = 
+					 model->pack.c_hs_per + model->pack.c_amb_per;
+	
+	/* calculate A^-1 (for diagonal matrix A) such that A(dT) + BT = POWER */
+	for (i = 0; i < NL*n+EXTRA; i++)
+		inva[i] = 1.0/a[i];
+
+	/* we are always going to use the eqn dT + A^-1 * B T = A^-1 * POWER. so, store  C = A^-1 * B	*/
+	diagmatmult(c, inva, b, NL*n+EXTRA);
+
+	/*	done	*/
+	model->c_ready = TRUE;
+}
+
+/* setting package nodes' power numbers	*/
+void set_internal_power_block(block_model_t *model, double *power)
+{
+	int i;
+	zero_dvector(&power[IFACE*model->n_units], model->n_units);
+	zero_dvector(&power[HSP*model->n_units], model->n_units);
+	for(i=0; i < model->n_units + EXTRA; i++)
+		power[HSINK*model->n_units+i] = model->config.ambient * model->g_amb[i];
+}
+
+/* power and temp should both be alloced using hotspot_vector. 
+ * 'b' is the 'thermal conductance' matrix. i.e, b * temp = power
+ *  => temp = invb * power. instead of computing invb, we have
+ * stored the LUP decomposition of B in 'lu' and 'p'. Using
+ * forward and backward substitution, we can then solve the 
+ * equation b * temp = power.
+ */
+void steady_state_temp_block(block_model_t *model, double *power, double *temp) 
+{
+	if (!model->r_ready)
+		fatal((char*)"R model not ready\n");
+
+	/* set power numbers for the virtual nodes */
+	set_internal_power_block(model, power);
+
+	/* 
+	 * find temperatures (spd flag is set to 1 by the same argument
+	 * as mentioned in the populate_R_model_block function)
+	 */
+	lusolve(model->lu, model->n_nodes, model->p, power, temp, 1);
+}
+
+/* compute the slope vector dy for the transient equation 
+ * dy + cy = p. useful in the transient solver
+ */
+void slope_fn_block(block_model_t *model, double *y, double *p, double *dy)
+{
+	/* shortcuts	*/
+	int n = model->n_nodes;
+	double **c = model->c;
+
+	/* for our equation, dy = p - cy */
+	#if (MATHACCEL == MA_INTEL || MATHACCEL == MA_APPLE)
+	/* dy = p	*/
+	cblas_dcopy(n, p, 1, dy, 1);
+	/* dy = dy - c*y = p - c*y */
+	cblas_dgemv(CblasRowMajor, CblasNoTrans, n, n, -1, c[0],
+				n, y, 1, 1, dy, 1);
+	#elif (MATHACCEL == MA_AMD || MATHACCEL == MA_SUN)
+	/* dy = p	*/
+	dcopy(n, p, 1, dy, 1);
+	/* dy = dy - c*y = p - c*y */
+	dgemv('T', n, n, -1, c[0], n, y, 1, 1, dy, 1);
+	#else
+	int i;
+	double *t = dvector(n);
+	matvectmult(t, c, y, n);
+	for (i = 0; i < n; i++)
+		dy[i] = p[i]-t[i];
+	free_dvector(t);
+	#endif
+}
+
+/* compute_temp: solve for temperature from the equation dT + CT = inv_A * Power 
+ * Given the temperature (temp) at time t, the power dissipation per cycle during the 
+ * last interval (time_elapsed), find the new temperature at time t+time_elapsed.
+ * power and temp should both be alloced using hotspot_vector
+ */
+void compute_temp_block(block_model_t *model, double *power, double *temp, double time_elapsed)
+{
+	double t, h, new_h;
+
+	#if VERBOSE > 1
+	//unsigned int i = 0;
+	#endif
+
+	if (!model->r_ready || !model->c_ready)
+		fatal((char*)"block model not ready\n");
+	if (temp == model->t_vector)
+		fatal((char*)"output same as scratch pad\n");
+
+	/* set power numbers for the virtual nodes */
+	set_internal_power_block(model, power);
+
+	/* use the scratch pad vector to find (inv_A)*POWER */
+	diagmatvectmult(model->t_vector, model->inva, power, model->n_nodes);
+
+	/* Obtain temp at time (t+time_elapsed). 
+	 * Instead of getting the temperature at t+time_elapsed directly, we do it 
+	 * in multiple steps with the correct step size at each time 
+	 * provided by rk4
+	 */
+	for (t = 0, new_h = MIN_STEP; t < time_elapsed && new_h >= MIN_STEP*DELTA; t+=h) {
+		h = new_h;
+		new_h = rk4(model, temp, model->t_vector, model->n_nodes, &h, 
+		/* the slope function callback is typecast accordingly */
+					temp, (slope_fn_ptr) slope_fn_block);
+		new_h = MIN(new_h, time_elapsed-t-h);
+		#if VERBOSE > 1
+		//i++;
+		#endif
+	}
+	#if VERBOSE > 1
+	//fprintf(stdout, "no. of rk4 calls during compute_temp: %d\n", i+1);
+	#endif
+}
+
+/* differs from 'dvector()' in that memory for internal nodes is also allocated	*/
+double *hotspot_vector_block(block_model_t *model)
+{
+	return dvector(model->n_nodes);
+}
+
+/* copy 'src' to 'dst' except for a window of 'size'
+ * elements starting at 'at'. useful in floorplan
+ * compaction
+ */
+void trim_hotspot_vector_block(block_model_t *model, double *dst, double *src, 
+						 	   int at, int size)
+{
+	int i;
+
+	for (i=0; i < at && i < model->n_nodes; i++)
+		dst[i] = src[i];
+	for(i=at+size; i < model->n_nodes; i++)
+		dst[i-size] = src[i];
+}
+
+/* update the model's node count	*/						 
+void resize_thermal_model_block(block_model_t *model, int n_units)
+{
+	if (n_units > model->base_n_units)
+		fatal((char*)"resizing block model to more than the allocated space\n");
+	model->n_units = n_units;
+	model->n_nodes = NL * n_units + EXTRA;
+	/* resize the 2-d matrices whose no. of columns changes	*/
+	resize_dmatrix(model->len, model->n_units, model->n_units);
+	resize_dmatrix(model->g, model->n_nodes, model->n_nodes);
+	resize_dmatrix(model->b, model->n_nodes, model->n_nodes);
+	resize_dmatrix(model->c, model->n_nodes, model->n_nodes);
+	resize_dmatrix(model->lu, model->n_nodes, model->n_nodes);
+}
+
+/* sets the temperature of a vector 'temp' allocated using 'hotspot_vector'	*/
+void set_temp_block(block_model_t *model, double *temp, double val)
+{
+	int i;
+	for(i=0; i < model->n_nodes; i++)
+		temp[i] = val;
+}
+
+/* dump temperature vector alloced using 'hotspot_vector' to 'file' */ 
+void dump_temp_block(block_model_t *model, double *temp, char *file)
+{
+	flp_t *flp = model->flp;
+	int i;
+	char str[STR_SIZE];
+	FILE *fp;
+
+	if (!strcasecmp(file, "stdout"))
+		fp = stdout;
+	else if (!strcasecmp(file, "stderr"))
+		fp = stderr;
+	else 	
+		fp = fopen (file, "w");
+
+	if (!fp) {
+		sprintf (str,"error: %s could not be opened for writing\n", file);
+		fatal(str);
+	}
+	/* on chip temperatures	*/
+	for (i=0; i < flp->n_units; i++)
+		fprintf(fp, "%s\t%.2f\n", flp->units[i].name, temp[i]);
+
+	/* interface temperatures	*/
+	for (i=0; i < flp->n_units; i++)
+		fprintf(fp, "iface_%s\t%.2f\n", flp->units[i].name, temp[IFACE*flp->n_units+i]);
+
+	/* spreader temperatures	*/
+	for (i=0; i < flp->n_units; i++)
+		fprintf(fp, "hsp_%s\t%.2f\n", flp->units[i].name, temp[HSP*flp->n_units+i]);
+
+	/* heatsink temperatures	*/
+	for (i=0; i < flp->n_units; i++)
+		fprintf(fp, "hsink_%s\t%.2f\n", flp->units[i].name, temp[HSINK*flp->n_units+i]);
+
+	/* internal node temperatures	*/
+	for (i=0; i < EXTRA; i++) {
+		sprintf(str, "inode_%d", i);
+		fprintf(fp, "%s\t%.2f\n", str, temp[i+NL*flp->n_units]);
+	}
+
+	if(fp != stdout && fp != stderr)
+		fclose(fp);	
+}
+
+void copy_temp_block(block_model_t *model, double *dst, double *src)
+{
+	copy_dvector(dst, src, NL*model->flp->n_units+EXTRA);
+}
+
+/* 
+ * read temperature vector alloced using 'hotspot_vector' from 'file'
+ * which was dumped using 'dump_temp'. values are clipped to thermal
+ * threshold based on 'clip'
+ */ 
+void read_temp_block(block_model_t *model, double *temp, char *file, int clip)
+{
+	/*	shortcuts	*/
+	flp_t *flp = model->flp;
+	double thermal_threshold = model->config.thermal_threshold;
+	double ambient = model->config.ambient;
+
+	int i, n, idx;
+	double max=0, val;
+	char *ptr, str1[LINE_SIZE], str2[LINE_SIZE];
+	char name[STR_SIZE], format[STR_SIZE];
+	FILE *fp;
+
+	if (!strcasecmp(file, "stdin"))
+		fp = stdin;
+	else
+		fp = fopen (file, "r");
+
+	if (!fp) {
+		sprintf (str1,"error: %s could not be opened for reading\n", file);
+		fatal(str1);
+	}	
+
+	/* temperatures of the different layers	*/
+	for (n=0; n < NL; n++) {
+		switch(n)
+		{
+			case 0:
+					strcpy(format,"%s%lf");
+					break;
+			case IFACE:
+					strcpy(format,"iface_%s%lf");
+					break;
+			case HSP:
+					strcpy(format,"hsp_%s%lf");
+					break;
+			case HSINK:
+					strcpy(format,"hsink_%s%lf");
+					break;
+			default:
+					fatal((char*)"unknown layer\n");
+					break;
+		}
+		for (i=0; i < flp->n_units; i++) {
+			fgets(str1, LINE_SIZE, fp);
+			if (feof(fp))
+				fatal((char*)"not enough lines in temperature file\n");
+			strcpy(str2, str1);
+
+			/* ignore comments and empty lines	*/
+			ptr = strtok(str1, " \r\t\n");
+			if (!ptr || ptr[0] == '#') {
+				i--;
+				continue;
+			}
+
+			if (sscanf(str2, format, name, &val) != 2)
+				fatal((char*)"invalid temperature file format\n");
+			idx = get_blk_index(flp, name);
+			if (idx >= 0)
+				temp[idx + n*flp->n_units] = val;
+			else	/* since get_blk_index calls fatal, the line below cannot be reached	*/
+				fatal((char*)"unit in temperature file not found in floorplan\n");
+
+			/* find max temp on the chip	*/
+			if (n == 0 && temp[idx] > max)
+				max = temp[idx];
+		}
+	}
+
+	/* internal node temperatures	*/	
+	for (i=0; i < EXTRA; i++) {
+		fgets(str1, LINE_SIZE, fp);
+		if (feof(fp))
+			fatal((char*)"not enough lines in temperature file\n");
+		strcpy(str2, str1);
+		/* ignore comments and empty lines	*/
+		ptr = strtok(str1, " \r\t\n");
+		if (!ptr || ptr[0] == '#') {
+			i--;
+			continue;
+		}
+		if (sscanf(str2, "%s%lf", name, &val) != 2)
+			fatal((char*)"invalid temperature file format\n");
+		sprintf(str1, "inode_%d", i);
+		if (strcasecmp(str1, name))
+			fatal((char*)"invalid temperature file format\n");
+		temp[i+NL*flp->n_units] = val;	
+	}
+
+	fgets(str1, LINE_SIZE, fp);
+	if (!feof(fp))
+		fatal((char*)"too many lines in temperature file\n");
+
+	if(fp != stdin)
+		fclose(fp);	
+
+	/* clipping	*/
+	if (clip && (max > thermal_threshold)) {
+		/* if max has to be brought down to thermal_threshold, 
+		 * (w.r.t the ambient) what is the scale down factor?
+		 */
+		double factor = (thermal_threshold - ambient) / (max - ambient);
+	
+		/* scale down all temperature differences (from ambient) by the same factor	*/
+		for (i=0; i < NL*flp->n_units + EXTRA; i++)
+			temp[i] = (temp[i]-ambient)*factor + ambient;
+	}
+}
+
+/* dump power numbers to file	*/
+void dump_power_block(block_model_t *model, double *power, char *file)
+{
+	flp_t *flp = model->flp;
+	int i;
+	char str[STR_SIZE];
+	FILE *fp;
+
+	if (!strcasecmp(file, "stdout"))
+		fp = stdout;
+	else if (!strcasecmp(file, "stderr"))
+		fp = stderr;
+	else 	
+		fp = fopen (file, "w");
+
+	if (!fp) {
+		sprintf (str,"error: %s could not be opened for writing\n", file);
+		fatal(str);
+	}
+	for (i=0; i < flp->n_units; i++)
+		fprintf(fp, "%s\t%.6f\n", flp->units[i].name, power[i]);
+	if(fp != stdout && fp != stderr)
+		fclose(fp);	
+}
+
+/* 
+ * read power vector alloced using 'hotspot_vector' from 'file'
+ * which was dumped using 'dump_power'. 
+ */ 
+void read_power_block (block_model_t *model, double *power, char *file)
+{
+	flp_t *flp = model->flp;
+	int idx;
+	double val;
+	char *ptr, str1[LINE_SIZE], str2[LINE_SIZE], name[STR_SIZE];
+	FILE *fp;
+
+	if (!strcasecmp(file, "stdin"))
+		fp = stdin;
+	else
+		fp = fopen (file, "r");
+
+	if (!fp) {
+		sprintf (str1,"error: %s could not be opened for reading\n", file);
+		fatal(str1);
+	}
+	while(!feof(fp)) {
+		fgets(str1, LINE_SIZE, fp);
+		if (feof(fp))
+			break;
+		strcpy(str2, str1);
+
+		/* ignore comments and empty lines	*/
+		ptr = strtok(str1, " \r\t\n");
+		if (!ptr || ptr[0] == '#')
+			continue;
+
+		if (sscanf(str2, "%s%lf", name, &val) != 2)
+			fatal((char*)"invalid power file format\n");
+		idx = get_blk_index(flp, name);
+		if (idx >= 0)
+			power[idx] = val;
+		else	/* since get_blk_index calls fatal, the line below cannot be reached	*/
+			fatal((char*)"unit in power file not found in floorplan\n");
+	}
+	if(fp != stdin)
+		fclose(fp);
+}
+
+double find_max_temp_block(block_model_t *model, double *temp)
+{
+	int i;
+	double max = 0.0;
+	for(i=0; i < model->n_units; i++) {
+		if (temp[i] < 0)
+			fatal((char*)"negative temperature!\n");
+		else if (max < temp[i])
+			max = temp[i];
+	}
+
+	return max;
+}
+
+double find_avg_temp_block(block_model_t *model, double *temp)
+{
+	int i;
+	double sum = 0.0;
+	for(i=0; i < model->n_units; i++) {
+		if (temp[i] < 0)
+			fatal((char*)"negative temperature!\n");
+		else 
+			sum += temp[i];
+	}
+
+	return (sum / model->n_units);
+}
+
+/* calculate avg sink temp for natural convection package model */
+double calc_sink_temp_block(block_model_t *model, double *temp, thermal_config_t *config)
+{
+	flp_t *flp = model->flp;
+	int i;
+	double sum = 0.0;
+	double width = get_total_width(flp);
+	double height = get_total_height(flp);
+	double spr_size = config->s_spreader*config->s_spreader;
+	double sink_size = config->s_sink*config->s_sink;
+	
+	/* heatsink temperatures	*/
+	for (i=0; i < flp->n_units; i++)
+		if (temp[HSINK*flp->n_units+i] < 0)
+			fatal((char*)"negative temperature!\n");
+		else  /* area-weighted average */
+			sum += temp[HSINK*flp->n_units+i]*(flp->units[i].width*flp->units[i].height);
+			
+	for(i=SINK_C_W; i <= SINK_C_E; i++)
+		if (temp[i+NL*flp->n_units] < 0)
+			fatal((char*)"negative temperature!\n");
+		else
+			sum += temp[i+NL*flp->n_units]*0.25*(config->s_spreader+height)*(config->s_spreader-width);
+
+	for(i=SINK_C_N; i <= SINK_C_S; i++)
+		if (temp[i+NL*flp->n_units] < 0)
+			fatal((char*)"negative temperature!\n");
+		else
+			sum += temp[i+NL*flp->n_units]*0.25*(config->s_spreader+width)*(config->s_spreader-height);
+
+	for(i=SINK_W; i <= SINK_S; i++)
+		if (temp[i+NL*flp->n_units] < 0)
+			fatal((char*)"negative temperature!\n");
+		else
+			sum += temp[i+NL*flp->n_units]*0.25*(sink_size-spr_size);
+	
+	return (sum / sink_size);
+}
+
+void delete_block_model(block_model_t *model)
+{
+	free_dvector(model->a);
+	free_dvector(model->inva);
+	free_dmatrix(model->b);
+	free_dmatrix(model->c);
+
+	free_dvector(model->gx);
+	free_dvector(model->gy);
+	free_dvector(model->gx_int);
+	free_dvector(model->gy_int);
+	free_dvector(model->gx_sp);
+	free_dvector(model->gy_sp);
+	free_dvector(model->gx_hs);
+	free_dvector(model->gy_hs);
+	free_dvector(model->g_amb);
+	free_dvector(model->t_vector);
+	free_ivector(model->p);
+
+	free_dmatrix(model->len);
+	free_dmatrix(model->g);
+	free_dmatrix(model->lu);
+
+	free_imatrix(model->border);
+
+	free(model);
+}
+
+void debug_print_block(block_model_t *model)
+{
+	fprintf(stdout, "printing block model information...\n");
+	fprintf(stdout, "n_nodes: %d\n", model->n_nodes);
+	fprintf(stdout, "n_units: %d\n", model->n_units);
+	fprintf(stdout, "base_n_units: %d\n", model->base_n_units);
+	fprintf(stdout, "r_ready: %d\n", model->r_ready);
+	fprintf(stdout, "c_ready: %d\n", model->c_ready);
+
+	debug_print_package_RC(&model->pack);
+
+	fprintf(stdout, "printing matrix b:\n");
+	dump_dmatrix(model->b, model->n_nodes, model->n_nodes);
+	fprintf(stdout, "printing vector a:\n");
+	dump_dvector(model->a, model->n_nodes);
+	fprintf(stdout, "printing vector inva:\n");
+	dump_dvector(model->inva, model->n_nodes);
+	fprintf(stdout, "printing matrix c:\n");
+	dump_dmatrix(model->c, model->n_nodes, model->n_nodes);
+	fprintf(stdout, "printing vector g_amb:\n");
+	dump_dvector(model->g_amb, model->n_units+EXTRA);
+}
+
diff -Naur temp/temperature.c HotSpot/temperature.c
--- temp/temperature.c	2017-11-20 10:04:24.521682846 +0100
+++ HotSpot/temperature.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,894 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#ifdef _MSC_VER
-#define strcasecmp    _stricmp
-#define strncasecmp   _strnicmp
-#else
-#include <strings.h>
-#endif
-#include <math.h>
-
-#include "temperature.h"
-#include "temperature_block.h"
-#include "temperature_grid.h"
-#include "flp.h"
-#include "util.h"
-
-/* default thermal configuration parameters	*/
-thermal_config_t default_thermal_config(void)
-{
-	thermal_config_t config;
-
-	/* chip specs	*/
-	config.t_chip = 0.15e-3;			/* chip thickness in meters	*/
-	config.k_chip = 100.0; /* chip thermal conductivity in W/(m-K) */
-	config.p_chip = 1.75e6; /* chip specific heat in J/(m^3-K) */
-	/* temperature threshold for DTM (Kelvin)*/
-	config.thermal_threshold = 81.8 + 273.15;
-
-	/* heat sink specs	*/
-	config.c_convec = 140.4;			/* convection capacitance in J/K */
-	config.r_convec = 0.1;				/* convection resistance in K/W	*/
-	config.s_sink = 60e-3;				/* heatsink side in m	*/
-	config.t_sink = 6.9e-3; 			/* heatsink thickness  in m	*/
-	config.k_sink = 400.0; /* heatsink thermal conductivity in W/(m-K) */
-	config.p_sink = 3.55e6; /* heatsink specific heat in J/(m^3-K) */
-	
-
-	/* heat spreader specs	*/
-	config.s_spreader = 30e-3;			/* spreader side in m	*/
-	config.t_spreader = 1e-3;			/* spreader thickness in m	*/
-	config.k_spreader = 400.0; /* heat spreader thermal conductivity in W/(m-K) */
-	config.p_spreader = 3.55e6; /* heat spreader specific heat in J/(m^3-K) */
-
-	/* interface material specs	*/
-	config.t_interface = 20e-6;			/* interface material thickness in m */
-	config.k_interface = 4.0; /* interface material thermal conductivity in W/(m-K) */
-	config.p_interface = 4.0e6; /* interface material specific heat in J/(m^3-K) */
-	
-	/* secondary heat transfer path */
-	config.model_secondary = FALSE;
-	config.r_convec_sec = 1.0;
-	config.c_convec_sec = 140.4; //FIXME! need updated value.
-	config.n_metal = 8;
-	config.t_metal = 10.0e-6;
-	config.t_c4 = 0.0001;
-	config.s_c4 = 20.0e-6;
-	config.n_c4 = 400;
-	config.s_sub = 0.021;
-	config.t_sub = 0.001;
-	config.s_solder = 0.021;
-	config.t_solder = 0.00094;
-	config.s_pcb = 0.1;
-	config.t_pcb = 0.002;
-	
-	/* others	*/
-	config.ambient = 45 + 273.15;		/* in kelvin	*/
-	/* initial temperatures	from file	*/
-	strcpy(config.init_file, NULLFILE);	
-	config.init_temp = 60 + 273.15;		/* in Kelvin	*/
-	/* steady state temperatures to file	*/
-	strcpy(config.steady_file, NULLFILE);
- 	/* 3.33 us sampling interval = 10K cycles at 3GHz	*/
-	config.sampling_intvl = 3.333e-6;
-	config.base_proc_freq = 3e9;		/* base processor frequency in Hz	*/
-	config.dtm_used = FALSE;			/* set accordingly	*/
-	
-	config.leakage_used = 0;
-	config.leakage_mode = 0;
-	
-	config.package_model_used = 0;
-	strcpy(config.package_config_file, NULLFILE);	
-	
-	/* set block model as default	*/
-	strcpy(config.model_type, BLOCK_MODEL_STR);
-
-	/* block model specific parameters	*/
-	config.block_omit_lateral = FALSE;	/* omit lateral chip resistances?	*/
-
-	/* grid model specific parameters	*/
-	config.grid_rows = 64;				/* grid resolution - no. of rows	*/
-	config.grid_cols = 64;				/* grid resolution - no. of cols	*/
-	/* layer configuration from	file */
-	strcpy(config.grid_layer_file, NULLFILE);
-	/* output steady state grid temperatures apart from block temperatures */
-	strcpy(config.grid_steady_file, NULLFILE);
-	/* 
-	 * mapping mode between block and grid models.
-	 * default: use the temperature of the center
-	 * grid cell as that of the entire block
-	 */
-	strcpy(config.grid_map_mode, GRID_CENTER_STR);
-
-	return config;
-}
-
-/* 
- * parse a table of name-value string pairs and add the configuration
- * parameters to 'config'
- */
-void thermal_config_add_from_strs(thermal_config_t *config, str_pair *table, int size)
-{
-	int idx;
-	if ((idx = get_str_index(table, size, "t_chip")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->t_chip) != 1)
-			fatal("invalid format for configuration  parameter t_chip\n");
-	if ((idx = get_str_index(table, size, "k_chip")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->k_chip) != 1)
-			fatal("invalid format for configuration  parameter k_chip\n");
-	if ((idx = get_str_index(table, size, "p_chip")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->p_chip) != 1)
-			fatal("invalid format for configuration  parameter p_chip\n");
-	if ((idx = get_str_index(table, size, "thermal_threshold")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->thermal_threshold) != 1)
-			fatal("invalid format for configuration  parameter thermal_threshold\n");
-	if ((idx = get_str_index(table, size, "c_convec")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->c_convec) != 1)
-			fatal("invalid format for configuration  parameter c_convec\n");
-	if ((idx = get_str_index(table, size, "r_convec")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->r_convec) != 1)
-			fatal("invalid format for configuration  parameter r_convec\n");
-	if ((idx = get_str_index(table, size, "s_sink")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->s_sink) != 1)
-			fatal("invalid format for configuration  parameter s_sink\n");
-	if ((idx = get_str_index(table, size, "t_sink")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->t_sink) != 1)
-			fatal("invalid format for configuration  parameter t_sink\n");
-	if ((idx = get_str_index(table, size, "k_sink")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->k_sink) != 1)
-			fatal("invalid format for configuration  parameter k_sink\n");
-	if ((idx = get_str_index(table, size, "p_sink")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->p_sink) != 1)
-			fatal("invalid format for configuration  parameter p_sink\n");
-	if ((idx = get_str_index(table, size, "s_spreader")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->s_spreader) != 1)
-			fatal("invalid format for configuration  parameter s_spreader\n");
-	if ((idx = get_str_index(table, size, "t_spreader")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->t_spreader) != 1)
-			fatal("invalid format for configuration  parameter t_spreader\n");
-	if ((idx = get_str_index(table, size, "k_spreader")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->k_spreader) != 1)
-			fatal("invalid format for configuration  parameter k_spreader\n");
-	if ((idx = get_str_index(table, size, "p_spreader")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->p_spreader) != 1)
-			fatal("invalid format for configuration  parameter p_spreader\n");
-	if ((idx = get_str_index(table, size, "t_interface")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->t_interface) != 1)
-			fatal("invalid format for configuration  parameter t_interface\n");
-	if ((idx = get_str_index(table, size, "k_interface")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->k_interface) != 1)
-			fatal("invalid format for configuration  parameter k_interface\n");
-	if ((idx = get_str_index(table, size, "p_interface")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->p_interface) != 1)
-			fatal("invalid format for configuration  parameter p_interface\n");
-	if ((idx = get_str_index(table, size, "model_secondary")) >= 0)
-		if(sscanf(table[idx].value, "%d", &config->model_secondary) != 1)
-			fatal("invalid format for configuration  parameter model_secondary\n");
-	if ((idx = get_str_index(table, size, "r_convec_sec")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->r_convec_sec) != 1)
-			fatal("invalid format for configuration  parameter r_convec_sec\n");
-	if ((idx = get_str_index(table, size, "c_convec_sec")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->c_convec_sec) != 1)
-			fatal("invalid format for configuration  parameter c_convec_sec\n");
-	if ((idx = get_str_index(table, size, "n_metal")) >= 0)
-		if(sscanf(table[idx].value, "%d", &config->n_metal) != 1)
-			fatal("invalid format for configuration  parameter n_metal\n");
-	if ((idx = get_str_index(table, size, "t_metal")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->t_metal) != 1)
-			fatal("invalid format for configuration  parameter t_metal\n");
-	if ((idx = get_str_index(table, size, "t_c4")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->t_c4) != 1)
-			fatal("invalid format for configuration  parameter t_c4\n");
-	if ((idx = get_str_index(table, size, "s_c4")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->s_c4) != 1)
-			fatal("invalid format for configuration  parameter s_c4\n");
-	if ((idx = get_str_index(table, size, "n_c4")) >= 0)
-		if(sscanf(table[idx].value, "%d", &config->n_c4) != 1)
-			fatal("invalid format for configuration  parameter n_c4\n");
-	if ((idx = get_str_index(table, size, "s_sub")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->s_sub) != 1)
-			fatal("invalid format for configuration  parameter s_sub\n");	
-	if ((idx = get_str_index(table, size, "t_sub")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->t_sub) != 1)
-			fatal("invalid format for configuration  parameter t_sub\n");
-	if ((idx = get_str_index(table, size, "s_solder")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->s_solder) != 1)
-			fatal("invalid format for configuration  parameter s_solder\n");
-	if ((idx = get_str_index(table, size, "t_solder")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->t_solder) != 1)
-			fatal("invalid format for configuration  parameter t_solder\n");
-	if ((idx = get_str_index(table, size, "s_pcb")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->s_pcb) != 1)
-			fatal("invalid format for configuration  parameter s_pcb\n");
-	if ((idx = get_str_index(table, size, "t_pcb")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->t_pcb) != 1)
-			fatal("invalid format for configuration  parameter t_pcb\n");		
-	if ((idx = get_str_index(table, size, "ambient")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->ambient) != 1)
-			fatal("invalid format for configuration  parameter ambient\n");
-	if ((idx = get_str_index(table, size, "init_file")) >= 0)
-		if(sscanf(table[idx].value, "%s", config->init_file) != 1)
-			fatal("invalid format for configuration  parameter init_file\n");
-	if ((idx = get_str_index(table, size, "init_temp")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->init_temp) != 1)
-			fatal("invalid format for configuration  parameter init_temp\n");
-	if ((idx = get_str_index(table, size, "steady_file")) >= 0)
-		if(sscanf(table[idx].value, "%s", config->steady_file) != 1)
-			fatal("invalid format for configuration  parameter steady_file\n");
-	if ((idx = get_str_index(table, size, "sampling_intvl")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->sampling_intvl) != 1)
-			fatal("invalid format for configuration  parameter sampling_intvl\n");
-	if ((idx = get_str_index(table, size, "base_proc_freq")) >= 0)
-		if(sscanf(table[idx].value, "%lf", &config->base_proc_freq) != 1)
-			fatal("invalid format for configuration  parameter base_proc_freq\n");
-	if ((idx = get_str_index(table, size, "dtm_used")) >= 0)
-		if(sscanf(table[idx].value, "%d", &config->dtm_used) != 1)
-			fatal("invalid format for configuration  parameter dtm_used\n");
-	if ((idx = get_str_index(table, size, "model_type")) >= 0)
-		if(sscanf(table[idx].value, "%s", config->model_type) != 1)
-			fatal("invalid format for configuration  parameter model_type\n");
-		if ((idx = get_str_index(table, size, "leakage_used")) >= 0) 
-		if(sscanf(table[idx].value, "%d", &config->leakage_used) != 1)
-			fatal("invalid format for configuration  parameter leakage_used\n");
-	if ((idx = get_str_index(table, size, "leakage_mode")) >= 0) 
-		if(sscanf(table[idx].value, "%d", &config->leakage_mode) != 1)
-			fatal("invalid format for configuration  parameter leakage_mode\n");
-	if ((idx = get_str_index(table, size, "package_model_used")) >= 0) 
-		if(sscanf(table[idx].value, "%d", &config->package_model_used) != 1)
-			fatal("invalid format for configuration  parameter package_model_used\n");
-	if ((idx = get_str_index(table, size, "package_config_file")) >= 0)
-		if(sscanf(table[idx].value, "%s", config->package_config_file) != 1)
-			fatal("invalid format for configuration  parameter package_config_file\n");
-	if ((idx = get_str_index(table, size, "block_omit_lateral")) >= 0)
-		if(sscanf(table[idx].value, "%d", &config->block_omit_lateral) != 1)
-			fatal("invalid format for configuration  parameter block_omit_lateral\n");
-	if ((idx = get_str_index(table, size, "grid_rows")) >= 0)
-		if(sscanf(table[idx].value, "%d", &config->grid_rows) != 1)
-			fatal("invalid format for configuration  parameter grid_rows\n");
-	if ((idx = get_str_index(table, size, "grid_cols")) >= 0)
-		if(sscanf(table[idx].value, "%d", &config->grid_cols) != 1)
-			fatal("invalid format for configuration  parameter grid_cols\n");
-	if ((idx = get_str_index(table, size, "grid_layer_file")) >= 0)
-		if(sscanf(table[idx].value, "%s", config->grid_layer_file) != 1)
-			fatal("invalid format for configuration  parameter grid_layer_file\n");
-	if ((idx = get_str_index(table, size, "grid_steady_file")) >= 0)
-		if(sscanf(table[idx].value, "%s", config->grid_steady_file) != 1)
-			fatal("invalid format for configuration  parameter grid_steady_file\n");
-	if ((idx = get_str_index(table, size, "grid_map_mode")) >= 0)
-		if(sscanf(table[idx].value, "%s", config->grid_map_mode) != 1)
-			fatal("invalid format for configuration  parameter grid_map_mode\n");
-	
-	if ((config->t_chip <= 0) || (config->s_sink <= 0) || (config->t_sink <= 0) || 
-		(config->s_spreader <= 0) || (config->t_spreader <= 0) || 
-		(config->t_interface <= 0))
-		fatal("chip and package dimensions should be greater than zero\n");
-	if ((config->t_metal <= 0) || (config->n_metal <= 0) || (config->t_c4 <= 0) || 
-		(config->s_c4 <= 0) || (config->n_c4 <= 0) || (config->s_sub <= 0) || (config->t_sub <= 0) ||
-		(config->s_solder <= 0) || (config->t_solder <= 0) || (config->s_pcb <= 0) ||
-		(config->t_solder <= 0) || (config->r_convec_sec <= 0) || (config->c_convec_sec <= 0))
-		fatal("secondary heat tranfer layer dimensions should be greater than zero\n");
-	/* leakage iteration is not supported in transient mode in this release */
-	if (config->leakage_used == 1) {
-		printf("Warning: transient leakage iteration is not supported in this release...\n");
-		printf(" ...all transient results are without thermal-leakage loop.\n");
-	}		
-	if ((config->model_secondary == 1) && (!strcasecmp(config->model_type, BLOCK_MODEL_STR)))
-		fatal("secondary heat tranfer path is supported only in the grid mode\n");	
-	if ((config->thermal_threshold < 0) || (config->c_convec < 0) || 
-		(config->r_convec < 0) || (config->ambient < 0) || 
-		(config->base_proc_freq <= 0) || (config->sampling_intvl <= 0))
-		fatal("invalid thermal simulation parameters\n");
-	if (strcasecmp(config->model_type, BLOCK_MODEL_STR) &&
-		strcasecmp(config->model_type, GRID_MODEL_STR))
-		fatal("invalid model type. use 'block' or 'grid'\n");
-	if(config->grid_rows <= 0 || config->grid_cols <= 0 ||
-	   (config->grid_rows & (config->grid_rows-1)) ||
-	   (config->grid_cols & (config->grid_cols-1)))
-		fatal("grid rows and columns should both be powers of two\n");
-	if (strcasecmp(config->grid_map_mode, GRID_AVG_STR) &&
-		strcasecmp(config->grid_map_mode, GRID_MIN_STR) &&
-		strcasecmp(config->grid_map_mode, GRID_MAX_STR) &&
-		strcasecmp(config->grid_map_mode, GRID_CENTER_STR))
-		fatal("invalid mapping mode. use 'avg', 'min', 'max' or 'center'\n");
-}
-
-/* 
- * convert config into a table of name-value pairs. returns the no.
- * of parameters converted
- */
-int thermal_config_to_strs(thermal_config_t *config, str_pair *table, int max_entries)
-{
-	if (max_entries < 49)
-		fatal("not enough entries in table\n");
-
-	sprintf(table[0].name, "t_chip");
-	sprintf(table[1].name, "k_chip");
-	sprintf(table[2].name, "p_chip");
-	sprintf(table[3].name, "thermal_threshold");
-	sprintf(table[4].name, "c_convec");
-	sprintf(table[5].name, "r_convec");
-	sprintf(table[6].name, "s_sink");
-	sprintf(table[7].name, "t_sink");
-	sprintf(table[8].name, "k_sink");
-	sprintf(table[9].name, "p_sink");
-	sprintf(table[10].name, "s_spreader");
-	sprintf(table[11].name, "t_spreader");
-	sprintf(table[12].name, "k_spreader");
-	sprintf(table[13].name, "p_spreader");
-	sprintf(table[14].name, "t_interface");
-	sprintf(table[15].name, "k_interface");
-	sprintf(table[16].name, "p_interface");
-	sprintf(table[17].name, "model_secondary");
-	sprintf(table[18].name, "r_convec_sec");
-	sprintf(table[19].name, "c_convec_sec");
-	sprintf(table[20].name, "n_metal");
-	sprintf(table[21].name, "t_metal");
-	sprintf(table[22].name, "t_c4");
-	sprintf(table[23].name, "s_c4");
-	sprintf(table[24].name, "n_c4");
-	sprintf(table[25].name, "s_sub");
-	sprintf(table[26].name, "t_sub");
-	sprintf(table[27].name, "s_solder");
-	sprintf(table[28].name, "t_solder");
-	sprintf(table[29].name, "s_pcb");
-	sprintf(table[30].name, "t_pcb");
-	sprintf(table[31].name, "ambient");
-	sprintf(table[32].name, "init_file");
-	sprintf(table[33].name, "init_temp");
-	sprintf(table[34].name, "steady_file");
-	sprintf(table[35].name, "sampling_intvl");
-	sprintf(table[36].name, "base_proc_freq");
-	sprintf(table[37].name, "dtm_used");
-	sprintf(table[38].name, "model_type");
-	sprintf(table[39].name, "leakage_used");
-	sprintf(table[40].name, "leakage_mode");
-	sprintf(table[41].name, "package_model_used");
-	sprintf(table[42].name, "package_config_file");
-	sprintf(table[43].name, "block_omit_lateral");
-	sprintf(table[44].name, "grid_rows");
-	sprintf(table[45].name, "grid_cols");
-	sprintf(table[46].name, "grid_layer_file");
-	sprintf(table[47].name, "grid_steady_file");
-	sprintf(table[48].name, "grid_map_mode");
-
-	sprintf(table[0].value, "%lg", config->t_chip);
-	sprintf(table[1].value, "%lg", config->k_chip);
-	sprintf(table[2].value, "%lg", config->p_chip);
-	sprintf(table[3].value, "%lg", config->thermal_threshold);
-	sprintf(table[4].value, "%lg", config->c_convec);
-	sprintf(table[5].value, "%lg", config->r_convec);
-	sprintf(table[6].value, "%lg", config->s_sink);
-	sprintf(table[7].value, "%lg", config->t_sink);
-	sprintf(table[8].value, "%lg", config->k_sink);
-	sprintf(table[9].value, "%lg", config->p_sink);
-	sprintf(table[10].value, "%lg", config->s_spreader);
-	sprintf(table[11].value, "%lg", config->t_spreader);
-	sprintf(table[12].value, "%lg", config->k_spreader);
-	sprintf(table[13].value, "%lg", config->p_spreader);
-	sprintf(table[14].value, "%lg", config->t_interface);
-	sprintf(table[15].value, "%lg", config->k_interface);
-	sprintf(table[16].value, "%lg", config->p_interface);
-	sprintf(table[17].value, "%d", config->model_secondary);
-	sprintf(table[18].value, "%lg", config->r_convec_sec);
-	sprintf(table[19].value, "%lg", config->c_convec_sec);
-	sprintf(table[20].value, "%d", config->n_metal);
-	sprintf(table[21].value, "%lg", config->t_metal);
-	sprintf(table[22].value, "%lg", config->t_c4);
-	sprintf(table[23].value, "%lg", config->s_c4);
-	sprintf(table[24].value, "%d", config->n_c4);
-	sprintf(table[25].value, "%lg", config->s_sub);
-	sprintf(table[26].value, "%lg", config->t_sub);
-	sprintf(table[27].value, "%lg", config->s_solder);
-	sprintf(table[28].value, "%lg", config->t_solder);
-	sprintf(table[29].value, "%lg", config->s_pcb);
-	sprintf(table[30].value, "%lg", config->t_pcb);
-	sprintf(table[31].value, "%lg", config->ambient);
-	sprintf(table[32].value, "%s", config->init_file);
-	sprintf(table[33].value, "%lg", config->init_temp);
-	sprintf(table[34].value, "%s", config->steady_file);
-	sprintf(table[35].value, "%lg", config->sampling_intvl);
-	sprintf(table[36].value, "%lg", config->base_proc_freq);
-	sprintf(table[37].value, "%d", config->dtm_used);
-	sprintf(table[38].value, "%s", config->model_type);
-	sprintf(table[39].value, "%d", config->leakage_used);
-	sprintf(table[40].value, "%d", config->leakage_mode);
-	sprintf(table[41].value, "%d", config->package_model_used);
-	sprintf(table[42].value, "%s", config->package_config_file);
-	sprintf(table[43].value, "%d", config->block_omit_lateral);
-	sprintf(table[44].value, "%d", config->grid_rows);
-	sprintf(table[45].value, "%d", config->grid_cols);
-	sprintf(table[46].value, "%s", config->grid_layer_file);
-	sprintf(table[47].value, "%s", config->grid_steady_file);
-	sprintf(table[48].value, "%s", config->grid_map_mode);
-
-	return 49;
-}
-
-/* package parameter routines	*/
-void populate_package_R(package_RC_t *p, thermal_config_t *config, double width, double height)
-{
-	double s_spreader = config->s_spreader;
-	double t_spreader = config->t_spreader;
-	double s_sink = config->s_sink;
-	double t_sink = config->t_sink;
-	double r_convec = config->r_convec;
-	
-	double s_sub = config->s_sub;
-	double t_sub = config->t_sub;
-	double s_solder = config->s_solder;
-	double t_solder = config->t_solder;
-	double s_pcb = config->s_pcb;
-	double t_pcb = config->t_pcb;
-	double r_convec_sec = config->r_convec_sec;
-	
-	double k_sink = config->k_sink;
-	double k_spreader = config->k_spreader;
- 
-
-	/* lateral R's of spreader and sink */
-	p->r_sp1_x = getr(k_spreader, (s_spreader-width)/4.0, (s_spreader+3*height)/4.0 * t_spreader);
-	p->r_sp1_y = getr(k_spreader, (s_spreader-height)/4.0, (s_spreader+3*width)/4.0 * t_spreader);
-	p->r_hs1_x = getr(k_sink, (s_spreader-width)/4.0, (s_spreader+3*height)/4.0 * t_sink);
-	p->r_hs1_y = getr(k_sink, (s_spreader-height)/4.0, (s_spreader+3*width)/4.0 * t_sink);
-	p->r_hs2_x = getr(k_sink, (s_spreader-width)/4.0, (3*s_spreader+height)/4.0 * t_sink);
-	p->r_hs2_y = getr(k_sink, (s_spreader-height)/4.0, (3*s_spreader+width)/4.0 * t_sink);
-	p->r_hs = getr(k_sink, (s_sink-s_spreader)/4.0, (s_sink+3*s_spreader)/4.0 * t_sink);
-
-	/* vertical R's of spreader and sink */
-	p->r_sp_per_x = getr(k_spreader, t_spreader, (s_spreader+height) * (s_spreader-width) / 4.0);
-	p->r_sp_per_y = getr(k_spreader, t_spreader, (s_spreader+width) * (s_spreader-height) / 4.0);
-	p->r_hs_c_per_x = getr(k_sink, t_sink, (s_spreader+height) * (s_spreader-width) / 4.0);
-	p->r_hs_c_per_y = getr(k_sink, t_sink, (s_spreader+width) * (s_spreader-height) / 4.0);
-	p->r_hs_per = getr(k_sink, t_sink, (s_sink*s_sink - s_spreader*s_spreader) / 4.0);
-	
-	/* vertical R's to ambient (divide r_convec proportional to area) */
-	p->r_amb_c_per_x = r_convec * (s_sink * s_sink) / ((s_spreader+height) * (s_spreader-width) / 4.0);
-	p->r_amb_c_per_y = r_convec * (s_sink * s_sink) / ((s_spreader+width) * (s_spreader-height) / 4.0);
-	p->r_amb_per = r_convec * (s_sink * s_sink) / ((s_sink*s_sink - s_spreader*s_spreader) / 4.0);
-	
-	/* lateral R's of package substrate, solder and PCB */
-	p->r_sub1_x = getr(K_SUB, (s_sub-width)/4.0, (s_sub+3*height)/4.0 * t_sub);
-	p->r_sub1_y = getr(K_SUB, (s_sub-height)/4.0, (s_sub+3*width)/4.0 * t_sub);
-	p->r_solder1_x = getr(K_SOLDER, (s_solder-width)/4.0, (s_solder+3*height)/4.0 * t_solder);
-	p->r_solder1_y = getr(K_SOLDER, (s_solder-height)/4.0, (s_solder+3*width)/4.0 * t_solder);
-	p->r_pcb1_x = getr(K_PCB, (s_solder-width)/4.0, (s_solder+3*height)/4.0 * t_pcb);
-	p->r_pcb1_y = getr(K_PCB, (s_solder-height)/4.0, (s_solder+3*width)/4.0 * t_pcb);
-	p->r_pcb2_x = getr(K_PCB, (s_solder-width)/4.0, (3*s_solder+height)/4.0 * t_pcb);
-	p->r_pcb2_y = getr(K_PCB, (s_solder-height)/4.0, (3*s_solder+width)/4.0 * t_pcb);
-	p->r_pcb = getr(K_PCB, (s_pcb-s_solder)/4.0, (s_pcb+3*s_solder)/4.0 * t_pcb);
-
-	/* vertical R's of package substrate, solder balls and PCB */
-	p->r_sub_per_x = getr(K_SUB, t_sub, (s_sub+height) * (s_sub-width) / 4.0);
-	p->r_sub_per_y = getr(K_SUB, t_sub, (s_sub+width) * (s_sub-height) / 4.0);
-	p->r_solder_per_x = getr(K_SOLDER, t_solder, (s_solder+height) * (s_solder-width) / 4.0);
-	p->r_solder_per_y = getr(K_SOLDER, t_solder, (s_solder+width) * (s_solder-height) / 4.0);
-	p->r_pcb_c_per_x = getr(K_PCB, t_pcb, (s_solder+height) * (s_solder-width) / 4.0);
-	p->r_pcb_c_per_y = getr(K_PCB, t_pcb, (s_solder+width) * (s_solder-height) / 4.0);
-	p->r_pcb_per = getr(K_PCB, t_pcb, (s_pcb*s_pcb - s_solder*s_solder) / 4.0);
-	
-	/* vertical R's to ambient at PCB (divide r_convec_sec proportional to area) */
-	p->r_amb_sec_c_per_x = r_convec_sec * (s_pcb * s_pcb) / ((s_solder+height) * (s_solder-width) / 4.0);
-	p->r_amb_sec_c_per_y = r_convec_sec * (s_pcb * s_pcb) / ((s_solder+width) * (s_solder-height) / 4.0);
-	p->r_amb_sec_per = r_convec_sec * (s_pcb * s_pcb) / ((s_pcb*s_pcb - s_solder*s_solder) / 4.0);
-}
-
-void populate_package_C(package_RC_t *p, thermal_config_t *config, double width, double height)
-{
-	double s_spreader = config->s_spreader;
-	double t_spreader = config->t_spreader;
-	double s_sink = config->s_sink;
-	double t_sink = config->t_sink;
-	double c_convec = config->c_convec;
-	
-	double s_sub = config->s_sub;
-	double t_sub = config->t_sub;
-	double s_solder = config->s_solder;
-	double t_solder = config->t_solder;
-	double s_pcb = config->s_pcb;
-	double t_pcb = config->t_pcb;
-	double c_convec_sec = config->c_convec_sec;
-	
-	double p_sink = config->p_sink;
-	double p_spreader = config->p_spreader;	
-
-	/* vertical C's of spreader and sink */
-	p->c_sp_per_x = getcap(p_spreader, t_spreader, (s_spreader+height) * (s_spreader-width) / 4.0);
-	p->c_sp_per_y = getcap(p_spreader, t_spreader, (s_spreader+width) * (s_spreader-height) / 4.0);
-	p->c_hs_c_per_x = getcap(p_sink, t_sink, (s_spreader+height) * (s_spreader-width) / 4.0);
-	p->c_hs_c_per_y = getcap(p_sink, t_sink, (s_spreader+width) * (s_spreader-height) / 4.0);
-	p->c_hs_per = getcap(p_sink, t_sink, (s_sink*s_sink - s_spreader*s_spreader) / 4.0);
-
-	/* vertical C's to ambient (divide c_convec proportional to area) */
-	p->c_amb_c_per_x = C_FACTOR * c_convec / (s_sink * s_sink) * ((s_spreader+height) * (s_spreader-width) / 4.0);
-	p->c_amb_c_per_y = C_FACTOR * c_convec / (s_sink * s_sink) * ((s_spreader+width) * (s_spreader-height) / 4.0);
-	p->c_amb_per = C_FACTOR * c_convec / (s_sink * s_sink) * ((s_sink*s_sink - s_spreader*s_spreader) / 4.0);
-	
-	/* vertical C's of package substrate, solder balls, and PCB */
-	p->c_sub_per_x = getcap(SPEC_HEAT_SUB, t_sub, (s_sub+height) * (s_sub-width) / 4.0);
-	p->c_sub_per_y = getcap(SPEC_HEAT_SUB, t_sub, (s_sub+width) * (s_sub-height) / 4.0);
-	p->c_solder_per_x = getcap(SPEC_HEAT_SOLDER, t_solder, (s_solder+height) * (s_solder-width) / 4.0);
-	p->c_solder_per_y = getcap(SPEC_HEAT_SOLDER, t_solder, (s_solder+width) * (s_solder-height) / 4.0);
-	p->c_pcb_c_per_x = getcap(SPEC_HEAT_PCB, t_pcb, (s_solder+height) * (s_solder-width) / 4.0);
-	p->c_pcb_c_per_y = getcap(SPEC_HEAT_PCB, t_pcb, (s_solder+width) * (s_solder-height) / 4.0);
-	p->c_pcb_per = getcap(SPEC_HEAT_PCB, t_pcb, (s_pcb*s_pcb - s_solder*s_solder) / 4.0);
-
-	/* vertical C's to ambient at PCB (divide c_convec_sec proportional to area) */
-	p->c_amb_sec_c_per_x = C_FACTOR * c_convec_sec / (s_pcb * s_pcb) * ((s_solder+height) * (s_solder-width) / 4.0);
-	p->c_amb_sec_c_per_y = C_FACTOR * c_convec_sec / (s_pcb * s_pcb) * ((s_solder+width) * (s_solder-height) / 4.0);
-	p->c_amb_sec_per = C_FACTOR * c_convec_sec / (s_pcb * s_pcb) * ((s_pcb*s_pcb - s_solder*s_solder) / 4.0);
-}
-
-/* debug print	*/
-void debug_print_package_RC(package_RC_t *p)
-{
-	fprintf(stdout, "printing package RC information...\n");
-	fprintf(stdout, "r_sp1_x: %f\tr_sp1_y: %f\n", p->r_sp1_x, p->r_sp1_y);
-	fprintf(stdout, "r_sp_per_x: %f\tr_sp_per_y: %f\n", p->r_sp_per_x, p->r_sp_per_y);
-	fprintf(stdout, "c_sp_per_x: %f\tc_sp_per_y: %f\n", p->c_sp_per_x, p->c_sp_per_y);
-	fprintf(stdout, "r_hs1_x: %f\tr_hs1_y: %f\n", p->r_hs1_x, p->r_hs1_y);
-	fprintf(stdout, "r_hs2_x: %f\tr_hs2_y: %f\n", p->r_hs2_x, p->r_hs2_y);
-	fprintf(stdout, "r_hs_c_per_x: %f\tr_hs_c_per_y: %f\n", p->r_hs_c_per_x, p->r_hs_c_per_y);
-	fprintf(stdout, "c_hs_c_per_x: %f\tc_hs_c_per_y: %f\n", p->c_hs_c_per_x, p->c_hs_c_per_y);
-	fprintf(stdout, "r_hs: %f\tr_hs_per: %f\n", p->r_hs, p->r_hs_per);
-	fprintf(stdout, "c_hs_per: %f\n", p->c_hs_per);
-	fprintf(stdout, "r_amb_c_per_x: %f\tr_amb_c_per_y: %f\n", p->r_amb_c_per_x, p->r_amb_c_per_y);
-	fprintf(stdout, "c_amb_c_per_x: %f\tc_amb_c_per_y: %f\n", p->c_amb_c_per_x, p->c_amb_c_per_y);
-	fprintf(stdout, "r_amb_per: %f\n", p->r_amb_per);
-	fprintf(stdout, "c_amb_per: %f\n", p->c_amb_per);
-	fprintf(stdout, "r_sub1_x: %f\tr_sub1_y: %f\n", p->r_sub1_x, p->r_sub1_y);
-	fprintf(stdout, "r_sub_per_x: %f\tr_sub_per_y: %f\n", p->r_sub_per_x, p->r_sub_per_y);
-	fprintf(stdout, "c_sub_per_x: %f\tc_sub_per_y: %f\n", p->c_sub_per_x, p->c_sub_per_y);
-	fprintf(stdout, "r_solder1_x: %f\tr_solder1_y: %f\n", p->r_solder1_x, p->r_solder1_y);
-	fprintf(stdout, "r_solder_per_x: %f\tr_solder_per_y: %f\n", p->r_solder_per_x, p->r_solder_per_y);
-	fprintf(stdout, "c_solder_per_x: %f\tc_solder_per_y: %f\n", p->c_solder_per_x, p->c_solder_per_y);
-	fprintf(stdout, "r_pcb1_x: %f\tr_pcb1_y: %f\n", p->r_pcb1_x, p->r_pcb1_y);
-	fprintf(stdout, "r_pcb2_x: %f\tr_pcb2_y: %f\n", p->r_pcb2_x, p->r_pcb2_y);
-	fprintf(stdout, "r_pcb_c_per_x: %f\tr_pcb_c_per_y: %f\n", p->r_pcb_c_per_x, p->r_pcb_c_per_y);
-	fprintf(stdout, "c_pcb_c_per_x: %f\tc_pcb_c_per_y: %f\n", p->c_pcb_c_per_x, p->c_pcb_c_per_y);
-	fprintf(stdout, "r_pcb: %f\tr_pcb_per: %f\n", p->r_pcb, p->r_pcb_per);
-	fprintf(stdout, "c_pcb_per: %f\n", p->c_pcb_per);
-	fprintf(stdout, "r_amb_sec_c_per_x: %f\tr_amb_sec_c_per_y: %f\n", p->r_amb_sec_c_per_x, p->r_amb_sec_c_per_y);
-	fprintf(stdout, "c_amb_sec_c_per_x: %f\tc_amb_sec_c_per_y: %f\n", p->c_amb_sec_c_per_x, p->c_amb_sec_c_per_y);
-	fprintf(stdout, "r_amb_sec_per: %f\n", p->r_amb_sec_per);
-	fprintf(stdout, "c_amb_sec_per: %f\n", p->c_amb_sec_per);
-}
-
-/* 
- * wrapper routines interfacing with those of the corresponding 
- * thermal model (block or grid)
- */
-
-/* 
- * allocate memory for the matrices. for the block model, placeholder 
- * can be an empty floorplan frame with only the names of the functional 
- * units. for the grid model, it is the default floorplan
- */
-RC_model_t *alloc_RC_model(thermal_config_t *config, flp_t *placeholder)
-{
-	RC_model_t *model= (RC_model_t *) calloc (1, sizeof(RC_model_t));
-	if (!model)
-		fatal("memory allocation error\n");
-	if(!(strcasecmp(config->model_type, BLOCK_MODEL_STR))) {
-		model->type = BLOCK_MODEL;
-		model->block = alloc_block_model(config, placeholder);
-		model->config = &model->block->config;
-	} else if(!(strcasecmp(config->model_type, GRID_MODEL_STR))) {
-		model->type = GRID_MODEL;
-		model->grid = alloc_grid_model(config, placeholder);
-		model->config = &model->grid->config;
-	} else 
-		fatal("unknown model type\n");
-	return model;	
-}
-
-/* populate the thermal restistance values */
-void populate_R_model(RC_model_t *model, flp_t *flp)
-{
-	if (model->type == BLOCK_MODEL)
-		populate_R_model_block(model->block, flp);
-	else if (model->type == GRID_MODEL)	
-		populate_R_model_grid(model->grid, flp);
-	else fatal("unknown model type\n");	
-}
-
-/* populate the thermal capacitance values */
-void populate_C_model(RC_model_t *model, flp_t *flp)
-{
-	if (model->type == BLOCK_MODEL)
-		populate_C_model_block(model->block, flp);
-	else if (model->type == GRID_MODEL)	
-		populate_C_model_grid(model->grid, flp);
-	else fatal("unknown model type\n");	
-}
-
-/* steady state temperature	*/
-void steady_state_temp(RC_model_t *model, double *power, double *temp) 
-{
-//	if (model->type == BLOCK_MODEL)
-//		steady_state_temp_block(model->block, power, temp);
-//	else if (model->type == GRID_MODEL)	
-//		steady_state_temp_grid(model->grid, power, temp);
-//	else fatal("unknown model type\n");	
-
-	int leak_convg_true = 0;
-	int leak_iter = 0;
-	int n, base=0;
-	//int idx=0;
-	double blk_height, blk_width;
-	int i, j, k;
-	
-	double *d_temp = NULL;
-	double *temp_old = NULL;
-	double *power_new = NULL;
-	double d_max=0.0;
-	
-	if (model->type == BLOCK_MODEL) {
-		n = model->block->flp->n_units;
-		if (model->config->leakage_used) { // if considering leakage-temperature loop
-			d_temp = hotspot_vector(model);
-			temp_old = hotspot_vector(model);
-			power_new = hotspot_vector(model);
-			for (leak_iter=0;(!leak_convg_true)&&(leak_iter<=LEAKAGE_MAX_ITER);leak_iter++){
-				for(i=0; i < n; i++) {
-					blk_height = model->block->flp->units[i].height;
-					blk_width = model->block->flp->units[i].width;
-					power_new[i] = power[i] + calc_leakage(model->config->leakage_mode,blk_height,blk_width,temp[i]);
-					temp_old[i] = temp[i]; //copy temp before update
-				}
-				steady_state_temp_block(model->block, power_new, temp); // update temperature
-				d_max = 0.0;
-				for(i=0; i < n; i++) {
-					d_temp[i] = temp[i] - temp_old[i]; //temperature increase due to leakage
-					if (d_temp[i]>d_max) {
-						d_max = d_temp[i];
-					}
-				}
-				if (d_max < LEAK_TOL) {// check convergence
-					leak_convg_true = 1;
-				}
-				if (d_max > TEMP_HIGH && leak_iter > 1) {// check to make sure d_max is not "nan" (esp. in natural convection)
-					fatal("temperature is too high, possible thermal runaway. Double-check power inputs and package settings.\n");
-				}
-			}
-			free(d_temp);
-			free(temp_old);
-			free(power_new);
-			/* if no convergence after max number of iterations, thermal runaway */
-			if (!leak_convg_true)
-				fatal("too many iterations before temperature-leakage convergence -- possible thermal runaway\n");
-		} else // if leakage-temperature loop is not considered
-			steady_state_temp_block(model->block, power, temp);
-	}
-	else if (model->type == GRID_MODEL)	{
-		if (model->config->leakage_used) { // if considering leakage-temperature loop
-			d_temp = hotspot_vector(model);
-			temp_old = hotspot_vector(model);
-			power_new = hotspot_vector(model);
-			for (leak_iter=0;(!leak_convg_true)&&(leak_iter<=LEAKAGE_MAX_ITER);leak_iter++){
-				for(k=0, base=0; k < model->grid->n_layers; k++) {
-					if(model->grid->layers[k].has_power)
-						for(j=0; j < model->grid->layers[k].flp->n_units; j++) {
-							blk_height = model->grid->layers[k].flp->units[j].height;
-							blk_width = model->grid->layers[k].flp->units[j].width;
-							power_new[base+j] = power[base+j] + calc_leakage(model->config->leakage_mode,blk_height,blk_width,temp[base+j]);
-							temp_old[base+j] = temp[base+j]; //copy temp before update
-						}
-					base += model->grid->layers[k].flp->n_units;	
-				}
-				steady_state_temp_grid(model->grid, power_new, temp);
-				d_max = 0.0;
-				for(k=0, base=0; k < model->grid->n_layers; k++) {
-					if(model->grid->layers[k].has_power)
-						for(j=0; j < model->grid->layers[k].flp->n_units; j++) {
-							d_temp[base+j] = temp[base+j] - temp_old[base+j]; //temperature increase due to leakage
-							if (d_temp[base+j]>d_max)
-								d_max = d_temp[base+j];
-						}
-					base += model->grid->layers[k].flp->n_units;	
-				}
-				if (d_max < LEAK_TOL) {// check convergence
-					leak_convg_true = 1;
-				}
-				if (d_max > TEMP_HIGH && leak_iter > 0) {// check to make sure d_max is not "nan" (esp. in natural convection)
-					fatal("temperature is too high, possible thermal runaway. Double-check power inputs and package settings.\n");
-				}
-			}
-			free(d_temp);
-			free(temp_old);
-			free(power_new);
-			/* if no convergence after max number of iterations, thermal runaway */
-			if (!leak_convg_true)
-				fatal("too many iterations before temperature-leakage convergence -- possible thermal runaway\n");			
-		} else // if leakage-temperature loop is not considered
-			steady_state_temp_grid(model->grid, power, temp);
-	}
-	else fatal("unknown model type\n");	
-}
-
-/* transient (instantaneous) temperature	*/
-void compute_temp(RC_model_t *model, double *power, double *temp, double time_elapsed)
-{
-	if (model->type == BLOCK_MODEL)
-		compute_temp_block(model->block, power, temp, time_elapsed);
-	else if (model->type == GRID_MODEL)	
-		compute_temp_grid(model->grid, power, temp, time_elapsed);
-	else fatal("unknown model type\n");	
-}
-
-/* differs from 'dvector()' in that memory for internal nodes is also allocated	*/
-double *hotspot_vector(RC_model_t *model)
-{
-	if (model->type == BLOCK_MODEL)
-		return hotspot_vector_block(model->block);
-	else if (model->type == GRID_MODEL)	
-		return hotspot_vector_grid(model->grid);
-	else fatal("unknown model type\n");	
-	return NULL;
-}
-
-/* copy 'src' to 'dst' except for a window of 'size'
- * elements starting at 'at'. useful in floorplan
- * compaction
- */
-void trim_hotspot_vector(RC_model_t *model, double *dst, double *src, 
-						 int at, int size)
-{
-	if (model->type == BLOCK_MODEL)
-		trim_hotspot_vector_block(model->block, dst, src, at, size);
-	else if (model->type == GRID_MODEL)	
-		trim_hotspot_vector_grid(model->grid, dst, src, at, size);
-	else fatal("unknown model type\n");	
-}
-
-/* update the model's node count	*/						 
-void resize_thermal_model(RC_model_t *model, int n_units)
-{
-	if (model->type == BLOCK_MODEL)
-		resize_thermal_model_block(model->block, n_units);
-	else if (model->type == GRID_MODEL)	
-		resize_thermal_model_grid(model->grid, n_units);
-	else fatal("unknown model type\n");	
-}
-
-/* sets the temperature of a vector 'temp' allocated using 'hotspot_vector'	*/
-void set_temp(RC_model_t *model, double *temp, double val)
-{
-	if (model->type == BLOCK_MODEL)
-		set_temp_block(model->block, temp, val);
-	else if (model->type == GRID_MODEL)	
-		set_temp_grid(model->grid, temp, val);
-	else fatal("unknown model type\n");	
-}
-
-/* dump temperature vector alloced using 'hotspot_vector' to 'file' */ 
-void dump_temp(RC_model_t *model, double *temp, char *file)
-{
-	if (model->type == BLOCK_MODEL)
-		dump_temp_block(model->block, temp, file);
-	else if (model->type == GRID_MODEL)	
-		dump_temp_grid(model->grid, temp, file);
-	else fatal("unknown model type\n");	
-}
-
-/* calculate average heatsink temperature for natural convection package */ 
-double calc_sink_temp(RC_model_t *model, double *temp)
-{
-	if (model->type == BLOCK_MODEL)
-		return calc_sink_temp_block(model->block, temp, model->config);
-	else if (model->type == GRID_MODEL)	
-		return calc_sink_temp_grid(model->grid, temp, model->config);
-	else fatal("unknown model type\n");	
-	return 0.0;
-}
-
-/* copy temperature vector from src to dst */ 
-void copy_temp(RC_model_t *model, double *dst, double *src)
-{
-	if (model->type == BLOCK_MODEL)
-		copy_temp_block(model->block, dst, src);
-	else if (model->type == GRID_MODEL)	
-		copy_temp_grid(model->grid, dst, src);
-	else fatal("unknown model type\n");	
-}
-
-/* 
- * read temperature vector alloced using 'hotspot_vector' from 'file'
- * which was dumped using 'dump_temp'. values are clipped to thermal
- * threshold based on 'clip'
- */ 
-void read_temp(RC_model_t *model, double *temp, char *file, int clip)
-{
-	if (model->type == BLOCK_MODEL)
-		read_temp_block(model->block, temp, file, clip);
-	else if (model->type == GRID_MODEL)	
-		read_temp_grid(model->grid, temp, file, clip);
-	else fatal("unknown model type\n");	
-}
-
-/* dump power numbers to file	*/
-void dump_power(RC_model_t *model, double *power, char *file)
-{
-	if (model->type == BLOCK_MODEL)
-		dump_power_block(model->block, power, file);
-	else if (model->type == GRID_MODEL)	
-		dump_power_grid(model->grid, power, file);
-	else fatal("unknown model type\n");	
-}
-
-/* 
- * read power vector alloced using 'hotspot_vector' from 'file'
- * which was dumped using 'dump_power'. 
- */ 
-void read_power (RC_model_t *model, double *power, char *file)
-{
-	if (model->type == BLOCK_MODEL)
-		read_power_block(model->block, power, file);
-	else if (model->type == GRID_MODEL)	
-		read_power_grid(model->grid, power, file);
-	else fatal("unknown model type\n");	
-}
-
-/* peak temperature on chip	*/
-double find_max_temp(RC_model_t *model, double *temp)
-{
-	if (model->type == BLOCK_MODEL)
-		return find_max_temp_block(model->block, temp);
-	else if (model->type == GRID_MODEL)	
-		return find_max_temp_grid(model->grid, temp);
-	else fatal("unknown model type\n");	
-	return 0.0;
-}
-
-/* average temperature on chip	*/
-double find_avg_temp(RC_model_t *model, double *temp)
-{
-	if (model->type == BLOCK_MODEL)
-		return find_avg_temp_block(model->block, temp);
-	else if (model->type == GRID_MODEL)	
-		return find_avg_temp_grid(model->grid, temp);
-	else fatal("unknown model type\n");	
-	return 0.0;
-}
-
-/* debug print	*/
-void debug_print_model(RC_model_t *model)
-{
-	if (model->type == BLOCK_MODEL)
-		debug_print_block(model->block);
-	else if (model->type == GRID_MODEL)	
-		debug_print_grid(model->grid);
-	else fatal("unknown model type\n");	
-}
-
-/* calculate temperature-dependent leakage power */
-/* will support HotLeakage in future releases */
-double calc_leakage(int mode, double h, double w, double temp)
-{
-	/* a simple leakage model.
-	 * Be aware -- this model may not be accurate in some cases.
-	 * You may want to use your own temperature-dependent leakage model here.
-	 */ 
-	double leak_alpha = 1.5e+4;
-	double leak_beta = 0.036;
-	double leak_Tbase = 383.15; /* 110C according to the above paper */
-
-	double leakage_power;
-	
-	if (mode)
-		fatal("HotLeakage currently is not implemented in this release of HotSpot, please check back later.\n");
-		
-	leakage_power = leak_alpha*h*w*exp(leak_beta*(temp-leak_Tbase));
-	return leakage_power;	
-}
-
-/* destructor */
-void delete_RC_model(RC_model_t *model)
-{
-	if (model->type == BLOCK_MODEL)
-		delete_block_model(model->block);
-	else if (model->type == GRID_MODEL)	
-		delete_grid_model(model->grid);
-	else fatal("unknown model type\n");	
-	free(model);
-}
diff -Naur temp/temperature.cc HotSpot/temperature.cc
--- temp/temperature.cc	1970-01-01 01:00:00.000000000 +0100
+++ HotSpot/temperature.cc	2017-11-20 09:59:35.312820617 +0100
@@ -0,0 +1,894 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#ifdef _MSC_VER
+#define strcasecmp    _stricmp
+#define strncasecmp   _strnicmp
+#else
+#include <strings.h>
+#endif
+#include <math.h>
+
+#include "temperature.h"
+#include "temperature_block.h"
+#include "temperature_grid.h"
+#include "flp.h"
+#include "util.h"
+
+/* default thermal configuration parameters	*/
+thermal_config_t default_thermal_config(void)
+{
+	thermal_config_t config;
+
+	/* chip specs	*/
+	config.t_chip = 0.15e-3;			/* chip thickness in meters	*/
+	config.k_chip = 100.0; /* chip thermal conductivity in W/(m-K) */
+	config.p_chip = 1.75e6; /* chip specific heat in J/(m^3-K) */
+	/* temperature threshold for DTM (Kelvin)*/
+	config.thermal_threshold = 81.8 + 273.15;
+
+	/* heat sink specs	*/
+	config.c_convec = 140.4;			/* convection capacitance in J/K */
+	config.r_convec = 0.1;				/* convection resistance in K/W	*/
+	config.s_sink = 60e-3;				/* heatsink side in m	*/
+	config.t_sink = 6.9e-3; 			/* heatsink thickness  in m	*/
+	config.k_sink = 400.0; /* heatsink thermal conductivity in W/(m-K) */
+	config.p_sink = 3.55e6; /* heatsink specific heat in J/(m^3-K) */
+	
+
+	/* heat spreader specs	*/
+	config.s_spreader = 30e-3;			/* spreader side in m	*/
+	config.t_spreader = 1e-3;			/* spreader thickness in m	*/
+	config.k_spreader = 400.0; /* heat spreader thermal conductivity in W/(m-K) */
+	config.p_spreader = 3.55e6; /* heat spreader specific heat in J/(m^3-K) */
+
+	/* interface material specs	*/
+	config.t_interface = 20e-6;			/* interface material thickness in m */
+	config.k_interface = 4.0; /* interface material thermal conductivity in W/(m-K) */
+	config.p_interface = 4.0e6; /* interface material specific heat in J/(m^3-K) */
+	
+	/* secondary heat transfer path */
+	config.model_secondary = FALSE;
+	config.r_convec_sec = 1.0;
+	config.c_convec_sec = 140.4; //FIXME! need updated value.
+	config.n_metal = 8;
+	config.t_metal = 10.0e-6;
+	config.t_c4 = 0.0001;
+	config.s_c4 = 20.0e-6;
+	config.n_c4 = 400;
+	config.s_sub = 0.021;
+	config.t_sub = 0.001;
+	config.s_solder = 0.021;
+	config.t_solder = 0.00094;
+	config.s_pcb = 0.1;
+	config.t_pcb = 0.002;
+	
+	/* others	*/
+	config.ambient = 45 + 273.15;		/* in kelvin	*/
+	/* initial temperatures	from file	*/
+	strcpy(config.init_file, NULLFILE);	
+	config.init_temp = 60 + 273.15;		/* in Kelvin	*/
+	/* steady state temperatures to file	*/
+	strcpy(config.steady_file, NULLFILE);
+ 	/* 3.33 us sampling interval = 10K cycles at 3GHz	*/
+	config.sampling_intvl = 3.333e-6;
+	config.base_proc_freq = 3e9;		/* base processor frequency in Hz	*/
+	config.dtm_used = FALSE;			/* set accordingly	*/
+	
+	config.leakage_used = 0;
+	config.leakage_mode = 0;
+	
+	config.package_model_used = 0;
+	strcpy(config.package_config_file, NULLFILE);	
+	
+	/* set block model as default	*/
+	strcpy(config.model_type, BLOCK_MODEL_STR);
+
+	/* block model specific parameters	*/
+	config.block_omit_lateral = FALSE;	/* omit lateral chip resistances?	*/
+
+	/* grid model specific parameters	*/
+	config.grid_rows = 64;				/* grid resolution - no. of rows	*/
+	config.grid_cols = 64;				/* grid resolution - no. of cols	*/
+	/* layer configuration from	file */
+	strcpy(config.grid_layer_file, NULLFILE);
+	/* output steady state grid temperatures apart from block temperatures */
+	strcpy(config.grid_steady_file, NULLFILE);
+	/* 
+	 * mapping mode between block and grid models.
+	 * default: use the temperature of the center
+	 * grid cell as that of the entire block
+	 */
+	strcpy(config.grid_map_mode, GRID_CENTER_STR);
+
+	return config;
+}
+
+/* 
+ * parse a table of name-value string pairs and add the configuration
+ * parameters to 'config'
+ */
+void thermal_config_add_from_strs(thermal_config_t *config, str_pair *table, int size)
+{
+	int idx;
+	if ((idx = get_str_index(table, size, (char*)"t_chip")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->t_chip) != 1)
+			fatal((char*)"invalid format for configuration  parameter t_chip\n");
+	if ((idx = get_str_index(table, size, (char*)"k_chip")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->k_chip) != 1)
+			fatal((char*)"invalid format for configuration  parameter k_chip\n");
+	if ((idx = get_str_index(table, size, (char*)"p_chip")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->p_chip) != 1)
+			fatal((char*)"invalid format for configuration  parameter p_chip\n");
+	if ((idx = get_str_index(table, size, (char*)"thermal_threshold")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->thermal_threshold) != 1)
+			fatal((char*)"invalid format for configuration  parameter thermal_threshold\n");
+	if ((idx = get_str_index(table, size, (char*)"c_convec")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->c_convec) != 1)
+			fatal((char*)"invalid format for configuration  parameter c_convec\n");
+	if ((idx = get_str_index(table, size, (char*)"r_convec")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->r_convec) != 1)
+			fatal((char*)"invalid format for configuration  parameter r_convec\n");
+	if ((idx = get_str_index(table, size, (char*)"s_sink")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->s_sink) != 1)
+			fatal((char*)"invalid format for configuration  parameter s_sink\n");
+	if ((idx = get_str_index(table, size, (char*)"t_sink")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->t_sink) != 1)
+			fatal((char*)"invalid format for configuration  parameter t_sink\n");
+	if ((idx = get_str_index(table, size, (char*)"k_sink")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->k_sink) != 1)
+			fatal((char*)"invalid format for configuration  parameter k_sink\n");
+	if ((idx = get_str_index(table, size, (char*)"p_sink")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->p_sink) != 1)
+			fatal((char*)"invalid format for configuration  parameter p_sink\n");
+	if ((idx = get_str_index(table, size, (char*)"s_spreader")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->s_spreader) != 1)
+			fatal((char*)"invalid format for configuration  parameter s_spreader\n");
+	if ((idx = get_str_index(table, size, (char*)"t_spreader")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->t_spreader) != 1)
+			fatal((char*)"invalid format for configuration  parameter t_spreader\n");
+	if ((idx = get_str_index(table, size, (char*)"k_spreader")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->k_spreader) != 1)
+			fatal((char*)"invalid format for configuration  parameter k_spreader\n");
+	if ((idx = get_str_index(table, size, (char*)"p_spreader")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->p_spreader) != 1)
+			fatal((char*)"invalid format for configuration  parameter p_spreader\n");
+	if ((idx = get_str_index(table, size, (char*)"t_interface")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->t_interface) != 1)
+			fatal((char*)"invalid format for configuration  parameter t_interface\n");
+	if ((idx = get_str_index(table, size, (char*)"k_interface")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->k_interface) != 1)
+			fatal((char*)"invalid format for configuration  parameter k_interface\n");
+	if ((idx = get_str_index(table, size, (char*)"p_interface")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->p_interface) != 1)
+			fatal((char*)"invalid format for configuration  parameter p_interface\n");
+	if ((idx = get_str_index(table, size, (char*)"model_secondary")) >= 0)
+		if(sscanf(table[idx].value, "%d", &config->model_secondary) != 1)
+			fatal((char*)"invalid format for configuration  parameter model_secondary\n");
+	if ((idx = get_str_index(table, size, (char*)"r_convec_sec")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->r_convec_sec) != 1)
+			fatal((char*)"invalid format for configuration  parameter r_convec_sec\n");
+	if ((idx = get_str_index(table, size, (char*)"c_convec_sec")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->c_convec_sec) != 1)
+			fatal((char*)"invalid format for configuration  parameter c_convec_sec\n");
+	if ((idx = get_str_index(table, size, (char*)"n_metal")) >= 0)
+		if(sscanf(table[idx].value, "%d", &config->n_metal) != 1)
+			fatal((char*)"invalid format for configuration  parameter n_metal\n");
+	if ((idx = get_str_index(table, size, (char*)"t_metal")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->t_metal) != 1)
+			fatal((char*)"invalid format for configuration  parameter t_metal\n");
+	if ((idx = get_str_index(table, size, (char*)"t_c4")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->t_c4) != 1)
+			fatal((char*)"invalid format for configuration  parameter t_c4\n");
+	if ((idx = get_str_index(table, size, (char*)"s_c4")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->s_c4) != 1)
+			fatal((char*)"invalid format for configuration  parameter s_c4\n");
+	if ((idx = get_str_index(table, size, (char*)"n_c4")) >= 0)
+		if(sscanf(table[idx].value, "%d", &config->n_c4) != 1)
+			fatal((char*)"invalid format for configuration  parameter n_c4\n");
+	if ((idx = get_str_index(table, size, (char*)"s_sub")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->s_sub) != 1)
+			fatal((char*)"invalid format for configuration  parameter s_sub\n");
+	if ((idx = get_str_index(table, size, (char*)"t_sub")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->t_sub) != 1)
+			fatal((char*)"invalid format for configuration  parameter t_sub\n");
+	if ((idx = get_str_index(table, size, (char*)"s_solder")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->s_solder) != 1)
+			fatal((char*)"invalid format for configuration  parameter s_solder\n");
+	if ((idx = get_str_index(table, size, (char*)"t_solder")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->t_solder) != 1)
+			fatal((char*)"invalid format for configuration  parameter t_solder\n");
+	if ((idx = get_str_index(table, size, (char*)"s_pcb")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->s_pcb) != 1)
+			fatal((char*)"invalid format for configuration  parameter s_pcb\n");
+	if ((idx = get_str_index(table, size, (char*)"t_pcb")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->t_pcb) != 1)
+			fatal((char*)"invalid format for configuration  parameter t_pcb\n");
+	if ((idx = get_str_index(table, size, (char*)"ambient")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->ambient) != 1)
+			fatal((char*)"invalid format for configuration  parameter ambient\n");
+	if ((idx = get_str_index(table, size, (char*)"init_file")) >= 0)
+		if(sscanf(table[idx].value, "%s", config->init_file) != 1)
+			fatal((char*)"invalid format for configuration  parameter init_file\n");
+	if ((idx = get_str_index(table, size, (char*)"init_temp")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->init_temp) != 1)
+			fatal((char*)"invalid format for configuration  parameter init_temp\n");
+	if ((idx = get_str_index(table, size, (char*)"steady_file")) >= 0)
+		if(sscanf(table[idx].value, "%s", config->steady_file) != 1)
+			fatal((char*)"invalid format for configuration  parameter steady_file\n");
+	if ((idx = get_str_index(table, size, (char*)"sampling_intvl")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->sampling_intvl) != 1)
+			fatal((char*)"invalid format for configuration  parameter sampling_intvl\n");
+	if ((idx = get_str_index(table, size, (char*)"base_proc_freq")) >= 0)
+		if(sscanf(table[idx].value, "%lf", &config->base_proc_freq) != 1)
+			fatal((char*)"invalid format for configuration  parameter base_proc_freq\n");
+	if ((idx = get_str_index(table, size, (char*)"dtm_used")) >= 0)
+		if(sscanf(table[idx].value, "%d", &config->dtm_used) != 1)
+			fatal((char*)"invalid format for configuration  parameter dtm_used\n");
+	if ((idx = get_str_index(table, size, (char*)"model_type")) >= 0)
+		if(sscanf(table[idx].value, "%s", config->model_type) != 1)
+			fatal((char*)"invalid format for configuration  parameter model_type\n");
+		if ((idx = get_str_index(table, size, (char*)"leakage_used")) >= 0)
+		if(sscanf(table[idx].value, "%d", &config->leakage_used) != 1)
+			fatal((char*)"invalid format for configuration  parameter leakage_used\n");
+	if ((idx = get_str_index(table, size, (char*)"leakage_mode")) >= 0)
+		if(sscanf(table[idx].value, "%d", &config->leakage_mode) != 1)
+			fatal((char*)"invalid format for configuration  parameter leakage_mode\n");
+	if ((idx = get_str_index(table, size, (char*)"package_model_used")) >= 0)
+		if(sscanf(table[idx].value, "%d", &config->package_model_used) != 1)
+			fatal((char*)"invalid format for configuration  parameter package_model_used\n");
+	if ((idx = get_str_index(table, size, (char*)"package_config_file")) >= 0)
+		if(sscanf(table[idx].value, "%s", config->package_config_file) != 1)
+			fatal((char*)"invalid format for configuration  parameter package_config_file\n");
+	if ((idx = get_str_index(table, size, (char*)"block_omit_lateral")) >= 0)
+		if(sscanf(table[idx].value, "%d", &config->block_omit_lateral) != 1)
+			fatal((char*)"invalid format for configuration  parameter block_omit_lateral\n");
+	if ((idx = get_str_index(table, size, (char*)"grid_rows")) >= 0)
+		if(sscanf(table[idx].value, "%d", &config->grid_rows) != 1)
+			fatal((char*)"invalid format for configuration  parameter grid_rows\n");
+	if ((idx = get_str_index(table, size, (char*)"grid_cols")) >= 0)
+		if(sscanf(table[idx].value, "%d", &config->grid_cols) != 1)
+			fatal((char*)"invalid format for configuration  parameter grid_cols\n");
+	if ((idx = get_str_index(table, size, (char*)"grid_layer_file")) >= 0)
+		if(sscanf(table[idx].value, "%s", config->grid_layer_file) != 1)
+			fatal((char*)"invalid format for configuration  parameter grid_layer_file\n");
+	if ((idx = get_str_index(table, size, (char*)"grid_steady_file")) >= 0)
+		if(sscanf(table[idx].value, "%s", config->grid_steady_file) != 1)
+			fatal((char*)"invalid format for configuration  parameter grid_steady_file\n");
+	if ((idx = get_str_index(table, size, (char*)"grid_map_mode")) >= 0)
+		if(sscanf(table[idx].value, "%s", config->grid_map_mode) != 1)
+			fatal((char*)"invalid format for configuration  parameter grid_map_mode\n");
+	
+	if ((config->t_chip <= 0) || (config->s_sink <= 0) || (config->t_sink <= 0) || 
+		(config->s_spreader <= 0) || (config->t_spreader <= 0) || 
+		(config->t_interface <= 0))
+		fatal((char*)"chip and package dimensions should be greater than zero\n");
+	if ((config->t_metal <= 0) || (config->n_metal <= 0) || (config->t_c4 <= 0) || 
+		(config->s_c4 <= 0) || (config->n_c4 <= 0) || (config->s_sub <= 0) || (config->t_sub <= 0) ||
+		(config->s_solder <= 0) || (config->t_solder <= 0) || (config->s_pcb <= 0) ||
+		(config->t_solder <= 0) || (config->r_convec_sec <= 0) || (config->c_convec_sec <= 0))
+		fatal((char*)"secondary heat tranfer layer dimensions should be greater than zero\n");
+	/* leakage iteration is not supported in transient mode in this release */
+	if (config->leakage_used == 1) {
+		printf("Warning: transient leakage iteration is not supported in this release...\n");
+		printf(" ...all transient results are without thermal-leakage loop.\n");
+	}		
+	if ((config->model_secondary == 1) && (!strcasecmp(config->model_type, BLOCK_MODEL_STR)))
+		fatal((char*)"secondary heat tranfer path is supported only in the grid mode\n");
+	if ((config->thermal_threshold < 0) || (config->c_convec < 0) || 
+		(config->r_convec < 0) || (config->ambient < 0) || 
+		(config->base_proc_freq <= 0) || (config->sampling_intvl <= 0))
+		fatal((char*)"invalid thermal simulation parameters\n");
+	if (strcasecmp(config->model_type, BLOCK_MODEL_STR) &&
+		strcasecmp(config->model_type, GRID_MODEL_STR))
+		fatal((char*)"invalid model type. use 'block' or 'grid'\n");
+	if(config->grid_rows <= 0 || config->grid_cols <= 0 ||
+	   (config->grid_rows & (config->grid_rows-1)) ||
+	   (config->grid_cols & (config->grid_cols-1)))
+		fatal((char*)"grid rows and columns should both be powers of two\n");
+	if (strcasecmp(config->grid_map_mode, GRID_AVG_STR) &&
+		strcasecmp(config->grid_map_mode, GRID_MIN_STR) &&
+		strcasecmp(config->grid_map_mode, GRID_MAX_STR) &&
+		strcasecmp(config->grid_map_mode, GRID_CENTER_STR))
+		fatal((char*)"invalid mapping mode. use 'avg', 'min', 'max' or 'center'\n");
+}
+
+/* 
+ * convert config into a table of name-value pairs. returns the no.
+ * of parameters converted
+ */
+int thermal_config_to_strs(thermal_config_t *config, str_pair *table, int max_entries)
+{
+	if (max_entries < 49)
+		fatal((char*)"not enough entries in table\n");
+
+	sprintf(table[0].name, "t_chip");
+	sprintf(table[1].name, "k_chip");
+	sprintf(table[2].name, "p_chip");
+	sprintf(table[3].name, "thermal_threshold");
+	sprintf(table[4].name, "c_convec");
+	sprintf(table[5].name, "r_convec");
+	sprintf(table[6].name, "s_sink");
+	sprintf(table[7].name, "t_sink");
+	sprintf(table[8].name, "k_sink");
+	sprintf(table[9].name, "p_sink");
+	sprintf(table[10].name, "s_spreader");
+	sprintf(table[11].name, "t_spreader");
+	sprintf(table[12].name, "k_spreader");
+	sprintf(table[13].name, "p_spreader");
+	sprintf(table[14].name, "t_interface");
+	sprintf(table[15].name, "k_interface");
+	sprintf(table[16].name, "p_interface");
+	sprintf(table[17].name, "model_secondary");
+	sprintf(table[18].name, "r_convec_sec");
+	sprintf(table[19].name, "c_convec_sec");
+	sprintf(table[20].name, "n_metal");
+	sprintf(table[21].name, "t_metal");
+	sprintf(table[22].name, "t_c4");
+	sprintf(table[23].name, "s_c4");
+	sprintf(table[24].name, "n_c4");
+	sprintf(table[25].name, "s_sub");
+	sprintf(table[26].name, "t_sub");
+	sprintf(table[27].name, "s_solder");
+	sprintf(table[28].name, "t_solder");
+	sprintf(table[29].name, "s_pcb");
+	sprintf(table[30].name, "t_pcb");
+	sprintf(table[31].name, "ambient");
+	sprintf(table[32].name, "init_file");
+	sprintf(table[33].name, "init_temp");
+	sprintf(table[34].name, "steady_file");
+	sprintf(table[35].name, "sampling_intvl");
+	sprintf(table[36].name, "base_proc_freq");
+	sprintf(table[37].name, "dtm_used");
+	sprintf(table[38].name, "model_type");
+	sprintf(table[39].name, "leakage_used");
+	sprintf(table[40].name, "leakage_mode");
+	sprintf(table[41].name, "package_model_used");
+	sprintf(table[42].name, "package_config_file");
+	sprintf(table[43].name, "block_omit_lateral");
+	sprintf(table[44].name, "grid_rows");
+	sprintf(table[45].name, "grid_cols");
+	sprintf(table[46].name, "grid_layer_file");
+	sprintf(table[47].name, "grid_steady_file");
+	sprintf(table[48].name, "grid_map_mode");
+
+	sprintf(table[0].value, "%lg", config->t_chip);
+	sprintf(table[1].value, "%lg", config->k_chip);
+	sprintf(table[2].value, "%lg", config->p_chip);
+	sprintf(table[3].value, "%lg", config->thermal_threshold);
+	sprintf(table[4].value, "%lg", config->c_convec);
+	sprintf(table[5].value, "%lg", config->r_convec);
+	sprintf(table[6].value, "%lg", config->s_sink);
+	sprintf(table[7].value, "%lg", config->t_sink);
+	sprintf(table[8].value, "%lg", config->k_sink);
+	sprintf(table[9].value, "%lg", config->p_sink);
+	sprintf(table[10].value, "%lg", config->s_spreader);
+	sprintf(table[11].value, "%lg", config->t_spreader);
+	sprintf(table[12].value, "%lg", config->k_spreader);
+	sprintf(table[13].value, "%lg", config->p_spreader);
+	sprintf(table[14].value, "%lg", config->t_interface);
+	sprintf(table[15].value, "%lg", config->k_interface);
+	sprintf(table[16].value, "%lg", config->p_interface);
+	sprintf(table[17].value, "%d", config->model_secondary);
+	sprintf(table[18].value, "%lg", config->r_convec_sec);
+	sprintf(table[19].value, "%lg", config->c_convec_sec);
+	sprintf(table[20].value, "%d", config->n_metal);
+	sprintf(table[21].value, "%lg", config->t_metal);
+	sprintf(table[22].value, "%lg", config->t_c4);
+	sprintf(table[23].value, "%lg", config->s_c4);
+	sprintf(table[24].value, "%d", config->n_c4);
+	sprintf(table[25].value, "%lg", config->s_sub);
+	sprintf(table[26].value, "%lg", config->t_sub);
+	sprintf(table[27].value, "%lg", config->s_solder);
+	sprintf(table[28].value, "%lg", config->t_solder);
+	sprintf(table[29].value, "%lg", config->s_pcb);
+	sprintf(table[30].value, "%lg", config->t_pcb);
+	sprintf(table[31].value, "%lg", config->ambient);
+	sprintf(table[32].value, "%s", config->init_file);
+	sprintf(table[33].value, "%lg", config->init_temp);
+	sprintf(table[34].value, "%s", config->steady_file);
+	sprintf(table[35].value, "%lg", config->sampling_intvl);
+	sprintf(table[36].value, "%lg", config->base_proc_freq);
+	sprintf(table[37].value, "%d", config->dtm_used);
+	sprintf(table[38].value, "%s", config->model_type);
+	sprintf(table[39].value, "%d", config->leakage_used);
+	sprintf(table[40].value, "%d", config->leakage_mode);
+	sprintf(table[41].value, "%d", config->package_model_used);
+	sprintf(table[42].value, "%s", config->package_config_file);
+	sprintf(table[43].value, "%d", config->block_omit_lateral);
+	sprintf(table[44].value, "%d", config->grid_rows);
+	sprintf(table[45].value, "%d", config->grid_cols);
+	sprintf(table[46].value, "%s", config->grid_layer_file);
+	sprintf(table[47].value, "%s", config->grid_steady_file);
+	sprintf(table[48].value, "%s", config->grid_map_mode);
+
+	return 49;
+}
+
+/* package parameter routines	*/
+void populate_package_R(package_RC_t *p, thermal_config_t *config, double width, double height)
+{
+	double s_spreader = config->s_spreader;
+	double t_spreader = config->t_spreader;
+	double s_sink = config->s_sink;
+	double t_sink = config->t_sink;
+	double r_convec = config->r_convec;
+	
+	double s_sub = config->s_sub;
+	double t_sub = config->t_sub;
+	double s_solder = config->s_solder;
+	double t_solder = config->t_solder;
+	double s_pcb = config->s_pcb;
+	double t_pcb = config->t_pcb;
+	double r_convec_sec = config->r_convec_sec;
+	
+	double k_sink = config->k_sink;
+	double k_spreader = config->k_spreader;
+ 
+
+	/* lateral R's of spreader and sink */
+	p->r_sp1_x = getr(k_spreader, (s_spreader-width)/4.0, (s_spreader+3*height)/4.0 * t_spreader);
+	p->r_sp1_y = getr(k_spreader, (s_spreader-height)/4.0, (s_spreader+3*width)/4.0 * t_spreader);
+	p->r_hs1_x = getr(k_sink, (s_spreader-width)/4.0, (s_spreader+3*height)/4.0 * t_sink);
+	p->r_hs1_y = getr(k_sink, (s_spreader-height)/4.0, (s_spreader+3*width)/4.0 * t_sink);
+	p->r_hs2_x = getr(k_sink, (s_spreader-width)/4.0, (3*s_spreader+height)/4.0 * t_sink);
+	p->r_hs2_y = getr(k_sink, (s_spreader-height)/4.0, (3*s_spreader+width)/4.0 * t_sink);
+	p->r_hs = getr(k_sink, (s_sink-s_spreader)/4.0, (s_sink+3*s_spreader)/4.0 * t_sink);
+
+	/* vertical R's of spreader and sink */
+	p->r_sp_per_x = getr(k_spreader, t_spreader, (s_spreader+height) * (s_spreader-width) / 4.0);
+	p->r_sp_per_y = getr(k_spreader, t_spreader, (s_spreader+width) * (s_spreader-height) / 4.0);
+	p->r_hs_c_per_x = getr(k_sink, t_sink, (s_spreader+height) * (s_spreader-width) / 4.0);
+	p->r_hs_c_per_y = getr(k_sink, t_sink, (s_spreader+width) * (s_spreader-height) / 4.0);
+	p->r_hs_per = getr(k_sink, t_sink, (s_sink*s_sink - s_spreader*s_spreader) / 4.0);
+	
+	/* vertical R's to ambient (divide r_convec proportional to area) */
+	p->r_amb_c_per_x = r_convec * (s_sink * s_sink) / ((s_spreader+height) * (s_spreader-width) / 4.0);
+	p->r_amb_c_per_y = r_convec * (s_sink * s_sink) / ((s_spreader+width) * (s_spreader-height) / 4.0);
+	p->r_amb_per = r_convec * (s_sink * s_sink) / ((s_sink*s_sink - s_spreader*s_spreader) / 4.0);
+	
+	/* lateral R's of package substrate, solder and PCB */
+	p->r_sub1_x = getr(K_SUB, (s_sub-width)/4.0, (s_sub+3*height)/4.0 * t_sub);
+	p->r_sub1_y = getr(K_SUB, (s_sub-height)/4.0, (s_sub+3*width)/4.0 * t_sub);
+	p->r_solder1_x = getr(K_SOLDER, (s_solder-width)/4.0, (s_solder+3*height)/4.0 * t_solder);
+	p->r_solder1_y = getr(K_SOLDER, (s_solder-height)/4.0, (s_solder+3*width)/4.0 * t_solder);
+	p->r_pcb1_x = getr(K_PCB, (s_solder-width)/4.0, (s_solder+3*height)/4.0 * t_pcb);
+	p->r_pcb1_y = getr(K_PCB, (s_solder-height)/4.0, (s_solder+3*width)/4.0 * t_pcb);
+	p->r_pcb2_x = getr(K_PCB, (s_solder-width)/4.0, (3*s_solder+height)/4.0 * t_pcb);
+	p->r_pcb2_y = getr(K_PCB, (s_solder-height)/4.0, (3*s_solder+width)/4.0 * t_pcb);
+	p->r_pcb = getr(K_PCB, (s_pcb-s_solder)/4.0, (s_pcb+3*s_solder)/4.0 * t_pcb);
+
+	/* vertical R's of package substrate, solder balls and PCB */
+	p->r_sub_per_x = getr(K_SUB, t_sub, (s_sub+height) * (s_sub-width) / 4.0);
+	p->r_sub_per_y = getr(K_SUB, t_sub, (s_sub+width) * (s_sub-height) / 4.0);
+	p->r_solder_per_x = getr(K_SOLDER, t_solder, (s_solder+height) * (s_solder-width) / 4.0);
+	p->r_solder_per_y = getr(K_SOLDER, t_solder, (s_solder+width) * (s_solder-height) / 4.0);
+	p->r_pcb_c_per_x = getr(K_PCB, t_pcb, (s_solder+height) * (s_solder-width) / 4.0);
+	p->r_pcb_c_per_y = getr(K_PCB, t_pcb, (s_solder+width) * (s_solder-height) / 4.0);
+	p->r_pcb_per = getr(K_PCB, t_pcb, (s_pcb*s_pcb - s_solder*s_solder) / 4.0);
+	
+	/* vertical R's to ambient at PCB (divide r_convec_sec proportional to area) */
+	p->r_amb_sec_c_per_x = r_convec_sec * (s_pcb * s_pcb) / ((s_solder+height) * (s_solder-width) / 4.0);
+	p->r_amb_sec_c_per_y = r_convec_sec * (s_pcb * s_pcb) / ((s_solder+width) * (s_solder-height) / 4.0);
+	p->r_amb_sec_per = r_convec_sec * (s_pcb * s_pcb) / ((s_pcb*s_pcb - s_solder*s_solder) / 4.0);
+}
+
+void populate_package_C(package_RC_t *p, thermal_config_t *config, double width, double height)
+{
+	double s_spreader = config->s_spreader;
+	double t_spreader = config->t_spreader;
+	double s_sink = config->s_sink;
+	double t_sink = config->t_sink;
+	double c_convec = config->c_convec;
+	
+	double s_sub = config->s_sub;
+	double t_sub = config->t_sub;
+	double s_solder = config->s_solder;
+	double t_solder = config->t_solder;
+	double s_pcb = config->s_pcb;
+	double t_pcb = config->t_pcb;
+	double c_convec_sec = config->c_convec_sec;
+	
+	double p_sink = config->p_sink;
+	double p_spreader = config->p_spreader;	
+
+	/* vertical C's of spreader and sink */
+	p->c_sp_per_x = getcap(p_spreader, t_spreader, (s_spreader+height) * (s_spreader-width) / 4.0);
+	p->c_sp_per_y = getcap(p_spreader, t_spreader, (s_spreader+width) * (s_spreader-height) / 4.0);
+	p->c_hs_c_per_x = getcap(p_sink, t_sink, (s_spreader+height) * (s_spreader-width) / 4.0);
+	p->c_hs_c_per_y = getcap(p_sink, t_sink, (s_spreader+width) * (s_spreader-height) / 4.0);
+	p->c_hs_per = getcap(p_sink, t_sink, (s_sink*s_sink - s_spreader*s_spreader) / 4.0);
+
+	/* vertical C's to ambient (divide c_convec proportional to area) */
+	p->c_amb_c_per_x = C_FACTOR * c_convec / (s_sink * s_sink) * ((s_spreader+height) * (s_spreader-width) / 4.0);
+	p->c_amb_c_per_y = C_FACTOR * c_convec / (s_sink * s_sink) * ((s_spreader+width) * (s_spreader-height) / 4.0);
+	p->c_amb_per = C_FACTOR * c_convec / (s_sink * s_sink) * ((s_sink*s_sink - s_spreader*s_spreader) / 4.0);
+	
+	/* vertical C's of package substrate, solder balls, and PCB */
+	p->c_sub_per_x = getcap(SPEC_HEAT_SUB, t_sub, (s_sub+height) * (s_sub-width) / 4.0);
+	p->c_sub_per_y = getcap(SPEC_HEAT_SUB, t_sub, (s_sub+width) * (s_sub-height) / 4.0);
+	p->c_solder_per_x = getcap(SPEC_HEAT_SOLDER, t_solder, (s_solder+height) * (s_solder-width) / 4.0);
+	p->c_solder_per_y = getcap(SPEC_HEAT_SOLDER, t_solder, (s_solder+width) * (s_solder-height) / 4.0);
+	p->c_pcb_c_per_x = getcap(SPEC_HEAT_PCB, t_pcb, (s_solder+height) * (s_solder-width) / 4.0);
+	p->c_pcb_c_per_y = getcap(SPEC_HEAT_PCB, t_pcb, (s_solder+width) * (s_solder-height) / 4.0);
+	p->c_pcb_per = getcap(SPEC_HEAT_PCB, t_pcb, (s_pcb*s_pcb - s_solder*s_solder) / 4.0);
+
+	/* vertical C's to ambient at PCB (divide c_convec_sec proportional to area) */
+	p->c_amb_sec_c_per_x = C_FACTOR * c_convec_sec / (s_pcb * s_pcb) * ((s_solder+height) * (s_solder-width) / 4.0);
+	p->c_amb_sec_c_per_y = C_FACTOR * c_convec_sec / (s_pcb * s_pcb) * ((s_solder+width) * (s_solder-height) / 4.0);
+	p->c_amb_sec_per = C_FACTOR * c_convec_sec / (s_pcb * s_pcb) * ((s_pcb*s_pcb - s_solder*s_solder) / 4.0);
+}
+
+/* debug print	*/
+void debug_print_package_RC(package_RC_t *p)
+{
+	fprintf(stdout, "printing package RC information...\n");
+	fprintf(stdout, "r_sp1_x: %f\tr_sp1_y: %f\n", p->r_sp1_x, p->r_sp1_y);
+	fprintf(stdout, "r_sp_per_x: %f\tr_sp_per_y: %f\n", p->r_sp_per_x, p->r_sp_per_y);
+	fprintf(stdout, "c_sp_per_x: %f\tc_sp_per_y: %f\n", p->c_sp_per_x, p->c_sp_per_y);
+	fprintf(stdout, "r_hs1_x: %f\tr_hs1_y: %f\n", p->r_hs1_x, p->r_hs1_y);
+	fprintf(stdout, "r_hs2_x: %f\tr_hs2_y: %f\n", p->r_hs2_x, p->r_hs2_y);
+	fprintf(stdout, "r_hs_c_per_x: %f\tr_hs_c_per_y: %f\n", p->r_hs_c_per_x, p->r_hs_c_per_y);
+	fprintf(stdout, "c_hs_c_per_x: %f\tc_hs_c_per_y: %f\n", p->c_hs_c_per_x, p->c_hs_c_per_y);
+	fprintf(stdout, "r_hs: %f\tr_hs_per: %f\n", p->r_hs, p->r_hs_per);
+	fprintf(stdout, "c_hs_per: %f\n", p->c_hs_per);
+	fprintf(stdout, "r_amb_c_per_x: %f\tr_amb_c_per_y: %f\n", p->r_amb_c_per_x, p->r_amb_c_per_y);
+	fprintf(stdout, "c_amb_c_per_x: %f\tc_amb_c_per_y: %f\n", p->c_amb_c_per_x, p->c_amb_c_per_y);
+	fprintf(stdout, "r_amb_per: %f\n", p->r_amb_per);
+	fprintf(stdout, "c_amb_per: %f\n", p->c_amb_per);
+	fprintf(stdout, "r_sub1_x: %f\tr_sub1_y: %f\n", p->r_sub1_x, p->r_sub1_y);
+	fprintf(stdout, "r_sub_per_x: %f\tr_sub_per_y: %f\n", p->r_sub_per_x, p->r_sub_per_y);
+	fprintf(stdout, "c_sub_per_x: %f\tc_sub_per_y: %f\n", p->c_sub_per_x, p->c_sub_per_y);
+	fprintf(stdout, "r_solder1_x: %f\tr_solder1_y: %f\n", p->r_solder1_x, p->r_solder1_y);
+	fprintf(stdout, "r_solder_per_x: %f\tr_solder_per_y: %f\n", p->r_solder_per_x, p->r_solder_per_y);
+	fprintf(stdout, "c_solder_per_x: %f\tc_solder_per_y: %f\n", p->c_solder_per_x, p->c_solder_per_y);
+	fprintf(stdout, "r_pcb1_x: %f\tr_pcb1_y: %f\n", p->r_pcb1_x, p->r_pcb1_y);
+	fprintf(stdout, "r_pcb2_x: %f\tr_pcb2_y: %f\n", p->r_pcb2_x, p->r_pcb2_y);
+	fprintf(stdout, "r_pcb_c_per_x: %f\tr_pcb_c_per_y: %f\n", p->r_pcb_c_per_x, p->r_pcb_c_per_y);
+	fprintf(stdout, "c_pcb_c_per_x: %f\tc_pcb_c_per_y: %f\n", p->c_pcb_c_per_x, p->c_pcb_c_per_y);
+	fprintf(stdout, "r_pcb: %f\tr_pcb_per: %f\n", p->r_pcb, p->r_pcb_per);
+	fprintf(stdout, "c_pcb_per: %f\n", p->c_pcb_per);
+	fprintf(stdout, "r_amb_sec_c_per_x: %f\tr_amb_sec_c_per_y: %f\n", p->r_amb_sec_c_per_x, p->r_amb_sec_c_per_y);
+	fprintf(stdout, "c_amb_sec_c_per_x: %f\tc_amb_sec_c_per_y: %f\n", p->c_amb_sec_c_per_x, p->c_amb_sec_c_per_y);
+	fprintf(stdout, "r_amb_sec_per: %f\n", p->r_amb_sec_per);
+	fprintf(stdout, "c_amb_sec_per: %f\n", p->c_amb_sec_per);
+}
+
+/* 
+ * wrapper routines interfacing with those of the corresponding 
+ * thermal model (block or grid)
+ */
+
+/* 
+ * allocate memory for the matrices. for the block model, placeholder 
+ * can be an empty floorplan frame with only the names of the functional 
+ * units. for the grid model, it is the default floorplan
+ */
+RC_model_t *alloc_RC_model(thermal_config_t *config, flp_t *placeholder)
+{
+	RC_model_t *model= (RC_model_t *) calloc (1, sizeof(RC_model_t));
+	if (!model)
+		fatal((char*)"memory allocation error\n");
+	if(!(strcasecmp(config->model_type, BLOCK_MODEL_STR))) {
+		model->type = BLOCK_MODEL;
+		model->block = alloc_block_model(config, placeholder);
+		model->config = &model->block->config;
+	} else if(!(strcasecmp(config->model_type, GRID_MODEL_STR))) {
+		model->type = GRID_MODEL;
+		model->grid = alloc_grid_model(config, placeholder);
+		model->config = &model->grid->config;
+	} else 
+		fatal((char*)"unknown model type\n");
+	return model;	
+}
+
+/* populate the thermal restistance values */
+void populate_R_model(RC_model_t *model, flp_t *flp)
+{
+	if (model->type == BLOCK_MODEL)
+		populate_R_model_block(model->block, flp);
+	else if (model->type == GRID_MODEL)	
+		populate_R_model_grid(model->grid, flp);
+	else fatal((char*)"unknown model type\n");
+}
+
+/* populate the thermal capacitance values */
+void populate_C_model(RC_model_t *model, flp_t *flp)
+{
+	if (model->type == BLOCK_MODEL)
+		populate_C_model_block(model->block, flp);
+	else if (model->type == GRID_MODEL)	
+		populate_C_model_grid(model->grid, flp);
+	else fatal((char*)"unknown model type\n");
+}
+
+/* steady state temperature	*/
+void steady_state_temp(RC_model_t *model, double *power, double *temp) 
+{
+//	if (model->type == BLOCK_MODEL)
+//		steady_state_temp_block(model->block, power, temp);
+//	else if (model->type == GRID_MODEL)	
+//		steady_state_temp_grid(model->grid, power, temp);
+//	else fatal((char*)"unknown model type\n");
+
+	int leak_convg_true = 0;
+	int leak_iter = 0;
+	int n, base=0;
+	//int idx=0;
+	double blk_height, blk_width;
+	int i, j, k;
+	
+	double *d_temp = NULL;
+	double *temp_old = NULL;
+	double *power_new = NULL;
+	double d_max=0.0;
+	
+	if (model->type == BLOCK_MODEL) {
+		n = model->block->flp->n_units;
+		if (model->config->leakage_used) { // if considering leakage-temperature loop
+			d_temp = hotspot_vector(model);
+			temp_old = hotspot_vector(model);
+			power_new = hotspot_vector(model);
+			for (leak_iter=0;(!leak_convg_true)&&(leak_iter<=LEAKAGE_MAX_ITER);leak_iter++){
+				for(i=0; i < n; i++) {
+					blk_height = model->block->flp->units[i].height;
+					blk_width = model->block->flp->units[i].width;
+					power_new[i] = power[i] + calc_leakage(model->config->leakage_mode,blk_height,blk_width,temp[i]);
+					temp_old[i] = temp[i]; //copy temp before update
+				}
+				steady_state_temp_block(model->block, power_new, temp); // update temperature
+				d_max = 0.0;
+				for(i=0; i < n; i++) {
+					d_temp[i] = temp[i] - temp_old[i]; //temperature increase due to leakage
+					if (d_temp[i]>d_max) {
+						d_max = d_temp[i];
+					}
+				}
+				if (d_max < LEAK_TOL) {// check convergence
+					leak_convg_true = 1;
+				}
+				if (d_max > TEMP_HIGH && leak_iter > 1) {// check to make sure d_max is not "nan" (esp. in natural convection)
+					fatal((char*)"temperature is too high, possible thermal runaway. Double-check power inputs and package settings.\n");
+				}
+			}
+			free(d_temp);
+			free(temp_old);
+			free(power_new);
+			/* if no convergence after max number of iterations, thermal runaway */
+			if (!leak_convg_true)
+				fatal((char*)"too many iterations before temperature-leakage convergence -- possible thermal runaway\n");
+		} else // if leakage-temperature loop is not considered
+			steady_state_temp_block(model->block, power, temp);
+	}
+	else if (model->type == GRID_MODEL)	{
+		if (model->config->leakage_used) { // if considering leakage-temperature loop
+			d_temp = hotspot_vector(model);
+			temp_old = hotspot_vector(model);
+			power_new = hotspot_vector(model);
+			for (leak_iter=0;(!leak_convg_true)&&(leak_iter<=LEAKAGE_MAX_ITER);leak_iter++){
+				for(k=0, base=0; k < model->grid->n_layers; k++) {
+					if(model->grid->layers[k].has_power)
+						for(j=0; j < model->grid->layers[k].flp->n_units; j++) {
+							blk_height = model->grid->layers[k].flp->units[j].height;
+							blk_width = model->grid->layers[k].flp->units[j].width;
+							power_new[base+j] = power[base+j] + calc_leakage(model->config->leakage_mode,blk_height,blk_width,temp[base+j]);
+							temp_old[base+j] = temp[base+j]; //copy temp before update
+						}
+					base += model->grid->layers[k].flp->n_units;	
+				}
+				steady_state_temp_grid(model->grid, power_new, temp);
+				d_max = 0.0;
+				for(k=0, base=0; k < model->grid->n_layers; k++) {
+					if(model->grid->layers[k].has_power)
+						for(j=0; j < model->grid->layers[k].flp->n_units; j++) {
+							d_temp[base+j] = temp[base+j] - temp_old[base+j]; //temperature increase due to leakage
+							if (d_temp[base+j]>d_max)
+								d_max = d_temp[base+j];
+						}
+					base += model->grid->layers[k].flp->n_units;	
+				}
+				if (d_max < LEAK_TOL) {// check convergence
+					leak_convg_true = 1;
+				}
+				if (d_max > TEMP_HIGH && leak_iter > 0) {// check to make sure d_max is not "nan" (esp. in natural convection)
+					fatal((char*)"temperature is too high, possible thermal runaway. Double-check power inputs and package settings.\n");
+				}
+			}
+			free(d_temp);
+			free(temp_old);
+			free(power_new);
+			/* if no convergence after max number of iterations, thermal runaway */
+			if (!leak_convg_true)
+				fatal((char*)"too many iterations before temperature-leakage convergence -- possible thermal runaway\n");
+		} else // if leakage-temperature loop is not considered
+			steady_state_temp_grid(model->grid, power, temp);
+	}
+	else fatal((char*)"unknown model type\n");
+}
+
+/* transient (instantaneous) temperature	*/
+void compute_temp(RC_model_t *model, double *power, double *temp, double time_elapsed)
+{
+	if (model->type == BLOCK_MODEL)
+		compute_temp_block(model->block, power, temp, time_elapsed);
+	else if (model->type == GRID_MODEL)	
+		compute_temp_grid(model->grid, power, temp, time_elapsed);
+	else fatal((char*)"unknown model type\n");
+}
+
+/* differs from 'dvector()' in that memory for internal nodes is also allocated	*/
+double *hotspot_vector(RC_model_t *model)
+{
+	if (model->type == BLOCK_MODEL)
+		return hotspot_vector_block(model->block);
+	else if (model->type == GRID_MODEL)	
+		return hotspot_vector_grid(model->grid);
+	else fatal((char*)"unknown model type\n");
+	return NULL;
+}
+
+/* copy 'src' to 'dst' except for a window of 'size'
+ * elements starting at 'at'. useful in floorplan
+ * compaction
+ */
+void trim_hotspot_vector(RC_model_t *model, double *dst, double *src, 
+						 int at, int size)
+{
+	if (model->type == BLOCK_MODEL)
+		trim_hotspot_vector_block(model->block, dst, src, at, size);
+	else if (model->type == GRID_MODEL)	
+		trim_hotspot_vector_grid(model->grid, dst, src, at, size);
+	else fatal((char*)"unknown model type\n");
+}
+
+/* update the model's node count	*/						 
+void resize_thermal_model(RC_model_t *model, int n_units)
+{
+	if (model->type == BLOCK_MODEL)
+		resize_thermal_model_block(model->block, n_units);
+	else if (model->type == GRID_MODEL)	
+		resize_thermal_model_grid(model->grid, n_units);
+	else fatal((char*)"unknown model type\n");
+}
+
+/* sets the temperature of a vector 'temp' allocated using 'hotspot_vector'	*/
+void set_temp(RC_model_t *model, double *temp, double val)
+{
+	if (model->type == BLOCK_MODEL)
+		set_temp_block(model->block, temp, val);
+	else if (model->type == GRID_MODEL)	
+		set_temp_grid(model->grid, temp, val);
+	else fatal((char*)"unknown model type\n");
+}
+
+/* dump temperature vector alloced using 'hotspot_vector' to 'file' */ 
+void dump_temp(RC_model_t *model, double *temp, char *file)
+{
+	if (model->type == BLOCK_MODEL)
+		dump_temp_block(model->block, temp, file);
+	else if (model->type == GRID_MODEL)	
+		dump_temp_grid(model->grid, temp, file);
+	else fatal((char*)"unknown model type\n");
+}
+
+/* calculate average heatsink temperature for natural convection package */ 
+double calc_sink_temp(RC_model_t *model, double *temp)
+{
+	if (model->type == BLOCK_MODEL)
+		return calc_sink_temp_block(model->block, temp, model->config);
+	else if (model->type == GRID_MODEL)	
+		return calc_sink_temp_grid(model->grid, temp, model->config);
+	else fatal((char*)"unknown model type\n");
+	return 0.0;
+}
+
+/* copy temperature vector from src to dst */ 
+void copy_temp(RC_model_t *model, double *dst, double *src)
+{
+	if (model->type == BLOCK_MODEL)
+		copy_temp_block(model->block, dst, src);
+	else if (model->type == GRID_MODEL)	
+		copy_temp_grid(model->grid, dst, src);
+	else fatal((char*)"unknown model type\n");
+}
+
+/* 
+ * read temperature vector alloced using 'hotspot_vector' from 'file'
+ * which was dumped using 'dump_temp'. values are clipped to thermal
+ * threshold based on 'clip'
+ */ 
+void read_temp(RC_model_t *model, double *temp, char *file, int clip)
+{
+	if (model->type == BLOCK_MODEL)
+		read_temp_block(model->block, temp, file, clip);
+	else if (model->type == GRID_MODEL)	
+		read_temp_grid(model->grid, temp, file, clip);
+	else fatal((char*)"unknown model type\n");
+}
+
+/* dump power numbers to file	*/
+void dump_power(RC_model_t *model, double *power, char *file)
+{
+	if (model->type == BLOCK_MODEL)
+		dump_power_block(model->block, power, file);
+	else if (model->type == GRID_MODEL)	
+		dump_power_grid(model->grid, power, file);
+	else fatal((char*)"unknown model type\n");
+}
+
+/* 
+ * read power vector alloced using 'hotspot_vector' from 'file'
+ * which was dumped using 'dump_power'. 
+ */ 
+void read_power (RC_model_t *model, double *power, char *file)
+{
+	if (model->type == BLOCK_MODEL)
+		read_power_block(model->block, power, file);
+	else if (model->type == GRID_MODEL)	
+		read_power_grid(model->grid, power, file);
+	else fatal((char*)"unknown model type\n");
+}
+
+/* peak temperature on chip	*/
+double find_max_temp(RC_model_t *model, double *temp)
+{
+	if (model->type == BLOCK_MODEL)
+		return find_max_temp_block(model->block, temp);
+	else if (model->type == GRID_MODEL)	
+		return find_max_temp_grid(model->grid, temp);
+	else fatal((char*)"unknown model type\n");
+	return 0.0;
+}
+
+/* average temperature on chip	*/
+double find_avg_temp(RC_model_t *model, double *temp)
+{
+	if (model->type == BLOCK_MODEL)
+		return find_avg_temp_block(model->block, temp);
+	else if (model->type == GRID_MODEL)	
+		return find_avg_temp_grid(model->grid, temp);
+	else fatal((char*)"unknown model type\n");
+	return 0.0;
+}
+
+/* debug print	*/
+void debug_print_model(RC_model_t *model)
+{
+	if (model->type == BLOCK_MODEL)
+		debug_print_block(model->block);
+	else if (model->type == GRID_MODEL)	
+		debug_print_grid(model->grid);
+	else fatal((char*)"unknown model type\n");
+}
+
+/* calculate temperature-dependent leakage power */
+/* will support HotLeakage in future releases */
+double calc_leakage(int mode, double h, double w, double temp)
+{
+	/* a simple leakage model.
+	 * Be aware -- this model may not be accurate in some cases.
+	 * You may want to use your own temperature-dependent leakage model here.
+	 */ 
+	double leak_alpha = 1.5e+4;
+	double leak_beta = 0.036;
+	double leak_Tbase = 383.15; /* 110C according to the above paper */
+
+	double leakage_power;
+	
+	if (mode)
+		fatal((char*)"HotLeakage currently is not implemented in this release of HotSpot, please check back later.\n");
+		
+	leakage_power = leak_alpha*h*w*exp(leak_beta*(temp-leak_Tbase));
+	return leakage_power;	
+}
+
+/* destructor */
+void delete_RC_model(RC_model_t *model)
+{
+	if (model->type == BLOCK_MODEL)
+		delete_block_model(model->block);
+	else if (model->type == GRID_MODEL)	
+		delete_grid_model(model->grid);
+	else fatal((char*)"unknown model type\n");
+	free(model);
+}
diff -Naur temp/temperature_grid.c HotSpot/temperature_grid.c
--- temp/temperature_grid.c	2017-11-20 10:04:24.521682846 +0100
+++ HotSpot/temperature_grid.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,3066 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#ifdef _MSC_VER
-#define strcasecmp    _stricmp
-#define strncasecmp   _strnicmp
-#else
-#include <strings.h>
-#endif
-#include <math.h>
-
-#include "temperature_grid.h"
-#include "flp.h"
-#include "util.h"
-
-/* constructors	*/
-blist_t *new_blist(int idx, double occupancy)
-{
-	blist_t *ptr = (blist_t *) calloc (1, sizeof(blist_t));
-	if (!ptr)
-		fatal("memory allocation error\n");
-	ptr->idx = idx;
-	ptr->occupancy = occupancy;
-	ptr->next = NULL;
-	return ptr;
-}
-
-blist_t ***new_b2gmap(int rows, int cols)
-{
-	int i;
-	blist_t ***b2gmap;
-
-	b2gmap = (blist_t ***) calloc (rows, sizeof(blist_t **));
-	b2gmap[0] = (blist_t **) calloc (rows * cols, sizeof(blist_t *));
-	if (!b2gmap || !b2gmap[0])
-		fatal("memory allocation error\n");
-
-	for(i=1; i < rows; i++) 
-		b2gmap[i] = b2gmap[0] + cols * i;
-
-	return b2gmap;	
-}
-
-/* destructor	*/
-void delete_b2gmap(blist_t ***b2gmap, int rows, int cols)
-{
-	int i, j;
-	blist_t *ptr, *temp;
-
-	/* free the linked list	*/
-	for(i=0; i < rows; i++)
-		for(j=0; j < cols; j++) {
-			ptr = b2gmap[i][j];
-			while(ptr) {
-				temp = ptr->next;
-				free(ptr);
-				ptr = temp;
-			}
-		}
-
-	/* free the array space	*/
-	free(b2gmap[0]);
-	free(b2gmap);
-}
-
-/* re-initialize */
-void reset_b2gmap(grid_model_t *model, layer_t *layer)
-{
-	int i, j;
-	blist_t *ptr, *temp;
-
-	/* free the linked list	*/
-	for(i=0; i < model->rows; i++)
-		for(j=0; j < model->cols; j++) {
-			ptr = layer->b2gmap[i][j];
-			while(ptr) {
-				temp = ptr->next;
-				free(ptr);
-				ptr = temp;
-			}
-			layer->b2gmap[i][j] = NULL;
-		}
-}
-
-/* create a linked list node and append it at the end	*/
-void blist_append(blist_t *head, int idx, double occupancy)
-{
-	blist_t *tail = NULL;
-	
-	if(!head)
-		fatal("blist_append called with empty list\n");
-
-	/* traverse till the end	*/
-	for(; head; head = head->next)
-		tail = head;
-
-	/* append */
-	tail->next =  new_blist(idx, occupancy);
-}
-
-/* compute the power/temperature average weighted by occupancies	*/
-double blist_avg(blist_t *ptr, flp_t *flp, double *v, int type)
-{
-	double  val = 0.0;
-	
-	for(; ptr; ptr = ptr->next) {
-		if (type == V_POWER)
-			val += ptr->occupancy * v[ptr->idx] / (flp->units[ptr->idx].width * 
-				   flp->units[ptr->idx].height);
-		else if (type == V_TEMP)		   
-			val += ptr->occupancy * v[ptr->idx];
-		else
-			fatal("unknown vector type\n");
-	}		
-
-	return val;		   
-}
-
-void debug_print_blist(blist_t *head, flp_t *flp);
-/* test the block-grid map data structure	*/
-void test_b2gmap(grid_model_t *model, layer_t *layer)
-{
-	int i, j;
-	blist_t *ptr;
-	double sum;
-
-	/* a correctly formed b2gmap should have the 
-	 * sum of occupancies in each linked list
-	 * to be equal to 1.0
-	 */
-	for (i=0; i < model->rows; i++)
-		for(j=0; j < model->cols; j++) {
-			sum = 0.0;
-			for(ptr = layer->b2gmap[i][j]; ptr; ptr = ptr->next)
-				sum += ptr->occupancy;
-			if (!eq(floor(sum*1e5 + 0.5)/1e5, 1.0)) {
-				fprintf(stdout, "i: %d\tj: %d\n", i, j);
-				debug_print_blist(layer->b2gmap[i][j], layer->flp);
-				fatal("erroneous b2gmap data structure. invalid floorplan?\n");
-			}	
-		}
-}
-
-/* setup the block and grid mapping data structures	*/
-void set_bgmap(grid_model_t *model, layer_t *layer)
-{
-	/* i1, i2, j1 and j2 are indices of the boundary grid cells	*/
-	int i, j, u, i1, i2, j1, j2;
-
-	/* shortcuts for cell width(cw) and cell height(ch)	*/
-	double cw = model->width / model->cols;
-	double ch = model->height / model->rows;
-
-	/* initialize	*/
-	reset_b2gmap(model, layer);
-
-	/* for each functional unit	*/
-	for(u=0; u < layer->flp->n_units; u++) {
-		/* shortcuts for unit boundaries	*/
-		double lu = layer->flp->units[u].leftx;
-		double ru = lu + layer->flp->units[u].width;
-		double bu = layer->flp->units[u].bottomy;
-		double tu = bu + layer->flp->units[u].height;
-
-		/* top index (lesser row) = rows - ceil (topy / cell height)	*/
-		i1 = model->rows - tolerant_ceil(tu/ch);
-		/* bottom index (greater row) = rows - floor (bottomy / cell height)	*/
-		i2 = model->rows - tolerant_floor(bu/ch);
-		/* left index = floor (leftx / cell width)	*/
-		j1 = tolerant_floor(lu/cw);
-		/* right index = ceil (rightx / cell width)	*/
-		j2 = tolerant_ceil(ru/cw);
-		/* sanity check	*/
-		if((i1 < 0) || (j1 < 0))
-			fatal("negative grid cell start index!\n");
-		if((i2 > model->rows) || (j2 > model->cols))
-			fatal("grid cell end index out of bounds!\n");
-		if((i1 >= i2) || (j1 >= j2))
-			fatal("invalid floorplan spec or grid resolution\n");
-
-		/* setup g2bmap	*/
-		layer->g2bmap[u].i1 = i1;
-		layer->g2bmap[u].i2 = i2;
-		layer->g2bmap[u].j1 = j1;
-		layer->g2bmap[u].j2 = j2;
-
-		/* setup b2gmap	*/
-		/* for each grid cell in this unit	*/
-		for(i=i1; i < i2; i++)
-			for(j=j1; j < j2; j++)
-				/* grid cells fully overlapped by this unit	*/
-				if ((i > i1) && (i < i2-1) && (j > j1) && (j < j2-1)) {
-					/* first unit in the list	*/
-					if (!layer->b2gmap[i][j])
-						layer->b2gmap[i][j] = new_blist(u, 1.0);
-					else {
-					/* this should not occur since the grid cell is 
-					 * fully covered and hence, no other unit should 
-					 * be sharing it
-					 */
-						blist_append(layer->b2gmap[i][j], u, 1.0);
-						warning("overlap of functional blocks?\n");
-					}
-				/* boundary grid cells partially overlapped by this unit	*/
-				} else {
-					/* shortcuts for cell boundaries	*/
-					double lc = j * cw, rc = (j+1) * cw;
-					double tc = model->height - i * ch;
-					double bc = model->height - (i+1) * ch;
-					
-					/* shortcuts for overlap width and height	*/
-					double oh = (MIN(tu, tc) - MAX(bu, bc));
-					double ow = (MIN(ru, rc) - MAX(lu, lc));
-					double occupancy;
-			
-					/* overlap tolerance	*/
-					if (eq(oh/ch, 0))
-						oh = 0;
-					else if (eq(oh/ch, 1))
-						oh = ch;
-
-					if (eq(ow/cw, 0))
-						ow = 0;
-					else if (eq(ow/cw, 1))
-						ow = cw;
-
-					occupancy = (oh * ow) / (ch * cw);
-					if (oh < 0 || ow < 0)
-						fatal("negative overlap!\n");
-
-					/* first unit in the list	*/
-					if (!layer->b2gmap[i][j])
-						layer->b2gmap[i][j] = new_blist(u, occupancy);
-					else
-					/* append at the end	*/
-						blist_append(layer->b2gmap[i][j], u, occupancy);
-				}
-	}
-
-	/* 
-	 * sanity check	
-	test_b2gmap(model, layer);
-	 */
-}
-
-/* populate default set of layers	*/ 
-void populate_default_layers(grid_model_t *model, flp_t *flp_default)
-{
-	/* silicon	*/
-	model->layers[LAYER_SI].no = LAYER_SI;
-	model->layers[LAYER_SI].has_lateral = TRUE;
-	model->layers[LAYER_SI].has_power = TRUE;
-	model->layers[LAYER_SI].k = model->config.k_chip;
-	model->layers[LAYER_SI].thickness = model->config.t_chip;
-	model->layers[LAYER_SI].sp = model->config.p_chip;
-	model->layers[LAYER_SI].flp = flp_default;
-	model->layers[LAYER_SI].b2gmap = new_b2gmap(model->rows, model->cols);
-	model->layers[LAYER_SI].g2bmap = (glist_t *) calloc(flp_default->n_units, sizeof(glist_t));
-	if (!model->layers[LAYER_SI].g2bmap)
-		fatal("memory allocation error\n");
-
-	/* interface material	*/
-	model->layers[LAYER_INT].no = LAYER_INT;
-	model->layers[LAYER_INT].has_lateral = TRUE;
-	model->layers[LAYER_INT].has_power = FALSE;
-	model->layers[LAYER_INT].k = model->config.k_interface;
-	model->layers[LAYER_INT].thickness = model->config.t_interface;
-	model->layers[LAYER_INT].sp = model->config.p_interface;
-	model->layers[LAYER_INT].flp = flp_default;
-	model->layers[LAYER_INT].b2gmap = model->layers[LAYER_SI].b2gmap;
-	model->layers[LAYER_INT].g2bmap = model->layers[LAYER_SI].g2bmap;
-	
-	if (model->config.model_secondary) {
-		/* metal layer	*/
-		model->layers[DEFAULT_CHIP_LAYERS + LAYER_METAL].no = DEFAULT_CHIP_LAYERS + LAYER_METAL;
-		model->layers[DEFAULT_CHIP_LAYERS + LAYER_METAL].has_lateral = TRUE;
-		model->layers[DEFAULT_CHIP_LAYERS + LAYER_METAL].has_power = FALSE;
-		model->layers[DEFAULT_CHIP_LAYERS + LAYER_METAL].k = K_METAL;
-		model->layers[DEFAULT_CHIP_LAYERS + LAYER_METAL].k1 = K_DIELECTRIC; 
-		model->layers[DEFAULT_CHIP_LAYERS + LAYER_METAL].thickness = model->config.t_metal;
-		model->layers[DEFAULT_CHIP_LAYERS + LAYER_METAL].sp = SPEC_HEAT_METAL;
-		model->layers[DEFAULT_CHIP_LAYERS + LAYER_METAL].flp = flp_default;
-		model->layers[DEFAULT_CHIP_LAYERS + LAYER_METAL].b2gmap = model->layers[LAYER_SI].b2gmap;
-		model->layers[DEFAULT_CHIP_LAYERS + LAYER_METAL].g2bmap = model->layers[LAYER_SI].g2bmap;
-		if (!model->layers[DEFAULT_CHIP_LAYERS + LAYER_METAL].g2bmap)
-			fatal("memory allocation error\n");
-  	
-		/* C4/underfill layer*/
-		model->layers[DEFAULT_CHIP_LAYERS + LAYER_C4].no = DEFAULT_CHIP_LAYERS + LAYER_C4;
-		model->layers[DEFAULT_CHIP_LAYERS + LAYER_C4].has_lateral = TRUE;
-		model->layers[DEFAULT_CHIP_LAYERS + LAYER_C4].has_power = FALSE;
-		model->layers[DEFAULT_CHIP_LAYERS + LAYER_C4].k = K_C4;
-		model->layers[DEFAULT_CHIP_LAYERS + LAYER_C4].k1 = K_UNDERFILL;
-		model->layers[DEFAULT_CHIP_LAYERS + LAYER_C4].thickness = model->config.t_c4;
-		model->layers[DEFAULT_CHIP_LAYERS + LAYER_C4].sp = SPEC_HEAT_C4;
-		model->layers[DEFAULT_CHIP_LAYERS + LAYER_C4].sp1 = SPEC_HEAT_UNDERFILL;
-		model->layers[DEFAULT_CHIP_LAYERS + LAYER_C4].flp = flp_default;
-		model->layers[DEFAULT_CHIP_LAYERS + LAYER_C4].b2gmap = model->layers[LAYER_SI].b2gmap;
-		model->layers[DEFAULT_CHIP_LAYERS + LAYER_C4].g2bmap = model->layers[LAYER_SI].g2bmap;
-	}
-}
-
-/* populate the package layers	*/ 
-void append_package_layers(grid_model_t *model)
-{
-	/* shortcut	*/
-	int nl = model->n_layers;
-
-	/* spreader	*/
-	model->layers[nl+LAYER_SP].no = nl+LAYER_SP;
-	model->layers[nl+LAYER_SP].has_lateral = TRUE;
-	model->layers[nl+LAYER_SP].has_power = FALSE;
-	model->layers[nl+LAYER_SP].k = model->config.k_spreader;
-	model->layers[nl+LAYER_SP].thickness = model->config.t_spreader;
-	model->layers[nl+LAYER_SP].sp = model->config.p_spreader;
-	model->layers[nl+LAYER_SP].flp = model->layers[nl-1].flp;
-	model->layers[nl+LAYER_SP].b2gmap = model->layers[nl-1].b2gmap;
-	model->layers[nl+LAYER_SP].g2bmap = model->layers[nl-1].g2bmap;
-
-	/* heatsink	*/
-	model->layers[nl+LAYER_SINK].no = nl+LAYER_SINK;
-	model->layers[nl+LAYER_SINK].has_lateral = TRUE;
-	model->layers[nl+LAYER_SINK].has_power = FALSE;
-	model->layers[nl+LAYER_SINK].k = model->config.k_sink;
-	model->layers[nl+LAYER_SINK].thickness = model->config.t_sink;
-	model->layers[nl+LAYER_SINK].sp = model->config.p_sink;
-	model->layers[nl+LAYER_SINK].flp = model->layers[nl-1].flp;
-	model->layers[nl+LAYER_SINK].b2gmap = model->layers[nl-1].b2gmap;
-	model->layers[nl+LAYER_SINK].g2bmap = model->layers[nl-1].g2bmap;
-
-	model->n_layers += DEFAULT_PACK_LAYERS;
-		
-	if (model->config.model_secondary) {
-		/* package substrate	*/
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SUB].no = nl+DEFAULT_PACK_LAYERS+LAYER_SUB;
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SUB].has_lateral = TRUE;
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SUB].has_power = FALSE;
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SUB].k = K_SUB;
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SUB].thickness = model->config.t_sub;
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SUB].sp = SPEC_HEAT_SUB;
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SUB].flp = model->layers[nl-1].flp;
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SUB].b2gmap = model->layers[nl-1].b2gmap;
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SUB].g2bmap = model->layers[nl-1].g2bmap;
-		
-		/* solder balls	*/
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SOLDER].no = nl+DEFAULT_PACK_LAYERS+LAYER_SOLDER;
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SOLDER].has_lateral = TRUE;
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SOLDER].has_power = FALSE;
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SOLDER].k = K_SOLDER;
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SOLDER].thickness = model->config.t_solder;
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SOLDER].sp = SPEC_HEAT_SOLDER;
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SOLDER].flp = model->layers[nl-1].flp;
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SOLDER].b2gmap = model->layers[nl-1].b2gmap;
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SOLDER].g2bmap = model->layers[nl-1].g2bmap;
-  	
-		/* PCB	*/
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_PCB].no = nl+DEFAULT_PACK_LAYERS+LAYER_PCB;
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_PCB].has_lateral = TRUE;
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_PCB].has_power = FALSE;
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_PCB].k = K_PCB;
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_PCB].thickness = model->config.t_pcb;
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_PCB].sp = SPEC_HEAT_PCB;
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_PCB].flp = model->layers[nl-1].flp;
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_PCB].b2gmap = model->layers[nl-1].b2gmap;
-		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_PCB].g2bmap = model->layers[nl-1].g2bmap;
-		
-		model->n_layers += SEC_PACK_LAYERS;		
-	}
-}
-
-/* parse the layer file open for reading	*/
-void parse_layer_file(grid_model_t *model, FILE *fp)
-{
-	char line[LINE_SIZE], *ptr, cval;
-	int count, i = 0, field = LCF_SNO, ival;
-	double dval;
-
-	fseek(fp, 0, SEEK_SET);
-	count = 0;
-	while (!feof(fp) && count < (model->n_layers * LCF_NPARAMS)) {
-		fgets(line, LINE_SIZE, fp);
-		if (feof(fp))
-			break;
-
-		/* ignore comments and empty lines	*/
-		ptr = strtok(line, " \r\t\n");
-		if (!ptr || ptr[0] == '#')
-			continue;
-			
-		switch (field) 
-		{
-			case LCF_SNO:
-						if (sscanf(ptr, "%d", &ival) != 1)
-							fatal("invalid layer number\n");
-						if(ival >= model->n_layers || ival < 0)
-							fatal("layer number must be >= 0 and < no. of layers\n");
-						if (model->layers[ival].no != 0)
-							fatal("layer numbers must be unique\n");
-						i = ival;
-						model->layers[i].no = ival;
-						break;
-			case LCF_LATERAL:
-						if (sscanf(ptr, "%c", &cval) != 1)
-							fatal("invalid layer heat flow indicator\n");
-						if (cval == 'Y' || cval == 'y')
-							model->layers[i].has_lateral = TRUE;
-						else if (cval == 'N' || cval == 'n')			
-							model->layers[i].has_lateral = FALSE;
-						else			
-							fatal("invalid layer heat flow indicator\n");
-						break;
-			case LCF_POWER:
-						if (sscanf(ptr, "%c", &cval) != 1)
-							fatal("invalid layer power dissipation indicator\n");
-						if (cval == 'Y' || cval == 'y')
-							model->layers[i].has_power = TRUE;
-						else if (cval == 'N' || cval == 'n')			
-							model->layers[i].has_power = FALSE;
-						else			
-							fatal("invalid layer power dissipation indicator\n");
-						break;
-			case LCF_SP:
-						if (sscanf(ptr, "%lf", &dval) != 1)
-							fatal("invalid specific heat\n");
-						model->layers[i].sp = dval;
-						break;
-			case LCF_RHO:
-						if (sscanf(ptr, "%lf", &dval) != 1)
-							fatal("invalid resistivity\n");
-						model->layers[i].k = 1.0 / dval;
-						break;
-			case LCF_THICK:
-						if (sscanf(ptr, "%lf", &dval) != 1)
-							fatal("invalid thickness\n");
-						model->layers[i].thickness = dval;
-						break;
-			case LCF_FLP:
-						model->layers[i].flp = read_flp(ptr, FALSE);
-						/* first layer	*/
-						if (count < LCF_NPARAMS) {
-							model->width = get_total_width(model->layers[i].flp);
-							model->height = get_total_height(model->layers[i].flp);
-						} else if(!eq(model->width, get_total_width(model->layers[i].flp)) || 
-								  !eq(model->height, get_total_height(model->layers[i].flp)))
-							fatal("width and height differ across layers\n");
-						break;
-			default:
-						fatal("invalid field id\n");
-						break;
-		}
-		field = (field + 1) % LCF_NPARAMS;
-		count++;
-	}
-
-	/* allocate the block-grid maps */
-	for(i=0; i < model->n_layers; i++) {
-		model->layers[i].b2gmap = new_b2gmap(model->rows, model->cols);
-		model->layers[i].g2bmap = (glist_t *) calloc(model->layers[i].flp->n_units, 
-								   sizeof(glist_t));
-		if (!model->layers[i].g2bmap)
-			fatal("memory allocation error\n");
-	}
-}
-
-/* populate layer info either from the default floorplan or from
- * the layer configuration file (lcf)
- */
-void populate_layers_grid(grid_model_t *model, flp_t *flp_default)
-{
-	char str[STR_SIZE];
-	FILE *fp = NULL;
-
-	/* lcf file specified	*/
-	if (model->has_lcf) {
-		if (!strcasecmp(model->config.grid_layer_file, "stdin"))
-			fp = stdin;
-		else
-			fp = fopen (model->config.grid_layer_file, "r");
-		if (!fp) {
-			sprintf(str, "error opening file %s\n", model->config.grid_layer_file);
-			fatal(str);
-		}
-	}
-
-	/* compute the no. of layers	*/
-	if (!model->config.model_secondary) {
-		if (model->has_lcf) {
-			model->n_layers = count_significant_lines(fp);
-			if (model->n_layers % LCF_NPARAMS)
-				fatal("wrong no. of lines in layer file\n");
-			model->n_layers /= LCF_NPARAMS;
-		/* default no. of layers when lcf file is not specified	*/	
-		} else
-			model->n_layers = DEFAULT_CHIP_LAYERS;
-	} else {
-		if (model->has_lcf) {
-			model->n_layers = count_significant_lines(fp);
-			if (model->n_layers % LCF_NPARAMS)
-				fatal("wrong no. of lines in layer file\n");
-			model->n_layers /= LCF_NPARAMS;
-			model->n_layers += SEC_CHIP_LAYERS;
-		/* default no. of layers when lcf file is not specified	*/	
-		} else
-			model->n_layers = DEFAULT_CHIP_LAYERS + SEC_CHIP_LAYERS;
-	}
-
-	/* allocate initial memory including package layers	*/
-	if (!model->config.model_secondary) {
-		model->layers = (layer_t *) calloc (model->n_layers + DEFAULT_PACK_LAYERS, sizeof(layer_t));
-		if (!model->layers)
-			fatal("memory allocation error\n");
-	} else {
-		model->layers = (layer_t *) calloc (model->n_layers + DEFAULT_PACK_LAYERS + SEC_PACK_LAYERS, sizeof(layer_t));
-		if (!model->layers)
-			fatal("memory allocation error\n");
-	}
-
-	/* read in values from the lcf when specified	*/
-	if (model->has_lcf) {
-		if (model->config.model_secondary)
-			fatal("modeling secondary heat transfer path not supported when layer configuration file specified...\n");
-		parse_layer_file(model, fp);
-		warning("layer configuration file specified. overriding default floorplan with those in lcf file...\n");
-	/* default set of layers	*/
-	} else
-		populate_default_layers(model, flp_default);
-	
-	/* append the package layers	*/
-	append_package_layers(model);
-
-	if (model->has_lcf && fp != stdin)
-		fclose(fp);
-}
-
-/* constructor	*/ 
-grid_model_t *alloc_grid_model(thermal_config_t *config, flp_t *flp_default)
-{
-	int i;
-	grid_model_t *model;
-
-	if (config->grid_rows & (config->grid_rows-1) ||
-		config->grid_cols & (config->grid_cols-1))
-		fatal("grid rows and columns should both be powers of two\n");
-
-	model = (grid_model_t *) calloc (1, sizeof(grid_model_t));
-	if (!model)
-		fatal("memory allocation error\n");
-	model->config = *config;
-	model->rows = config->grid_rows;
-	model->cols = config->grid_cols;
-
-	if(!strcasecmp(model->config.grid_map_mode, GRID_AVG_STR))
-		model->map_mode = GRID_AVG;
-	else if(!strcasecmp(model->config.grid_map_mode, GRID_MIN_STR))
-		model->map_mode = GRID_MIN;
-	else if(!strcasecmp(model->config.grid_map_mode, GRID_MAX_STR))
-		model->map_mode = GRID_MAX;
-	else if(!strcasecmp(model->config.grid_map_mode, GRID_CENTER_STR))
-		model->map_mode = GRID_CENTER;
-	else
-		fatal("unknown mapping mode\n");
-
-	/* layer configuration file specified?	*/
-	if(strcmp(model->config.grid_layer_file, NULLFILE))
-		model->has_lcf = TRUE;
-	else {
-		model->has_lcf = FALSE;
-		model->base_n_units = flp_default->n_units;
-	}
-
-	/* get layer information	*/
-	populate_layers_grid(model, flp_default);
-
-	/* count the total no. of blocks */
-	model->total_n_blocks = 0;
-	for(i=0; i < model->n_layers; i++)
-		model->total_n_blocks += model->layers[i].flp->n_units;
-
-	/* allocate internal state	*/
-	model->last_steady = new_grid_model_vector(model);
-	model->last_trans = new_grid_model_vector(model);
-	
-	return model;
-}
-
-void populate_R_model_grid(grid_model_t *model, flp_t *flp)
-{
-	int i;
-	double cw, ch;
-	
-	int inner_layers;
-	int model_secondary = model->config.model_secondary;
-	
-	if (model_secondary)
-		inner_layers = model->n_layers - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS;
-	else
-		inner_layers = model->n_layers - DEFAULT_PACK_LAYERS;
-
-	/* setup the block-grid maps; flp parameter is ignored */
-	if (model->has_lcf)
-		for(i=0; i < inner_layers; i++)
-			set_bgmap(model, &model->layers[i]);
-	/* only the silicon layer has allocated space for the maps. 
-	 * all the rest just point to it. so it is sufficient to
-	 * setup the block-grid map for the silicon layer alone.
-	 * further, for default layer configuration, the `flp' 
-	 * parameter should be the same as that of the silicon 
-	 * layer. finally, the chip width and height information 
-	 * need to be populated for default layer configuration
-	 */
-	else {
-		if (flp != model->layers[LAYER_SI].flp)
-			fatal("mismatch between the floorplan and the thermal model\n");
-		model->width = get_total_width(flp);
-		model->height = get_total_height(flp);
-		set_bgmap(model, &model->layers[LAYER_SI]);
-	}
-	/* sanity check on floorplan sizes	*/
-	if (model->width > model->config.s_sink || 
-		model->height > model->config.s_sink || 
-		model->width > model->config.s_spreader || 
-		model->height > model->config.s_spreader) {
-		print_flp(model->layers[0].flp);
-		print_flp_fig(model->layers[0].flp);
-		fatal("inordinate floorplan size!\n");
-	}
-
-	/* shortcuts for cell width(cw) and cell height(ch)	*/
-	cw = model->width / model->cols;
-	ch = model->height / model->rows;
-
-	/* package R's	*/
-	populate_package_R(&model->pack, &model->config, model->width, model->height);
-
-	/* layer specific resistances	*/
-	for(i=0; i < model->n_layers; i++) {
-		if (model->layers[i].has_lateral) {
-			model->layers[i].rx =  getr(model->layers[i].k, cw, ch * model->layers[i].thickness);
-			model->layers[i].ry =  getr(model->layers[i].k, ch, cw * model->layers[i].thickness);
-			if (model_secondary && (i==inner_layers-SEC_CHIP_LAYERS+LAYER_C4)) {
-				model->layers[i].rx1 =  getr(model->layers[i].k1, cw, ch * model->layers[i].thickness);
-				model->layers[i].ry1 =  getr(model->layers[i].k1, ch, cw * model->layers[i].thickness);
-			}
-		} else {
-			/* positive infinity	*/
-			model->layers[i].rx = LARGENUM;
-			model->layers[i].ry = LARGENUM;
-			if (model_secondary && (i==inner_layers-SEC_CHIP_LAYERS+LAYER_C4)) {
-				model->layers[i].rx1 = LARGENUM;
-				model->layers[i].ry1 = LARGENUM;
-			}
-		}
-		model->layers[i].rz =  getr(model->layers[i].k, model->layers[i].thickness, cw * ch);
-		if (model_secondary && (i==inner_layers-SEC_CHIP_LAYERS+LAYER_C4)) {
-			model->layers[i].rz1 =  getr(model->layers[i].k1, model->layers[i].thickness, cw * ch);
-		}
-		
-		if (!model_secondary) {
-			/* heatsink	is connected to ambient. divide r_convec proportional to cell area */
-			if (i == model->n_layers - DEFAULT_PACK_LAYERS + LAYER_SINK)
-				model->layers[i].rz += model->config.r_convec * 
-								   (model->config.s_sink * model->config.s_sink) / (cw * ch);
-		} else {
-			/* heatsink	is connected to ambient. divide r_convec proportional to cell area */
-			if (i == model->n_layers - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SINK)
-				model->layers[i].rz += model->config.r_convec * 
-								   (model->config.s_sink * model->config.s_sink) / (cw * ch);\
-			/* PCB	is connected to ambient. divide r_convec_sec proportional to cell area */
-//			if (i == model->n_layers - SEC_PACK_LAYERS + LAYER_PCB)
-//				model->layers[i].rz += model->config.r_convec_sec * 
-//								   (model->config.s_pcb * model->config.s_pcb) / (cw * ch);
-		}
-	}
-
-	/* done	*/
-	model->r_ready = TRUE;
-}
-
-void populate_C_model_grid(grid_model_t *model, flp_t *flp)
-{
-	int i;
-	
-	int inner_layers;
-	int model_secondary = model->config.model_secondary;
-	
-	/* shortcuts for cell width(cw) and cell height(ch)	*/
-	double cw = model->width / model->cols;
-	double ch = model->height / model->rows;
-	
-	if (model_secondary)
-		inner_layers = model->n_layers - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS;
-	else
-		inner_layers = model->n_layers - DEFAULT_PACK_LAYERS;
-
-	if (!model->r_ready)
-		fatal("R model not ready\n");
-	if (!model->has_lcf && flp != model->layers[LAYER_SI].flp)
-		fatal("different floorplans for R and C models!\n");
-
-	/* package C's	*/
-	populate_package_C(&model->pack, &model->config, model->width, model->height);
-
-	/* layer specific capacitances	*/
-	for(i=0; i < model->n_layers; i++)
-		model->layers[i].c =  getcap(model->layers[i].sp, model->layers[i].thickness, cw * ch);
-		if (model_secondary && (i==inner_layers-SEC_CHIP_LAYERS+LAYER_C4))
-			model->layers[i].c1 =  getcap(model->layers[i].sp1, model->layers[i].thickness, cw * ch);
-	
-	if (!model_secondary) {		
-		/* last layer (heatsink) is connected to the ambient. 
-	 	* divide c_convec proportional to cell area 
-	 	*/
-		model->layers[model->n_layers-DEFAULT_PACK_LAYERS+LAYER_SINK].c += C_FACTOR * model->config.c_convec * (cw * ch) /
-										  (model->config.s_sink * model->config.s_sink);
-	} else {
-		model->layers[model->n_layers-DEFAULT_PACK_LAYERS-SEC_PACK_LAYERS+LAYER_SINK].c += C_FACTOR * model->config.c_convec * (cw * ch) /
-										  (model->config.s_sink * model->config.s_sink);
-		model->layers[model->n_layers-SEC_PACK_LAYERS+LAYER_PCB].c += C_FACTOR * model->config.c_convec_sec * (cw * ch) /
-										  (model->config.s_pcb * model->config.s_pcb);
-	}
-
-	/* done	*/	
-	model->c_ready = TRUE;
-}
-
-/* destructor	*/
-void delete_grid_model(grid_model_t *model)
-{
-	int i;
-	
-	int inner_layers;
-	int model_secondary = model->config.model_secondary;
-	
-	if (model_secondary)
-		inner_layers = model->n_layers - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS;
-	else
-		inner_layers = model->n_layers - DEFAULT_PACK_LAYERS;
-
-	if (model->has_lcf) 
-		for(i=0; i < inner_layers; i++) {
-			delete_b2gmap(model->layers[i].b2gmap, model->rows, model->cols);
-			free(model->layers[i].g2bmap);
-			free_flp(model->layers[i].flp, FALSE);
-		}
-	/* only the silicon layer has allocated space for the maps. 
-	 * all the rest just point to it. also, its floorplan was
-	 * allocated elsewhere. so, we don't need to deallocate those.
-	 */
-	else {
-		delete_b2gmap(model->layers[LAYER_SI].b2gmap, model->rows, model->cols);
-		free(model->layers[LAYER_SI].g2bmap);
-	}
-	
-	free_grid_model_vector(model->last_steady);
-	free_grid_model_vector(model->last_trans);
-	free(model->layers);
-	free(model);
-}
-
-/* differs from 'dvector()' in that memory for internal nodes is also allocated	*/
-double *hotspot_vector_grid(grid_model_t *model)
-{
-	double total_nodes;
-	if (model->total_n_blocks <= 0)
-		fatal("total_n_blocks is not greater than zero\n");
-	
-	if (model->config.model_secondary)
-		total_nodes = model->total_n_blocks + EXTRA + EXTRA_SEC;
-	else
-		total_nodes = model->total_n_blocks + EXTRA;
-	
-	return dvector(total_nodes);
-}
-
-/* copy 'src' to 'dst' except for a window of 'size'
- * elements starting at 'at'. useful in floorplan
- * compaction. can be used only with default layer
- * configuration as all layers should have the same
- * floorplan. incompatible with layer configuration
- * file.
- */
-void trim_hotspot_vector_grid(grid_model_t *model, double *dst, double *src, 
-						 	  int at, int size)
-{
-	int i;
-	
-	double total_nodes;
-	if (model->config.model_secondary)
-		total_nodes = model->total_n_blocks + EXTRA + EXTRA_SEC;
-	else
-		total_nodes = model->total_n_blocks + EXTRA;
-	
-	if (model->has_lcf)
-		fatal("trim_hotspot_vector_grid called with lcf file\n");
-	for (i=0; i < at && i < total_nodes; i++)
-		dst[i] = src[i];
-	for(i=at+size; i < total_nodes; i++)
-		dst[i-size] = src[i];
-}
-
-/* update the model corresponding to floorplan compaction	*/						 
-void resize_thermal_model_grid(grid_model_t *model, int n_units)
-{
-	int i;
-
-	if (model->has_lcf)
-		fatal("resize_thermal_model_grid called with lcf file\n");
-	if (n_units > model->base_n_units)
-		fatal("resizing grid model to more than the allocated space\n");
-
-	/* count the total no. of blocks again */
-	model->total_n_blocks = 0;
-	for(i=0; i < model->n_layers; i++)
-		model->total_n_blocks += model->layers[i].flp->n_units;
-
-	/* nothing more needs to be done because the only data structure
-	 * that is dependent on flp->n_units is g2bmap (others are
-	 * dependent on 'grid size' which does not change because
-	 * of resizing). g2bmap is a 1-d array and needs no reallocation
-	 */
-}
-
-/* sets the temperature of a vector 'temp' allocated using 'hotspot_vector'	*/
-void set_temp_grid(grid_model_t *model, double *temp, double val)
-{
-	int i;
-	
-	double total_nodes;
-	if (model->config.model_secondary)
-		total_nodes = model->total_n_blocks + EXTRA + EXTRA_SEC;
-	else
-		total_nodes = model->total_n_blocks + EXTRA;
-		
-	if (model->total_n_blocks <= 0)
-		fatal("total_n_blocks is not greater than zero\n");
-	for(i=0; i < total_nodes; i++)
-		temp[i] = val;
-}
-
-/* dump the steady state grid temperatures of the top layer onto 'file'	*/
-void dump_top_layer_temp_grid (grid_model_t *model, char *file, 
-										grid_model_vector_t *temp)
-{
-	int i, j;
-	char str[STR_SIZE];
-	FILE *fp;
-
-	if (!model->r_ready)
-		fatal("R model not ready\n");
-
-	if (!strcasecmp(file, "stdout"))
-		fp = stdout;
-	else if (!strcasecmp(file, "stderr"))
-		fp = stderr;
-	else 	
-		fp = fopen (file, "w");
-
-	if (!fp) {
-		sprintf (str,"error: %s could not be opened for writing\n", file);
-		fatal(str);
-	}
-
-	for(i=0;  i < model->rows; i++){
-		for(j=0;  j < model->cols; j++){
-			fprintf(fp, "%d\t%.2f\n", i*model->cols+j, 
-					/* top layer of the most-recently computed 
-					 * steady state temperature	
-					 */
-					model->last_steady->cuboid[0][i][j]); 
-    }
-			fprintf(fp, "\n");
-  }
-		
-	if(fp != stdout && fp != stderr)
-		fclose(fp);	
-}
-
-/* dump the steady state grid temperatures of the top layer onto 'file'	*/
-void dump_steady_temp_grid (grid_model_t *model, char *file)
-{
-	/* top layer of the most-recently computed steady state temperature	*/
-	dump_top_layer_temp_grid(model, file, model->last_steady);
-}
-
-/* dump temperature vector alloced using 'hotspot_vector' to 'file' */ 
-void dump_temp_grid(grid_model_t *model, double *temp, char *file)
-{
-	int i, n, base = 0;
-	char str[STR_SIZE];
-	FILE *fp;
-	
-	int extra_nodes;
-	int model_secondary = model->config.model_secondary;
-	if (model_secondary)
-		extra_nodes = EXTRA + EXTRA_SEC;
-	else
-		extra_nodes = EXTRA;
-
-	if (!strcasecmp(file, "stdout"))
-		fp = stdout;
-	else if (!strcasecmp(file, "stderr"))
-		fp = stderr;
-	else 	
-		fp = fopen (file, "w");
-
-	if (!fp) {
-		sprintf (str,"error: %s could not be opened for writing\n", file);
-		fatal(str);
-	}
-
-	/* layer temperatures	*/
-	for(n=0; n < model->n_layers; n++) {
-		if (!model_secondary) {
-			/* default set of layers	*/
-			if (!model->has_lcf) {
-				switch(n)
-				{
-					case LAYER_SI:
-							strcpy(str,"");
-							break;
-					case LAYER_INT:
-							strcpy(str,"iface_");
-							break;
-					case DEFAULT_CHIP_LAYERS+LAYER_SP:
-							strcpy(str,"hsp_");
-							break;
-					case DEFAULT_CHIP_LAYERS+LAYER_SINK:
-							strcpy(str,"hsink_");
-							break;
-					default:
-							fatal("unknown layer\n");
-							break;
-				}
-			/* layer configuration file	*/
-			} else {
-					if (n == (model->n_layers - DEFAULT_PACK_LAYERS + LAYER_SP))
-						strcpy(str, "hsp_");	/* spreader layer	*/
-					else if (n == (model->n_layers - DEFAULT_PACK_LAYERS + LAYER_SINK))
-						strcpy(str, "hsink_");	/* heatsink layer	*/
-					else	/* other layers	*/
-						sprintf(str,"layer_%d_", n);
-			}
-		} else {
-			/* default set of layers	*/
-			if (!model->has_lcf) {
-				switch(n)
-				{
-					case LAYER_SI:
-							strcpy(str,"");
-							break;
-					case LAYER_INT:
-							strcpy(str,"iface_");
-							break;
-					case DEFAULT_CHIP_LAYERS+SEC_CHIP_LAYERS+LAYER_SP:
-							strcpy(str,"hsp_");
-							break;
-					case DEFAULT_CHIP_LAYERS+SEC_CHIP_LAYERS+LAYER_SINK:
-							strcpy(str,"hsink_");
-							break;
-					case DEFAULT_CHIP_LAYERS+LAYER_METAL:
-							strcpy(str,"metal_");
-							break;
-					case DEFAULT_CHIP_LAYERS+LAYER_C4:
-							strcpy(str,"c4_");
-							break;
-					case DEFAULT_CHIP_LAYERS+SEC_CHIP_LAYERS+DEFAULT_PACK_LAYERS+LAYER_SUB:
-							strcpy(str,"sub_");
-							break;
-					case DEFAULT_CHIP_LAYERS+SEC_CHIP_LAYERS+DEFAULT_PACK_LAYERS+LAYER_SOLDER:
-							strcpy(str,"solder_");
-							break;
-					case DEFAULT_CHIP_LAYERS+SEC_CHIP_LAYERS+DEFAULT_PACK_LAYERS+LAYER_PCB:
-							strcpy(str,"pcb_");
-							break;
-					default:
-							fatal("unknown layer\n");
-							break;
-				}
-			/* layer configuration file	*/
-			} else {
-					if (n == (model->n_layers - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SP))
-						strcpy(str, "hsp_");	/* spreader layer	*/
-					else if (n == (model->n_layers - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SINK))
-						strcpy(str, "hsink_");	/* heatsink layer	*/
-					else if (n == (model->n_layers - SEC_PACK_LAYERS + LAYER_SUB))
-						strcpy(str, "sub_");	/* package substrate layer	*/
-					else if (n == (model->n_layers - SEC_PACK_LAYERS + LAYER_SOLDER))
-						strcpy(str, "solder_");	/* solder layer	*/
-					else if (n == (model->n_layers - SEC_PACK_LAYERS + LAYER_PCB))
-						strcpy(str, "pcb_");	/* pcb layer	*/
-					else	/* other layers	*/
-						sprintf(str,"layer_%d_", n);
-			}
-		}
-
-		for(i=0; i < model->layers[n].flp->n_units; i++)
-			fprintf(fp, "%s%s\t%.2f\n", str, 
-					model->layers[n].flp->units[i].name, temp[base+i]);
-		base += model->layers[n].flp->n_units;	
-	}
-
-	if (base != model->total_n_blocks)
-		fatal("total_n_blocks failed to tally\n");
-
-	/* internal node temperatures	*/
-	for (i=0; i < extra_nodes; i++) {
-			sprintf(str, "inode_%d", i);
-			fprintf(fp, "%s\t%.2f\n", str, temp[base+i]);
-		}
-	if(fp != stdout && fp != stderr)
-		fclose(fp);	
-}
-
-void copy_temp_grid(grid_model_t *model, double *dst, double *src)
-{
-	if (!model->config.model_secondary)
-		copy_dvector(dst, src, model->total_n_blocks + EXTRA);
-	else
-		copy_dvector(dst, src, model->total_n_blocks + EXTRA + EXTRA_SEC);
-}
-
-/* 
- * read temperature vector alloced using 'hotspot_vector' from 'file'
- * which was dumped using 'dump_temp'. values are clipped to thermal
- * threshold based on 'clip'
- */ 
-void read_temp_grid(grid_model_t *model, double *temp, char *file, int clip)
-{
-	int i, n, idx, base = 0;
-	double max=0, val;
-	char *ptr, str1[LINE_SIZE], str2[LINE_SIZE];
-	char name[STR_SIZE], format[STR_SIZE];
-	FILE *fp;
-	
-	int model_secondary = model->config.model_secondary;
-	int extra_nodes;
-	if (model->config.model_secondary)
-		extra_nodes = EXTRA + EXTRA_SEC;
-	else
-		extra_nodes = EXTRA;
-
-	if (!strcasecmp(file, "stdin"))
-		fp = stdin;
-	else
-		fp = fopen (file, "r");
-
-	if (!fp) {
-		sprintf (str1,"error: %s could not be opened for reading\n", file);
-		fatal(str1);
-	}	
-
-	/* temperatures of the different layers	*/
-	for (n=0; n < model->n_layers; n++) {
-		if (!model_secondary) {
-			/* default set of layers	*/
-			if (!model->has_lcf) {
-				switch(n)
-				{
-					case LAYER_SI:
-							strcpy(format,"%s%lf");
-							break;
-					case LAYER_INT:
-							strcpy(format,"iface_%s%lf");
-							break;
-					case DEFAULT_CHIP_LAYERS+LAYER_SP:
-							strcpy(format,"hsp_%s%lf");
-							break;
-					case DEFAULT_CHIP_LAYERS+LAYER_SINK:
-							strcpy(format,"hsink_%s%lf");
-							break;
-					default:
-							fatal("unknown layer\n");
-							break;
-				}
-			/* layer configuration file	*/
-			} else {
-				if (!model->config.model_secondary) {
-					if (n == (model->n_layers - DEFAULT_PACK_LAYERS + LAYER_SP))
-						strcpy(format, "hsp_%s%lf");	/* spreader layer	*/
-					else if (n == (model->n_layers - DEFAULT_PACK_LAYERS + LAYER_SINK))
-						strcpy(format, "hsink_%s%lf");	/* heatsink layer	*/
-					else	/* other layers	*/
-						sprintf(format,"layer_%d_%%s%%lf", n);
-				}
-			}
-		} else {
-			/* default set of layers	*/
-			if (!model->has_lcf) {
-				switch(n)
-				{
-					case LAYER_SI:
-							strcpy(format,"%s%lf");
-							break;
-					case LAYER_INT:
-							strcpy(format,"iface_%s%lf");
-							break;
-					case DEFAULT_CHIP_LAYERS+SEC_CHIP_LAYERS+LAYER_SP:
-							strcpy(format,"hsp_%s%lf");
-							break;
-					case DEFAULT_CHIP_LAYERS+SEC_CHIP_LAYERS+LAYER_SINK:
-							strcpy(format,"hsink_%s%lf");
-							break;
-					case DEFAULT_CHIP_LAYERS+LAYER_METAL:
-							strcpy(format,"metal_%s%lf");
-							break;
-					case DEFAULT_CHIP_LAYERS+LAYER_C4:
-							strcpy(format,"c4_%s%lf");
-							break;
-					case DEFAULT_CHIP_LAYERS+SEC_CHIP_LAYERS+DEFAULT_PACK_LAYERS+LAYER_SUB:
-							strcpy(format,"sub_%s%lf");
-							break;
-					case DEFAULT_CHIP_LAYERS+SEC_CHIP_LAYERS+DEFAULT_PACK_LAYERS+LAYER_SOLDER:
-							strcpy(format,"solder_%s%lf");
-							break;
-					case DEFAULT_CHIP_LAYERS+SEC_CHIP_LAYERS+DEFAULT_PACK_LAYERS+LAYER_PCB:
-							strcpy(format,"pcb_%s%lf");
-							break;
-					default:
-							fatal("unknown layer\n");
-							break;
-				}
-			/* layer configuration file	*/
-			} else {
-						if (n == (model->n_layers - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SP))
-							strcpy(format, "hsp_%s%lf");	/* spreader layer	*/
-						else if (n == (model->n_layers - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SINK))
-							strcpy(format, "hsink_%s%lf");	/* heatsink layer	*/
-						else if (n == (model->n_layers - SEC_PACK_LAYERS + LAYER_SUB))
-							strcpy(format, "sub_%s%lf");	/* package substrate layer	*/
-						else if (n == (model->n_layers - SEC_PACK_LAYERS + LAYER_SOLDER))
-							strcpy(format, "solder_%s%lf");	/* solder ball layer	*/
-						else if (n == (model->n_layers - SEC_PACK_LAYERS + LAYER_PCB))
-							strcpy(format, "pcb_%s%lf");	/* PCB layer	*/
-						else	/* other layers	*/
-							sprintf(format,"layer_%d_%%s%%lf", n);
-			}
-		}
-
-		for (i=0; i < model->layers[n].flp->n_units; i++) {
-			fgets(str1, LINE_SIZE, fp);
-			if (feof(fp))
-				fatal("not enough lines in temperature file\n");
-			strcpy(str2, str1);
-			/* ignore comments and empty lines	*/
-			ptr = strtok(str1, " \r\t\n");
-			if (!ptr || ptr[0] == '#') {
-				i--;
-				continue;
-			}
-			if (sscanf(str2, format, name, &val) != 2)
-				fatal("invalid temperature file format\n");
-			idx = get_blk_index(model->layers[n].flp, name);
-			if (idx >= 0)
-				temp[base+idx] = val;
-			else	/* since get_blk_index calls fatal, the line below cannot be reached	*/
-				fatal ("unit in temperature file not found in floorplan\n");
-
-			/* find max temp on the top layer 
-			 * (silicon for the default set of layers)
-			 */
-			if (n == 0 && temp[idx] > max)
-				max = temp[idx];
-		}
-		base += model->layers[n].flp->n_units;
-	}
-
-	if (base != model->total_n_blocks)
-		fatal("total_n_blocks failed to tally\n");
-
-	/* internal node temperatures	*/
-	for (i=0; i < extra_nodes; i++) {
-		fgets(str1, LINE_SIZE, fp);
-		if (feof(fp))
-			fatal("not enough lines in temperature file\n");
-		strcpy(str2, str1);
-		/* ignore comments and empty lines	*/
-		ptr = strtok(str1, " \r\t\n");
-		if (!ptr || ptr[0] == '#') {
-			i--;
-			continue;
-		}
-		if (sscanf(str2, "%s%lf", name, &val) != 2)
-			fatal("invalid temperature file format\n");
-		sprintf(str1, "inode_%d", i);
-		if (strcasecmp(str1, name))
-			fatal("invalid temperature file format\n");
-		temp[base+i] = val;	
-	}
-
-	fgets(str1, LINE_SIZE, fp);
-	if (!feof(fp))
-		fatal("too many lines in temperature file\n");
-
-	if(fp != stdin)
-		fclose(fp);	
-
-	/* clipping	*/
-	if (clip && (max > model->config.thermal_threshold)) {
-		/* if max has to be brought down to thermal_threshold, 
-		 * (w.r.t the ambient) what is the scale down factor?
-		 */
-		double factor = (model->config.thermal_threshold - model->config.ambient) / 
-						(max - model->config.ambient);
-	
-		/* scale down all temperature differences (from ambient) by the same factor	*/
-		for (i=0; i < model->total_n_blocks + extra_nodes; i++)
-			temp[i] = (temp[i]-model->config.ambient)*factor + model->config.ambient;
-	}
-}
-
-/* dump power numbers to file	*/
-void dump_power_grid(grid_model_t *model, double *power, char *file)
-{
-	int i, n, base = 0;
-	char str[STR_SIZE];
-	FILE *fp;
-
-	if (!strcasecmp(file, "stdout"))
-		fp = stdout;
-	else if (!strcasecmp(file, "stderr"))
-		fp = stderr;
-	else 	
-		fp = fopen (file, "w");
-	if (!fp) {
-		sprintf (str,"error: %s could not be opened for writing\n", file);
-		fatal(str);
-	}
-
-	/* dump values only for the layers dissipating power	*/
-	for(n=0; n < model->n_layers; n++) {
-		if (model->layers[n].has_power) {
-			for(i=0; i < model->layers[n].flp->n_units; i++)
-				if (model->has_lcf)
-					fprintf(fp, "layer_%d_%s\t%.6f\n", n, 
-							model->layers[n].flp->units[i].name, power[base+i]);
-				else 
-					fprintf(fp, "%s\t%.6f\n", 
-							model->layers[n].flp->units[i].name, power[base+i]);
-		}				
-		base += model->layers[n].flp->n_units;		
-	}
-
-	if(fp != stdout && fp != stderr)
-		fclose(fp);	
-}
-
-/* 
- * read power vector alloced using 'hotspot_vector' from 'file'
- * which was dumped using 'dump_power'. 
- */ 
-void read_power_grid (grid_model_t *model, double *power, char *file)
-{
-	int i, idx, n, base = 0;
-	double val;
-	char *ptr, str1[LINE_SIZE], str2[LINE_SIZE]; 
-	char name[STR_SIZE], format[STR_SIZE];
-	FILE *fp;
-
-	if (!strcasecmp(file, "stdin"))
-		fp = stdin;
-	else
-		fp = fopen (file, "r");
-	if (!fp) {
-		sprintf (str1,"error: %s could not be opened for reading\n", file);
-		fatal(str1);
-	}
-
-	/* lcf file could potentially specify more than one power dissipating 
-	 * layer. hence, units with zero power within a layer cannot be left
-	 * out in the power file.
-	 */
-	if (model->has_lcf) {
-		for(n=0; n < model->n_layers; n++) {
-			if (model->layers[n].has_power)
-				for(i=0; i < model->layers[n].flp->n_units; i++) {
-					fgets(str1, LINE_SIZE, fp);
-					if (feof(fp))
-						fatal("not enough lines in power file\n");
-					strcpy(str2, str1);
-
-					/* ignore comments and empty lines	*/
-					ptr = strtok(str1, " \r\t\n");
-					if (!ptr || ptr[0] == '#') {
-						i--;
-						continue;
-					}
-
-					sprintf(format, "layer_%d_%%s%%lf", n);
-		  			if (sscanf(str2, format, name, &val) != 2)
-						fatal("invalid power file format\n");
-		  			idx = get_blk_index(model->layers[n].flp, name);
-		  			if (idx >= 0)
-						power[base+idx] = val;
-					/* since get_blk_index calls fatal, the line below cannot be reached	*/
-		  			else
-						fatal ("unit in power file not found in floorplan\n");
-				}
-			base += model->layers[n].flp->n_units;	
-		}
-		fgets(str1, LINE_SIZE, fp);
-		if (!feof(fp))
-			fatal("too many lines in power file\n");
-	/* default layer configuration. so only one layer
-	 * has power dissipation. units with zero power 
-	 * can be omitted in the power file
-	 */
-	} else {
-		while(!feof(fp)) {
-			fgets(str1, LINE_SIZE, fp);
-			if (feof(fp))
-				break;
-			strcpy(str2, str1);
-	
-			/* ignore comments and empty lines	*/
-			ptr = strtok(str1, " \r\t\n");
-			if (!ptr || ptr[0] == '#')
-				continue;
-	
-			if (sscanf(str2, "%s%lf", name, &val) != 2)
-				fatal("invalid power file format\n");
-			idx = get_blk_index(model->layers[LAYER_SI].flp, name);
-			if (idx >= 0)
-				power[idx] = val;
-			else	/* since get_blk_index calls fatal, the line below cannot be reached	*/
-				fatal ("unit in power file not found in floorplan\n");
-		}
-	}
-
-	if(fp != stdin)
-		fclose(fp);
-}
-
-double find_max_temp_grid(grid_model_t *model, double *temp)
-{
-	int i;
-	double max = 0.0;
-	/* max temperature occurs on the top-most layer	*/
-	for(i=0; i < model->layers[0].flp->n_units; i++) {
-		if (temp[i] < 0)
-			fatal("negative temperature!\n");
-		else if (max < temp[i])
-			max = temp[i];
-	}
-
-	return max;
-}
-
-double find_avg_temp_grid(grid_model_t *model, double *temp)
-{
-	int i, n, base = 0, count = 0; 
-	double sum = 0.0;
-	/* average temperature of all the power dissipating blocks	*/
-	for(n=0; n < model->n_layers; n++) {
-		if (model->layers[n].has_power) {
-			for(i=0; i < model->layers[n].flp->n_units; i++) {
-				if (temp[base+i] < 0)
-					fatal("negative temperature!\n");
-				else 
-					sum += temp[base+i];
-			}
-			count += model->layers[n].flp->n_units;
-		}	
-		base += model->layers[n].flp->n_units;
-	}
-
-	if (!count)
-		fatal("no power dissipating units?!\n");
-	return (sum / count);
-}
-
-/* calculate average heatsink temperature for natural convection package */
-double calc_sink_temp_grid(grid_model_t *model, double *temp, thermal_config_t *config)
-{
-	int i, n, base = 0; 
-	int hsidx = model->n_layers - DEFAULT_PACK_LAYERS + LAYER_SINK;
-	double sum = 0.0;
-	double spr_size = config->s_spreader*config->s_spreader;
-	double sink_size = config->s_sink*config->s_sink;
-
-	/* heat sink core	*/
-	for(n=0; n < hsidx; n++)
-		base += model->layers[n].flp->n_units;
-
-	for(i=base; i < base+model->layers[n].flp->n_units; i++)
-		if (temp[i] < 0)
-			fatal("negative temperature!\n");
-		else /* area-weighted average */
-			sum += temp[i]*(model->layers[n].flp->units[i-base].width*model->layers[n].flp->units[i-base].height);
-
-	/* heat sink periphery	*/
-	base = model->total_n_blocks;
-	
-	for(i=SINK_C_W; i <= SINK_C_E; i++)
-		if (temp[i+base] < 0)
-			fatal("negative temperature!\n");
-		else
-			sum += temp[i+base]*0.25*(config->s_spreader+model->height)*(config->s_spreader-model->width);
-
-	for(i=SINK_C_N; i <= SINK_C_S; i++)
-		if (temp[i+base] < 0)
-			fatal("negative temperature!\n");
-		else
-			sum += temp[i+base]*0.25*(config->s_spreader+model->width)*(config->s_spreader-model->height);
-
-	for(i=SINK_W; i <= SINK_S; i++)
-		if (temp[i+base] < 0)
-			fatal("negative temperature!\n");
-		else
-			sum += temp[i+base]*0.25*(sink_size-spr_size);
-
-	return (sum / sink_size);
-}
-
-/* grid_model_vector routines	*/
-
-/* constructor	*/
-grid_model_vector_t *new_grid_model_vector(grid_model_t *model)
-{
-	grid_model_vector_t *v;
-	
-	int extra_nodes;
-	if (model->config.model_secondary)
-		extra_nodes = EXTRA + EXTRA_SEC;
-	else
-		extra_nodes = EXTRA;
-
-	v = (grid_model_vector_t *) calloc (1, sizeof(grid_model_vector_t));
-	if (!v)
-		fatal("memory allocation error\n");
-
-	v->cuboid = dcuboid_tail(model->rows, model->cols, model->n_layers, extra_nodes);
-	v->extra = v->cuboid[0][0] + model->rows * model->cols * model->n_layers;
-	return v;
-}
-
-/* destructor	*/
-void free_grid_model_vector(grid_model_vector_t *v)
-{
-	free_dcuboid(v->cuboid);
-	free(v);
-}
-
-/* translate power/temperature between block and grid vectors	*/
-void xlate_vector_b2g(grid_model_t *model, double *b, grid_model_vector_t *g, int type)
-{
-	int i, j, n, base = 0;
-	double area;
-	
-	int extra_nodes;
-	if (model->config.model_secondary)
-		extra_nodes = EXTRA + EXTRA_SEC;
-	else
-		extra_nodes = EXTRA;
-
-	/* area of a single grid cell	*/
-	area = (model->width * model->height) / (model->cols * model->rows);
-
-	for(n=0; n < model->n_layers; n++) {
-		for(i=0; i < model->rows; i++)
-			for(j=0; j < model->cols; j++) {
-				/* for each grid cell, the power density / temperature are 
-				 * the average of the power densities / temperatures of the 
-				 * blocks in it weighted by their occupancies
-				 */
-				/* convert power density to power	*/ 
-				if (type == V_POWER)
-					g->cuboid[n][i][j] = blist_avg(model->layers[n].b2gmap[i][j], 
-										 model->layers[n].flp, &b[base], type) * area;
-				/* no conversion necessary for temperature	*/ 
-				else if (type == V_TEMP)
-					g->cuboid[n][i][j] = blist_avg(model->layers[n].b2gmap[i][j], 
-										 model->layers[n].flp, &b[base], type);
-				else
-					fatal("unknown vector type\n");
-			}
-		/* keep track of the beginning address of this layer in the 
-		 * block power vector
-		 */
-		base += model->layers[n].flp->n_units;							 
-	}
-
-	/* extra spreader and sink nodes	*/
-	for(i=0; i < extra_nodes; i++)
-		g->extra[i] = b[base+i];
-}
-
-/* translate temperature between grid and block vectors	*/
-void xlate_temp_g2b(grid_model_t *model, double *b, grid_model_vector_t *g)
-{
-	int i, j, n, u, base = 0, count;
-	int i1, j1, i2, j2, ci1, cj1, ci2, cj2;
-	double min, max, avg;
-	
-	int extra_nodes;
-	if (model->config.model_secondary)
-		extra_nodes = EXTRA + EXTRA_SEC;
-	else
-		extra_nodes = EXTRA;
-
-	for(n=0; n < model->n_layers; n++) {
-		for(u=0; u < model->layers[n].flp->n_units; u++) {
-			/* extent of this unit in grid cell units	*/
-			i1 = model->layers[n].g2bmap[u].i1;
-			j1 = model->layers[n].g2bmap[u].j1;
-			i2 = model->layers[n].g2bmap[u].i2;
-			j2 = model->layers[n].g2bmap[u].j2;
-
-			/* map the center grid cell's temperature to the block	*/
-			if (model->map_mode == GRID_CENTER) {
-				/* center co-ordinates	*/	
-				ci1 = (i1 + i2) / 2;
-				cj1 = (j1 + j2) / 2;
-				/* in case of even no. of cells, center 
-				 * is the average of two central cells
-				 */
-				/* ci2 = ci1-1 when even, ci1 otherwise	*/  
-				ci2 = ci1 - !((i2-i1) % 2);
-				/* cj2 = cj1-1 when even, cj1 otherwise	*/  
-				cj2 = cj1 - !((j2-j1) % 2);
-
-				b[base+u] = (g->cuboid[n][ci1][cj1] + g->cuboid[n][ci2][cj1] + 
-						    g->cuboid[n][ci1][cj2] + g->cuboid[n][ci2][cj2]) / 4;
-				continue;
-			}
-		
-			/* find the min/max/avg temperatures of the 
-			 * grid cells in this block
-			 */
-			avg = 0.0;
-			count = 0;
-			min = max = g->cuboid[n][i1][j1];
-			for(i=i1; i < i2; i++)
-				for(j=j1; j < j2; j++) {
-					avg += g->cuboid[n][i][j];
-					if (g->cuboid[n][i][j] < min)
-						min = g->cuboid[n][i][j];
-					if (g->cuboid[n][i][j] > max)
-						max = g->cuboid[n][i][j];
-					count++;
-				}
-
-			/* map to output accordingly	*/
-			switch (model->map_mode)
-			{
-				case GRID_AVG:
-					b[base+u] = avg / count;
-					break;
-				case GRID_MIN:
-					b[base+u] = min;
-					break;
-				case GRID_MAX:
-					b[base+u] = max;
-					break;
-				/* taken care of already	*/	
-				case GRID_CENTER:
-					break;
-				default:
-					fatal("unknown mapping mode\n");
-					break;
-			}
-		}
-		/* keep track of the beginning address of this layer in the 
-		 * block power vector
-		 */
-		base += model->layers[n].flp->n_units;							 
-	}
-
-	/* extra spreader and sink nodes	*/
-	for(i=0; i < extra_nodes; i++)
-		b[base+i] = g->extra[i];
-}
-
-/* setting package nodes' power numbers	*/
-void set_internal_power_grid(grid_model_t *model, double *power)
-{
-	if (!model->config.model_secondary)
-		zero_dvector(&power[model->total_n_blocks], EXTRA);
-	else
-		zero_dvector(&power[model->total_n_blocks], EXTRA+EXTRA_SEC);
-}
-
-/* set up initial temperatures for the steady state solution
- * heuristically (ignoring the lateral resistances)
- */
-void set_heuristic_temp(grid_model_t *model, grid_model_vector_t *power, 
-						grid_model_vector_t *temp)
-{
-	int n, i, j, nl, nr, nc;
-	double **sum;
-
-	/* shortcuts	*/
-	nl = model->n_layers;
-	nr = model->rows;
-	nc = model->cols;
-
-	/* package temperatures	*/
-	/* if all lateral resistances are considered infinity, all peripheral 
-	 * package nodes are at the ambient temperature
-	 */
-	temp->extra[SINK_N] = temp->extra[SINK_S] = 
-						  temp->extra[SINK_E] = temp->extra[SINK_W] = 
-						  temp->extra[SINK_C_N] = temp->extra[SINK_C_S] = 
-						  temp->extra[SINK_C_E] = temp->extra[SINK_C_W] = 
-						  temp->extra[SP_N] = temp->extra[SP_S] = 
-						  temp->extra[SP_E] = temp->extra[SP_W] =
-						  model->config.ambient;
-	
-	if (model->config.model_secondary) {
-		temp->extra[PCB_N] = temp->extra[PCB_S] = 
-						  temp->extra[PCB_E] = temp->extra[PCB_W] = 
-						  temp->extra[PCB_C_N] = temp->extra[PCB_C_S] = 
-						  temp->extra[PCB_C_E] = temp->extra[PCB_C_W] =
-						  temp->extra[SOLDER_N] = temp->extra[SOLDER_S] =
-						  temp->extra[SOLDER_E] = temp->extra[SOLDER_W] = 
-						  temp->extra[SUB_N] = temp->extra[SUB_S] = 
-						  temp->extra[SUB_E] = temp->extra[SUB_W] =
-						  model->config.ambient;
-	}
-
-	/* layer temperatures	*/
-	/* add up power for each grid cell across all layers */
-	sum = dmatrix(nr, nc);
-	for(n=0; n < nl; n++)
-		scaleadd_dvector(sum[0], sum[0], power->cuboid[n][0], nr*nc, 1.0);
-	
-	/* last layer	*/
-		for(i=0; i < nr; i++)
-			for(j=0; j < nc; j++)
-				temp->cuboid[nl-1][i][j] = model->config.ambient + sum[i][j] * 
-										 model->layers[nl-1].rz;
-		/* subtract away the layer's power	*/			
-		scaleadd_dvector(sum[0], sum[0], power->cuboid[nl-1][0], nr*nc, -1.0);
-				
-		/* go from last-1 to first	*/
-		for(n=nl-2; n >= 0; n--) {
-			/* nth layer temp is n+1th temp + cumul_power * rz of the nth layer	*/
-			scaleadd_dvector(temp->cuboid[n][0], temp->cuboid[n+1][0], sum[0], 
-							 nr*nc, model->layers[n].rz);
-			/* subtract away the layer's power	*/			
-			scaleadd_dvector(sum[0], sum[0], power->cuboid[n][0], nr*nc, -1.0);
-		} 
-	free_dmatrix(sum); 
-}
-
-/* single steady state iteration of grid solver - package part */
-double single_iteration_steady_pack(grid_model_t *model, grid_model_vector_t *power,
-									grid_model_vector_t *temp)
-{
-	int i, j;
-//	int extra_nodes;
-//	if (model->config.model_secondary) 
-//		extra_nodes = EXTRA + EXTRA_SEC;
-//	else 
-//		extra_nodes = EXTRA;
-		
-	double delta[EXTRA+EXTRA_SEC], max = 0;
-	/* sum of the conductances	*/
-	double csum;
-	/* weighted sum of temperatures	*/
-	double wsum;
-
-	/* shortcuts	*/
-	double *v = temp->extra;
-	package_RC_t *pk = &model->pack;
-	thermal_config_t *c = &model->config;
-	layer_t *l = model->layers;
-	int nl = model->n_layers;
-	int nr = model->rows;
-	int nc = model->cols;
-	int spidx, hsidx, subidx, solderidx, pcbidx;
-	
-	if (!model->config.model_secondary) {
-		spidx = nl - DEFAULT_PACK_LAYERS + LAYER_SP;
-		hsidx = nl - DEFAULT_PACK_LAYERS + LAYER_SINK;
-	} else {
-		spidx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SP;
-		hsidx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SINK;
-		subidx = nl - SEC_PACK_LAYERS + LAYER_SUB;
-		solderidx = nl - SEC_PACK_LAYERS + LAYER_SOLDER;
-		pcbidx = nl -SEC_PACK_LAYERS + LAYER_PCB;	
-		
-	}
-
-	/* sink outer north/south	*/
-	csum = 1.0/(pk->r_hs_per + pk->r_amb_per) + 1.0/(pk->r_hs2_y + pk->r_hs);
-	wsum = c->ambient/(pk->r_hs_per + pk->r_amb_per) + v[SINK_C_N]/(pk->r_hs2_y + pk->r_hs);
-	delta[SINK_N] = fabs(v[SINK_N] - wsum / csum);
-	v[SINK_N] = wsum / csum;
-	wsum = c->ambient/(pk->r_hs_per + pk->r_amb_per) + v[SINK_C_S]/(pk->r_hs2_y + pk->r_hs);
-	delta[SINK_S] = fabs(v[SINK_S] - wsum / csum);
-	v[SINK_S] = wsum / csum;
-	
-	/* sink outer west/east	*/
-	csum = 1.0/(pk->r_hs_per + pk->r_amb_per) + 1.0/(pk->r_hs2_x + pk->r_hs);
-	wsum = c->ambient/(pk->r_hs_per + pk->r_amb_per) + v[SINK_C_W]/(pk->r_hs2_x + pk->r_hs);
-	delta[SINK_W] = fabs(v[SINK_W] - wsum / csum);
-	v[SINK_W] = wsum / csum;
-	wsum = c->ambient/(pk->r_hs_per + pk->r_amb_per) + v[SINK_C_E]/(pk->r_hs2_x + pk->r_hs);
-	delta[SINK_E] = fabs(v[SINK_E] - wsum / csum);
-	v[SINK_E] = wsum / csum;
-
-	/* sink inner north/south	*/
-	/* partition r_hs1_y among all the nc grid cells. edge cell has half the ry */
-	csum = nc / (l[hsidx].ry / 2.0 + nc * pk->r_hs1_y);
-	csum += 1.0/(pk->r_hs_c_per_y + pk->r_amb_c_per_y) + 
-			1.0/pk->r_sp_per_y + 1.0/(pk->r_hs2_y + pk->r_hs);
-
-	wsum = 0.0;
-	for(j=0; j < nc; j++)
-		wsum += temp->cuboid[hsidx][0][j];
-	wsum /= (l[hsidx].ry / 2.0 + nc * pk->r_hs1_y);
-	wsum += c->ambient/(pk->r_hs_c_per_y + pk->r_amb_c_per_y) + 
-			v[SP_N]/pk->r_sp_per_y + v[SINK_N]/(pk->r_hs2_y + pk->r_hs);
-	delta[SINK_C_N] = fabs(v[SINK_C_N] - wsum / csum);
-	v[SINK_C_N] = wsum / csum;
-
-	wsum = 0.0;
-	for(j=0; j < nc; j++)
-		wsum += temp->cuboid[hsidx][nr-1][j];
-	wsum /= (l[hsidx].ry / 2.0 + nc * pk->r_hs1_y);
-	wsum += c->ambient/(pk->r_hs_c_per_y + pk->r_amb_c_per_y) + 
-			v[SP_S]/pk->r_sp_per_y + v[SINK_S]/(pk->r_hs2_y + pk->r_hs);
-	delta[SINK_C_S] = fabs(v[SINK_C_S] - wsum / csum);
-	v[SINK_C_S] = wsum / csum;
-
-	/* sink inner west/east	*/
-	/* partition r_hs1_x among all the nr grid cells. edge cell has half the rx */
-	csum = nr / (l[hsidx].rx / 2.0 + nr * pk->r_hs1_x);
-	csum += 1.0/(pk->r_hs_c_per_x + pk->r_amb_c_per_x) + 
-			1.0/pk->r_sp_per_x + 1.0/(pk->r_hs2_x + pk->r_hs);
-
-	wsum = 0.0;
-	for(i=0; i < nr; i++)
-		wsum += temp->cuboid[hsidx][i][0];
-	wsum /= (l[hsidx].rx / 2.0 + nr * pk->r_hs1_x);
-	wsum += c->ambient/(pk->r_hs_c_per_x + pk->r_amb_c_per_x) + 
-			v[SP_W]/pk->r_sp_per_x + v[SINK_W]/(pk->r_hs2_x + pk->r_hs);
-	delta[SINK_C_W] = fabs(v[SINK_C_W] - wsum / csum);
-	v[SINK_C_W] = wsum / csum;
-
-	wsum = 0.0;
-	for(i=0; i < nr; i++)
-		wsum += temp->cuboid[hsidx][i][nc-1];
-	wsum /= (l[hsidx].rx / 2.0 + nr * pk->r_hs1_x);
-	wsum += c->ambient/(pk->r_hs_c_per_x + pk->r_amb_c_per_x) + 
-			v[SP_E]/pk->r_sp_per_x + v[SINK_E]/(pk->r_hs2_x + pk->r_hs);
-	delta[SINK_C_E] = fabs(v[SINK_C_E] - wsum / csum);
-	v[SINK_C_E] = wsum / csum;
-
-	/* spreader north/south	*/
-	/* partition r_sp1_y among all the nc grid cells. edge cell has half the ry */
-	csum = nc / (l[spidx].ry / 2.0 + nc * pk->r_sp1_y);
-	csum += 1.0/pk->r_sp_per_y;
-
-	wsum = 0.0;
-	for(j=0; j < nc; j++)
-		wsum += temp->cuboid[spidx][0][j];
-	wsum /= (l[spidx].ry / 2.0 + nc * pk->r_sp1_y);
-	wsum += v[SINK_C_N]/pk->r_sp_per_y;
-	delta[SP_N] = fabs(v[SP_N] - wsum / csum);
-	v[SP_N] = wsum / csum;
-
-	wsum = 0.0;
-	for(j=0; j < nc; j++)
-		wsum += temp->cuboid[spidx][nr-1][j];
-	wsum /= (l[spidx].ry / 2.0 + nc * pk->r_sp1_y);
-	wsum += v[SINK_C_S]/pk->r_sp_per_y;
-	delta[SP_S] = fabs(v[SP_S] - wsum / csum);
-	v[SP_S] = wsum / csum;
-
-	/* spreader west/east	*/
-	/* partition r_sp1_x among all the nr grid cells. edge cell has half the rx */
-	csum = nr / (l[spidx].rx / 2.0 + nr * pk->r_sp1_x);
-	csum += 1.0/pk->r_sp_per_x;
-
-	wsum = 0.0;
-	for(i=0; i < nr; i++)
-		wsum += temp->cuboid[spidx][i][0];
-	wsum /= (l[spidx].rx / 2.0 + nr * pk->r_sp1_x);
-	wsum += v[SINK_C_W]/pk->r_sp_per_x;
-	delta[SP_W] = fabs(v[SP_W] - wsum / csum);
-	v[SP_W] = wsum / csum;
-
-	wsum = 0.0;
-	for(i=0; i < nr; i++)
-		wsum += temp->cuboid[spidx][i][nc-1];
-	wsum /= (l[spidx].rx / 2.0 + nr * pk->r_sp1_x);
-	wsum += v[SINK_C_E]/pk->r_sp_per_x;
-	delta[SP_E] = fabs(v[SP_E] - wsum / csum);
-	v[SP_E] = wsum / csum;
-	
-	if (model->config.model_secondary) {
-		/* secondary path package nodes */
-		/* PCB outer north/south	*/
-		csum = 1.0/(pk->r_amb_sec_per) + 1.0/(pk->r_pcb2_y + pk->r_pcb);
-		wsum = c->ambient/(pk->r_amb_sec_per) + v[PCB_C_N]/(pk->r_pcb2_y + pk->r_pcb);
-		delta[PCB_N] = fabs(v[PCB_N] - wsum / csum);
-		v[PCB_N] = wsum / csum;
-		wsum = c->ambient/(pk->r_amb_sec_per) + v[PCB_C_S]/(pk->r_pcb2_y + pk->r_pcb);
-		delta[PCB_S] = fabs(v[PCB_S] - wsum / csum);
-		v[PCB_S] = wsum / csum;
-		
-		/* PCB outer west/east	*/
-		csum = 1.0/(pk->r_amb_sec_per) + 1.0/(pk->r_pcb2_x + pk->r_pcb);
-		wsum = c->ambient/(pk->r_amb_sec_per) + v[PCB_C_W]/(pk->r_pcb2_x + pk->r_pcb);
-		delta[PCB_W] = fabs(v[PCB_W] - wsum / csum);
-		v[PCB_W] = wsum / csum;
-		wsum = c->ambient/(pk->r_amb_sec_per) + v[PCB_C_E]/(pk->r_pcb2_x + pk->r_pcb);
-		delta[PCB_E] = fabs(v[PCB_E] - wsum / csum);
-		v[PCB_E] = wsum / csum;
-  	
-		/* PCB inner north/south	*/
-		/* partition r_pcb1_y among all the nc grid cells. edge cell has half the ry */
-		csum = nc / (l[pcbidx].ry / 2.0 + nc * pk->r_pcb1_y);
-		csum += 1.0/(pk->r_amb_sec_c_per_y) + 
-				1.0/pk->r_pcb_c_per_y + 1.0/(pk->r_pcb2_y + pk->r_pcb);
-  	
-		wsum = 0.0;
-		for(j=0; j < nc; j++)
-			wsum += temp->cuboid[pcbidx][0][j];
-		wsum /= (l[pcbidx].ry / 2.0 + nc * pk->r_pcb1_y);
-		wsum += c->ambient/(pk->r_amb_sec_c_per_y) + 
-				v[SOLDER_N]/pk->r_pcb_c_per_y + v[PCB_N]/(pk->r_pcb2_y + pk->r_pcb);
-		delta[PCB_C_N] = fabs(v[PCB_C_N] - wsum / csum);
-		v[PCB_C_N] = wsum / csum;
-  	
- 		wsum = 0.0;
-		for(j=0; j < nc; j++)
-			wsum += temp->cuboid[pcbidx][nr-1][j];
-		wsum /= (l[pcbidx].ry / 2.0 + nc * pk->r_pcb1_y);
-		wsum += c->ambient/(pk->r_amb_sec_c_per_y) + 
-				v[SOLDER_S]/pk->r_pcb_c_per_y + v[PCB_S]/(pk->r_pcb2_y + pk->r_pcb);
-		delta[PCB_C_S] = fabs(v[PCB_C_S] - wsum / csum);
-		v[PCB_C_S] = wsum / csum;
-  	
-		/* PCB inner west/east	*/
-		/* partition r_pcb1_x among all the nr grid cells. edge cell has half the rx */
-		csum = nr / (l[pcbidx].rx / 2.0 + nr * pk->r_pcb1_x);
-		csum += 1.0/(pk->r_amb_sec_c_per_x) + 
-				1.0/pk->r_pcb_c_per_x + 1.0/(pk->r_pcb2_x + pk->r_pcb);
-  	
-		wsum = 0.0;
-		for(i=0; i < nr; i++)
-			wsum += temp->cuboid[pcbidx][i][0];
-		wsum /= (l[pcbidx].rx / 2.0 + nr * pk->r_pcb1_x);
-		wsum += c->ambient/(pk->r_amb_sec_c_per_x) + 
-				v[SOLDER_W]/pk->r_pcb_c_per_x + v[PCB_W]/(pk->r_pcb2_x + pk->r_pcb);
-		delta[PCB_C_W] = fabs(v[PCB_C_W] - wsum / csum);
-		v[PCB_C_W] = wsum / csum;
-  	
-		wsum = 0.0;
-		for(i=0; i < nr; i++)
-			wsum += temp->cuboid[pcbidx][i][nc-1];
-		wsum /= (l[pcbidx].rx / 2.0 + nr * pk->r_pcb1_x);
-		wsum += c->ambient/(pk->r_amb_sec_c_per_x) + 
-				v[SOLDER_E]/pk->r_pcb_c_per_x + v[PCB_E]/(pk->r_pcb2_x + pk->r_pcb);
-		delta[PCB_C_E] = fabs(v[PCB_C_E] - wsum / csum);
-		v[PCB_C_E] = wsum / csum;
-  	
-		/* solder north/south	*/
-		/* partition r_solder1_y among all the nc grid cells. edge cell has half the ry */
-		csum = nc / (l[solderidx].ry / 2.0 + nc * pk->r_solder1_y);
-		csum += 1.0/pk->r_solder_per_y + 1.0/pk->r_pcb_c_per_y;
-  	
-		wsum = 0.0;
-		for(j=0; j < nc; j++)
-			wsum += temp->cuboid[solderidx][0][j];
-		wsum /= (l[solderidx].ry / 2.0 + nc * pk->r_solder1_y);
-		wsum += v[PCB_C_N]/pk->r_pcb_c_per_y + v[SUB_N]/pk->r_solder_per_y;
-		delta[SOLDER_N] = fabs(v[SOLDER_N] - wsum / csum);
-		v[SOLDER_N] = wsum / csum;
-  	
-		wsum = 0.0;
-		for(j=0; j < nc; j++)
-			wsum += temp->cuboid[solderidx][nr-1][j];
-		wsum /= (l[solderidx].ry / 2.0 + nc * pk->r_solder1_y);
-		wsum += v[PCB_C_S]/pk->r_pcb_c_per_y + v[SUB_S]/pk->r_solder_per_y;
-		delta[SOLDER_S] = fabs(v[SOLDER_S] - wsum / csum);
-		v[SOLDER_S] = wsum / csum;
-  	
-		/* solder west/east	*/
-		/* partition r_solder1_x among all the nr grid cells. edge cell has half the rx */
-		csum = nr / (l[solderidx].rx / 2.0 + nr * pk->r_solder1_x);
-		csum += 1.0/pk->r_solder_per_x + 1.0/pk->r_pcb_c_per_x;
-  	
-		wsum = 0.0;
-		for(i=0; i < nr; i++)
-			wsum += temp->cuboid[solderidx][i][0];
-		wsum /= (l[solderidx].rx / 2.0 + nr * pk->r_solder1_x);
-		wsum += v[PCB_C_W]/pk->r_pcb_c_per_x + v[SUB_W]/pk->r_solder_per_x;
-		delta[SOLDER_W] = fabs(v[SOLDER_W] - wsum / csum);
-		v[SOLDER_W] = wsum / csum;
-  	
-		wsum = 0.0;
-		for(i=0; i < nr; i++)
-			wsum += temp->cuboid[solderidx][i][nc-1];
-		wsum /= (l[solderidx].rx / 2.0 + nr * pk->r_solder1_x);
-		wsum += v[PCB_C_E]/pk->r_pcb_c_per_x + v[SUB_E]/pk->r_solder_per_x;
-		delta[SOLDER_E] = fabs(v[SOLDER_E] - wsum / csum);
-		v[SOLDER_E] = wsum / csum; 
-		
-		/* substrate north/south	*/
-		/* partition r_sub1_y among all the nc grid cells. edge cell has half the ry */
-		csum = nc / (l[subidx].ry / 2.0 + nc * pk->r_sub1_y);
-		csum += 1.0/pk->r_solder_per_y;
-  	
-		wsum = 0.0;
-		for(j=0; j < nc; j++)
-			wsum += temp->cuboid[subidx][0][j];
-		wsum /= (l[subidx].ry / 2.0 + nc * pk->r_sub1_y);
-		wsum += v[SOLDER_N]/pk->r_solder_per_y;
-		delta[SUB_N] = fabs(v[SUB_N] - wsum / csum);
-		v[SUB_N] = wsum / csum;
-		
-		wsum = 0.0;
-		for(j=0; j < nc; j++)
-			wsum += temp->cuboid[subidx][nr-1][j];
-		wsum /= (l[subidx].ry / 2.0 + nc * pk->r_sub1_y);
-		wsum += v[SOLDER_S]/pk->r_solder_per_y;
-		delta[SUB_S] = fabs(v[SUB_S] - wsum / csum);
-		v[SUB_S] = wsum / csum;
-  	
-		/* substrate west/east	*/
-		/* partition r_sub1_x among all the nr grid cells. edge cell has half the rx */
-		csum = nr / (l[subidx].rx / 2.0 + nr * pk->r_sub1_x);
-		csum += 1.0/pk->r_solder_per_x;
-  	
-		wsum = 0.0;
-		for(i=0; i < nr; i++)
-			wsum += temp->cuboid[subidx][i][0];
-		wsum /= (l[subidx].rx / 2.0 + nr * pk->r_sub1_x);
-		wsum += v[SOLDER_W]/pk->r_solder_per_x;
-		delta[SUB_W] = fabs(v[SUB_W] - wsum / csum);
-		v[SUB_W] = wsum / csum;
-  	
-		wsum = 0.0;
-		for(i=0; i < nr; i++)
-			wsum += temp->cuboid[subidx][i][nc-1];
-		wsum /= (l[subidx].rx / 2.0 + nr * pk->r_sub1_x);
-		wsum += v[SOLDER_E]/pk->r_solder_per_x;
-		delta[SUB_E] = fabs(v[SUB_E] - wsum / csum);
-		v[SUB_E] = wsum / csum;
-	} 
-	
-	if (!model->config.model_secondary) {
-		for(i=0; i < EXTRA; i++) {
-			if (delta[i] > max)
-				max = delta[i];
-		}
-	} else {
-		for(i=0; i < EXTRA + EXTRA_SEC; i++) {
-			if (delta[i] > max)
-				max = delta[i];
-		}
-	}
-	return max;
-}
-
-/* macros for calculating conductances	*/
-/* conductance to the next cell north. zero if on northern boundary	*/
-# define NC(l,n,i,j,nl,nr,nc)		((i > 0) ? (1.0/l[n].ry) : 0.0)
-/* conductance to the next cell south. zero if on southern boundary	*/
-# define SC(l,n,i,j,nl,nr,nc)		((i < nr-1) ? (1.0/l[n].ry) : 0.0)
-/* conductance to the next cell east. zero if on eastern boundary	*/
-# define EC(l,n,i,j,nl,nr,nc)		((j < nc-1) ? (1.0/l[n].rx) : 0.0)
-/* conductance to the next cell west. zero if on western boundary	*/
-# define WC(l,n,i,j,nl,nr,nc)		((j > 0) ? (1.0/l[n].rx) : 0.0)
-/* conductance to the next cell below. zero if on bottom face		*/
-# define BC(l,n,i,j,nl,nr,nc)		((n < nl-1) ? (1.0/l[n].rz) : 0.0)
-/* conductance to the next cell above. zero if on top face			*/
-# define AC(l,n,i,j,nl,nr,nc)		((n > 0) ? (1.0/l[n-1].rz) : 0.0)
-
-/* macros for calculating weighted temperatures	*/
-/* weighted T of the next cell north. zero if on northern boundary	*/
-# define NT(l,v,n,i,j,nl,nr,nc)		((i > 0) ? (v[n][i-1][j]/l[n].ry) : 0.0)
-/* weighted T of the next cell south. zero if on southern boundary	*/
-# define ST(l,v,n,i,j,nl,nr,nc)		((i < nr-1) ? (v[n][i+1][j]/l[n].ry) : 0.0)
-/* weighted T of the next cell east. zero if on eastern boundary	*/
-# define ET(l,v,n,i,j,nl,nr,nc)		((j < nc-1) ? (v[n][i][j+1]/l[n].rx) : 0.0)
-/* weighted T of the next cell west. zero if on western boundary	*/
-# define WT(l,v,n,i,j,nl,nr,nc)		((j > 0) ? (v[n][i][j-1]/l[n].rx) : 0.0)
-/* weighted T of the next cell below. zero if on bottom face		*/
-# define BT(l,v,n,i,j,nl,nr,nc)		((n < nl-1) ? (v[n+1][i][j]/l[n].rz) : 0.0)
-/* weighted T of the next cell above. zero if on top face			*/
-# define AT(l,v,n,i,j,nl,nr,nc)		((n > 0) ? (v[n-1][i][j]/l[n-1].rz) : 0.0)
-
-
-/* single steady state iteration of grid solver - silicon part */
-double single_iteration_steady_grid(grid_model_t *model, grid_model_vector_t *power,
-									grid_model_vector_t *temp)
-{
-	int n, i, j;
-	double prev, delta, max = 0;
-	/* sum of the conductances	*/
-	double csum;
-	/* weighted sum of temperatures	*/
-	double wsum;
-	
-	/* shortcuts for cell width(cw) and cell height(ch)	*/
-	double cw = model->width / model->cols;
-	double ch = model->height / model->rows;
-
-	/* shortcuts	*/
-	double ***v = temp->cuboid;
-	thermal_config_t *c = &model->config;
-	layer_t *l = model->layers;
-	int nl = model->n_layers;
-	int nr = model->rows;
-	int nc = model->cols;
-	int spidx, hsidx, metalidx, c4idx, subidx, solderidx, pcbidx;
-	int model_secondary = model->config.model_secondary;
-	
-	if (!model->config.model_secondary) {
-		spidx = nl - DEFAULT_PACK_LAYERS + LAYER_SP;
-		hsidx = nl - DEFAULT_PACK_LAYERS + LAYER_SINK;
-	} else {
-		spidx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SP;
-		hsidx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SINK;
-		subidx = nl - SEC_PACK_LAYERS + LAYER_SUB;
-		solderidx = nl - SEC_PACK_LAYERS + LAYER_SOLDER;
-		pcbidx = nl - SEC_PACK_LAYERS + LAYER_PCB;
-		c4idx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS - SEC_CHIP_LAYERS + LAYER_C4;
-		metalidx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS - SEC_CHIP_LAYERS + LAYER_METAL;		
-	}
-
-	/* for each grid cell	*/
-	for(n=0; n < nl; n++) {
-		for(i=0; i < nr; i++) {
-			for(j=0; j < nc; j++) {
-				if((n==LAYER_SI) && model_secondary) {//top silicon layer: above is metal, beneath is TIM
-					csum = NC(l,n,i,j,nl,nr,nc) + SC(l,n,i,j,nl,nr,nc) + 
-					   EC(l,n,i,j,nl,nr,nc) + WC(l,n,i,j,nl,nr,nc) + 
-					   1.0/l[metalidx].rz + BC(l,n,i,j,nl,nr,nc);
-					wsum = NT(l,v,n,i,j,nl,nr,nc) + ST(l,v,n,i,j,nl,nr,nc) + 
-					   ET(l,v,n,i,j,nl,nr,nc) + WT(l,v,n,i,j,nl,nr,nc) + 
-					   v[metalidx][i][j]/l[metalidx].rz + BT(l,v,n,i,j,nl,nr,nc);
-				} else if((n==(metalidx-1)) && model_secondary ) {//last TIM layer: above is silicon, beneath is spreader
-					csum = NC(l,n,i,j,nl,nr,nc) + SC(l,n,i,j,nl,nr,nc) + 
-					   EC(l,n,i,j,nl,nr,nc) + WC(l,n,i,j,nl,nr,nc) + 
-					   1.0/l[metalidx-2].rz + 1.0/l[metalidx-1].rz;
-					wsum = NT(l,v,n,i,j,nl,nr,nc) + ST(l,v,n,i,j,nl,nr,nc) + 
-					   ET(l,v,n,i,j,nl,nr,nc) + WT(l,v,n,i,j,nl,nr,nc) + 
-					   v[metalidx-2][i][j]/l[metalidx-2].rz + v[spidx][i][j]/l[metalidx-1].rz;
-				} else if((n==spidx) && model_secondary ) {//spreader: above is TIM, beneath is sink
-					csum = NC(l,n,i,j,nl,nr,nc) + SC(l,n,i,j,nl,nr,nc) + 
-					   EC(l,n,i,j,nl,nr,nc) + WC(l,n,i,j,nl,nr,nc) + 
-					   1.0/l[metalidx-1].rz + BC(l,n,i,j,nl,nr,nc);
-					wsum = NT(l,v,n,i,j,nl,nr,nc) + ST(l,v,n,i,j,nl,nr,nc) + 
-					   ET(l,v,n,i,j,nl,nr,nc) + WT(l,v,n,i,j,nl,nr,nc) + 
-					   v[metalidx-1][i][j]/l[metalidx-1].rz + BT(l,v,n,i,j,nl,nr,nc);
-				} else if((n==metalidx) && model_secondary) { //metal layer: above is C4, below is Si
-					csum = NC(l,n,i,j,nl,nr,nc) + SC(l,n,i,j,nl,nr,nc) + 
-					   EC(l,n,i,j,nl,nr,nc) + WC(l,n,i,j,nl,nr,nc) + 
-					   1.0/l[c4idx].rz + 1.0/l[metalidx].rz;
-					wsum = NT(l,v,n,i,j,nl,nr,nc) + ST(l,v,n,i,j,nl,nr,nc) + 
-					   ET(l,v,n,i,j,nl,nr,nc) + WT(l,v,n,i,j,nl,nr,nc) + 
-					   v[c4idx][i][j]/l[c4idx].rz + v[LAYER_SI][i][j]/l[n].rz;
-				} else if((n==c4idx) && model_secondary) { // c4 layer: above is sub, below is metal
-					csum = NC(l,n,i,j,nl,nr,nc) + SC(l,n,i,j,nl,nr,nc) + 
-					   EC(l,n,i,j,nl,nr,nc) + WC(l,n,i,j,nl,nr,nc) + 
-					   1.0/l[subidx].rz + 1.0/l[c4idx].rz;
-					wsum = NT(l,v,n,i,j,nl,nr,nc) + ST(l,v,n,i,j,nl,nr,nc) + 
-					   ET(l,v,n,i,j,nl,nr,nc) + WT(l,v,n,i,j,nl,nr,nc) + 
-					   v[subidx][i][j]/l[subidx].rz + v[metalidx][i][j]/l[n].rz;
-				} else if((n==subidx) && model_secondary) { //sub layer: above is solder, below is c4 
-					csum = NC(l,n,i,j,nl,nr,nc) + SC(l,n,i,j,nl,nr,nc) + 
-					   EC(l,n,i,j,nl,nr,nc) + WC(l,n,i,j,nl,nr,nc) + 
-					   1.0/l[solderidx].rz + 1.0/l[subidx].rz;
-					wsum = NT(l,v,n,i,j,nl,nr,nc) + ST(l,v,n,i,j,nl,nr,nc) + 
-					   ET(l,v,n,i,j,nl,nr,nc) + WT(l,v,n,i,j,nl,nr,nc) + 
-					   v[solderidx][i][j]/l[solderidx].rz + v[c4idx][i][j]/l[n].rz;
-				} else if((n==solderidx) && model_secondary) { //solder layer: above is PCB, below is sub
-					csum = NC(l,n,i,j,nl,nr,nc) + SC(l,n,i,j,nl,nr,nc) + 
-					   EC(l,n,i,j,nl,nr,nc) + WC(l,n,i,j,nl,nr,nc) + 
-					   1.0/l[pcbidx].rz + 1.0/l[solderidx].rz;
-					wsum = NT(l,v,n,i,j,nl,nr,nc) + ST(l,v,n,i,j,nl,nr,nc) + 
-					   ET(l,v,n,i,j,nl,nr,nc) + WT(l,v,n,i,j,nl,nr,nc) + 
-					   v[pcbidx][i][j]/l[pcbidx].rz + v[subidx][i][j]/l[n].rz;
-				} else if((n==pcbidx) && model_secondary) { //PCB layer, above is ambient, below is solder
-					csum = NC(l,n,i,j,nl,nr,nc) + SC(l,n,i,j,nl,nr,nc) + 
-					   EC(l,n,i,j,nl,nr,nc) + WC(l,n,i,j,nl,nr,nc) + 
-					   1.0/l[pcbidx].rz;
-					wsum = NT(l,v,n,i,j,nl,nr,nc) + ST(l,v,n,i,j,nl,nr,nc) + 
-					   ET(l,v,n,i,j,nl,nr,nc) + WT(l,v,n,i,j,nl,nr,nc) + 
-					   v[solderidx][i][j]/l[n].rz;
-				}	else if((n==hsidx) && model_secondary) {
-					csum = NC(l,n,i,j,nl,nr,nc) + SC(l,n,i,j,nl,nr,nc) + 
-					   EC(l,n,i,j,nl,nr,nc) + WC(l,n,i,j,nl,nr,nc) + 
-					   1.0/l[spidx].rz;
-					wsum = NT(l,v,n,i,j,nl,nr,nc) + ST(l,v,n,i,j,nl,nr,nc) + 
-					   ET(l,v,n,i,j,nl,nr,nc) + WT(l,v,n,i,j,nl,nr,nc) + 
-					   v[spidx][i][j]/l[n-1].rz;
-				}	else {
-					/* sum the conductances to cells north, south, 
-				 	* east, west, above and below
-				 	*/
-					csum = NC(l,n,i,j,nl,nr,nc) + SC(l,n,i,j,nl,nr,nc) + 
-					   EC(l,n,i,j,nl,nr,nc) + WC(l,n,i,j,nl,nr,nc) + 
-					   AC(l,n,i,j,nl,nr,nc) + BC(l,n,i,j,nl,nr,nc);
-
-					/* sum of the weighted temperatures of all the neighbours	*/
-					wsum = NT(l,v,n,i,j,nl,nr,nc) + ST(l,v,n,i,j,nl,nr,nc) + 
-					   ET(l,v,n,i,j,nl,nr,nc) + WT(l,v,n,i,j,nl,nr,nc) + 
-					   AT(l,v,n,i,j,nl,nr,nc) + BT(l,v,n,i,j,nl,nr,nc);
-				}
-				
-				/* special treatment to C4/underfill */
-				if ((n == c4idx) && model->config.model_secondary) {
-					//FIXME!
-				}
-				/* spreader core is connected to its periphery	*/
-				if (n == spidx) {
-					/* northern boundary - edge cell has half the ry	*/
-					if (i == 0) {
-						csum += 1.0/(l[n].ry/2.0 + nc*model->pack.r_sp1_y); 
-						wsum += temp->extra[SP_N]/(l[n].ry/2.0 + nc*model->pack.r_sp1_y); 
-					}
-					/* southern boundary - edge cell has half the ry	*/
-					if (i == nr-1) {
-						csum += 1.0/(l[n].ry/2.0 + nc*model->pack.r_sp1_y); 
-						wsum += temp->extra[SP_S]/(l[n].ry/2.0 + nc*model->pack.r_sp1_y); 
-					}
-					/* eastern boundary	 - edge cell has half the rx	*/
-					if (j == nc-1) {
-						csum += 1.0/(l[n].rx/2.0 + nr*model->pack.r_sp1_x); 
-						wsum += temp->extra[SP_E]/(l[n].rx/2.0 + nr*model->pack.r_sp1_x); 
-					}
-					/* western boundary	- edge cell has half the rx		*/
-					if (j == 0) {
-						csum += 1.0/(l[n].rx/2.0 + nr*model->pack.r_sp1_x); 
-						wsum += temp->extra[SP_W]/(l[n].rx/2.0 + nr*model->pack.r_sp1_x); 
-					}
-				/* heatsink core is connected to its inner periphery and ambient	*/
-				} else if (n == hsidx) {
-					/* all nodes are connected to the ambient	*/
-					csum += 1.0/l[n].rz;
-					wsum += c->ambient/l[n].rz;
-					/* northern boundary - edge cell has half the ry	*/
-					if (i == 0) {
-						csum += 1.0/(l[n].ry/2.0 + nc*model->pack.r_hs1_y); 
-						wsum += temp->extra[SINK_C_N]/(l[n].ry/2.0 + nc*model->pack.r_hs1_y); 
-					}
-					/* southern boundary - edge cell has half the ry	*/
-					if (i == nr-1) {
-						csum += 1.0/(l[n].ry/2.0 + nc*model->pack.r_hs1_y); 
-						wsum += temp->extra[SINK_C_S]/(l[n].ry/2.0 + nc*model->pack.r_hs1_y); 
-					}
-					/* eastern boundary	 - edge cell has half the rx	*/
-					if (j == nc-1) {
-						csum += 1.0/(l[n].rx/2.0 + nr*model->pack.r_hs1_x); 
-						wsum += temp->extra[SINK_C_E]/(l[n].rx/2.0 + nr*model->pack.r_hs1_x); 
-					}
-					/* western boundary	- edge cell has half the rx		*/
-					if (j == 0) {
-						csum += 1.0/(l[n].rx/2.0 + nr*model->pack.r_hs1_x); 
-						wsum += temp->extra[SINK_C_W]/(l[n].rx/2.0 + nr*model->pack.r_hs1_x); 
-					}
-				} else if ((n==subidx) && model->config.model_secondary) {
-					/* northern boundary - edge cell has half the ry	*/
-					if (i == 0) {
-						csum += 1.0/(l[n].ry/2.0 + nc*model->pack.r_sub1_y); 
-						wsum += temp->extra[SUB_N]/(l[n].ry/2.0 + nc*model->pack.r_sub1_y); 
-					}
-					/* southern boundary - edge cell has half the ry	*/
-					if (i == nr-1) {
-						csum += 1.0/(l[n].ry/2.0 + nc*model->pack.r_sub1_y); 
-						wsum += temp->extra[SUB_S]/(l[n].ry/2.0 + nc*model->pack.r_sub1_y); 
-					}
-					/* eastern boundary	 - edge cell has half the rx	*/
-					if (j == nc-1) {
-						csum += 1.0/(l[n].rx/2.0 + nr*model->pack.r_sub1_x); 
-						wsum += temp->extra[SUB_E]/(l[n].rx/2.0 + nr*model->pack.r_sub1_x); 
-					}
-					/* western boundary	- edge cell has half the rx		*/
-					if (j == 0) {
-						csum += 1.0/(l[n].rx/2.0 + nr*model->pack.r_sub1_x); 
-						wsum += temp->extra[SUB_W]/(l[n].rx/2.0 + nr*model->pack.r_sub1_x); 
-					} 
-				} else if ((n==solderidx) && model->config.model_secondary) {
-					/* northern boundary - edge cell has half the ry	*/
-					if (i == 0) {
-						csum += 1.0/(l[n].ry/2.0 + nc*model->pack.r_solder1_y); 
-						wsum += temp->extra[SOLDER_N]/(l[n].ry/2.0 + nc*model->pack.r_solder1_y); 
-					}
-					/* southern boundary - edge cell has half the ry	*/
-					if (i == nr-1) {
-						csum += 1.0/(l[n].ry/2.0 + nc*model->pack.r_solder1_y); 
-						wsum += temp->extra[SOLDER_S]/(l[n].ry/2.0 + nc*model->pack.r_solder1_y); 
-					}
-					/* eastern boundary	 - edge cell has half the rx	*/
-					if (j == nc-1) {
-						csum += 1.0/(l[n].rx/2.0 + nr*model->pack.r_solder1_x); 
-						wsum += temp->extra[SOLDER_E]/(l[n].rx/2.0 + nr*model->pack.r_solder1_x); 
-					}
-					/* western boundary	- edge cell has half the rx		*/
-					if (j == 0) {
-						csum += 1.0/(l[n].rx/2.0 + nr*model->pack.r_solder1_x); 
-						wsum += temp->extra[SOLDER_W]/(l[n].rx/2.0 + nr*model->pack.r_solder1_x); 
-					} 
-				} else if ((n==pcbidx) && model->config.model_secondary) {
-					/* all nodes are connected to the ambient	*/
-					csum += 1.0/(model->config.r_convec_sec * 
-								   (model->config.s_pcb * model->config.s_pcb) / (cw * ch));
-					wsum += c->ambient/(model->config.r_convec_sec * 
-								   (model->config.s_pcb * model->config.s_pcb) / (cw * ch));
-					/* northern boundary - edge cell has half the ry	*/
-					if (i == 0) {
-						csum += 1.0/(l[n].ry/2.0 + nc*model->pack.r_pcb1_y); 
-						wsum += temp->extra[PCB_C_N]/(l[n].ry/2.0 + nc*model->pack.r_pcb1_y); 
-					}
-					/* southern boundary - edge cell has half the ry	*/
-					if (i == nr-1) {
-						csum += 1.0/(l[n].ry/2.0 + nc*model->pack.r_pcb1_y); 
-						wsum += temp->extra[PCB_C_S]/(l[n].ry/2.0 + nc*model->pack.r_pcb1_y); 
-					}
-					/* eastern boundary	 - edge cell has half the rx	*/
-					if (j == nc-1) {
-						csum += 1.0/(l[n].rx/2.0 + nr*model->pack.r_pcb1_x); 
-						wsum += temp->extra[PCB_C_E]/(l[n].rx/2.0 + nr*model->pack.r_pcb1_x); 
-					}
-					/* western boundary	- edge cell has half the rx		*/
-					if (j == 0) {
-						csum += 1.0/(l[n].rx/2.0 + nr*model->pack.r_pcb1_x); 
-						wsum += temp->extra[PCB_C_W]/(l[n].rx/2.0 + nr*model->pack.r_pcb1_x); 
-					}
-				}
-
-				/* update the current cell's temperature	*/	   
-				prev = v[n][i][j];
-				v[n][i][j] = (power->cuboid[n][i][j] + wsum) / csum;
-				
-				/* compute maximum delta	*/
-				delta =  fabs(prev - v[n][i][j]);
-				if (delta > max)
-					max = delta;
-			}
-		}
-	}
-	/* package part of the iteration	*/
-	return (MAX(max, single_iteration_steady_pack(model, power, temp)));
-}
-
-/* restriction operator for multigrid solver. given a power vector
- * corresponding to a fine grid, outputs a vector corresponding
- * to one level coarser grid (half the no. of rows and cols)
- * NOTE: model->rows and model->cols denote the size of the
- * coarser grid
- */
-void multigrid_restrict_power(grid_model_t *model, grid_model_vector_t *dst, 
-							  grid_model_vector_t *src)
-{
-	/* coarse grid indices	*/
-	int n, i, j;
-
-	/* grid cells - add the four nearest neighbours	*/
-	for(n=0; n < model->n_layers; n++)
-		for(i=0; i < model->rows; i++)
-			for(j=0; j < model->cols; j++)
-			{
-				dst->cuboid[n][i][j] = (src->cuboid[n][2*i][2*j] +
-										src->cuboid[n][2*i+1][2*j] +
-										src->cuboid[n][2*i][2*j+1] +
-										src->cuboid[n][2*i+1][2*j+1]);
-			}
-	/* package nodes - copy them as it is	*/
-	if (!model->config.model_secondary)
-		copy_dvector(dst->extra, src->extra, EXTRA);
-	else
-		copy_dvector(dst->extra, src->extra, EXTRA+EXTRA_SEC);
-}
-
-/* prolongation(interpolation) operator for multigrid solver. 
- * given a temperature vector corresponding to a coarse grid,
- * outputs a (bi)linearly interpolated vector corresponding 
- * to one level finer grid (twice the no. of rows and cols)
- * NOTE: model->rows and model->cols denote the size of the
- * coarser grid
- */
-void multigrid_prolong_temp(grid_model_t *model, grid_model_vector_t *dst, 
-							grid_model_vector_t *src)
-{
-	/* coarse grid indices	*/
-	int n, i, j;
-
-	/* shortcuts	*/
-	int nr = model->rows;
-	int nc = model->cols;
-	double ***d = dst->cuboid;
-	double ***s = src->cuboid;
-
-	/* For the fine grid cells not on the boundary,
-	 * we want to linearly interpolate in the region 
-	 * surrounded by the coarse grid cells (i,j),
-	 * (i+1,j) (i,j+1) and (i+1, j+1). The fine
-	 * grid cells in that region are (2i+1, 2j+1),
-	 * (2i+2, 2j+1), (2i+1, 2j+2) and (2i+2, 2j+2).
-	 * To interpolate bilinearly, we first interpolate
-	 * along one axis and then along the other. In
-	 * each axis, due to the proximity of the fine
-	 * grid cell co-ordinates to one of the coarse
-	 * grid cells, the weights are 3/4 and 1/4 (not
-	 * 1/2 and 1/2) So, repeating them along the  
-	 * other axis also results in weights of 9/16,
-	 * 3/16, 3/16 and 1/16
-	 */ 
-	for(n=0; n < model->n_layers; n++)
-		for(i=0; i < nr-1; i++)
-			for(j=0; j < nc-1; j++) {
-				d[n][2*i+1][2*j+1] = 9.0/16.0 * s[n][i][j] +
-									 3.0/16.0 * s[n][i+1][j] +
-									 1.0/16.0 * s[n][i+1][j+1] +
-									 3.0/16.0 * s[n][i][j+1];
-				d[n][2*i+2][2*j+1] = 3.0/16.0 * s[n][i][j] +
-									 9.0/16.0 * s[n][i+1][j] +
-									 3.0/16.0 * s[n][i+1][j+1] +
-									 1.0/16.0 * s[n][i][j+1];
-				d[n][2*i+2][2*j+2] = 1.0/16.0 * s[n][i][j] +
-									 3.0/16.0 * s[n][i+1][j] +
-									 9.0/16.0 * s[n][i+1][j+1] +
-									 3.0/16.0 * s[n][i][j+1];
-				d[n][2*i+1][2*j+2] = 3.0/16.0 * s[n][i][j] +
-									 1.0/16.0 * s[n][i+1][j] +
-									 3.0/16.0 * s[n][i+1][j+1] +
-									 9.0/16.0 * s[n][i][j+1];
-			}
-
-	/* for the cells on the boundary, we perform
-	 * a zeroth order interpolation. i.e., copy
-	 * the nearest coarse grid cell's value
-	 * as it is
-	 */
-	for(n=0; n < model->n_layers; n++) {
-		for(i=0; i < nr; i++) {
-			d[n][2*i][0] = d[n][2*i+1][0] = s[n][i][0];
-			d[n][2*i][2*nc-1] = d[n][2*i+1][2*nc-1] = s[n][i][nc-1];
-		}	
-		for(j=0; j < nc; j++) {
-			d[n][0][2*j] = d[n][0][2*j+1] = s[n][0][j];
-			d[n][2*nr-1][2*j] = d[n][2*nr-1][2*j+1] = s[n][nr-1][j];
-		}
-	}
-	
-	/* package nodes - copy them as it is	*/
-	if (!model->config.model_secondary) 
-		copy_dvector(dst->extra, src->extra, EXTRA);
-	else
-		copy_dvector(dst->extra, src->extra, EXTRA+EXTRA_SEC);
-}
-
-/* recursive multigrid solver. it uses the Gauss-Seidel (GS) iterative 
- * solver to solve at a particular grid granularity. Although GS removes
- * high frequency errors in a solution estimate pretty quickly, it 
- * takes a lot of time to eliminate the low frequency ones. These 
- * low frequency errors can be eliminated easily by coarsifying the
- * grid. This is the core principle of mulrigrid solvers. The version here
- * is called "nested iteration". It solves the problem (iteratively using GS)
- * first in the coarsest granularity and then utilizes that solution to 
- * estimate the solution in the next finer grid. This is repeated until
- * the solution is found in the finest desired grid. For details, take 
- * a look at Numerical Recipes in C (2nd edition), sections 19.5 and 19.6
- * (http://www.nrbook.com/a/bookcpdf/c19-5.pdf and
- * http://www.nrbook.com/a/bookcpdf/c19-6.pdf). Also refer to Prof.
- * Jayathi Murthy's ME 608 notes from Purdue - Chapter 8, sections 8.7-8.9.
- * (http://meweb.ecn.purdue.edu/~jmurthy/me608/main.pdf - pg. 175-192)
- */ 
-void recursive_multigrid(grid_model_t *model, grid_model_vector_t *power,
-						 grid_model_vector_t *temp)
-{
-	double delta;
-	#if VERBOSE > 1
-	unsigned int i = 0;
-	#endif
-	grid_model_vector_t *coarse_power, *coarse_temp;
-	int n;
-
-	/* setup heuristic initial temperatures	at the coarsest level*/
-	if (model->rows <= 1 || model->cols <= 1) {
-		set_heuristic_temp(model, power, temp);
-		
-	
-	/* for finer grids. use coarser solutions as estimates	*/
-	} else {
-		/* make the grid coarser	*/
-		model->rows /= 2;
-		model->cols /= 2;
-		for(n=0; n < model->n_layers; n++) {
-			/* only rz's and c's change. rx's and 
-			 * ry's remain the same	
-			 */
-			model->layers[n].rz /= 4;
-			if (model->c_ready)
-				model->layers[n].c *= 4;
-		}
-
-		/* vectors for the coarse grid	*/
-		coarse_power = new_grid_model_vector(model);
-		coarse_temp = new_grid_model_vector(model);
-
-		/* coarsen the power vector	*/
-		multigrid_restrict_power(model, coarse_power, power);
-
-		/* solve recursively	*/
-		recursive_multigrid(model, coarse_power, coarse_temp);
-
-		/* interpolate the solution to the current fine grid	*/
-		multigrid_prolong_temp(model, temp, coarse_temp);
-
-		/* cleanup	*/
-		free_grid_model_vector(coarse_power);
-		free_grid_model_vector(coarse_temp);
-		
-		/* restore the grid */
-		model->rows *= 2;
-		model->cols *= 2;
-		for(n=0; n < model->n_layers; n++) {
-			model->layers[n].rz *= 4;
-			if (model->c_ready)
-				model->layers[n].c /= 4;
-		}
-	}
-	/* refine solution iteratively till convergence	*/
-	do {
-		delta = single_iteration_steady_grid(model, power, temp);
-		#if VERBOSE > 1
-			i++;
-		#endif
-	} while (!eq(delta, 0));
-	#if VERBOSE > 1
-	fprintf(stdout, "no. of iterations for steady state convergence (%d x %d grid): %d\n", 
-					model->rows, model->cols, i);
-	#endif
-}
-
-void steady_state_temp_grid(grid_model_t *model, double *power, double *temp)
-{
-	grid_model_vector_t *p;
-	double total;
-
-	if (!model->r_ready)
-		fatal("R model not ready\n");
-
-	p = new_grid_model_vector(model);
-
-	/* package nodes' power numbers	*/
-	set_internal_power_grid(model, power);
-	
-	/* total power - package nodes have no power dissipation	*/
-	total = sum_dvector(power, model->total_n_blocks);
-
-	/* map the block power numbers to the grid	*/
-	xlate_vector_b2g(model, power, p, V_POWER);
-
-	/* solve recursively. use grid model's internal 
-	 * state vector to store the grid temperatures
-	 */ 
-	recursive_multigrid(model, p, model->last_steady);
-
-	/* map the temperature numbers back	*/
-	xlate_temp_g2b(model, temp, model->last_steady);
-
-	free_grid_model_vector(p);
-}
-
-/* function to access a 1-d array as a 3-d matrix	*/
-#define A3D(array,n,i,j,nl,nr,nc)		(array[(n)*(nr)*(nc) + (i)*(nc) + (j)])
-
-/* compute the slope vector for the package nodes	*/
-void slope_fn_pack(grid_model_t *model, double *v, grid_model_vector_t *p, double *dv)
-{
-	int i, j;
-	/* sum of the currents(power values)	*/
-	double psum;
-	
-	/* shortcuts	*/
-	package_RC_t *pk = &model->pack;
-	thermal_config_t *c = &model->config;
-	layer_t *l = model->layers;
-	int nl = model->n_layers;
-	int nr = model->rows;
-	int nc = model->cols;
-	int spidx, hsidx, metalidx, c4idx, subidx, solderidx, pcbidx;
-	
-	/* pointer to the starting address of the extra nodes	*/
-	double *x = v + nl*nr*nc;
-
-	
-	if (!model->config.model_secondary) {
-		spidx = nl - DEFAULT_PACK_LAYERS + LAYER_SP;
-		hsidx = nl - DEFAULT_PACK_LAYERS + LAYER_SINK;
-	} else {
-		spidx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SP;
-		hsidx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SINK;
-		metalidx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS - SEC_CHIP_LAYERS + LAYER_METAL;
-		c4idx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS - SEC_CHIP_LAYERS + LAYER_C4;
-		subidx = nl - SEC_PACK_LAYERS + LAYER_SUB;
-		solderidx = nl - SEC_PACK_LAYERS + LAYER_SOLDER;
-		pcbidx = nl - SEC_PACK_LAYERS + LAYER_PCB;		
-	}
-	
-
-	/* sink outer north/south	*/
-	psum = (c->ambient - x[SINK_N])/(pk->r_hs_per + pk->r_amb_per) + 
-		   (x[SINK_C_N] - x[SINK_N])/(pk->r_hs2_y + pk->r_hs);
-	dv[nl*nr*nc + SINK_N] = psum / (pk->c_hs_per + pk->c_amb_per);
-	psum = (c->ambient - x[SINK_S])/(pk->r_hs_per + pk->r_amb_per) + 
-		   (x[SINK_C_S] - x[SINK_S])/(pk->r_hs2_y + pk->r_hs);
-	dv[nl*nr*nc + SINK_S] = psum / (pk->c_hs_per + pk->c_amb_per);
-
-	/* sink outer west/east	*/
-	psum = (c->ambient - x[SINK_W])/(pk->r_hs_per + pk->r_amb_per) + 
-		   (x[SINK_C_W] - x[SINK_W])/(pk->r_hs2_x + pk->r_hs);
-	dv[nl*nr*nc + SINK_W] = psum / (pk->c_hs_per + pk->c_amb_per);
-	psum = (c->ambient - x[SINK_E])/(pk->r_hs_per + pk->r_amb_per) + 
-		   (x[SINK_C_E] - x[SINK_E])/(pk->r_hs2_x + pk->r_hs);
-	dv[nl*nr*nc + SINK_E] = psum / (pk->c_hs_per + pk->c_amb_per);
-
-	/* sink inner north/south	*/
-	/* partition r_hs1_y among all the nc grid cells. edge cell has half the ry	*/
-	psum = 0.0;
-	for(j=0; j < nc; j++)
-		psum += (A3D(v,hsidx,0,j,nl,nr,nc) - x[SINK_C_N]);
-	psum /= (l[hsidx].ry / 2.0 + nc * pk->r_hs1_y);
-	psum += (c->ambient - x[SINK_C_N])/(pk->r_hs_c_per_y + pk->r_amb_c_per_y) + 
-			(x[SP_N] - x[SINK_C_N])/pk->r_sp_per_y +
-			(x[SINK_N] - x[SINK_C_N])/(pk->r_hs2_y + pk->r_hs);
-	dv[nl*nr*nc + SINK_C_N] = psum / (pk->c_hs_c_per_y + pk->c_amb_c_per_y);
-
-	psum = 0.0;
-	for(j=0; j < nc; j++)
-		psum += (A3D(v,hsidx,nr-1,j,nl,nr,nc) - x[SINK_C_S]);
-	psum /= (l[hsidx].ry / 2.0 + nc * pk->r_hs1_y);
-	psum += (c->ambient - x[SINK_C_S])/(pk->r_hs_c_per_y + pk->r_amb_c_per_y) + 
-			(x[SP_S] - x[SINK_C_S])/pk->r_sp_per_y +
-			(x[SINK_S] - x[SINK_C_S])/(pk->r_hs2_y + pk->r_hs);
-	dv[nl*nr*nc + SINK_C_S] = psum / (pk->c_hs_c_per_y + pk->c_amb_c_per_y);
-
-	/* sink inner west/east	*/
-	/* partition r_hs1_x among all the nr grid cells. edge cell has half the rx	*/
-	psum = 0.0;
-	for(i=0; i < nr; i++)
-		psum += (A3D(v,hsidx,i,0,nl,nr,nc) - x[SINK_C_W]);
-	psum /= (l[hsidx].rx / 2.0 + nr * pk->r_hs1_x);
-	psum += (c->ambient - x[SINK_C_W])/(pk->r_hs_c_per_x + pk->r_amb_c_per_x) + 
-			(x[SP_W] - x[SINK_C_W])/pk->r_sp_per_x +
-			(x[SINK_W] - x[SINK_C_W])/(pk->r_hs2_x + pk->r_hs);
-	dv[nl*nr*nc + SINK_C_W] = psum / (pk->c_hs_c_per_x + pk->c_amb_c_per_x);
-
-	psum = 0.0;
-	for(i=0; i < nr; i++)
-		psum += (A3D(v,hsidx,i,nc-1,nl,nr,nc) - x[SINK_C_E]);
-	psum /= (l[hsidx].rx / 2.0 + nr * pk->r_hs1_x);
-	psum += (c->ambient - x[SINK_C_E])/(pk->r_hs_c_per_x + pk->r_amb_c_per_x) + 
-			(x[SP_E] - x[SINK_C_E])/pk->r_sp_per_x +
-			(x[SINK_E] - x[SINK_C_E])/(pk->r_hs2_x + pk->r_hs);
-	dv[nl*nr*nc + SINK_C_E] = psum / (pk->c_hs_c_per_x + pk->c_amb_c_per_x);
-
-	/* spreader north/south	*/
-	/* partition r_sp1_y among all the nc grid cells. edge cell has half the ry	*/
-	psum = 0.0;
-	for(j=0; j < nc; j++)
-		psum += (A3D(v,spidx,0,j,nl,nr,nc) - x[SP_N]);
-	psum /= (l[spidx].ry / 2.0 + nc * pk->r_sp1_y);
-	psum += (x[SINK_C_N] - x[SP_N])/pk->r_sp_per_y;
-	dv[nl*nr*nc + SP_N] = psum / pk->c_sp_per_y;
-
-	psum = 0.0;
-	for(j=0; j < nc; j++)
-		psum += (A3D(v,spidx,nr-1,j,nl,nr,nc) - x[SP_S]);
-	psum /= (l[spidx].ry / 2.0 + nc * pk->r_sp1_y);
-	psum += (x[SINK_C_S] - x[SP_S])/pk->r_sp_per_y;
-	dv[nl*nr*nc + SP_S] = psum / pk->c_sp_per_y;
-
-	/* spreader west/east	*/
-	/* partition r_sp1_x among all the nr grid cells. edge cell has half the rx	*/
-	psum = 0.0;
-	for(i=0; i < nr; i++)
-		psum += (A3D(v,spidx,i,0,nl,nr,nc) - x[SP_W]);
-	psum /= (l[spidx].rx / 2.0 + nr * pk->r_sp1_x);
-	psum += (x[SINK_C_W] - x[SP_W])/pk->r_sp_per_x;
-	dv[nl*nr*nc + SP_W] = psum / pk->c_sp_per_x;
-
-	psum = 0.0;
-	for(i=0; i < nr; i++)
-		psum += (A3D(v,spidx,i,nc-1,nl,nr,nc) - x[SP_E]);
-	psum /= (l[spidx].rx / 2.0 + nr * pk->r_sp1_x);
-	psum += (x[SINK_C_E] - x[SP_E])/pk->r_sp_per_x;
-	dv[nl*nr*nc + SP_E] = psum / pk->c_sp_per_x;
-	
-	if (model->config.model_secondary) {
-		/* PCB outer north/south	*/
-		psum = (c->ambient - x[PCB_N])/(pk->r_amb_sec_per) + 
-			   (x[PCB_C_N] - x[PCB_N])/(pk->r_pcb2_y + pk->r_pcb);
-		dv[nl*nr*nc + PCB_N] = psum / (pk->c_pcb_per + pk->c_amb_sec_per);
-		psum = (c->ambient - x[PCB_S])/(pk->r_amb_sec_per) + 
-			   (x[PCB_C_S] - x[PCB_S])/(pk->r_pcb2_y + pk->r_pcb);
-		dv[nl*nr*nc + PCB_S] = psum / (pk->c_pcb_per + pk->c_amb_sec_per);
-  	
-		/* PCB outer west/east	*/
-		psum = (c->ambient - x[PCB_W])/(pk->r_amb_sec_per) + 
-			   (x[PCB_C_W] - x[PCB_W])/(pk->r_pcb2_x + pk->r_pcb);
-		dv[nl*nr*nc + PCB_W] = psum / (pk->c_pcb_per + pk->c_amb_sec_per);
-		psum = (c->ambient - x[PCB_E])/(pk->r_amb_sec_per) + 
-			   (x[PCB_C_E] - x[PCB_E])/(pk->r_pcb2_x + pk->r_pcb);
-		dv[nl*nr*nc + PCB_E] = psum / (pk->c_pcb_per + pk->c_amb_sec_per);
-  	
-		/* PCB inner north/south	*/
-		/* partition r_pcb1_y among all the nc grid cells. edge cell has half the ry	*/
-		psum = 0.0;
-		for(j=0; j < nc; j++)
-			psum += (A3D(v,pcbidx,0,j,nl,nr,nc) - x[PCB_C_N]);
-		psum /= (l[pcbidx].ry / 2.0 + nc * pk->r_pcb1_y);
-		psum += (c->ambient - x[PCB_C_N])/(pk->r_amb_sec_c_per_y) + 
-				(x[SOLDER_N] - x[PCB_C_N])/pk->r_pcb_c_per_y +
-				(x[PCB_N] - x[PCB_C_N])/(pk->r_pcb2_y + pk->r_pcb);
-		dv[nl*nr*nc + PCB_C_N] = psum / (pk->c_pcb_c_per_y + pk->c_amb_sec_c_per_y);
-  	
-		psum = 0.0;
-		for(j=0; j < nc; j++)
-			psum += (A3D(v,pcbidx,nr-1,j,nl,nr,nc) - x[PCB_C_S]);
-		psum /= (l[pcbidx].ry / 2.0 + nc * pk->r_pcb1_y);
-		psum += (c->ambient - x[PCB_C_S])/(pk->r_amb_sec_c_per_y) + 
-				(x[SOLDER_S] - x[PCB_C_S])/pk->r_pcb_c_per_y +
-				(x[PCB_S] - x[PCB_C_S])/(pk->r_pcb2_y + pk->r_pcb);
-		dv[nl*nr*nc + PCB_C_S] = psum / (pk->c_pcb_c_per_y + pk->c_amb_sec_c_per_y);
-  	
-  	/* PCB inner west/east	*/
-		/* partition r_pcb1_x among all the nr grid cells. edge cell has half the rx	*/
-		psum = 0.0;
-		for(i=0; i < nr; i++)
-			psum += (A3D(v,pcbidx,i,0,nl,nr,nc) - x[PCB_C_W]);
-		psum /= (l[pcbidx].rx / 2.0 + nr * pk->r_pcb1_x);
-		psum += (c->ambient - x[PCB_C_W])/(pk->r_amb_sec_c_per_x) + 
-				(x[SOLDER_W] - x[PCB_C_W])/pk->r_pcb_c_per_x +
-				(x[PCB_W] - x[PCB_C_W])/(pk->r_pcb2_x + pk->r_pcb);
-		dv[nl*nr*nc + PCB_C_W] = psum / (pk->c_pcb_c_per_x + pk->c_amb_sec_c_per_x);
-  	
-		psum = 0.0;
-		for(i=0; i < nr; i++)
-			psum += (A3D(v,pcbidx,i,nc-1,nl,nr,nc) - x[PCB_C_E]);
-		psum /= (l[pcbidx].rx / 2.0 + nr * pk->r_pcb1_x);
-		psum += (c->ambient - x[PCB_C_E])/(pk->r_amb_sec_c_per_x) + 
-				(x[SOLDER_E] - x[PCB_C_E])/pk->r_pcb_c_per_x +
-				(x[PCB_E] - x[PCB_C_E])/(pk->r_pcb2_x + pk->r_pcb);
-		dv[nl*nr*nc + PCB_C_E] = psum / (pk->c_pcb_c_per_x + pk->c_amb_sec_c_per_x);
-  	
-		/* solder ball north/south	*/
-		/* partition r_solder1_y among all the nc grid cells. edge cell has half the ry	*/
-		psum = 0.0;
-		for(j=0; j < nc; j++)
-			psum += (A3D(v,solderidx,0,j,nl,nr,nc) - x[SOLDER_N]);
-		psum /= (l[solderidx].ry / 2.0 + nc * pk->r_solder1_y);
-		psum += (x[PCB_C_N] - x[SOLDER_N])/pk->r_pcb_c_per_y;
-		dv[nl*nr*nc + SOLDER_N] = psum / pk->c_solder_per_y;
-  	
-		psum = 0.0;
-		for(j=0; j < nc; j++)
-			psum += (A3D(v,solderidx,nr-1,j,nl,nr,nc) - x[SOLDER_S]);
-		psum /= (l[solderidx].ry / 2.0 + nc * pk->r_solder1_y);
-		psum += (x[PCB_C_S] - x[SOLDER_S])/pk->r_pcb_c_per_y;
-		dv[nl*nr*nc + SOLDER_S] = psum / pk->c_solder_per_y;
-  	
-		/* solder ball west/east	*/
-		/* partition r_solder1_x among all the nr grid cells. edge cell has half the rx	*/
-		psum = 0.0;
-		for(i=0; i < nr; i++)
-			psum += (A3D(v,solderidx,i,0,nl,nr,nc) - x[SOLDER_W]);
-		psum /= (l[solderidx].rx / 2.0 + nr * pk->r_solder1_x);
-		psum += (x[PCB_C_W] - x[SOLDER_W])/pk->r_pcb_c_per_x;
-		dv[nl*nr*nc + SOLDER_W] = psum / pk->c_solder_per_x;
-  	
-		psum = 0.0;
-		for(i=0; i < nr; i++)
-			psum += (A3D(v,solderidx,i,nc-1,nl,nr,nc) - x[SOLDER_E]);
-		psum /= (l[solderidx].rx / 2.0 + nr * pk->r_solder1_x);
-		psum += (x[PCB_C_E] - x[SOLDER_E])/pk->r_pcb_c_per_x;
-		dv[nl*nr*nc + SOLDER_E] = psum / pk->c_solder_per_x;
-		
-		/* package substrate north/south	*/
-		/* partition r_sub1_y among all the nc grid cells. edge cell has half the ry	*/
-		psum = 0.0;
-		for(j=0; j < nc; j++)
-			psum += (A3D(v,subidx,0,j,nl,nr,nc) - x[SUB_N]);
-		psum /= (l[subidx].ry / 2.0 + nc * pk->r_sub1_y);
-		psum += (x[SOLDER_N] - x[SUB_N])/pk->r_solder_per_y;
-		dv[nl*nr*nc + SUB_N] = psum / pk->c_sub_per_y;
-  	
-		psum = 0.0;
-		for(j=0; j < nc; j++)
-			psum += (A3D(v,subidx,nr-1,j,nl,nr,nc) - x[SUB_S]);
-		psum /= (l[subidx].ry / 2.0 + nc * pk->r_sub1_y);
-		psum += (x[SOLDER_S] - x[SUB_S])/pk->r_solder_per_y;
-		dv[nl*nr*nc + SUB_S] = psum / pk->c_sub_per_y;
-  	
-		/* sub ball west/east	*/
-		/* partition r_sub1_x among all the nr grid cells. edge cell has half the rx	*/
-		psum = 0.0;
-		for(i=0; i < nr; i++)
-			psum += (A3D(v,subidx,i,0,nl,nr,nc) - x[SUB_W]);
-		psum /= (l[subidx].rx / 2.0 + nr * pk->r_sub1_x);
-		psum += (x[SOLDER_W] - x[SUB_W])/pk->r_solder_per_x;
-		dv[nl*nr*nc + SUB_W] = psum / pk->c_sub_per_x;
-  	
-		psum = 0.0;
-		for(i=0; i < nr; i++)
-			psum += (A3D(v,subidx,i,nc-1,nl,nr,nc) - x[SUB_E]);
-		psum /= (l[subidx].rx / 2.0 + nr * pk->r_sub1_x);
-		psum += (x[SOLDER_E] - x[SUB_E])/pk->r_solder_per_x;
-		dv[nl*nr*nc + SUB_E] = psum / pk->c_sub_per_x;
-	}
-}
-
-/* macros for calculating currents(power values)	*/
-/* current(power) from the next cell north. zero if on northern boundary	*/
-# define NP(l,v,n,i,j,nl,nr,nc)		((i > 0) ? ((A3D(v,n,i-1,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].ry) : 0.0)
-/* current(power) from the next cell south. zero if on southern boundary	*/
-# define SP(l,v,n,i,j,nl,nr,nc)		((i < nr-1) ? ((A3D(v,n,i+1,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].ry) : 0.0)
-/* current(power) from the next cell east. zero if on eastern boundary	*/
-# define EP(l,v,n,i,j,nl,nr,nc)		((j < nc-1) ? ((A3D(v,n,i,j+1,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].rx) : 0.0)
-/* current(power) from the next cell west. zero if on western boundary	*/
-# define WP(l,v,n,i,j,nl,nr,nc)		((j > 0) ? ((A3D(v,n,i,j-1,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].rx) : 0.0)
-/* current(power) from the next cell below. zero if on bottom face		*/
-# define BP(l,v,n,i,j,nl,nr,nc)		((n < nl-1) ? ((A3D(v,n+1,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].rz) : 0.0)
-/* current(power) from the next cell above. zero if on top face			*/
-# define AP(l,v,n,i,j,nl,nr,nc)		((n > 0) ? ((A3D(v,n-1,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n-1].rz) : 0.0)
-
-/* compute the slope vector for the grid cells. the transient
- * equation is CdV + sum{(T - Ti)/Ri} = P 
- * so, slope = dV = [P + sum{(Ti-T)/Ri}]/C
- */
-void slope_fn_grid(grid_model_t *model, double *v, grid_model_vector_t *p, double *dv)
-{
-	int n, i, j;
-	/* sum of the currents(power values)	*/
-	double psum;
-	
-	/* shortcuts for cell width(cw) and cell height(ch)	*/
-	double cw = model->width / model->cols;
-	double ch = model->height / model->rows;
-
-	/* shortcuts	*/
-	thermal_config_t *c = &model->config;
-	layer_t *l = model->layers;
-	int nl = model->n_layers;
-	int nr = model->rows;
-	int nc = model->cols;
-	int spidx, hsidx, metalidx, c4idx, subidx, solderidx, pcbidx;
-	int model_secondary = model->config.model_secondary;
-	
-	/* pointer to the starting address of the extra nodes	*/
-	double *x = v + nl*nr*nc;
-	
-	if (!model->config.model_secondary) {
-		spidx = nl - DEFAULT_PACK_LAYERS + LAYER_SP;
-		hsidx = nl - DEFAULT_PACK_LAYERS + LAYER_SINK;
-	} else {
-		spidx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SP;
-		hsidx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SINK;
-		metalidx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS - SEC_CHIP_LAYERS + LAYER_METAL;
-		c4idx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS - SEC_CHIP_LAYERS + LAYER_C4;
-		subidx = nl - SEC_PACK_LAYERS + LAYER_SUB;
-		solderidx = nl - SEC_PACK_LAYERS + LAYER_SOLDER;
-		pcbidx = nl - SEC_PACK_LAYERS + LAYER_PCB;		
-	}
-	
-	/* for each grid cell	*/
-	for(n=0; n < nl; n++)
-		for(i=0; i < nr; i++)
-			for(j=0; j < nc; j++) {
-				if (n==LAYER_SI && model_secondary) { //top silicon layer
-					psum = NP(l,v,n,i,j,nl,nr,nc) + SP(l,v,n,i,j,nl,nr,nc) + 
-					   EP(l,v,n,i,j,nl,nr,nc) + WP(l,v,n,i,j,nl,nr,nc) + 
-					   ((A3D(v,metalidx,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[metalidx].rz) +
-					   ((A3D(v,n+1,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].rz);
-				} else if (n==spidx && model_secondary) { //spreader layer
-					psum = NP(l,v,n,i,j,nl,nr,nc) + SP(l,v,n,i,j,nl,nr,nc) + 
-					   EP(l,v,n,i,j,nl,nr,nc) + WP(l,v,n,i,j,nl,nr,nc) + 
-					   ((A3D(v,metalidx-1,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[metalidx-1].rz) +
-					   ((A3D(v,hsidx,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].rz);
-				} else if (n==metalidx && model_secondary) { //metal layer
-					psum = NP(l,v,n,i,j,nl,nr,nc) + SP(l,v,n,i,j,nl,nr,nc) + 
-					   EP(l,v,n,i,j,nl,nr,nc) + WP(l,v,n,i,j,nl,nr,nc) + 
-					   ((A3D(v,c4idx,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[c4idx].rz) +
-					   ((A3D(v,LAYER_SI,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].rz);
-				} else if (n==metalidx-1 && model_secondary) { // TIM layer
-					psum = NP(l,v,n,i,j,nl,nr,nc) + SP(l,v,n,i,j,nl,nr,nc) + 
-					   EP(l,v,n,i,j,nl,nr,nc) + WP(l,v,n,i,j,nl,nr,nc) + 
-					   ((A3D(v,metalidx-2,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[metalidx-2].rz) +
-					   ((A3D(v,spidx,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].rz);
-				} else if (n==c4idx && model_secondary) { //C4 layer
-					psum = NP(l,v,n,i,j,nl,nr,nc) + SP(l,v,n,i,j,nl,nr,nc) + 
-					   EP(l,v,n,i,j,nl,nr,nc) + WP(l,v,n,i,j,nl,nr,nc) + 
-					   ((A3D(v,subidx,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[subidx].rz) +
-					   ((A3D(v,metalidx,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].rz);
-				} else if (n==subidx && model_secondary) { //Substrate layer
-					psum = NP(l,v,n,i,j,nl,nr,nc) + SP(l,v,n,i,j,nl,nr,nc) + 
-					   EP(l,v,n,i,j,nl,nr,nc) + WP(l,v,n,i,j,nl,nr,nc) + 
-					   ((A3D(v,solderidx,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[solderidx].rz) +
-					   ((A3D(v,c4idx,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].rz);
-				} else if (n==pcbidx && model_secondary) { //PCB layer
-					psum = NP(l,v,n,i,j,nl,nr,nc) + SP(l,v,n,i,j,nl,nr,nc) + 
-					   EP(l,v,n,i,j,nl,nr,nc) + WP(l,v,n,i,j,nl,nr,nc) + 
-					   ((A3D(v,solderidx,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].rz);
-				} else if (n==hsidx && model_secondary) { // heatsink layer
-					psum = NP(l,v,n,i,j,nl,nr,nc) + SP(l,v,n,i,j,nl,nr,nc) + 
-					   EP(l,v,n,i,j,nl,nr,nc) + WP(l,v,n,i,j,nl,nr,nc) + 
-					   ((A3D(v,spidx,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[spidx].rz);
-				} else {
-					/* sum the currents(power values) to cells north, south, 
-				 	* east, west, above and below
-				 	*/
-					psum = NP(l,v,n,i,j,nl,nr,nc) + SP(l,v,n,i,j,nl,nr,nc) + 
-					   EP(l,v,n,i,j,nl,nr,nc) + WP(l,v,n,i,j,nl,nr,nc) + 
-					   AP(l,v,n,i,j,nl,nr,nc) + BP(l,v,n,i,j,nl,nr,nc);
-				}
-
-				/* spreader core is connected to its periphery	*/
-				if (n == spidx) {
-					/* northern boundary - edge cell has half the ry	*/
-					if (i == 0)
-						psum += (x[SP_N] - A3D(v,n,i,j,nl,nr,nc))/(l[n].ry/2.0 + nc*model->pack.r_sp1_y); 
-					/* southern boundary - edge cell has half the ry	*/
-					if (i == nr-1)
-						psum += (x[SP_S] - A3D(v,n,i,j,nl,nr,nc))/(l[n].ry/2.0 + nc*model->pack.r_sp1_y); 
-					/* eastern boundary	 - edge cell has half the rx	*/
-					if (j == nc-1)
-						psum += (x[SP_E] - A3D(v,n,i,j,nl,nr,nc))/(l[n].rx/2.0 + nr*model->pack.r_sp1_x); 
-					/* western boundary	 - edge cell has half the rx	*/
-					if (j == 0)
-						psum += (x[SP_W] - A3D(v,n,i,j,nl,nr,nc))/(l[n].rx/2.0 + nr*model->pack.r_sp1_x); 
-				/* heatsink core is connected to its inner periphery and ambient	*/
-				} else if (n == hsidx) {
-					/* all nodes are connected to the ambient	*/
-					psum += (c->ambient - A3D(v,n,i,j,nl,nr,nc))/l[n].rz;
-					/* northern boundary - edge cell has half the ry	*/
-					if (i == 0)
-						psum += (x[SINK_C_N] - A3D(v,n,i,j,nl,nr,nc))/(l[n].ry/2.0 + nc*model->pack.r_hs1_y); 
-					/* southern boundary - edge cell has half the ry	*/
-					if (i == nr-1)
-						psum += (x[SINK_C_S] - A3D(v,n,i,j,nl,nr,nc))/(l[n].ry/2.0 + nc*model->pack.r_hs1_y); 
-					/* eastern boundary	 - edge cell has half the rx	*/
-					if (j == nc-1)
-						psum += (x[SINK_C_E] - A3D(v,n,i,j,nl,nr,nc))/(l[n].rx/2.0 + nr*model->pack.r_hs1_x); 
-					/* western boundary	 - edge cell has half the rx	*/
-					if (j == 0)
-						psum += (x[SINK_C_W] - A3D(v,n,i,j,nl,nr,nc))/(l[n].rx/2.0 + nr*model->pack.r_hs1_x); 
-				}	else if (n == pcbidx && model->config.model_secondary) {
-					/* all nodes are connected to the ambient	*/
-					psum += (c->ambient - A3D(v,n,i,j,nl,nr,nc))/(model->config.r_convec_sec * 
-								   (model->config.s_pcb * model->config.s_pcb) / (cw * ch));
-					/* northern boundary - edge cell has half the ry	*/
-					if (i == 0)
-						psum += (x[PCB_C_N] - A3D(v,n,i,j,nl,nr,nc))/(l[n].ry/2.0 + nc*model->pack.r_pcb1_y); 
-					/* southern boundary - edge cell has half the ry	*/
-					if (i == nr-1)
-						psum += (x[PCB_C_S] - A3D(v,n,i,j,nl,nr,nc))/(l[n].ry/2.0 + nc*model->pack.r_pcb1_y); 
-					/* eastern boundary	 - edge cell has half the rx	*/
-					if (j == nc-1)
-						psum += (x[PCB_C_E] - A3D(v,n,i,j,nl,nr,nc))/(l[n].rx/2.0 + nr*model->pack.r_pcb1_x); 
-					/* western boundary	 - edge cell has half the rx	*/
-					if (j == 0)
-						psum += (x[PCB_C_W] - A3D(v,n,i,j,nl,nr,nc))/(l[n].rx/2.0 + nr*model->pack.r_pcb1_x); 
-				}	else if (n == subidx && model->config.model_secondary) {
-					/* northern boundary - edge cell has half the ry	*/
-					if (i == 0)
-						psum += (x[SUB_N] - A3D(v,n,i,j,nl,nr,nc))/(l[n].ry/2.0 + nc*model->pack.r_sub1_y); 
-					/* southern boundary - edge cell has half the ry	*/
-					if (i == nr-1)
-						psum += (x[SUB_S] - A3D(v,n,i,j,nl,nr,nc))/(l[n].ry/2.0 + nc*model->pack.r_sub1_y); 
-					/* eastern boundary	 - edge cell has half the rx	*/
-					if (j == nc-1)
-						psum += (x[SUB_E] - A3D(v,n,i,j,nl,nr,nc))/(l[n].rx/2.0 + nr*model->pack.r_sub1_x); 
-					/* western boundary	 - edge cell has half the rx	*/
-					if (j == 0)
-						psum += (x[SUB_W] - A3D(v,n,i,j,nl,nr,nc))/(l[n].rx/2.0 + nr*model->pack.r_sub1_x); 
-				}	else if (n == solderidx && model->config.model_secondary) {
-					/* northern boundary - edge cell has half the ry	*/
-					if (i == 0)
-						psum += (x[SOLDER_N] - A3D(v,n,i,j,nl,nr,nc))/(l[n].ry/2.0 + nc*model->pack.r_solder1_y); 
-					/* southern boundary - edge cell has half the ry	*/
-					if (i == nr-1)
-						psum += (x[SOLDER_S] - A3D(v,n,i,j,nl,nr,nc))/(l[n].ry/2.0 + nc*model->pack.r_solder1_y); 
-					/* eastern boundary	 - edge cell has half the rx	*/
-					if (j == nc-1)
-						psum += (x[SOLDER_E] - A3D(v,n,i,j,nl,nr,nc))/(l[n].rx/2.0 + nr*model->pack.r_solder1_x); 
-					/* western boundary	 - edge cell has half the rx	*/
-					if (j == 0)
-						psum += (x[SOLDER_W] - A3D(v,n,i,j,nl,nr,nc))/(l[n].rx/2.0 + nr*model->pack.r_solder1_x); 
-				}
-
-				/* update the current cell's temperature	*/	   
-				A3D(dv,n,i,j,nl,nr,nc) = (p->cuboid[n][i][j] + psum) / l[n].c;
-			}
-	slope_fn_pack(model, v, p, dv);
-}
-
-void compute_temp_grid(grid_model_t *model, double *power, double *temp, double time_elapsed)
-{
-	double t, h, new_h;
-	int extra_nodes;
-	grid_model_vector_t *p;
-	#if VERBOSE > 1
-	unsigned int i = 0;
-	#endif
-	
-	if (model->config.model_secondary)
-		extra_nodes = EXTRA + EXTRA_SEC;
-	else
-		extra_nodes = EXTRA;
-	
-	if (!model->r_ready || !model->c_ready)
-		fatal("grid model not ready\n");
-
-	p = new_grid_model_vector(model);
-
-	/* package nodes' power numbers	*/
-	set_internal_power_grid(model, power);
-
-	/* map the block power/temp numbers to the grid	*/
-	xlate_vector_b2g(model, power, p, V_POWER);
-
-	/* if temp is NULL, re-use the temperature from the
-	 * last call. otherwise, translate afresh and remember 
-	 * the grid and block temperature arrays for future use
-	 */
-	if (temp != NULL) {
-		xlate_vector_b2g(model, temp, model->last_trans, V_TEMP);
-		model->last_temp = temp;
-	}	
-
-	/* Obtain temp at time (t+time_elapsed). 
-	 * Instead of getting the temperature at t+time_elapsed directly, we
-	 * do it in multiple steps with the correct step size at each time 
-	 * provided by rk4. 
-	 */
-	for (t = 0, new_h = MIN_STEP; t < time_elapsed && new_h >= MIN_STEP*DELTA; t+=h) {
-		h = new_h;
-		/* pass the entire grid and the tail of package nodes 
-		 * as a 1-d array
-		 */
-		new_h = rk4(model, model->last_trans->cuboid[0][0],  p, 
-				 /* array size = grid size + EXTRA	*/
-				 model->rows * model->cols * model->n_layers + extra_nodes, &h,
-				 model->last_trans->cuboid[0][0], 
-				 /* the slope function callback is typecast accordingly */
-				 (slope_fn_ptr) slope_fn_grid);
-		new_h = MIN(new_h, time_elapsed-t-h);
-		#if VERBOSE > 1
-			i++;
-		#endif	
-	}
-
-	#if VERBOSE > 1
-	fprintf(stdout, "no. of rk4 calls during compute_temp: %d\n", i+1);
-	#endif
-
-	/* map the temperature numbers back	*/
-	xlate_temp_g2b(model, model->last_temp, model->last_trans);
-
-	free_grid_model_vector(p);
-}
-
-/* debug print	*/
-void debug_print_blist(blist_t *head, flp_t *flp)
-{
-	blist_t *ptr;
-	fprintf(stdout, "printing blist information...\n");
-	for(ptr = head; ptr; ptr = ptr->next) {
-		fprintf(stdout, "unit: %s\n", flp->units[ptr->idx].name);
-		fprintf(stdout, "occupancy: %f\n", ptr->occupancy);
-	}
-}
-
-void debug_print_glist(glist_t *array, flp_t *flp)
-{
-	int i;
-	fprintf(stdout, "printing glist information...\n");
-	for(i=0; i < flp->n_units; i++)
-		fprintf(stdout, "unit: %s\tstartx: %d\tendx: %d\tstarty: %d\tendy: %d\n",
-				flp->units[i].name, array[i].j1, array[i].j2, array[i].i1, array[i].i2);
-}
-
-void debug_print_layer(grid_model_t *model, layer_t *layer)
-{
-	int i, j;
-	fprintf(stdout, "printing layer information...\n");
-	fprintf(stdout, "no: %d\n", layer->no);
-	fprintf(stdout, "has_lateral: %d\n", layer->has_lateral);
-	fprintf(stdout, "has_power: %d\n", layer->has_power);
-	fprintf(stdout, "k: %f\n", layer->k);
-	fprintf(stdout, "thickness: %f\n", layer->thickness);
-	fprintf(stdout, "sp: %f\n", layer->sp);
-	fprintf(stdout, "rx: %f\try: %f\trz: %f\tc: %f\n", 
-			layer->rx, layer->ry, layer->rz, layer->c);
-
-	fprintf(stdout, "printing b2gmap information...\n");
-	for(i=0; i < model->rows; i++)
-		for(j=0; j < model->cols; j++) {
-			fprintf(stdout, "row: %d, col: %d\n", i, j);
-			debug_print_blist(layer->b2gmap[i][j], layer->flp);
-		}
-
-	fprintf(stdout, "printing g2bmap information...\n");
-	debug_print_glist(layer->g2bmap, layer->flp);
-}
-
-void debug_print_grid_model_vector(grid_model_t *model, grid_model_vector_t *v, int nl, int nr, int nc)
-{
-	int n;
-	int extra_nodes;
-	
-	if (model->config.model_secondary)
-		extra_nodes = EXTRA + EXTRA_SEC;
-	else
-		extra_nodes = EXTRA;
-
-	fprintf(stdout, "printing cuboid information...\n");
-	for(n=0; n < nl; n++)
-		dump_dmatrix(v->cuboid[n], nr, nc);
-	fprintf(stdout, "printing extra information...\n");
-	dump_dvector(v->extra, extra_nodes);
-}
-
-void debug_print_grid(grid_model_t *model)
-{
-	int i;
-	int extra_nodes;
-	
-	if (model->config.model_secondary)
-		extra_nodes = EXTRA + EXTRA_SEC;
-	else
-		extra_nodes = EXTRA;
-		
-	fprintf(stdout, "printing grid model information...\n");
-	fprintf(stdout, "rows: %d\n", model->rows);
-	fprintf(stdout, "cols: %d\n", model->cols);
-	fprintf(stdout, "width: %f\n", model->width);
-	fprintf(stdout, "height: %f\n", model->height);
-
-	debug_print_package_RC(&model->pack);
-
-	fprintf(stdout, "total_n_blocks: %d\n", model->total_n_blocks);
-	fprintf(stdout, "map_mode: %d\n", model->map_mode);
-	fprintf(stdout, "r_ready: %d\n", model->r_ready);
-	fprintf(stdout, "c_ready: %d\n", model->c_ready);
-	fprintf(stdout, "has_lcf: %d\n", model->has_lcf);
-
-	fprintf(stdout, "printing last_steady information...\n");
-	debug_print_grid_model_vector(model, model->last_steady, model->n_layers, 
-								  model->rows, model->cols);
-
-	fprintf(stdout, "printing last_trans information...\n");
-	debug_print_grid_model_vector(model, model->last_trans, model->n_layers,
-								  model->rows, model->cols);
-
-	fprintf(stdout, "printing last_temp information...\n");
-	if (model->last_temp)
-		dump_dvector(model->last_temp, model->total_n_blocks + extra_nodes);
-	else
-		fprintf(stdout, "(null)\n");
-
-	for(i=0; i < model->n_layers; i++)
-		debug_print_layer(model, &model->layers[i]);
-
-	fprintf(stdout, "base_n_units: %d\n", model->base_n_units);
-}
-
diff -Naur temp/temperature_grid.cc HotSpot/temperature_grid.cc
--- temp/temperature_grid.cc	1970-01-01 01:00:00.000000000 +0100
+++ HotSpot/temperature_grid.cc	2017-11-20 09:59:35.312820617 +0100
@@ -0,0 +1,3067 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#ifdef _MSC_VER
+#define strcasecmp    _stricmp
+#define strncasecmp   _strnicmp
+#else
+#include <strings.h>
+#endif
+#include <math.h>
+
+#include "temperature_grid.h"
+#include "flp.h"
+#include "util.h"
+
+/* constructors	*/
+blist_t *new_blist(int idx, double occupancy)
+{
+	blist_t *ptr = (blist_t *) calloc (1, sizeof(blist_t));
+	if (!ptr)
+		fatal((char*)"memory allocation error\n");
+	ptr->idx = idx;
+	ptr->occupancy = occupancy;
+	ptr->next = NULL;
+	return ptr;
+}
+
+blist_t ***new_b2gmap(int rows, int cols)
+{
+	int i;
+	blist_t ***b2gmap;
+
+	b2gmap = (blist_t ***) calloc (rows, sizeof(blist_t **));
+	b2gmap[0] = (blist_t **) calloc (rows * cols, sizeof(blist_t *));
+	if (!b2gmap || !b2gmap[0])
+		fatal((char*)"memory allocation error\n");
+
+	for(i=1; i < rows; i++) 
+		b2gmap[i] = b2gmap[0] + cols * i;
+
+	return b2gmap;	
+}
+
+/* destructor	*/
+void delete_b2gmap(blist_t ***b2gmap, int rows, int cols)
+{
+	int i, j;
+	blist_t *ptr, *temp;
+
+	/* free the linked list	*/
+	for(i=0; i < rows; i++)
+		for(j=0; j < cols; j++) {
+			ptr = b2gmap[i][j];
+			while(ptr) {
+				temp = ptr->next;
+				free(ptr);
+				ptr = temp;
+			}
+		}
+
+	/* free the array space	*/
+	free(b2gmap[0]);
+	free(b2gmap);
+}
+
+/* re-initialize */
+void reset_b2gmap(grid_model_t *model, layer_t *layer)
+{
+	int i, j;
+	blist_t *ptr, *temp;
+
+	/* free the linked list	*/
+	for(i=0; i < model->rows; i++)
+		for(j=0; j < model->cols; j++) {
+			ptr = layer->b2gmap[i][j];
+			while(ptr) {
+				temp = ptr->next;
+				free(ptr);
+				ptr = temp;
+			}
+			layer->b2gmap[i][j] = NULL;
+		}
+}
+
+/* create a linked list node and append it at the end	*/
+void blist_append(blist_t *head, int idx, double occupancy)
+{
+	blist_t *tail = NULL;
+	
+	if(!head)
+		fatal((char*)"blist_append called with empty list\n");
+
+	/* traverse till the end	*/
+	for(; head; head = head->next)
+		tail = head;
+
+	/* append */
+	tail->next =  new_blist(idx, occupancy);
+}
+
+/* compute the power/temperature average weighted by occupancies	*/
+double blist_avg(blist_t *ptr, flp_t *flp, double *v, int type)
+{
+	double  val = 0.0;
+	
+	for(; ptr; ptr = ptr->next) {
+		if (type == V_POWER)
+			val += ptr->occupancy * v[ptr->idx] / (flp->units[ptr->idx].width * 
+				   flp->units[ptr->idx].height);
+		else if (type == V_TEMP)		   
+			val += ptr->occupancy * v[ptr->idx];
+		else
+			fatal((char*)"unknown vector type\n");
+	}		
+
+	return val;		   
+}
+
+void debug_print_blist(blist_t *head, flp_t *flp);
+/* test the block-grid map data structure	*/
+void test_b2gmap(grid_model_t *model, layer_t *layer)
+{
+	int i, j;
+	blist_t *ptr;
+	double sum;
+
+	/* a correctly formed b2gmap should have the 
+	 * sum of occupancies in each linked list
+	 * to be equal to 1.0
+	 */
+	for (i=0; i < model->rows; i++)
+		for(j=0; j < model->cols; j++) {
+			sum = 0.0;
+			for(ptr = layer->b2gmap[i][j]; ptr; ptr = ptr->next)
+				sum += ptr->occupancy;
+			if (!eq(floor(sum*1e5 + 0.5)/1e5, 1.0)) {
+				fprintf(stdout, "i: %d\tj: %d\n", i, j);
+				debug_print_blist(layer->b2gmap[i][j], layer->flp);
+				fatal((char*)"erroneous b2gmap data structure. invalid floorplan?\n");
+			}	
+		}
+}
+
+/* setup the block and grid mapping data structures	*/
+void set_bgmap(grid_model_t *model, layer_t *layer)
+{
+	/* i1, i2, j1 and j2 are indices of the boundary grid cells	*/
+	int i, j, u, i1, i2, j1, j2;
+
+	/* shortcuts for cell width(cw) and cell height(ch)	*/
+	double cw = model->width / model->cols;
+	double ch = model->height / model->rows;
+
+	/* initialize	*/
+	reset_b2gmap(model, layer);
+
+	/* for each functional unit	*/
+	for(u=0; u < layer->flp->n_units; u++) {
+		/* shortcuts for unit boundaries	*/
+		double lu = layer->flp->units[u].leftx;
+		double ru = lu + layer->flp->units[u].width;
+		double bu = layer->flp->units[u].bottomy;
+		double tu = bu + layer->flp->units[u].height;
+
+		/* top index (lesser row) = rows - ceil (topy / cell height)	*/
+		i1 = model->rows - tolerant_ceil(tu/ch);
+		/* bottom index (greater row) = rows - floor (bottomy / cell height)	*/
+		i2 = model->rows - tolerant_floor(bu/ch);
+		/* left index = floor (leftx / cell width)	*/
+		j1 = tolerant_floor(lu/cw);
+		/* right index = ceil (rightx / cell width)	*/
+		j2 = tolerant_ceil(ru/cw);
+		/* sanity check	*/
+		if((i1 < 0) || (j1 < 0))
+			fatal((char*)"negative grid cell start index!\n");
+		if((i2 > model->rows) || (j2 > model->cols))
+			fatal((char*)"grid cell end index out of bounds!\n");
+		if((i1 >= i2) || (j1 >= j2))
+			fatal((char*)"invalid floorplan spec or grid resolution\n");
+
+		/* setup g2bmap	*/
+		layer->g2bmap[u].i1 = i1;
+		layer->g2bmap[u].i2 = i2;
+		layer->g2bmap[u].j1 = j1;
+		layer->g2bmap[u].j2 = j2;
+
+		/* setup b2gmap	*/
+		/* for each grid cell in this unit	*/
+		for(i=i1; i < i2; i++)
+			for(j=j1; j < j2; j++)
+				/* grid cells fully overlapped by this unit	*/
+				if ((i > i1) && (i < i2-1) && (j > j1) && (j < j2-1)) {
+					/* first unit in the list	*/
+					if (!layer->b2gmap[i][j])
+						layer->b2gmap[i][j] = new_blist(u, 1.0);
+					else {
+					/* this should not occur since the grid cell is 
+					 * fully covered and hence, no other unit should 
+					 * be sharing it
+					 */
+						blist_append(layer->b2gmap[i][j], u, 1.0);
+						warning((char*)"overlap of functional blocks?\n");
+					}
+				/* boundary grid cells partially overlapped by this unit	*/
+				} else {
+					/* shortcuts for cell boundaries	*/
+					double lc = j * cw, rc = (j+1) * cw;
+					double tc = model->height - i * ch;
+					double bc = model->height - (i+1) * ch;
+					
+					/* shortcuts for overlap width and height	*/
+					double oh = (MIN(tu, tc) - MAX(bu, bc));
+					double ow = (MIN(ru, rc) - MAX(lu, lc));
+					double occupancy;
+			
+					/* overlap tolerance	*/
+					if (eq(oh/ch, 0))
+						oh = 0;
+					else if (eq(oh/ch, 1))
+						oh = ch;
+
+					if (eq(ow/cw, 0))
+						ow = 0;
+					else if (eq(ow/cw, 1))
+						ow = cw;
+
+					occupancy = (oh * ow) / (ch * cw);
+					if (oh < 0 || ow < 0)
+						fatal((char*)"negative overlap!\n");
+
+					/* first unit in the list	*/
+					if (!layer->b2gmap[i][j])
+						layer->b2gmap[i][j] = new_blist(u, occupancy);
+					else
+					/* append at the end	*/
+						blist_append(layer->b2gmap[i][j], u, occupancy);
+				}
+	}
+
+	/* 
+	 * sanity check	
+	test_b2gmap(model, layer);
+	 */
+}
+
+/* populate default set of layers	*/ 
+void populate_default_layers(grid_model_t *model, flp_t *flp_default)
+{
+	/* silicon	*/
+	model->layers[LAYER_SI].no = LAYER_SI;
+	model->layers[LAYER_SI].has_lateral = TRUE;
+	model->layers[LAYER_SI].has_power = TRUE;
+	model->layers[LAYER_SI].k = model->config.k_chip;
+	model->layers[LAYER_SI].thickness = model->config.t_chip;
+	model->layers[LAYER_SI].sp = model->config.p_chip;
+	model->layers[LAYER_SI].flp = flp_default;
+	model->layers[LAYER_SI].b2gmap = new_b2gmap(model->rows, model->cols);
+	model->layers[LAYER_SI].g2bmap = (glist_t *) calloc(flp_default->n_units, sizeof(glist_t));
+	if (!model->layers[LAYER_SI].g2bmap)
+		fatal((char*)"memory allocation error\n");
+
+	/* interface material	*/
+	model->layers[LAYER_INT].no = LAYER_INT;
+	model->layers[LAYER_INT].has_lateral = TRUE;
+	model->layers[LAYER_INT].has_power = FALSE;
+	model->layers[LAYER_INT].k = model->config.k_interface;
+	model->layers[LAYER_INT].thickness = model->config.t_interface;
+	model->layers[LAYER_INT].sp = model->config.p_interface;
+	model->layers[LAYER_INT].flp = flp_default;
+	model->layers[LAYER_INT].b2gmap = model->layers[LAYER_SI].b2gmap;
+	model->layers[LAYER_INT].g2bmap = model->layers[LAYER_SI].g2bmap;
+	
+	if (model->config.model_secondary) {
+		/* metal layer	*/
+		model->layers[DEFAULT_CHIP_LAYERS + LAYER_METAL].no = DEFAULT_CHIP_LAYERS + LAYER_METAL;
+		model->layers[DEFAULT_CHIP_LAYERS + LAYER_METAL].has_lateral = TRUE;
+		model->layers[DEFAULT_CHIP_LAYERS + LAYER_METAL].has_power = FALSE;
+		model->layers[DEFAULT_CHIP_LAYERS + LAYER_METAL].k = K_METAL;
+		model->layers[DEFAULT_CHIP_LAYERS + LAYER_METAL].k1 = K_DIELECTRIC; 
+		model->layers[DEFAULT_CHIP_LAYERS + LAYER_METAL].thickness = model->config.t_metal;
+		model->layers[DEFAULT_CHIP_LAYERS + LAYER_METAL].sp = SPEC_HEAT_METAL;
+		model->layers[DEFAULT_CHIP_LAYERS + LAYER_METAL].flp = flp_default;
+		model->layers[DEFAULT_CHIP_LAYERS + LAYER_METAL].b2gmap = model->layers[LAYER_SI].b2gmap;
+		model->layers[DEFAULT_CHIP_LAYERS + LAYER_METAL].g2bmap = model->layers[LAYER_SI].g2bmap;
+		if (!model->layers[DEFAULT_CHIP_LAYERS + LAYER_METAL].g2bmap)
+			fatal((char*)"memory allocation error\n");
+  	
+		/* C4/underfill layer*/
+		model->layers[DEFAULT_CHIP_LAYERS + LAYER_C4].no = DEFAULT_CHIP_LAYERS + LAYER_C4;
+		model->layers[DEFAULT_CHIP_LAYERS + LAYER_C4].has_lateral = TRUE;
+		model->layers[DEFAULT_CHIP_LAYERS + LAYER_C4].has_power = FALSE;
+		model->layers[DEFAULT_CHIP_LAYERS + LAYER_C4].k = K_C4;
+		model->layers[DEFAULT_CHIP_LAYERS + LAYER_C4].k1 = K_UNDERFILL;
+		model->layers[DEFAULT_CHIP_LAYERS + LAYER_C4].thickness = model->config.t_c4;
+		model->layers[DEFAULT_CHIP_LAYERS + LAYER_C4].sp = SPEC_HEAT_C4;
+		model->layers[DEFAULT_CHIP_LAYERS + LAYER_C4].sp1 = SPEC_HEAT_UNDERFILL;
+		model->layers[DEFAULT_CHIP_LAYERS + LAYER_C4].flp = flp_default;
+		model->layers[DEFAULT_CHIP_LAYERS + LAYER_C4].b2gmap = model->layers[LAYER_SI].b2gmap;
+		model->layers[DEFAULT_CHIP_LAYERS + LAYER_C4].g2bmap = model->layers[LAYER_SI].g2bmap;
+	}
+}
+
+/* populate the package layers	*/ 
+void append_package_layers(grid_model_t *model)
+{
+	/* shortcut	*/
+	int nl = model->n_layers;
+
+	/* spreader	*/
+	model->layers[nl+LAYER_SP].no = nl+LAYER_SP;
+	model->layers[nl+LAYER_SP].has_lateral = TRUE;
+	model->layers[nl+LAYER_SP].has_power = FALSE;
+	model->layers[nl+LAYER_SP].k = model->config.k_spreader;
+	model->layers[nl+LAYER_SP].thickness = model->config.t_spreader;
+	model->layers[nl+LAYER_SP].sp = model->config.p_spreader;
+	model->layers[nl+LAYER_SP].flp = model->layers[nl-1].flp;
+	model->layers[nl+LAYER_SP].b2gmap = model->layers[nl-1].b2gmap;
+	model->layers[nl+LAYER_SP].g2bmap = model->layers[nl-1].g2bmap;
+
+	/* heatsink	*/
+	model->layers[nl+LAYER_SINK].no = nl+LAYER_SINK;
+	model->layers[nl+LAYER_SINK].has_lateral = TRUE;
+	model->layers[nl+LAYER_SINK].has_power = FALSE;
+	model->layers[nl+LAYER_SINK].k = model->config.k_sink;
+	model->layers[nl+LAYER_SINK].thickness = model->config.t_sink;
+	model->layers[nl+LAYER_SINK].sp = model->config.p_sink;
+	model->layers[nl+LAYER_SINK].flp = model->layers[nl-1].flp;
+	model->layers[nl+LAYER_SINK].b2gmap = model->layers[nl-1].b2gmap;
+	model->layers[nl+LAYER_SINK].g2bmap = model->layers[nl-1].g2bmap;
+
+	model->n_layers += DEFAULT_PACK_LAYERS;
+		
+	if (model->config.model_secondary) {
+		/* package substrate	*/
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SUB].no = nl+DEFAULT_PACK_LAYERS+LAYER_SUB;
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SUB].has_lateral = TRUE;
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SUB].has_power = FALSE;
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SUB].k = K_SUB;
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SUB].thickness = model->config.t_sub;
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SUB].sp = SPEC_HEAT_SUB;
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SUB].flp = model->layers[nl-1].flp;
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SUB].b2gmap = model->layers[nl-1].b2gmap;
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SUB].g2bmap = model->layers[nl-1].g2bmap;
+		
+		/* solder balls	*/
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SOLDER].no = nl+DEFAULT_PACK_LAYERS+LAYER_SOLDER;
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SOLDER].has_lateral = TRUE;
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SOLDER].has_power = FALSE;
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SOLDER].k = K_SOLDER;
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SOLDER].thickness = model->config.t_solder;
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SOLDER].sp = SPEC_HEAT_SOLDER;
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SOLDER].flp = model->layers[nl-1].flp;
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SOLDER].b2gmap = model->layers[nl-1].b2gmap;
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_SOLDER].g2bmap = model->layers[nl-1].g2bmap;
+  	
+		/* PCB	*/
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_PCB].no = nl+DEFAULT_PACK_LAYERS+LAYER_PCB;
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_PCB].has_lateral = TRUE;
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_PCB].has_power = FALSE;
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_PCB].k = K_PCB;
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_PCB].thickness = model->config.t_pcb;
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_PCB].sp = SPEC_HEAT_PCB;
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_PCB].flp = model->layers[nl-1].flp;
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_PCB].b2gmap = model->layers[nl-1].b2gmap;
+		model->layers[nl+DEFAULT_PACK_LAYERS+LAYER_PCB].g2bmap = model->layers[nl-1].g2bmap;
+		
+		model->n_layers += SEC_PACK_LAYERS;		
+	}
+}
+
+/* parse the layer file open for reading	*/
+void parse_layer_file(grid_model_t *model, FILE *fp)
+{
+	char line[LINE_SIZE], *ptr, cval;
+	int count, i = 0, field = LCF_SNO, ival;
+	double dval;
+
+	fseek(fp, 0, SEEK_SET);
+	count = 0;
+	while (!feof(fp) && count < (model->n_layers * LCF_NPARAMS)) {
+		ptr = fgets(line, LINE_SIZE, fp);
+		if (feof(fp))
+			break;
+
+		/* ignore comments and empty lines	*/
+		ptr = strtok(line, " \r\t\n");
+		if (!ptr || ptr[0] == '#')
+			continue;
+			
+		switch (field) 
+		{
+			case LCF_SNO:
+						if (sscanf(ptr, "%d", &ival) != 1)
+							fatal((char*)"invalid layer number\n");
+						if(ival >= model->n_layers || ival < 0)
+							fatal((char*)"layer number must be >= 0 and < no. of layers\n");
+						if (model->layers[ival].no != 0)
+							fatal((char*)"layer numbers must be unique\n");
+						i = ival;
+						model->layers[i].no = ival;
+						break;
+			case LCF_LATERAL:
+						if (sscanf(ptr, "%c", &cval) != 1)
+							fatal((char*)"invalid layer heat flow indicator\n");
+						if (cval == 'Y' || cval == 'y')
+							model->layers[i].has_lateral = TRUE;
+						else if (cval == 'N' || cval == 'n')			
+							model->layers[i].has_lateral = FALSE;
+						else			
+							fatal((char*)"invalid layer heat flow indicator\n");
+						break;
+			case LCF_POWER:
+						if (sscanf(ptr, "%c", &cval) != 1)
+							fatal((char*)"invalid layer power dissipation indicator\n");
+						if (cval == 'Y' || cval == 'y')
+							model->layers[i].has_power = TRUE;
+						else if (cval == 'N' || cval == 'n')			
+							model->layers[i].has_power = FALSE;
+						else			
+							fatal((char*)"invalid layer power dissipation indicator\n");
+						break;
+			case LCF_SP:
+						if (sscanf(ptr, "%lf", &dval) != 1)
+							fatal((char*)"invalid specific heat\n");
+						model->layers[i].sp = dval;
+						break;
+			case LCF_RHO:
+						if (sscanf(ptr, "%lf", &dval) != 1)
+							fatal((char*)"invalid resistivity\n");
+						model->layers[i].k = 1.0 / dval;
+						break;
+			case LCF_THICK:
+						if (sscanf(ptr, "%lf", &dval) != 1)
+							fatal((char*)"invalid thickness\n");
+						model->layers[i].thickness = dval;
+						break;
+			case LCF_FLP:
+						model->layers[i].flp = read_flp(ptr, FALSE);
+						/* first layer	*/
+						if (count < LCF_NPARAMS) {
+							model->width = get_total_width(model->layers[i].flp);
+							model->height = get_total_height(model->layers[i].flp);
+						} else if(!eq(model->width, get_total_width(model->layers[i].flp)) || 
+								  !eq(model->height, get_total_height(model->layers[i].flp)))
+							fatal((char*)"width and height differ across layers\n");
+						break;
+			default:
+						fatal((char*)"invalid field id\n");
+						break;
+		}
+		field = (field + 1) % LCF_NPARAMS;
+		count++;
+	}
+
+	/* allocate the block-grid maps */
+	for(i=0; i < model->n_layers; i++) {
+		model->layers[i].b2gmap = new_b2gmap(model->rows, model->cols);
+		model->layers[i].g2bmap = (glist_t *) calloc(model->layers[i].flp->n_units, 
+								   sizeof(glist_t));
+		if (!model->layers[i].g2bmap)
+			fatal((char*)"memory allocation error\n");
+	}
+}
+
+/* populate layer info either from the default floorplan or from
+ * the layer configuration file (lcf)
+ */
+void populate_layers_grid(grid_model_t *model, flp_t *flp_default)
+{
+	char str[STR_SIZE];
+	FILE *fp = NULL;
+
+	/* lcf file specified	*/
+	if (model->has_lcf) {
+		if (!strcasecmp(model->config.grid_layer_file, "stdin"))
+			fp = stdin;
+		else
+			fp = fopen (model->config.grid_layer_file, "r");
+		if (!fp) {
+			sprintf(str, "error opening file %s\n", model->config.grid_layer_file);
+			fatal(str);
+		}
+	}
+
+	/* compute the no. of layers	*/
+	if (!model->config.model_secondary) {
+		if (model->has_lcf) {
+			model->n_layers = count_significant_lines(fp);
+			if (model->n_layers % LCF_NPARAMS)
+				fatal((char*)"wrong no. of lines in layer file\n");
+			model->n_layers /= LCF_NPARAMS;
+		/* default no. of layers when lcf file is not specified	*/	
+		} else
+			model->n_layers = DEFAULT_CHIP_LAYERS;
+	} else {
+		if (model->has_lcf) {
+			model->n_layers = count_significant_lines(fp);
+			if (model->n_layers % LCF_NPARAMS)
+				fatal((char*)"wrong no. of lines in layer file\n");
+			model->n_layers /= LCF_NPARAMS;
+			model->n_layers += SEC_CHIP_LAYERS;
+		/* default no. of layers when lcf file is not specified	*/	
+		} else
+			model->n_layers = DEFAULT_CHIP_LAYERS + SEC_CHIP_LAYERS;
+	}
+
+	/* allocate initial memory including package layers	*/
+	if (!model->config.model_secondary) {
+		model->layers = (layer_t *) calloc (model->n_layers + DEFAULT_PACK_LAYERS, sizeof(layer_t));
+		if (!model->layers)
+			fatal((char*)"memory allocation error\n");
+	} else {
+		model->layers = (layer_t *) calloc (model->n_layers + DEFAULT_PACK_LAYERS + SEC_PACK_LAYERS, sizeof(layer_t));
+		if (!model->layers)
+			fatal((char*)"memory allocation error\n");
+	}
+
+	/* read in values from the lcf when specified	*/
+	if (model->has_lcf) {
+		if (model->config.model_secondary)
+			fatal((char*)"modeling secondary heat transfer path not supported when layer configuration file specified...\n");
+		parse_layer_file(model, fp);
+		warning((char*)"layer configuration file specified. overriding default floorplan with those in lcf file...\n");
+	/* default set of layers	*/
+	} else
+		populate_default_layers(model, flp_default);
+	
+	/* append the package layers	*/
+	append_package_layers(model);
+
+	if (model->has_lcf && fp != stdin)
+		fclose(fp);
+}
+
+/* constructor	*/ 
+grid_model_t *alloc_grid_model(thermal_config_t *config, flp_t *flp_default)
+{
+	int i;
+	grid_model_t *model;
+
+	if ((config->grid_rows & (config->grid_rows-1)) ||
+		(config->grid_cols & (config->grid_cols-1)))
+		fatal((char*)"grid rows and columns should both be powers of two\n");
+
+	model = (grid_model_t *) calloc (1, sizeof(grid_model_t));
+	if (!model)
+		fatal((char*)"memory allocation error\n");
+	model->config = *config;
+	model->rows = config->grid_rows;
+	model->cols = config->grid_cols;
+
+	if(!strcasecmp(model->config.grid_map_mode, GRID_AVG_STR))
+		model->map_mode = GRID_AVG;
+	else if(!strcasecmp(model->config.grid_map_mode, GRID_MIN_STR))
+		model->map_mode = GRID_MIN;
+	else if(!strcasecmp(model->config.grid_map_mode, GRID_MAX_STR))
+		model->map_mode = GRID_MAX;
+	else if(!strcasecmp(model->config.grid_map_mode, GRID_CENTER_STR))
+		model->map_mode = GRID_CENTER;
+	else
+		fatal((char*)"unknown mapping mode\n");
+
+	/* layer configuration file specified?	*/
+	if(strcmp(model->config.grid_layer_file, NULLFILE))
+		model->has_lcf = TRUE;
+	else {
+		model->has_lcf = FALSE;
+		model->base_n_units = flp_default->n_units;
+	}
+
+	/* get layer information	*/
+	populate_layers_grid(model, flp_default);
+
+	/* count the total no. of blocks */
+	model->total_n_blocks = 0;
+	for(i=0; i < model->n_layers; i++)
+		model->total_n_blocks += model->layers[i].flp->n_units;
+
+	/* allocate internal state	*/
+	model->last_steady = new_grid_model_vector(model);
+	model->last_trans = new_grid_model_vector(model);
+	
+	return model;
+}
+
+void populate_R_model_grid(grid_model_t *model, flp_t *flp)
+{
+	int i;
+	double cw, ch;
+	
+	int inner_layers;
+	int model_secondary = model->config.model_secondary;
+	
+	if (model_secondary)
+		inner_layers = model->n_layers - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS;
+	else
+		inner_layers = model->n_layers - DEFAULT_PACK_LAYERS;
+
+	/* setup the block-grid maps; flp parameter is ignored */
+	if (model->has_lcf)
+		for(i=0; i < inner_layers; i++)
+			set_bgmap(model, &model->layers[i]);
+	/* only the silicon layer has allocated space for the maps. 
+	 * all the rest just point to it. so it is sufficient to
+	 * setup the block-grid map for the silicon layer alone.
+	 * further, for default layer configuration, the `flp' 
+	 * parameter should be the same as that of the silicon 
+	 * layer. finally, the chip width and height information 
+	 * need to be populated for default layer configuration
+	 */
+	else {
+		if (flp != model->layers[LAYER_SI].flp)
+			fatal((char*)"mismatch between the floorplan and the thermal model\n");
+		model->width = get_total_width(flp);
+		model->height = get_total_height(flp);
+		set_bgmap(model, &model->layers[LAYER_SI]);
+	}
+	/* sanity check on floorplan sizes	*/
+	if (model->width > model->config.s_sink || 
+		model->height > model->config.s_sink || 
+		model->width > model->config.s_spreader || 
+		model->height > model->config.s_spreader) {
+		print_flp(model->layers[0].flp);
+		print_flp_fig(model->layers[0].flp);
+		fatal((char*)"inordinate floorplan size!\n");
+	}
+
+	/* shortcuts for cell width(cw) and cell height(ch)	*/
+	cw = model->width / model->cols;
+	ch = model->height / model->rows;
+
+	/* package R's	*/
+	populate_package_R(&model->pack, &model->config, model->width, model->height);
+
+	/* layer specific resistances	*/
+	for(i=0; i < model->n_layers; i++) {
+		if (model->layers[i].has_lateral) {
+			model->layers[i].rx =  getr(model->layers[i].k, cw, ch * model->layers[i].thickness);
+			model->layers[i].ry =  getr(model->layers[i].k, ch, cw * model->layers[i].thickness);
+			if (model_secondary && (i==inner_layers-SEC_CHIP_LAYERS+LAYER_C4)) {
+				model->layers[i].rx1 =  getr(model->layers[i].k1, cw, ch * model->layers[i].thickness);
+				model->layers[i].ry1 =  getr(model->layers[i].k1, ch, cw * model->layers[i].thickness);
+			}
+		} else {
+			/* positive infinity	*/
+			model->layers[i].rx = LARGENUM;
+			model->layers[i].ry = LARGENUM;
+			if (model_secondary && (i==inner_layers-SEC_CHIP_LAYERS+LAYER_C4)) {
+				model->layers[i].rx1 = LARGENUM;
+				model->layers[i].ry1 = LARGENUM;
+			}
+		}
+		model->layers[i].rz =  getr(model->layers[i].k, model->layers[i].thickness, cw * ch);
+		if (model_secondary && (i==inner_layers-SEC_CHIP_LAYERS+LAYER_C4)) {
+			model->layers[i].rz1 =  getr(model->layers[i].k1, model->layers[i].thickness, cw * ch);
+		}
+		
+		if (!model_secondary) {
+			/* heatsink	is connected to ambient. divide r_convec proportional to cell area */
+			if (i == model->n_layers - DEFAULT_PACK_LAYERS + LAYER_SINK)
+				model->layers[i].rz += model->config.r_convec * 
+								   (model->config.s_sink * model->config.s_sink) / (cw * ch);
+		} else {
+			/* heatsink	is connected to ambient. divide r_convec proportional to cell area */
+			if (i == model->n_layers - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SINK)
+				model->layers[i].rz += model->config.r_convec * 
+								   (model->config.s_sink * model->config.s_sink) / (cw * ch);\
+			/* PCB	is connected to ambient. divide r_convec_sec proportional to cell area */
+//			if (i == model->n_layers - SEC_PACK_LAYERS + LAYER_PCB)
+//				model->layers[i].rz += model->config.r_convec_sec * 
+//								   (model->config.s_pcb * model->config.s_pcb) / (cw * ch);
+		}
+	}
+
+	/* done	*/
+	model->r_ready = TRUE;
+}
+
+void populate_C_model_grid(grid_model_t *model, flp_t *flp)
+{
+	int i;
+	
+	int inner_layers;
+	int model_secondary = model->config.model_secondary;
+	
+	/* shortcuts for cell width(cw) and cell height(ch)	*/
+	double cw = model->width / model->cols;
+	double ch = model->height / model->rows;
+	
+	if (model_secondary)
+		inner_layers = model->n_layers - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS;
+	else
+		inner_layers = model->n_layers - DEFAULT_PACK_LAYERS;
+
+	if (!model->r_ready)
+		fatal((char*)"R model not ready\n");
+	if (!model->has_lcf && flp != model->layers[LAYER_SI].flp)
+		fatal((char*)"different floorplans for R and C models!\n");
+
+	/* package C's	*/
+	populate_package_C(&model->pack, &model->config, model->width, model->height);
+
+	/* layer specific capacitances	*/
+	for(i=0; i < model->n_layers; i++)
+		model->layers[i].c =  getcap(model->layers[i].sp, model->layers[i].thickness, cw * ch);
+		if (model_secondary && (i==inner_layers-SEC_CHIP_LAYERS+LAYER_C4))
+			model->layers[i].c1 =  getcap(model->layers[i].sp1, model->layers[i].thickness, cw * ch);
+	
+	if (!model_secondary) {		
+		/* last layer (heatsink) is connected to the ambient. 
+	 	* divide c_convec proportional to cell area 
+	 	*/
+		model->layers[model->n_layers-DEFAULT_PACK_LAYERS+LAYER_SINK].c += C_FACTOR * model->config.c_convec * (cw * ch) /
+										  (model->config.s_sink * model->config.s_sink);
+	} else {
+		model->layers[model->n_layers-DEFAULT_PACK_LAYERS-SEC_PACK_LAYERS+LAYER_SINK].c += C_FACTOR * model->config.c_convec * (cw * ch) /
+										  (model->config.s_sink * model->config.s_sink);
+		model->layers[model->n_layers-SEC_PACK_LAYERS+LAYER_PCB].c += C_FACTOR * model->config.c_convec_sec * (cw * ch) /
+										  (model->config.s_pcb * model->config.s_pcb);
+	}
+
+	/* done	*/	
+	model->c_ready = TRUE;
+}
+
+/* destructor	*/
+void delete_grid_model(grid_model_t *model)
+{
+	int i;
+	
+	int inner_layers;
+	int model_secondary = model->config.model_secondary;
+	
+	if (model_secondary)
+		inner_layers = model->n_layers - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS;
+	else
+		inner_layers = model->n_layers - DEFAULT_PACK_LAYERS;
+
+	if (model->has_lcf) 
+		for(i=0; i < inner_layers; i++) {
+			delete_b2gmap(model->layers[i].b2gmap, model->rows, model->cols);
+			free(model->layers[i].g2bmap);
+			free_flp(model->layers[i].flp, FALSE);
+		}
+	/* only the silicon layer has allocated space for the maps. 
+	 * all the rest just point to it. also, its floorplan was
+	 * allocated elsewhere. so, we don't need to deallocate those.
+	 */
+	else {
+		delete_b2gmap(model->layers[LAYER_SI].b2gmap, model->rows, model->cols);
+		free(model->layers[LAYER_SI].g2bmap);
+	}
+	
+	free_grid_model_vector(model->last_steady);
+	free_grid_model_vector(model->last_trans);
+	free(model->layers);
+	free(model);
+}
+
+/* differs from 'dvector()' in that memory for internal nodes is also allocated	*/
+double *hotspot_vector_grid(grid_model_t *model)
+{
+	double total_nodes;
+	if (model->total_n_blocks <= 0)
+		fatal((char*)"total_n_blocks is not greater than zero\n");
+	
+	if (model->config.model_secondary)
+		total_nodes = model->total_n_blocks + EXTRA + EXTRA_SEC;
+	else
+		total_nodes = model->total_n_blocks + EXTRA;
+	
+	return dvector(total_nodes);
+}
+
+/* copy 'src' to 'dst' except for a window of 'size'
+ * elements starting at 'at'. useful in floorplan
+ * compaction. can be used only with default layer
+ * configuration as all layers should have the same
+ * floorplan. incompatible with layer configuration
+ * file.
+ */
+void trim_hotspot_vector_grid(grid_model_t *model, double *dst, double *src, 
+						 	  int at, int size)
+{
+	int i;
+	
+	double total_nodes;
+	if (model->config.model_secondary)
+		total_nodes = model->total_n_blocks + EXTRA + EXTRA_SEC;
+	else
+		total_nodes = model->total_n_blocks + EXTRA;
+	
+	if (model->has_lcf)
+		fatal((char*)"trim_hotspot_vector_grid called with lcf file\n");
+	for (i=0; i < at && i < total_nodes; i++)
+		dst[i] = src[i];
+	for(i=at+size; i < total_nodes; i++)
+		dst[i-size] = src[i];
+}
+
+/* update the model corresponding to floorplan compaction	*/						 
+void resize_thermal_model_grid(grid_model_t *model, int n_units)
+{
+	int i;
+
+	if (model->has_lcf)
+		fatal((char*)"resize_thermal_model_grid called with lcf file\n");
+	if (n_units > model->base_n_units)
+		fatal((char*)"resizing grid model to more than the allocated space\n");
+
+	/* count the total no. of blocks again */
+	model->total_n_blocks = 0;
+	for(i=0; i < model->n_layers; i++)
+		model->total_n_blocks += model->layers[i].flp->n_units;
+
+	/* nothing more needs to be done because the only data structure
+	 * that is dependent on flp->n_units is g2bmap (others are
+	 * dependent on 'grid size' which does not change because
+	 * of resizing). g2bmap is a 1-d array and needs no reallocation
+	 */
+}
+
+/* sets the temperature of a vector 'temp' allocated using 'hotspot_vector'	*/
+void set_temp_grid(grid_model_t *model, double *temp, double val)
+{
+	int i;
+	
+	double total_nodes;
+	if (model->config.model_secondary)
+		total_nodes = model->total_n_blocks + EXTRA + EXTRA_SEC;
+	else
+		total_nodes = model->total_n_blocks + EXTRA;
+		
+	if (model->total_n_blocks <= 0)
+		fatal((char*)"total_n_blocks is not greater than zero\n");
+	for(i=0; i < total_nodes; i++)
+		temp[i] = val;
+}
+
+/* dump the steady state grid temperatures of the top layer onto 'file'	*/
+void dump_top_layer_temp_grid (grid_model_t *model, char *file, 
+										grid_model_vector_t *temp)
+{
+	int i, j;
+	char str[STR_SIZE];
+	FILE *fp;
+
+	if (!model->r_ready)
+		fatal((char*)"R model not ready\n");
+
+	if (!strcasecmp(file, "stdout"))
+		fp = stdout;
+	else if (!strcasecmp(file, "stderr"))
+		fp = stderr;
+	else 	
+		fp = fopen (file, "w");
+
+	if (!fp) {
+		sprintf (str,"error: %s could not be opened for writing\n", file);
+		fatal(str);
+	}
+
+	for(i=0;  i < model->rows; i++){
+		for(j=0;  j < model->cols; j++){
+			fprintf(fp, "%d\t%.2f\n", i*model->cols+j, 
+					/* top layer of the most-recently computed 
+					 * steady state temperature	
+					 */
+					model->last_steady->cuboid[0][i][j]); 
+    }
+			fprintf(fp, "\n");
+  }
+		
+	if(fp != stdout && fp != stderr)
+		fclose(fp);	
+}
+
+/* dump the steady state grid temperatures of the top layer onto 'file'	*/
+void dump_steady_temp_grid (grid_model_t *model, char *file)
+{
+	/* top layer of the most-recently computed steady state temperature	*/
+	dump_top_layer_temp_grid(model, file, model->last_steady);
+}
+
+/* dump temperature vector alloced using 'hotspot_vector' to 'file' */ 
+void dump_temp_grid(grid_model_t *model, double *temp, char *file)
+{
+	int i, n, base = 0;
+	char str[STR_SIZE];
+	FILE *fp;
+	
+	int extra_nodes;
+	int model_secondary = model->config.model_secondary;
+	if (model_secondary)
+		extra_nodes = EXTRA + EXTRA_SEC;
+	else
+		extra_nodes = EXTRA;
+
+	if (!strcasecmp(file, "stdout"))
+		fp = stdout;
+	else if (!strcasecmp(file, "stderr"))
+		fp = stderr;
+	else 	
+		fp = fopen (file, "w");
+
+	if (!fp) {
+		sprintf (str,"error: %s could not be opened for writing\n", file);
+		fatal(str);
+	}
+
+	/* layer temperatures	*/
+	for(n=0; n < model->n_layers; n++) {
+		if (!model_secondary) {
+			/* default set of layers	*/
+			if (!model->has_lcf) {
+				switch(n)
+				{
+					case LAYER_SI:
+							strcpy(str,"");
+							break;
+					case LAYER_INT:
+							strcpy(str,"iface_");
+							break;
+					case DEFAULT_CHIP_LAYERS+LAYER_SP:
+							strcpy(str,"hsp_");
+							break;
+					case DEFAULT_CHIP_LAYERS+LAYER_SINK:
+							strcpy(str,"hsink_");
+							break;
+					default:
+							fatal((char*)"unknown layer\n");
+							break;
+				}
+			/* layer configuration file	*/
+			} else {
+					if (n == (model->n_layers - DEFAULT_PACK_LAYERS + LAYER_SP))
+						strcpy(str, "hsp_");	/* spreader layer	*/
+					else if (n == (model->n_layers - DEFAULT_PACK_LAYERS + LAYER_SINK))
+						strcpy(str, "hsink_");	/* heatsink layer	*/
+					else	/* other layers	*/
+						sprintf(str,"layer_%d_", n);
+			}
+		} else {
+			/* default set of layers	*/
+			if (!model->has_lcf) {
+				switch(n)
+				{
+					case LAYER_SI:
+							strcpy(str,"");
+							break;
+					case LAYER_INT:
+							strcpy(str,"iface_");
+							break;
+					case DEFAULT_CHIP_LAYERS+SEC_CHIP_LAYERS+LAYER_SP:
+							strcpy(str,"hsp_");
+							break;
+					case DEFAULT_CHIP_LAYERS+SEC_CHIP_LAYERS+LAYER_SINK:
+							strcpy(str,"hsink_");
+							break;
+					case DEFAULT_CHIP_LAYERS+LAYER_METAL:
+							strcpy(str,"metal_");
+							break;
+					case DEFAULT_CHIP_LAYERS+LAYER_C4:
+							strcpy(str,"c4_");
+							break;
+					case DEFAULT_CHIP_LAYERS+SEC_CHIP_LAYERS+DEFAULT_PACK_LAYERS+LAYER_SUB:
+							strcpy(str,"sub_");
+							break;
+					case DEFAULT_CHIP_LAYERS+SEC_CHIP_LAYERS+DEFAULT_PACK_LAYERS+LAYER_SOLDER:
+							strcpy(str,"solder_");
+							break;
+					case DEFAULT_CHIP_LAYERS+SEC_CHIP_LAYERS+DEFAULT_PACK_LAYERS+LAYER_PCB:
+							strcpy(str,"pcb_");
+							break;
+					default:
+							fatal((char*)"unknown layer\n");
+							break;
+				}
+			/* layer configuration file	*/
+			} else {
+					if (n == (model->n_layers - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SP))
+						strcpy(str, "hsp_");	/* spreader layer	*/
+					else if (n == (model->n_layers - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SINK))
+						strcpy(str, "hsink_");	/* heatsink layer	*/
+					else if (n == (model->n_layers - SEC_PACK_LAYERS + LAYER_SUB))
+						strcpy(str, "sub_");	/* package substrate layer	*/
+					else if (n == (model->n_layers - SEC_PACK_LAYERS + LAYER_SOLDER))
+						strcpy(str, "solder_");	/* solder layer	*/
+					else if (n == (model->n_layers - SEC_PACK_LAYERS + LAYER_PCB))
+						strcpy(str, "pcb_");	/* pcb layer	*/
+					else	/* other layers	*/
+						sprintf(str,"layer_%d_", n);
+			}
+		}
+
+		for(i=0; i < model->layers[n].flp->n_units; i++)
+			fprintf(fp, "%s%s\t%.2f\n", str, 
+					model->layers[n].flp->units[i].name, temp[base+i]);
+		base += model->layers[n].flp->n_units;	
+	}
+
+	if (base != model->total_n_blocks)
+		fatal((char*)"total_n_blocks failed to tally\n");
+
+	/* internal node temperatures	*/
+	for (i=0; i < extra_nodes; i++) {
+			sprintf(str, "inode_%d", i);
+			fprintf(fp, "%s\t%.2f\n", str, temp[base+i]);
+		}
+	if(fp != stdout && fp != stderr)
+		fclose(fp);	
+}
+
+void copy_temp_grid(grid_model_t *model, double *dst, double *src)
+{
+	if (!model->config.model_secondary)
+		copy_dvector(dst, src, model->total_n_blocks + EXTRA);
+	else
+		copy_dvector(dst, src, model->total_n_blocks + EXTRA + EXTRA_SEC);
+}
+
+/* 
+ * read temperature vector alloced using 'hotspot_vector' from 'file'
+ * which was dumped using 'dump_temp'. values are clipped to thermal
+ * threshold based on 'clip'
+ */ 
+void read_temp_grid(grid_model_t *model, double *temp, char *file, int clip)
+{
+	int i, n, idx, base = 0;
+	double max=0, val;
+	char *ptr, str1[LINE_SIZE], str2[LINE_SIZE];
+	char name[STR_SIZE], format[STR_SIZE];
+	FILE *fp;
+	
+	int model_secondary = model->config.model_secondary;
+	int extra_nodes;
+	if (model->config.model_secondary)
+		extra_nodes = EXTRA + EXTRA_SEC;
+	else
+		extra_nodes = EXTRA;
+
+	if (!strcasecmp(file, "stdin"))
+		fp = stdin;
+	else
+		fp = fopen (file, "r");
+
+	if (!fp) {
+		sprintf (str1,"error: %s could not be opened for reading\n", file);
+		fatal(str1);
+	}	
+
+	/* temperatures of the different layers	*/
+	for (n=0; n < model->n_layers; n++) {
+		if (!model_secondary) {
+			/* default set of layers	*/
+			if (!model->has_lcf) {
+				switch(n)
+				{
+					case LAYER_SI:
+							strcpy(format,"%s%lf");
+							break;
+					case LAYER_INT:
+							strcpy(format,"iface_%s%lf");
+							break;
+					case DEFAULT_CHIP_LAYERS+LAYER_SP:
+							strcpy(format,"hsp_%s%lf");
+							break;
+					case DEFAULT_CHIP_LAYERS+LAYER_SINK:
+							strcpy(format,"hsink_%s%lf");
+							break;
+					default:
+							fatal((char*)"unknown layer\n");
+							break;
+				}
+			/* layer configuration file	*/
+			} else {
+				if (!model->config.model_secondary) {
+					if (n == (model->n_layers - DEFAULT_PACK_LAYERS + LAYER_SP))
+						strcpy(format, "hsp_%s%lf");	/* spreader layer	*/
+					else if (n == (model->n_layers - DEFAULT_PACK_LAYERS + LAYER_SINK))
+						strcpy(format, "hsink_%s%lf");	/* heatsink layer	*/
+					else	/* other layers	*/
+						sprintf(format,"layer_%d_%%s%%lf", n);
+				}
+			}
+		} else {
+			/* default set of layers	*/
+			if (!model->has_lcf) {
+				switch(n)
+				{
+					case LAYER_SI:
+							strcpy(format,"%s%lf");
+							break;
+					case LAYER_INT:
+							strcpy(format,"iface_%s%lf");
+							break;
+					case DEFAULT_CHIP_LAYERS+SEC_CHIP_LAYERS+LAYER_SP:
+							strcpy(format,"hsp_%s%lf");
+							break;
+					case DEFAULT_CHIP_LAYERS+SEC_CHIP_LAYERS+LAYER_SINK:
+							strcpy(format,"hsink_%s%lf");
+							break;
+					case DEFAULT_CHIP_LAYERS+LAYER_METAL:
+							strcpy(format,"metal_%s%lf");
+							break;
+					case DEFAULT_CHIP_LAYERS+LAYER_C4:
+							strcpy(format,"c4_%s%lf");
+							break;
+					case DEFAULT_CHIP_LAYERS+SEC_CHIP_LAYERS+DEFAULT_PACK_LAYERS+LAYER_SUB:
+							strcpy(format,"sub_%s%lf");
+							break;
+					case DEFAULT_CHIP_LAYERS+SEC_CHIP_LAYERS+DEFAULT_PACK_LAYERS+LAYER_SOLDER:
+							strcpy(format,"solder_%s%lf");
+							break;
+					case DEFAULT_CHIP_LAYERS+SEC_CHIP_LAYERS+DEFAULT_PACK_LAYERS+LAYER_PCB:
+							strcpy(format,"pcb_%s%lf");
+							break;
+					default:
+							fatal((char*)"unknown layer\n");
+							break;
+				}
+			/* layer configuration file	*/
+			} else {
+						if (n == (model->n_layers - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SP))
+							strcpy(format, "hsp_%s%lf");	/* spreader layer	*/
+						else if (n == (model->n_layers - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SINK))
+							strcpy(format, "hsink_%s%lf");	/* heatsink layer	*/
+						else if (n == (model->n_layers - SEC_PACK_LAYERS + LAYER_SUB))
+							strcpy(format, "sub_%s%lf");	/* package substrate layer	*/
+						else if (n == (model->n_layers - SEC_PACK_LAYERS + LAYER_SOLDER))
+							strcpy(format, "solder_%s%lf");	/* solder ball layer	*/
+						else if (n == (model->n_layers - SEC_PACK_LAYERS + LAYER_PCB))
+							strcpy(format, "pcb_%s%lf");	/* PCB layer	*/
+						else	/* other layers	*/
+							sprintf(format,"layer_%d_%%s%%lf", n);
+			}
+		}
+
+		for (i=0; i < model->layers[n].flp->n_units; i++) {
+			ptr = fgets(str1, LINE_SIZE, fp);
+			if (feof(fp))
+				fatal((char*)"not enough lines in temperature file\n");
+			strcpy(str2, str1);
+			/* ignore comments and empty lines	*/
+			ptr = strtok(str1, " \r\t\n");
+			if (!ptr || ptr[0] == '#') {
+				i--;
+				continue;
+			}
+			if (sscanf(str2, format, name, &val) != 2)
+				fatal((char*)"invalid temperature file format\n");
+			idx = get_blk_index(model->layers[n].flp, name);
+			if (idx >= 0)
+				temp[base+idx] = val;
+			else	/* since get_blk_index calls fatal, the line below cannot be reached	*/
+				fatal((char*)"unit in temperature file not found in floorplan\n");
+
+			/* find max temp on the top layer 
+			 * (silicon for the default set of layers)
+			 */
+			if (n == 0 && temp[idx] > max)
+				max = temp[idx];
+		}
+		base += model->layers[n].flp->n_units;
+	}
+
+	if (base != model->total_n_blocks)
+		fatal((char*)"total_n_blocks failed to tally\n");
+
+	/* internal node temperatures	*/
+	for (i=0; i < extra_nodes; i++) {
+		ptr = fgets(str1, LINE_SIZE, fp);
+		if (feof(fp))
+			fatal((char*)"not enough lines in temperature file\n");
+		strcpy(str2, str1);
+		/* ignore comments and empty lines	*/
+		ptr = strtok(str1, " \r\t\n");
+		if (!ptr || ptr[0] == '#') {
+			i--;
+			continue;
+		}
+		if (sscanf(str2, "%s%lf", name, &val) != 2)
+			fatal((char*)"invalid temperature file format\n");
+		sprintf(str1, "inode_%d", i);
+		if (strcasecmp(str1, name))
+			fatal((char*)"invalid temperature file format\n");
+		temp[base+i] = val;	
+	}
+
+	ptr = fgets(str1, LINE_SIZE, fp);
+	if (!feof(fp))
+		fatal((char*)"too many lines in temperature file\n");
+
+	if(fp != stdin)
+		fclose(fp);	
+
+	/* clipping	*/
+	if (clip && (max > model->config.thermal_threshold)) {
+		/* if max has to be brought down to thermal_threshold, 
+		 * (w.r.t the ambient) what is the scale down factor?
+		 */
+		double factor = (model->config.thermal_threshold - model->config.ambient) / 
+						(max - model->config.ambient);
+	
+		/* scale down all temperature differences (from ambient) by the same factor	*/
+		for (i=0; i < model->total_n_blocks + extra_nodes; i++)
+			temp[i] = (temp[i]-model->config.ambient)*factor + model->config.ambient;
+	}
+}
+
+/* dump power numbers to file	*/
+void dump_power_grid(grid_model_t *model, double *power, char *file)
+{
+	int i, n, base = 0;
+	char str[STR_SIZE];
+	FILE *fp;
+
+	if (!strcasecmp(file, "stdout"))
+		fp = stdout;
+	else if (!strcasecmp(file, "stderr"))
+		fp = stderr;
+	else 	
+		fp = fopen (file, "w");
+	if (!fp) {
+		sprintf (str,"error: %s could not be opened for writing\n", file);
+		fatal(str);
+	}
+
+	/* dump values only for the layers dissipating power	*/
+	for(n=0; n < model->n_layers; n++) {
+		if (model->layers[n].has_power) {
+			for(i=0; i < model->layers[n].flp->n_units; i++)
+				if (model->has_lcf)
+					fprintf(fp, "layer_%d_%s\t%.6f\n", n, 
+							model->layers[n].flp->units[i].name, power[base+i]);
+				else 
+					fprintf(fp, "%s\t%.6f\n", 
+							model->layers[n].flp->units[i].name, power[base+i]);
+		}				
+		base += model->layers[n].flp->n_units;		
+	}
+
+	if(fp != stdout && fp != stderr)
+		fclose(fp);	
+}
+
+/* 
+ * read power vector alloced using 'hotspot_vector' from 'file'
+ * which was dumped using 'dump_power'. 
+ */ 
+void read_power_grid (grid_model_t *model, double *power, char *file)
+{
+	int i, idx, n, base = 0;
+	double val;
+	char *ptr, str1[LINE_SIZE], str2[LINE_SIZE]; 
+	char name[STR_SIZE], format[STR_SIZE];
+	FILE *fp;
+
+	if (!strcasecmp(file, "stdin"))
+		fp = stdin;
+	else
+		fp = fopen (file, "r");
+	if (!fp) {
+		sprintf (str1,"error: %s could not be opened for reading\n", file);
+		fatal(str1);
+	}
+
+	/* lcf file could potentially specify more than one power dissipating 
+	 * layer. hence, units with zero power within a layer cannot be left
+	 * out in the power file.
+	 */
+	if (model->has_lcf) {
+		for(n=0; n < model->n_layers; n++) {
+			if (model->layers[n].has_power)
+				for(i=0; i < model->layers[n].flp->n_units; i++) {
+					ptr = fgets(str1, LINE_SIZE, fp);
+					if (feof(fp))
+						fatal((char*)"not enough lines in power file\n");
+					strcpy(str2, str1);
+
+					/* ignore comments and empty lines	*/
+					ptr = strtok(str1, " \r\t\n");
+					if (!ptr || ptr[0] == '#') {
+						i--;
+						continue;
+					}
+
+					sprintf(format, "layer_%d_%%s%%lf", n);
+		  			if (sscanf(str2, format, name, &val) != 2)
+						fatal((char*)"invalid power file format\n");
+		  			idx = get_blk_index(model->layers[n].flp, name);
+		  			if (idx >= 0)
+						power[base+idx] = val;
+					/* since get_blk_index calls fatal, the line below cannot be reached	*/
+		  			else
+						fatal((char*)"unit in power file not found in floorplan\n");
+				}
+			base += model->layers[n].flp->n_units;	
+		}
+		ptr = fgets(str1, LINE_SIZE, fp);
+		if (!feof(fp))
+			fatal((char*)"too many lines in power file\n");
+	/* default layer configuration. so only one layer
+	 * has power dissipation. units with zero power 
+	 * can be omitted in the power file
+	 */
+	} else {
+		while(!feof(fp)) {
+			ptr = fgets(str1, LINE_SIZE, fp);
+			if (feof(fp))
+				break;
+			strcpy(str2, str1);
+	
+			/* ignore comments and empty lines	*/
+			ptr = strtok(str1, " \r\t\n");
+			if (!ptr || ptr[0] == '#')
+				continue;
+	
+			if (sscanf(str2, "%s%lf", name, &val) != 2)
+				fatal((char*)"invalid power file format\n");
+			idx = get_blk_index(model->layers[LAYER_SI].flp, name);
+			if (idx >= 0)
+				power[idx] = val;
+			else	/* since get_blk_index calls fatal, the line below cannot be reached	*/
+				fatal((char*)"unit in power file not found in floorplan\n");
+		}
+	}
+
+	if(fp != stdin)
+		fclose(fp);
+}
+
+double find_max_temp_grid(grid_model_t *model, double *temp)
+{
+	int i;
+	double max = 0.0;
+	/* max temperature occurs on the top-most layer	*/
+	for(i=0; i < model->layers[0].flp->n_units; i++) {
+		if (temp[i] < 0)
+			fatal((char*)"negative temperature!\n");
+		else if (max < temp[i])
+			max = temp[i];
+	}
+
+	return max;
+}
+
+double find_avg_temp_grid(grid_model_t *model, double *temp)
+{
+	int i, n, base = 0, count = 0; 
+	double sum = 0.0;
+	/* average temperature of all the power dissipating blocks	*/
+	for(n=0; n < model->n_layers; n++) {
+		if (model->layers[n].has_power) {
+			for(i=0; i < model->layers[n].flp->n_units; i++) {
+				if (temp[base+i] < 0)
+					fatal((char*)"negative temperature!\n");
+				else 
+					sum += temp[base+i];
+			}
+			count += model->layers[n].flp->n_units;
+		}	
+		base += model->layers[n].flp->n_units;
+	}
+
+	if (!count)
+		fatal((char*)"no power dissipating units?!\n");
+	return (sum / count);
+}
+
+/* calculate average heatsink temperature for natural convection package */
+double calc_sink_temp_grid(grid_model_t *model, double *temp, thermal_config_t *config)
+{
+	int i, n, base = 0; 
+	int hsidx = model->n_layers - DEFAULT_PACK_LAYERS + LAYER_SINK;
+	double sum = 0.0;
+	double spr_size = config->s_spreader*config->s_spreader;
+	double sink_size = config->s_sink*config->s_sink;
+
+	/* heat sink core	*/
+	for(n=0; n < hsidx; n++)
+		base += model->layers[n].flp->n_units;
+
+	for(i=base; i < base+model->layers[n].flp->n_units; i++)
+		if (temp[i] < 0)
+			fatal((char*)"negative temperature!\n");
+		else /* area-weighted average */
+			sum += temp[i]*(model->layers[n].flp->units[i-base].width*model->layers[n].flp->units[i-base].height);
+
+	/* heat sink periphery	*/
+	base = model->total_n_blocks;
+	
+	for(i=SINK_C_W; i <= SINK_C_E; i++)
+		if (temp[i+base] < 0)
+			fatal((char*)"negative temperature!\n");
+		else
+			sum += temp[i+base]*0.25*(config->s_spreader+model->height)*(config->s_spreader-model->width);
+
+	for(i=SINK_C_N; i <= SINK_C_S; i++)
+		if (temp[i+base] < 0)
+			fatal((char*)"negative temperature!\n");
+		else
+			sum += temp[i+base]*0.25*(config->s_spreader+model->width)*(config->s_spreader-model->height);
+
+	for(i=SINK_W; i <= SINK_S; i++)
+		if (temp[i+base] < 0)
+			fatal((char*)"negative temperature!\n");
+		else
+			sum += temp[i+base]*0.25*(sink_size-spr_size);
+
+	return (sum / sink_size);
+}
+
+/* grid_model_vector routines	*/
+
+/* constructor	*/
+grid_model_vector_t *new_grid_model_vector(grid_model_t *model)
+{
+	grid_model_vector_t *v;
+	
+	int extra_nodes;
+	if (model->config.model_secondary)
+		extra_nodes = EXTRA + EXTRA_SEC;
+	else
+		extra_nodes = EXTRA;
+
+	v = (grid_model_vector_t *) calloc (1, sizeof(grid_model_vector_t));
+	if (!v)
+		fatal((char*)"memory allocation error\n");
+
+	v->cuboid = dcuboid_tail(model->rows, model->cols, model->n_layers, extra_nodes);
+	v->extra = v->cuboid[0][0] + model->rows * model->cols * model->n_layers;
+	return v;
+}
+
+/* destructor	*/
+void free_grid_model_vector(grid_model_vector_t *v)
+{
+	free_dcuboid(v->cuboid);
+	free(v);
+}
+
+/* translate power/temperature between block and grid vectors	*/
+void xlate_vector_b2g(grid_model_t *model, double *b, grid_model_vector_t *g, int type)
+{
+	int i, j, n, base = 0;
+	double area;
+	
+	int extra_nodes;
+	if (model->config.model_secondary)
+		extra_nodes = EXTRA + EXTRA_SEC;
+	else
+		extra_nodes = EXTRA;
+
+	/* area of a single grid cell	*/
+	area = (model->width * model->height) / (model->cols * model->rows);
+
+	for(n=0; n < model->n_layers; n++) {
+		for(i=0; i < model->rows; i++)
+			for(j=0; j < model->cols; j++) {
+				/* for each grid cell, the power density / temperature are 
+				 * the average of the power densities / temperatures of the 
+				 * blocks in it weighted by their occupancies
+				 */
+				/* convert power density to power	*/ 
+				if (type == V_POWER)
+					g->cuboid[n][i][j] = blist_avg(model->layers[n].b2gmap[i][j], 
+										 model->layers[n].flp, &b[base], type) * area;
+				/* no conversion necessary for temperature	*/ 
+				else if (type == V_TEMP)
+					g->cuboid[n][i][j] = blist_avg(model->layers[n].b2gmap[i][j], 
+										 model->layers[n].flp, &b[base], type);
+				else
+					fatal((char*)"unknown vector type\n");
+			}
+		/* keep track of the beginning address of this layer in the 
+		 * block power vector
+		 */
+		base += model->layers[n].flp->n_units;							 
+	}
+
+	/* extra spreader and sink nodes	*/
+	for(i=0; i < extra_nodes; i++)
+		g->extra[i] = b[base+i];
+}
+
+/* translate temperature between grid and block vectors	*/
+void xlate_temp_g2b(grid_model_t *model, double *b, grid_model_vector_t *g)
+{
+	int i, j, n, u, base = 0, count;
+	int i1, j1, i2, j2, ci1, cj1, ci2, cj2;
+	double min, max, avg;
+	
+	int extra_nodes;
+	if (model->config.model_secondary)
+		extra_nodes = EXTRA + EXTRA_SEC;
+	else
+		extra_nodes = EXTRA;
+
+	for(n=0; n < model->n_layers; n++) {
+		for(u=0; u < model->layers[n].flp->n_units; u++) {
+			/* extent of this unit in grid cell units	*/
+			i1 = model->layers[n].g2bmap[u].i1;
+			j1 = model->layers[n].g2bmap[u].j1;
+			i2 = model->layers[n].g2bmap[u].i2;
+			j2 = model->layers[n].g2bmap[u].j2;
+
+			/* map the center grid cell's temperature to the block	*/
+			if (model->map_mode == GRID_CENTER) {
+				/* center co-ordinates	*/	
+				ci1 = (i1 + i2) / 2;
+				cj1 = (j1 + j2) / 2;
+				/* in case of even no. of cells, center 
+				 * is the average of two central cells
+				 */
+				/* ci2 = ci1-1 when even, ci1 otherwise	*/  
+				ci2 = ci1 - !((i2-i1) % 2);
+				/* cj2 = cj1-1 when even, cj1 otherwise	*/  
+				cj2 = cj1 - !((j2-j1) % 2);
+
+				b[base+u] = (g->cuboid[n][ci1][cj1] + g->cuboid[n][ci2][cj1] + 
+						    g->cuboid[n][ci1][cj2] + g->cuboid[n][ci2][cj2]) / 4;
+				continue;
+			}
+		
+			/* find the min/max/avg temperatures of the 
+			 * grid cells in this block
+			 */
+			avg = 0.0;
+			count = 0;
+			min = max = g->cuboid[n][i1][j1];
+			for(i=i1; i < i2; i++)
+				for(j=j1; j < j2; j++) {
+					avg += g->cuboid[n][i][j];
+					if (g->cuboid[n][i][j] < min)
+						min = g->cuboid[n][i][j];
+					if (g->cuboid[n][i][j] > max)
+						max = g->cuboid[n][i][j];
+					count++;
+				}
+
+			/* map to output accordingly	*/
+			switch (model->map_mode)
+			{
+				case GRID_AVG:
+					b[base+u] = avg / count;
+					break;
+				case GRID_MIN:
+					b[base+u] = min;
+					break;
+				case GRID_MAX:
+					b[base+u] = max;
+					break;
+				/* taken care of already	*/	
+				case GRID_CENTER:
+					break;
+				default:
+					fatal((char*)"unknown mapping mode\n");
+					break;
+			}
+		}
+		/* keep track of the beginning address of this layer in the 
+		 * block power vector
+		 */
+		base += model->layers[n].flp->n_units;							 
+	}
+
+	/* extra spreader and sink nodes	*/
+	for(i=0; i < extra_nodes; i++)
+		b[base+i] = g->extra[i];
+}
+
+/* setting package nodes' power numbers	*/
+void set_internal_power_grid(grid_model_t *model, double *power)
+{
+	if (!model->config.model_secondary)
+		zero_dvector(&power[model->total_n_blocks], EXTRA);
+	else
+		zero_dvector(&power[model->total_n_blocks], EXTRA+EXTRA_SEC);
+}
+
+/* set up initial temperatures for the steady state solution
+ * heuristically (ignoring the lateral resistances)
+ */
+void set_heuristic_temp(grid_model_t *model, grid_model_vector_t *power, 
+						grid_model_vector_t *temp)
+{
+	int n, i, j, nl, nr, nc;
+	double **sum;
+
+	/* shortcuts	*/
+	nl = model->n_layers;
+	nr = model->rows;
+	nc = model->cols;
+
+	/* package temperatures	*/
+	/* if all lateral resistances are considered infinity, all peripheral 
+	 * package nodes are at the ambient temperature
+	 */
+	temp->extra[SINK_N] = temp->extra[SINK_S] = 
+						  temp->extra[SINK_E] = temp->extra[SINK_W] = 
+						  temp->extra[SINK_C_N] = temp->extra[SINK_C_S] = 
+						  temp->extra[SINK_C_E] = temp->extra[SINK_C_W] = 
+						  temp->extra[SP_N] = temp->extra[SP_S] = 
+						  temp->extra[SP_E] = temp->extra[SP_W] =
+						  model->config.ambient;
+	
+	if (model->config.model_secondary) {
+		temp->extra[PCB_N] = temp->extra[PCB_S] = 
+						  temp->extra[PCB_E] = temp->extra[PCB_W] = 
+						  temp->extra[PCB_C_N] = temp->extra[PCB_C_S] = 
+						  temp->extra[PCB_C_E] = temp->extra[PCB_C_W] =
+						  temp->extra[SOLDER_N] = temp->extra[SOLDER_S] =
+						  temp->extra[SOLDER_E] = temp->extra[SOLDER_W] = 
+						  temp->extra[SUB_N] = temp->extra[SUB_S] = 
+						  temp->extra[SUB_E] = temp->extra[SUB_W] =
+						  model->config.ambient;
+	}
+
+	/* layer temperatures	*/
+	/* add up power for each grid cell across all layers */
+	sum = dmatrix(nr, nc);
+	for(n=0; n < nl; n++)
+		scaleadd_dvector(sum[0], sum[0], power->cuboid[n][0], nr*nc, 1.0);
+	
+	/* last layer	*/
+		for(i=0; i < nr; i++)
+			for(j=0; j < nc; j++)
+				temp->cuboid[nl-1][i][j] = model->config.ambient + sum[i][j] * 
+										 model->layers[nl-1].rz;
+		/* subtract away the layer's power	*/			
+		scaleadd_dvector(sum[0], sum[0], power->cuboid[nl-1][0], nr*nc, -1.0);
+				
+		/* go from last-1 to first	*/
+		for(n=nl-2; n >= 0; n--) {
+			/* nth layer temp is n+1th temp + cumul_power * rz of the nth layer	*/
+			scaleadd_dvector(temp->cuboid[n][0], temp->cuboid[n+1][0], sum[0], 
+							 nr*nc, model->layers[n].rz);
+			/* subtract away the layer's power	*/			
+			scaleadd_dvector(sum[0], sum[0], power->cuboid[n][0], nr*nc, -1.0);
+		} 
+	free_dmatrix(sum); 
+}
+
+/* single steady state iteration of grid solver - package part */
+double single_iteration_steady_pack(grid_model_t *model, grid_model_vector_t *power,
+									grid_model_vector_t *temp)
+{
+	int i, j;
+//	int extra_nodes;
+//	if (model->config.model_secondary) 
+//		extra_nodes = EXTRA + EXTRA_SEC;
+//	else 
+//		extra_nodes = EXTRA;
+		
+	double delta[EXTRA+EXTRA_SEC], max = 0;
+	/* sum of the conductances	*/
+	double csum;
+	/* weighted sum of temperatures	*/
+	double wsum;
+
+	/* shortcuts	*/
+	double *v = temp->extra;
+	package_RC_t *pk = &model->pack;
+	thermal_config_t *c = &model->config;
+	layer_t *l = model->layers;
+	int nl = model->n_layers;
+	int nr = model->rows;
+	int nc = model->cols;
+	int spidx = 0, hsidx = 0, subidx = 0, solderidx = 0, pcbidx = 0;
+	
+	if (!model->config.model_secondary) {
+		spidx = nl - DEFAULT_PACK_LAYERS + LAYER_SP;
+		hsidx = nl - DEFAULT_PACK_LAYERS + LAYER_SINK;
+	} else {
+		spidx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SP;
+		hsidx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SINK;
+		subidx = nl - SEC_PACK_LAYERS + LAYER_SUB;
+		solderidx = nl - SEC_PACK_LAYERS + LAYER_SOLDER;
+		pcbidx = nl -SEC_PACK_LAYERS + LAYER_PCB;	
+		
+	}
+
+	/* sink outer north/south	*/
+	csum = 1.0/(pk->r_hs_per + pk->r_amb_per) + 1.0/(pk->r_hs2_y + pk->r_hs);
+	wsum = c->ambient/(pk->r_hs_per + pk->r_amb_per) + v[SINK_C_N]/(pk->r_hs2_y + pk->r_hs);
+	delta[SINK_N] = fabs(v[SINK_N] - wsum / csum);
+	v[SINK_N] = wsum / csum;
+	wsum = c->ambient/(pk->r_hs_per + pk->r_amb_per) + v[SINK_C_S]/(pk->r_hs2_y + pk->r_hs);
+	delta[SINK_S] = fabs(v[SINK_S] - wsum / csum);
+	v[SINK_S] = wsum / csum;
+	
+	/* sink outer west/east	*/
+	csum = 1.0/(pk->r_hs_per + pk->r_amb_per) + 1.0/(pk->r_hs2_x + pk->r_hs);
+	wsum = c->ambient/(pk->r_hs_per + pk->r_amb_per) + v[SINK_C_W]/(pk->r_hs2_x + pk->r_hs);
+	delta[SINK_W] = fabs(v[SINK_W] - wsum / csum);
+	v[SINK_W] = wsum / csum;
+	wsum = c->ambient/(pk->r_hs_per + pk->r_amb_per) + v[SINK_C_E]/(pk->r_hs2_x + pk->r_hs);
+	delta[SINK_E] = fabs(v[SINK_E] - wsum / csum);
+	v[SINK_E] = wsum / csum;
+
+	/* sink inner north/south	*/
+	/* partition r_hs1_y among all the nc grid cells. edge cell has half the ry */
+	csum = nc / (l[hsidx].ry / 2.0 + nc * pk->r_hs1_y);
+	csum += 1.0/(pk->r_hs_c_per_y + pk->r_amb_c_per_y) + 
+			1.0/pk->r_sp_per_y + 1.0/(pk->r_hs2_y + pk->r_hs);
+
+	wsum = 0.0;
+	for(j=0; j < nc; j++)
+		wsum += temp->cuboid[hsidx][0][j];
+	wsum /= (l[hsidx].ry / 2.0 + nc * pk->r_hs1_y);
+	wsum += c->ambient/(pk->r_hs_c_per_y + pk->r_amb_c_per_y) + 
+			v[SP_N]/pk->r_sp_per_y + v[SINK_N]/(pk->r_hs2_y + pk->r_hs);
+	delta[SINK_C_N] = fabs(v[SINK_C_N] - wsum / csum);
+	v[SINK_C_N] = wsum / csum;
+
+	wsum = 0.0;
+	for(j=0; j < nc; j++)
+		wsum += temp->cuboid[hsidx][nr-1][j];
+	wsum /= (l[hsidx].ry / 2.0 + nc * pk->r_hs1_y);
+	wsum += c->ambient/(pk->r_hs_c_per_y + pk->r_amb_c_per_y) + 
+			v[SP_S]/pk->r_sp_per_y + v[SINK_S]/(pk->r_hs2_y + pk->r_hs);
+	delta[SINK_C_S] = fabs(v[SINK_C_S] - wsum / csum);
+	v[SINK_C_S] = wsum / csum;
+
+	/* sink inner west/east	*/
+	/* partition r_hs1_x among all the nr grid cells. edge cell has half the rx */
+	csum = nr / (l[hsidx].rx / 2.0 + nr * pk->r_hs1_x);
+	csum += 1.0/(pk->r_hs_c_per_x + pk->r_amb_c_per_x) + 
+			1.0/pk->r_sp_per_x + 1.0/(pk->r_hs2_x + pk->r_hs);
+
+	wsum = 0.0;
+	for(i=0; i < nr; i++)
+		wsum += temp->cuboid[hsidx][i][0];
+	wsum /= (l[hsidx].rx / 2.0 + nr * pk->r_hs1_x);
+	wsum += c->ambient/(pk->r_hs_c_per_x + pk->r_amb_c_per_x) + 
+			v[SP_W]/pk->r_sp_per_x + v[SINK_W]/(pk->r_hs2_x + pk->r_hs);
+	delta[SINK_C_W] = fabs(v[SINK_C_W] - wsum / csum);
+	v[SINK_C_W] = wsum / csum;
+
+	wsum = 0.0;
+	for(i=0; i < nr; i++)
+		wsum += temp->cuboid[hsidx][i][nc-1];
+	wsum /= (l[hsidx].rx / 2.0 + nr * pk->r_hs1_x);
+	wsum += c->ambient/(pk->r_hs_c_per_x + pk->r_amb_c_per_x) + 
+			v[SP_E]/pk->r_sp_per_x + v[SINK_E]/(pk->r_hs2_x + pk->r_hs);
+	delta[SINK_C_E] = fabs(v[SINK_C_E] - wsum / csum);
+	v[SINK_C_E] = wsum / csum;
+
+	/* spreader north/south	*/
+	/* partition r_sp1_y among all the nc grid cells. edge cell has half the ry */
+	csum = nc / (l[spidx].ry / 2.0 + nc * pk->r_sp1_y);
+	csum += 1.0/pk->r_sp_per_y;
+
+	wsum = 0.0;
+	for(j=0; j < nc; j++)
+		wsum += temp->cuboid[spidx][0][j];
+	wsum /= (l[spidx].ry / 2.0 + nc * pk->r_sp1_y);
+	wsum += v[SINK_C_N]/pk->r_sp_per_y;
+	delta[SP_N] = fabs(v[SP_N] - wsum / csum);
+	v[SP_N] = wsum / csum;
+
+	wsum = 0.0;
+	for(j=0; j < nc; j++)
+		wsum += temp->cuboid[spidx][nr-1][j];
+	wsum /= (l[spidx].ry / 2.0 + nc * pk->r_sp1_y);
+	wsum += v[SINK_C_S]/pk->r_sp_per_y;
+	delta[SP_S] = fabs(v[SP_S] - wsum / csum);
+	v[SP_S] = wsum / csum;
+
+	/* spreader west/east	*/
+	/* partition r_sp1_x among all the nr grid cells. edge cell has half the rx */
+	csum = nr / (l[spidx].rx / 2.0 + nr * pk->r_sp1_x);
+	csum += 1.0/pk->r_sp_per_x;
+
+	wsum = 0.0;
+	for(i=0; i < nr; i++)
+		wsum += temp->cuboid[spidx][i][0];
+	wsum /= (l[spidx].rx / 2.0 + nr * pk->r_sp1_x);
+	wsum += v[SINK_C_W]/pk->r_sp_per_x;
+	delta[SP_W] = fabs(v[SP_W] - wsum / csum);
+	v[SP_W] = wsum / csum;
+
+	wsum = 0.0;
+	for(i=0; i < nr; i++)
+		wsum += temp->cuboid[spidx][i][nc-1];
+	wsum /= (l[spidx].rx / 2.0 + nr * pk->r_sp1_x);
+	wsum += v[SINK_C_E]/pk->r_sp_per_x;
+	delta[SP_E] = fabs(v[SP_E] - wsum / csum);
+	v[SP_E] = wsum / csum;
+	
+	if (model->config.model_secondary) {
+		/* secondary path package nodes */
+		/* PCB outer north/south	*/
+		csum = 1.0/(pk->r_amb_sec_per) + 1.0/(pk->r_pcb2_y + pk->r_pcb);
+		wsum = c->ambient/(pk->r_amb_sec_per) + v[PCB_C_N]/(pk->r_pcb2_y + pk->r_pcb);
+		delta[PCB_N] = fabs(v[PCB_N] - wsum / csum);
+		v[PCB_N] = wsum / csum;
+		wsum = c->ambient/(pk->r_amb_sec_per) + v[PCB_C_S]/(pk->r_pcb2_y + pk->r_pcb);
+		delta[PCB_S] = fabs(v[PCB_S] - wsum / csum);
+		v[PCB_S] = wsum / csum;
+		
+		/* PCB outer west/east	*/
+		csum = 1.0/(pk->r_amb_sec_per) + 1.0/(pk->r_pcb2_x + pk->r_pcb);
+		wsum = c->ambient/(pk->r_amb_sec_per) + v[PCB_C_W]/(pk->r_pcb2_x + pk->r_pcb);
+		delta[PCB_W] = fabs(v[PCB_W] - wsum / csum);
+		v[PCB_W] = wsum / csum;
+		wsum = c->ambient/(pk->r_amb_sec_per) + v[PCB_C_E]/(pk->r_pcb2_x + pk->r_pcb);
+		delta[PCB_E] = fabs(v[PCB_E] - wsum / csum);
+		v[PCB_E] = wsum / csum;
+  	
+		/* PCB inner north/south	*/
+		/* partition r_pcb1_y among all the nc grid cells. edge cell has half the ry */
+		csum = nc / (l[pcbidx].ry / 2.0 + nc * pk->r_pcb1_y);
+		csum += 1.0/(pk->r_amb_sec_c_per_y) + 
+				1.0/pk->r_pcb_c_per_y + 1.0/(pk->r_pcb2_y + pk->r_pcb);
+  	
+		wsum = 0.0;
+		for(j=0; j < nc; j++)
+			wsum += temp->cuboid[pcbidx][0][j];
+		wsum /= (l[pcbidx].ry / 2.0 + nc * pk->r_pcb1_y);
+		wsum += c->ambient/(pk->r_amb_sec_c_per_y) + 
+				v[SOLDER_N]/pk->r_pcb_c_per_y + v[PCB_N]/(pk->r_pcb2_y + pk->r_pcb);
+		delta[PCB_C_N] = fabs(v[PCB_C_N] - wsum / csum);
+		v[PCB_C_N] = wsum / csum;
+  	
+ 		wsum = 0.0;
+		for(j=0; j < nc; j++)
+			wsum += temp->cuboid[pcbidx][nr-1][j];
+		wsum /= (l[pcbidx].ry / 2.0 + nc * pk->r_pcb1_y);
+		wsum += c->ambient/(pk->r_amb_sec_c_per_y) + 
+				v[SOLDER_S]/pk->r_pcb_c_per_y + v[PCB_S]/(pk->r_pcb2_y + pk->r_pcb);
+		delta[PCB_C_S] = fabs(v[PCB_C_S] - wsum / csum);
+		v[PCB_C_S] = wsum / csum;
+  	
+		/* PCB inner west/east	*/
+		/* partition r_pcb1_x among all the nr grid cells. edge cell has half the rx */
+		csum = nr / (l[pcbidx].rx / 2.0 + nr * pk->r_pcb1_x);
+		csum += 1.0/(pk->r_amb_sec_c_per_x) + 
+				1.0/pk->r_pcb_c_per_x + 1.0/(pk->r_pcb2_x + pk->r_pcb);
+  	
+		wsum = 0.0;
+		for(i=0; i < nr; i++)
+			wsum += temp->cuboid[pcbidx][i][0];
+		wsum /= (l[pcbidx].rx / 2.0 + nr * pk->r_pcb1_x);
+		wsum += c->ambient/(pk->r_amb_sec_c_per_x) + 
+				v[SOLDER_W]/pk->r_pcb_c_per_x + v[PCB_W]/(pk->r_pcb2_x + pk->r_pcb);
+		delta[PCB_C_W] = fabs(v[PCB_C_W] - wsum / csum);
+		v[PCB_C_W] = wsum / csum;
+  	
+		wsum = 0.0;
+		for(i=0; i < nr; i++)
+			wsum += temp->cuboid[pcbidx][i][nc-1];
+		wsum /= (l[pcbidx].rx / 2.0 + nr * pk->r_pcb1_x);
+		wsum += c->ambient/(pk->r_amb_sec_c_per_x) + 
+				v[SOLDER_E]/pk->r_pcb_c_per_x + v[PCB_E]/(pk->r_pcb2_x + pk->r_pcb);
+		delta[PCB_C_E] = fabs(v[PCB_C_E] - wsum / csum);
+		v[PCB_C_E] = wsum / csum;
+  	
+		/* solder north/south	*/
+		/* partition r_solder1_y among all the nc grid cells. edge cell has half the ry */
+		csum = nc / (l[solderidx].ry / 2.0 + nc * pk->r_solder1_y);
+		csum += 1.0/pk->r_solder_per_y + 1.0/pk->r_pcb_c_per_y;
+  	
+		wsum = 0.0;
+		for(j=0; j < nc; j++)
+			wsum += temp->cuboid[solderidx][0][j];
+		wsum /= (l[solderidx].ry / 2.0 + nc * pk->r_solder1_y);
+		wsum += v[PCB_C_N]/pk->r_pcb_c_per_y + v[SUB_N]/pk->r_solder_per_y;
+		delta[SOLDER_N] = fabs(v[SOLDER_N] - wsum / csum);
+		v[SOLDER_N] = wsum / csum;
+  	
+		wsum = 0.0;
+		for(j=0; j < nc; j++)
+			wsum += temp->cuboid[solderidx][nr-1][j];
+		wsum /= (l[solderidx].ry / 2.0 + nc * pk->r_solder1_y);
+		wsum += v[PCB_C_S]/pk->r_pcb_c_per_y + v[SUB_S]/pk->r_solder_per_y;
+		delta[SOLDER_S] = fabs(v[SOLDER_S] - wsum / csum);
+		v[SOLDER_S] = wsum / csum;
+  	
+		/* solder west/east	*/
+		/* partition r_solder1_x among all the nr grid cells. edge cell has half the rx */
+		csum = nr / (l[solderidx].rx / 2.0 + nr * pk->r_solder1_x);
+		csum += 1.0/pk->r_solder_per_x + 1.0/pk->r_pcb_c_per_x;
+  	
+		wsum = 0.0;
+		for(i=0; i < nr; i++)
+			wsum += temp->cuboid[solderidx][i][0];
+		wsum /= (l[solderidx].rx / 2.0 + nr * pk->r_solder1_x);
+		wsum += v[PCB_C_W]/pk->r_pcb_c_per_x + v[SUB_W]/pk->r_solder_per_x;
+		delta[SOLDER_W] = fabs(v[SOLDER_W] - wsum / csum);
+		v[SOLDER_W] = wsum / csum;
+  	
+		wsum = 0.0;
+		for(i=0; i < nr; i++)
+			wsum += temp->cuboid[solderidx][i][nc-1];
+		wsum /= (l[solderidx].rx / 2.0 + nr * pk->r_solder1_x);
+		wsum += v[PCB_C_E]/pk->r_pcb_c_per_x + v[SUB_E]/pk->r_solder_per_x;
+		delta[SOLDER_E] = fabs(v[SOLDER_E] - wsum / csum);
+		v[SOLDER_E] = wsum / csum; 
+		
+		/* substrate north/south	*/
+		/* partition r_sub1_y among all the nc grid cells. edge cell has half the ry */
+		csum = nc / (l[subidx].ry / 2.0 + nc * pk->r_sub1_y);
+		csum += 1.0/pk->r_solder_per_y;
+  	
+		wsum = 0.0;
+		for(j=0; j < nc; j++)
+			wsum += temp->cuboid[subidx][0][j];
+		wsum /= (l[subidx].ry / 2.0 + nc * pk->r_sub1_y);
+		wsum += v[SOLDER_N]/pk->r_solder_per_y;
+		delta[SUB_N] = fabs(v[SUB_N] - wsum / csum);
+		v[SUB_N] = wsum / csum;
+		
+		wsum = 0.0;
+		for(j=0; j < nc; j++)
+			wsum += temp->cuboid[subidx][nr-1][j];
+		wsum /= (l[subidx].ry / 2.0 + nc * pk->r_sub1_y);
+		wsum += v[SOLDER_S]/pk->r_solder_per_y;
+		delta[SUB_S] = fabs(v[SUB_S] - wsum / csum);
+		v[SUB_S] = wsum / csum;
+  	
+		/* substrate west/east	*/
+		/* partition r_sub1_x among all the nr grid cells. edge cell has half the rx */
+		csum = nr / (l[subidx].rx / 2.0 + nr * pk->r_sub1_x);
+		csum += 1.0/pk->r_solder_per_x;
+  	
+		wsum = 0.0;
+		for(i=0; i < nr; i++)
+			wsum += temp->cuboid[subidx][i][0];
+		wsum /= (l[subidx].rx / 2.0 + nr * pk->r_sub1_x);
+		wsum += v[SOLDER_W]/pk->r_solder_per_x;
+		delta[SUB_W] = fabs(v[SUB_W] - wsum / csum);
+		v[SUB_W] = wsum / csum;
+  	
+		wsum = 0.0;
+		for(i=0; i < nr; i++)
+			wsum += temp->cuboid[subidx][i][nc-1];
+		wsum /= (l[subidx].rx / 2.0 + nr * pk->r_sub1_x);
+		wsum += v[SOLDER_E]/pk->r_solder_per_x;
+		delta[SUB_E] = fabs(v[SUB_E] - wsum / csum);
+		v[SUB_E] = wsum / csum;
+	} 
+	
+	if (!model->config.model_secondary) {
+		for(i=0; i < EXTRA; i++) {
+			if (delta[i] > max)
+				max = delta[i];
+		}
+	} else {
+		for(i=0; i < EXTRA + EXTRA_SEC; i++) {
+			if (delta[i] > max)
+				max = delta[i];
+		}
+	}
+	return max;
+}
+
+/* macros for calculating conductances	*/
+/* conductance to the next cell north. zero if on northern boundary	*/
+# define NC(l,n,i,j,nl,nr,nc)		((i > 0) ? (1.0/l[n].ry) : 0.0)
+/* conductance to the next cell south. zero if on southern boundary	*/
+# define SC(l,n,i,j,nl,nr,nc)		((i < nr-1) ? (1.0/l[n].ry) : 0.0)
+/* conductance to the next cell east. zero if on eastern boundary	*/
+# define EC(l,n,i,j,nl,nr,nc)		((j < nc-1) ? (1.0/l[n].rx) : 0.0)
+/* conductance to the next cell west. zero if on western boundary	*/
+# define WC(l,n,i,j,nl,nr,nc)		((j > 0) ? (1.0/l[n].rx) : 0.0)
+/* conductance to the next cell below. zero if on bottom face		*/
+# define BC(l,n,i,j,nl,nr,nc)		((n < nl-1) ? (1.0/l[n].rz) : 0.0)
+/* conductance to the next cell above. zero if on top face			*/
+# define AC(l,n,i,j,nl,nr,nc)		((n > 0) ? (1.0/l[n-1].rz) : 0.0)
+
+/* macros for calculating weighted temperatures	*/
+/* weighted T of the next cell north. zero if on northern boundary	*/
+# define NT(l,v,n,i,j,nl,nr,nc)		((i > 0) ? (v[n][i-1][j]/l[n].ry) : 0.0)
+/* weighted T of the next cell south. zero if on southern boundary	*/
+# define ST(l,v,n,i,j,nl,nr,nc)		((i < nr-1) ? (v[n][i+1][j]/l[n].ry) : 0.0)
+/* weighted T of the next cell east. zero if on eastern boundary	*/
+# define ET(l,v,n,i,j,nl,nr,nc)		((j < nc-1) ? (v[n][i][j+1]/l[n].rx) : 0.0)
+/* weighted T of the next cell west. zero if on western boundary	*/
+# define WT(l,v,n,i,j,nl,nr,nc)		((j > 0) ? (v[n][i][j-1]/l[n].rx) : 0.0)
+/* weighted T of the next cell below. zero if on bottom face		*/
+# define BT(l,v,n,i,j,nl,nr,nc)		((n < nl-1) ? (v[n+1][i][j]/l[n].rz) : 0.0)
+/* weighted T of the next cell above. zero if on top face			*/
+# define AT(l,v,n,i,j,nl,nr,nc)		((n > 0) ? (v[n-1][i][j]/l[n-1].rz) : 0.0)
+
+
+/* single steady state iteration of grid solver - silicon part */
+double single_iteration_steady_grid(grid_model_t *model, grid_model_vector_t *power,
+									grid_model_vector_t *temp)
+{
+	int n, i, j;
+	double prev, delta, max = 0;
+	/* sum of the conductances	*/
+	double csum;
+	/* weighted sum of temperatures	*/
+	double wsum;
+	
+	/* shortcuts for cell width(cw) and cell height(ch)	*/
+	double cw = model->width / model->cols;
+	double ch = model->height / model->rows;
+
+	/* shortcuts	*/
+	double ***v = temp->cuboid;
+	thermal_config_t *c = &model->config;
+	layer_t *l = model->layers;
+	int nl = model->n_layers;
+	int nr = model->rows;
+	int nc = model->cols;
+	int spidx = 0, hsidx = 0, metalidx = 0, c4idx = 0, subidx = 0, solderidx = 0, pcbidx = 0;
+	int model_secondary = model->config.model_secondary;
+	
+	if (!model->config.model_secondary) {
+		spidx = nl - DEFAULT_PACK_LAYERS + LAYER_SP;
+		hsidx = nl - DEFAULT_PACK_LAYERS + LAYER_SINK;
+	} else {
+		spidx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SP;
+		hsidx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SINK;
+		subidx = nl - SEC_PACK_LAYERS + LAYER_SUB;
+		solderidx = nl - SEC_PACK_LAYERS + LAYER_SOLDER;
+		pcbidx = nl - SEC_PACK_LAYERS + LAYER_PCB;
+		c4idx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS - SEC_CHIP_LAYERS + LAYER_C4;
+		metalidx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS - SEC_CHIP_LAYERS + LAYER_METAL;		
+	}
+
+	/* for each grid cell	*/
+	for(n=0; n < nl; n++) {
+		for(i=0; i < nr; i++) {
+			for(j=0; j < nc; j++) {
+				if((n==LAYER_SI) && model_secondary) {//top silicon layer: above is metal, beneath is TIM
+					csum = NC(l,n,i,j,nl,nr,nc) + SC(l,n,i,j,nl,nr,nc) + 
+					   EC(l,n,i,j,nl,nr,nc) + WC(l,n,i,j,nl,nr,nc) + 
+					   1.0/l[metalidx].rz + BC(l,n,i,j,nl,nr,nc);
+					wsum = NT(l,v,n,i,j,nl,nr,nc) + ST(l,v,n,i,j,nl,nr,nc) + 
+					   ET(l,v,n,i,j,nl,nr,nc) + WT(l,v,n,i,j,nl,nr,nc) + 
+					   v[metalidx][i][j]/l[metalidx].rz + BT(l,v,n,i,j,nl,nr,nc);
+				} else if((n==(metalidx-1)) && model_secondary ) {//last TIM layer: above is silicon, beneath is spreader
+					csum = NC(l,n,i,j,nl,nr,nc) + SC(l,n,i,j,nl,nr,nc) + 
+					   EC(l,n,i,j,nl,nr,nc) + WC(l,n,i,j,nl,nr,nc) + 
+					   1.0/l[metalidx-2].rz + 1.0/l[metalidx-1].rz;
+					wsum = NT(l,v,n,i,j,nl,nr,nc) + ST(l,v,n,i,j,nl,nr,nc) + 
+					   ET(l,v,n,i,j,nl,nr,nc) + WT(l,v,n,i,j,nl,nr,nc) + 
+					   v[metalidx-2][i][j]/l[metalidx-2].rz + v[spidx][i][j]/l[metalidx-1].rz;
+				} else if((n==spidx) && model_secondary ) {//spreader: above is TIM, beneath is sink
+					csum = NC(l,n,i,j,nl,nr,nc) + SC(l,n,i,j,nl,nr,nc) + 
+					   EC(l,n,i,j,nl,nr,nc) + WC(l,n,i,j,nl,nr,nc) + 
+					   1.0/l[metalidx-1].rz + BC(l,n,i,j,nl,nr,nc);
+					wsum = NT(l,v,n,i,j,nl,nr,nc) + ST(l,v,n,i,j,nl,nr,nc) + 
+					   ET(l,v,n,i,j,nl,nr,nc) + WT(l,v,n,i,j,nl,nr,nc) + 
+					   v[metalidx-1][i][j]/l[metalidx-1].rz + BT(l,v,n,i,j,nl,nr,nc);
+				} else if((n==metalidx) && model_secondary) { //metal layer: above is C4, below is Si
+					csum = NC(l,n,i,j,nl,nr,nc) + SC(l,n,i,j,nl,nr,nc) + 
+					   EC(l,n,i,j,nl,nr,nc) + WC(l,n,i,j,nl,nr,nc) + 
+					   1.0/l[c4idx].rz + 1.0/l[metalidx].rz;
+					wsum = NT(l,v,n,i,j,nl,nr,nc) + ST(l,v,n,i,j,nl,nr,nc) + 
+					   ET(l,v,n,i,j,nl,nr,nc) + WT(l,v,n,i,j,nl,nr,nc) + 
+					   v[c4idx][i][j]/l[c4idx].rz + v[LAYER_SI][i][j]/l[n].rz;
+				} else if((n==c4idx) && model_secondary) { // c4 layer: above is sub, below is metal
+					csum = NC(l,n,i,j,nl,nr,nc) + SC(l,n,i,j,nl,nr,nc) + 
+					   EC(l,n,i,j,nl,nr,nc) + WC(l,n,i,j,nl,nr,nc) + 
+					   1.0/l[subidx].rz + 1.0/l[c4idx].rz;
+					wsum = NT(l,v,n,i,j,nl,nr,nc) + ST(l,v,n,i,j,nl,nr,nc) + 
+					   ET(l,v,n,i,j,nl,nr,nc) + WT(l,v,n,i,j,nl,nr,nc) + 
+					   v[subidx][i][j]/l[subidx].rz + v[metalidx][i][j]/l[n].rz;
+				} else if((n==subidx) && model_secondary) { //sub layer: above is solder, below is c4 
+					csum = NC(l,n,i,j,nl,nr,nc) + SC(l,n,i,j,nl,nr,nc) + 
+					   EC(l,n,i,j,nl,nr,nc) + WC(l,n,i,j,nl,nr,nc) + 
+					   1.0/l[solderidx].rz + 1.0/l[subidx].rz;
+					wsum = NT(l,v,n,i,j,nl,nr,nc) + ST(l,v,n,i,j,nl,nr,nc) + 
+					   ET(l,v,n,i,j,nl,nr,nc) + WT(l,v,n,i,j,nl,nr,nc) + 
+					   v[solderidx][i][j]/l[solderidx].rz + v[c4idx][i][j]/l[n].rz;
+				} else if((n==solderidx) && model_secondary) { //solder layer: above is PCB, below is sub
+					csum = NC(l,n,i,j,nl,nr,nc) + SC(l,n,i,j,nl,nr,nc) + 
+					   EC(l,n,i,j,nl,nr,nc) + WC(l,n,i,j,nl,nr,nc) + 
+					   1.0/l[pcbidx].rz + 1.0/l[solderidx].rz;
+					wsum = NT(l,v,n,i,j,nl,nr,nc) + ST(l,v,n,i,j,nl,nr,nc) + 
+					   ET(l,v,n,i,j,nl,nr,nc) + WT(l,v,n,i,j,nl,nr,nc) + 
+					   v[pcbidx][i][j]/l[pcbidx].rz + v[subidx][i][j]/l[n].rz;
+				} else if((n==pcbidx) && model_secondary) { //PCB layer, above is ambient, below is solder
+					csum = NC(l,n,i,j,nl,nr,nc) + SC(l,n,i,j,nl,nr,nc) + 
+					   EC(l,n,i,j,nl,nr,nc) + WC(l,n,i,j,nl,nr,nc) + 
+					   1.0/l[pcbidx].rz;
+					wsum = NT(l,v,n,i,j,nl,nr,nc) + ST(l,v,n,i,j,nl,nr,nc) + 
+					   ET(l,v,n,i,j,nl,nr,nc) + WT(l,v,n,i,j,nl,nr,nc) + 
+					   v[solderidx][i][j]/l[n].rz;
+				}	else if((n==hsidx) && model_secondary) {
+					csum = NC(l,n,i,j,nl,nr,nc) + SC(l,n,i,j,nl,nr,nc) + 
+					   EC(l,n,i,j,nl,nr,nc) + WC(l,n,i,j,nl,nr,nc) + 
+					   1.0/l[spidx].rz;
+					wsum = NT(l,v,n,i,j,nl,nr,nc) + ST(l,v,n,i,j,nl,nr,nc) + 
+					   ET(l,v,n,i,j,nl,nr,nc) + WT(l,v,n,i,j,nl,nr,nc) + 
+					   v[spidx][i][j]/l[n-1].rz;
+				}	else {
+					/* sum the conductances to cells north, south, 
+				 	* east, west, above and below
+				 	*/
+					csum = NC(l,n,i,j,nl,nr,nc) + SC(l,n,i,j,nl,nr,nc) + 
+					   EC(l,n,i,j,nl,nr,nc) + WC(l,n,i,j,nl,nr,nc) + 
+					   AC(l,n,i,j,nl,nr,nc) + BC(l,n,i,j,nl,nr,nc);
+
+					/* sum of the weighted temperatures of all the neighbours	*/
+					wsum = NT(l,v,n,i,j,nl,nr,nc) + ST(l,v,n,i,j,nl,nr,nc) + 
+					   ET(l,v,n,i,j,nl,nr,nc) + WT(l,v,n,i,j,nl,nr,nc) + 
+					   AT(l,v,n,i,j,nl,nr,nc) + BT(l,v,n,i,j,nl,nr,nc);
+				}
+				
+				/* special treatment to C4/underfill */
+				if ((n == c4idx) && model->config.model_secondary) {
+					//FIXME!
+				}
+				/* spreader core is connected to its periphery	*/
+				if (n == spidx) {
+					/* northern boundary - edge cell has half the ry	*/
+					if (i == 0) {
+						csum += 1.0/(l[n].ry/2.0 + nc*model->pack.r_sp1_y); 
+						wsum += temp->extra[SP_N]/(l[n].ry/2.0 + nc*model->pack.r_sp1_y); 
+					}
+					/* southern boundary - edge cell has half the ry	*/
+					if (i == nr-1) {
+						csum += 1.0/(l[n].ry/2.0 + nc*model->pack.r_sp1_y); 
+						wsum += temp->extra[SP_S]/(l[n].ry/2.0 + nc*model->pack.r_sp1_y); 
+					}
+					/* eastern boundary	 - edge cell has half the rx	*/
+					if (j == nc-1) {
+						csum += 1.0/(l[n].rx/2.0 + nr*model->pack.r_sp1_x); 
+						wsum += temp->extra[SP_E]/(l[n].rx/2.0 + nr*model->pack.r_sp1_x); 
+					}
+					/* western boundary	- edge cell has half the rx		*/
+					if (j == 0) {
+						csum += 1.0/(l[n].rx/2.0 + nr*model->pack.r_sp1_x); 
+						wsum += temp->extra[SP_W]/(l[n].rx/2.0 + nr*model->pack.r_sp1_x); 
+					}
+				/* heatsink core is connected to its inner periphery and ambient	*/
+				} else if (n == hsidx) {
+					/* all nodes are connected to the ambient	*/
+					csum += 1.0/l[n].rz;
+					wsum += c->ambient/l[n].rz;
+					/* northern boundary - edge cell has half the ry	*/
+					if (i == 0) {
+						csum += 1.0/(l[n].ry/2.0 + nc*model->pack.r_hs1_y); 
+						wsum += temp->extra[SINK_C_N]/(l[n].ry/2.0 + nc*model->pack.r_hs1_y); 
+					}
+					/* southern boundary - edge cell has half the ry	*/
+					if (i == nr-1) {
+						csum += 1.0/(l[n].ry/2.0 + nc*model->pack.r_hs1_y); 
+						wsum += temp->extra[SINK_C_S]/(l[n].ry/2.0 + nc*model->pack.r_hs1_y); 
+					}
+					/* eastern boundary	 - edge cell has half the rx	*/
+					if (j == nc-1) {
+						csum += 1.0/(l[n].rx/2.0 + nr*model->pack.r_hs1_x); 
+						wsum += temp->extra[SINK_C_E]/(l[n].rx/2.0 + nr*model->pack.r_hs1_x); 
+					}
+					/* western boundary	- edge cell has half the rx		*/
+					if (j == 0) {
+						csum += 1.0/(l[n].rx/2.0 + nr*model->pack.r_hs1_x); 
+						wsum += temp->extra[SINK_C_W]/(l[n].rx/2.0 + nr*model->pack.r_hs1_x); 
+					}
+				} else if ((n==subidx) && model->config.model_secondary) {
+					/* northern boundary - edge cell has half the ry	*/
+					if (i == 0) {
+						csum += 1.0/(l[n].ry/2.0 + nc*model->pack.r_sub1_y); 
+						wsum += temp->extra[SUB_N]/(l[n].ry/2.0 + nc*model->pack.r_sub1_y); 
+					}
+					/* southern boundary - edge cell has half the ry	*/
+					if (i == nr-1) {
+						csum += 1.0/(l[n].ry/2.0 + nc*model->pack.r_sub1_y); 
+						wsum += temp->extra[SUB_S]/(l[n].ry/2.0 + nc*model->pack.r_sub1_y); 
+					}
+					/* eastern boundary	 - edge cell has half the rx	*/
+					if (j == nc-1) {
+						csum += 1.0/(l[n].rx/2.0 + nr*model->pack.r_sub1_x); 
+						wsum += temp->extra[SUB_E]/(l[n].rx/2.0 + nr*model->pack.r_sub1_x); 
+					}
+					/* western boundary	- edge cell has half the rx		*/
+					if (j == 0) {
+						csum += 1.0/(l[n].rx/2.0 + nr*model->pack.r_sub1_x); 
+						wsum += temp->extra[SUB_W]/(l[n].rx/2.0 + nr*model->pack.r_sub1_x); 
+					} 
+				} else if ((n==solderidx) && model->config.model_secondary) {
+					/* northern boundary - edge cell has half the ry	*/
+					if (i == 0) {
+						csum += 1.0/(l[n].ry/2.0 + nc*model->pack.r_solder1_y); 
+						wsum += temp->extra[SOLDER_N]/(l[n].ry/2.0 + nc*model->pack.r_solder1_y); 
+					}
+					/* southern boundary - edge cell has half the ry	*/
+					if (i == nr-1) {
+						csum += 1.0/(l[n].ry/2.0 + nc*model->pack.r_solder1_y); 
+						wsum += temp->extra[SOLDER_S]/(l[n].ry/2.0 + nc*model->pack.r_solder1_y); 
+					}
+					/* eastern boundary	 - edge cell has half the rx	*/
+					if (j == nc-1) {
+						csum += 1.0/(l[n].rx/2.0 + nr*model->pack.r_solder1_x); 
+						wsum += temp->extra[SOLDER_E]/(l[n].rx/2.0 + nr*model->pack.r_solder1_x); 
+					}
+					/* western boundary	- edge cell has half the rx		*/
+					if (j == 0) {
+						csum += 1.0/(l[n].rx/2.0 + nr*model->pack.r_solder1_x); 
+						wsum += temp->extra[SOLDER_W]/(l[n].rx/2.0 + nr*model->pack.r_solder1_x); 
+					} 
+				} else if ((n==pcbidx) && model->config.model_secondary) {
+					/* all nodes are connected to the ambient	*/
+					csum += 1.0/(model->config.r_convec_sec * 
+								   (model->config.s_pcb * model->config.s_pcb) / (cw * ch));
+					wsum += c->ambient/(model->config.r_convec_sec * 
+								   (model->config.s_pcb * model->config.s_pcb) / (cw * ch));
+					/* northern boundary - edge cell has half the ry	*/
+					if (i == 0) {
+						csum += 1.0/(l[n].ry/2.0 + nc*model->pack.r_pcb1_y); 
+						wsum += temp->extra[PCB_C_N]/(l[n].ry/2.0 + nc*model->pack.r_pcb1_y); 
+					}
+					/* southern boundary - edge cell has half the ry	*/
+					if (i == nr-1) {
+						csum += 1.0/(l[n].ry/2.0 + nc*model->pack.r_pcb1_y); 
+						wsum += temp->extra[PCB_C_S]/(l[n].ry/2.0 + nc*model->pack.r_pcb1_y); 
+					}
+					/* eastern boundary	 - edge cell has half the rx	*/
+					if (j == nc-1) {
+						csum += 1.0/(l[n].rx/2.0 + nr*model->pack.r_pcb1_x); 
+						wsum += temp->extra[PCB_C_E]/(l[n].rx/2.0 + nr*model->pack.r_pcb1_x); 
+					}
+					/* western boundary	- edge cell has half the rx		*/
+					if (j == 0) {
+						csum += 1.0/(l[n].rx/2.0 + nr*model->pack.r_pcb1_x); 
+						wsum += temp->extra[PCB_C_W]/(l[n].rx/2.0 + nr*model->pack.r_pcb1_x); 
+					}
+				}
+
+				/* update the current cell's temperature	*/	   
+				prev = v[n][i][j];
+				v[n][i][j] = (power->cuboid[n][i][j] + wsum) / csum;
+				
+				/* compute maximum delta	*/
+				delta =  fabs(prev - v[n][i][j]);
+				if (delta > max)
+					max = delta;
+			}
+		}
+	}
+	/* package part of the iteration	*/
+	return (MAX(max, single_iteration_steady_pack(model, power, temp)));
+}
+
+/* restriction operator for multigrid solver. given a power vector
+ * corresponding to a fine grid, outputs a vector corresponding
+ * to one level coarser grid (half the no. of rows and cols)
+ * NOTE: model->rows and model->cols denote the size of the
+ * coarser grid
+ */
+void multigrid_restrict_power(grid_model_t *model, grid_model_vector_t *dst, 
+							  grid_model_vector_t *src)
+{
+	/* coarse grid indices	*/
+	int n, i, j;
+
+	/* grid cells - add the four nearest neighbours	*/
+	for(n=0; n < model->n_layers; n++)
+		for(i=0; i < model->rows; i++)
+			for(j=0; j < model->cols; j++)
+			{
+				dst->cuboid[n][i][j] = (src->cuboid[n][2*i][2*j] +
+										src->cuboid[n][2*i+1][2*j] +
+										src->cuboid[n][2*i][2*j+1] +
+										src->cuboid[n][2*i+1][2*j+1]);
+			}
+	/* package nodes - copy them as it is	*/
+	if (!model->config.model_secondary)
+		copy_dvector(dst->extra, src->extra, EXTRA);
+	else
+		copy_dvector(dst->extra, src->extra, EXTRA+EXTRA_SEC);
+}
+
+/* prolongation(interpolation) operator for multigrid solver. 
+ * given a temperature vector corresponding to a coarse grid,
+ * outputs a (bi)linearly interpolated vector corresponding 
+ * to one level finer grid (twice the no. of rows and cols)
+ * NOTE: model->rows and model->cols denote the size of the
+ * coarser grid
+ */
+void multigrid_prolong_temp(grid_model_t *model, grid_model_vector_t *dst, 
+							grid_model_vector_t *src)
+{
+	/* coarse grid indices	*/
+	int n, i, j;
+
+	/* shortcuts	*/
+	int nr = model->rows;
+	int nc = model->cols;
+	double ***d = dst->cuboid;
+	double ***s = src->cuboid;
+
+	/* For the fine grid cells not on the boundary,
+	 * we want to linearly interpolate in the region 
+	 * surrounded by the coarse grid cells (i,j),
+	 * (i+1,j) (i,j+1) and (i+1, j+1). The fine
+	 * grid cells in that region are (2i+1, 2j+1),
+	 * (2i+2, 2j+1), (2i+1, 2j+2) and (2i+2, 2j+2).
+	 * To interpolate bilinearly, we first interpolate
+	 * along one axis and then along the other. In
+	 * each axis, due to the proximity of the fine
+	 * grid cell co-ordinates to one of the coarse
+	 * grid cells, the weights are 3/4 and 1/4 (not
+	 * 1/2 and 1/2) So, repeating them along the  
+	 * other axis also results in weights of 9/16,
+	 * 3/16, 3/16 and 1/16
+	 */ 
+	for(n=0; n < model->n_layers; n++)
+		for(i=0; i < nr-1; i++)
+			for(j=0; j < nc-1; j++) {
+				d[n][2*i+1][2*j+1] = 9.0/16.0 * s[n][i][j] +
+									 3.0/16.0 * s[n][i+1][j] +
+									 1.0/16.0 * s[n][i+1][j+1] +
+									 3.0/16.0 * s[n][i][j+1];
+				d[n][2*i+2][2*j+1] = 3.0/16.0 * s[n][i][j] +
+									 9.0/16.0 * s[n][i+1][j] +
+									 3.0/16.0 * s[n][i+1][j+1] +
+									 1.0/16.0 * s[n][i][j+1];
+				d[n][2*i+2][2*j+2] = 1.0/16.0 * s[n][i][j] +
+									 3.0/16.0 * s[n][i+1][j] +
+									 9.0/16.0 * s[n][i+1][j+1] +
+									 3.0/16.0 * s[n][i][j+1];
+				d[n][2*i+1][2*j+2] = 3.0/16.0 * s[n][i][j] +
+									 1.0/16.0 * s[n][i+1][j] +
+									 3.0/16.0 * s[n][i+1][j+1] +
+									 9.0/16.0 * s[n][i][j+1];
+			}
+
+	/* for the cells on the boundary, we perform
+	 * a zeroth order interpolation. i.e., copy
+	 * the nearest coarse grid cell's value
+	 * as it is
+	 */
+	for(n=0; n < model->n_layers; n++) {
+		for(i=0; i < nr; i++) {
+			d[n][2*i][0] = d[n][2*i+1][0] = s[n][i][0];
+			d[n][2*i][2*nc-1] = d[n][2*i+1][2*nc-1] = s[n][i][nc-1];
+		}	
+		for(j=0; j < nc; j++) {
+			d[n][0][2*j] = d[n][0][2*j+1] = s[n][0][j];
+			d[n][2*nr-1][2*j] = d[n][2*nr-1][2*j+1] = s[n][nr-1][j];
+		}
+	}
+	
+	/* package nodes - copy them as it is	*/
+	if (!model->config.model_secondary) 
+		copy_dvector(dst->extra, src->extra, EXTRA);
+	else
+		copy_dvector(dst->extra, src->extra, EXTRA+EXTRA_SEC);
+}
+
+/* recursive multigrid solver. it uses the Gauss-Seidel (GS) iterative 
+ * solver to solve at a particular grid granularity. Although GS removes
+ * high frequency errors in a solution estimate pretty quickly, it 
+ * takes a lot of time to eliminate the low frequency ones. These 
+ * low frequency errors can be eliminated easily by coarsifying the
+ * grid. This is the core principle of mulrigrid solvers. The version here
+ * is called "nested iteration". It solves the problem (iteratively using GS)
+ * first in the coarsest granularity and then utilizes that solution to 
+ * estimate the solution in the next finer grid. This is repeated until
+ * the solution is found in the finest desired grid. For details, take 
+ * a look at Numerical Recipes in C (2nd edition), sections 19.5 and 19.6
+ * (http://www.nrbook.com/a/bookcpdf/c19-5.pdf and
+ * http://www.nrbook.com/a/bookcpdf/c19-6.pdf). Also refer to Prof.
+ * Jayathi Murthy's ME 608 notes from Purdue - Chapter 8, sections 8.7-8.9.
+ * (http://meweb.ecn.purdue.edu/~jmurthy/me608/main.pdf - pg. 175-192)
+ */ 
+void recursive_multigrid(grid_model_t *model, grid_model_vector_t *power,
+						 grid_model_vector_t *temp)
+{
+	double delta;
+	#if VERBOSE > 1
+	//unsigned int i = 0;
+	#endif
+	grid_model_vector_t *coarse_power, *coarse_temp;
+	int n;
+
+	/* setup heuristic initial temperatures	at the coarsest level*/
+	if (model->rows <= 1 || model->cols <= 1) {
+		set_heuristic_temp(model, power, temp);
+		
+	
+	/* for finer grids. use coarser solutions as estimates	*/
+	} else {
+		/* make the grid coarser	*/
+		model->rows /= 2;
+		model->cols /= 2;
+		for(n=0; n < model->n_layers; n++) {
+			/* only rz's and c's change. rx's and 
+			 * ry's remain the same	
+			 */
+			model->layers[n].rz /= 4;
+			if (model->c_ready)
+				model->layers[n].c *= 4;
+		}
+
+		/* vectors for the coarse grid	*/
+		coarse_power = new_grid_model_vector(model);
+		coarse_temp = new_grid_model_vector(model);
+
+		/* coarsen the power vector	*/
+		multigrid_restrict_power(model, coarse_power, power);
+
+		/* solve recursively	*/
+		recursive_multigrid(model, coarse_power, coarse_temp);
+
+		/* interpolate the solution to the current fine grid	*/
+		multigrid_prolong_temp(model, temp, coarse_temp);
+
+		/* cleanup	*/
+		free_grid_model_vector(coarse_power);
+		free_grid_model_vector(coarse_temp);
+		
+		/* restore the grid */
+		model->rows *= 2;
+		model->cols *= 2;
+		for(n=0; n < model->n_layers; n++) {
+			model->layers[n].rz *= 4;
+			if (model->c_ready)
+				model->layers[n].c /= 4;
+		}
+	}
+	/* refine solution iteratively till convergence	*/
+	do {
+		delta = single_iteration_steady_grid(model, power, temp);
+		#if VERBOSE > 1
+			//i++;
+		#endif
+	} while (!eq(delta, 0));
+	#if VERBOSE > 1
+	//fprintf(stdout, "no. of iterations for steady state convergence (%d x %d grid): %d\n", model->rows, model->cols, i);
+	#endif
+}
+
+void steady_state_temp_grid(grid_model_t *model, double *power, double *temp)
+{
+	grid_model_vector_t *p;
+	//double total;
+
+	if (!model->r_ready)
+		fatal((char*)"R model not ready\n");
+
+	p = new_grid_model_vector(model);
+
+	/* package nodes' power numbers	*/
+	set_internal_power_grid(model, power);
+	
+	/* total power - package nodes have no power dissipation	*/
+	//total = sum_dvector(power, model->total_n_blocks);
+
+	/* map the block power numbers to the grid	*/
+	xlate_vector_b2g(model, power, p, V_POWER);
+
+	/* solve recursively. use grid model's internal 
+	 * state vector to store the grid temperatures
+	 */ 
+	recursive_multigrid(model, p, model->last_steady);
+
+	/* map the temperature numbers back	*/
+	xlate_temp_g2b(model, temp, model->last_steady);
+
+	free_grid_model_vector(p);
+}
+
+/* function to access a 1-d array as a 3-d matrix	*/
+#define A3D(array,n,i,j,nl,nr,nc)		(array[(n)*(nr)*(nc) + (i)*(nc) + (j)])
+
+/* compute the slope vector for the package nodes	*/
+void slope_fn_pack(grid_model_t *model, double *v, grid_model_vector_t *p, double *dv)
+{
+	int i, j;
+	/* sum of the currents(power values)	*/
+	double psum;
+	
+	/* shortcuts	*/
+	package_RC_t *pk = &model->pack;
+	thermal_config_t *c = &model->config;
+	layer_t *l = model->layers;
+	int nl = model->n_layers;
+	int nr = model->rows;
+	int nc = model->cols;
+	int spidx = 0, hsidx = 0;
+	//int metalidx = 0, c4idx = 0;
+	int subidx = 0, solderidx = 0, pcbidx = 0;
+	
+	/* pointer to the starting address of the extra nodes	*/
+	double *x = v + nl*nr*nc;
+
+	
+	if (!model->config.model_secondary) {
+		spidx = nl - DEFAULT_PACK_LAYERS + LAYER_SP;
+		hsidx = nl - DEFAULT_PACK_LAYERS + LAYER_SINK;
+	} else {
+		spidx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SP;
+		hsidx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SINK;
+		//metalidx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS - SEC_CHIP_LAYERS + LAYER_METAL;
+		//c4idx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS - SEC_CHIP_LAYERS + LAYER_C4;
+		subidx = nl - SEC_PACK_LAYERS + LAYER_SUB;
+		solderidx = nl - SEC_PACK_LAYERS + LAYER_SOLDER;
+		pcbidx = nl - SEC_PACK_LAYERS + LAYER_PCB;		
+	}
+	
+
+	/* sink outer north/south	*/
+	psum = (c->ambient - x[SINK_N])/(pk->r_hs_per + pk->r_amb_per) + 
+		   (x[SINK_C_N] - x[SINK_N])/(pk->r_hs2_y + pk->r_hs);
+	dv[nl*nr*nc + SINK_N] = psum / (pk->c_hs_per + pk->c_amb_per);
+	psum = (c->ambient - x[SINK_S])/(pk->r_hs_per + pk->r_amb_per) + 
+		   (x[SINK_C_S] - x[SINK_S])/(pk->r_hs2_y + pk->r_hs);
+	dv[nl*nr*nc + SINK_S] = psum / (pk->c_hs_per + pk->c_amb_per);
+
+	/* sink outer west/east	*/
+	psum = (c->ambient - x[SINK_W])/(pk->r_hs_per + pk->r_amb_per) + 
+		   (x[SINK_C_W] - x[SINK_W])/(pk->r_hs2_x + pk->r_hs);
+	dv[nl*nr*nc + SINK_W] = psum / (pk->c_hs_per + pk->c_amb_per);
+	psum = (c->ambient - x[SINK_E])/(pk->r_hs_per + pk->r_amb_per) + 
+		   (x[SINK_C_E] - x[SINK_E])/(pk->r_hs2_x + pk->r_hs);
+	dv[nl*nr*nc + SINK_E] = psum / (pk->c_hs_per + pk->c_amb_per);
+
+	/* sink inner north/south	*/
+	/* partition r_hs1_y among all the nc grid cells. edge cell has half the ry	*/
+	psum = 0.0;
+	for(j=0; j < nc; j++)
+		psum += (A3D(v,hsidx,0,j,nl,nr,nc) - x[SINK_C_N]);
+	psum /= (l[hsidx].ry / 2.0 + nc * pk->r_hs1_y);
+	psum += (c->ambient - x[SINK_C_N])/(pk->r_hs_c_per_y + pk->r_amb_c_per_y) + 
+			(x[SP_N] - x[SINK_C_N])/pk->r_sp_per_y +
+			(x[SINK_N] - x[SINK_C_N])/(pk->r_hs2_y + pk->r_hs);
+	dv[nl*nr*nc + SINK_C_N] = psum / (pk->c_hs_c_per_y + pk->c_amb_c_per_y);
+
+	psum = 0.0;
+	for(j=0; j < nc; j++)
+		psum += (A3D(v,hsidx,nr-1,j,nl,nr,nc) - x[SINK_C_S]);
+	psum /= (l[hsidx].ry / 2.0 + nc * pk->r_hs1_y);
+	psum += (c->ambient - x[SINK_C_S])/(pk->r_hs_c_per_y + pk->r_amb_c_per_y) + 
+			(x[SP_S] - x[SINK_C_S])/pk->r_sp_per_y +
+			(x[SINK_S] - x[SINK_C_S])/(pk->r_hs2_y + pk->r_hs);
+	dv[nl*nr*nc + SINK_C_S] = psum / (pk->c_hs_c_per_y + pk->c_amb_c_per_y);
+
+	/* sink inner west/east	*/
+	/* partition r_hs1_x among all the nr grid cells. edge cell has half the rx	*/
+	psum = 0.0;
+	for(i=0; i < nr; i++)
+		psum += (A3D(v,hsidx,i,0,nl,nr,nc) - x[SINK_C_W]);
+	psum /= (l[hsidx].rx / 2.0 + nr * pk->r_hs1_x);
+	psum += (c->ambient - x[SINK_C_W])/(pk->r_hs_c_per_x + pk->r_amb_c_per_x) + 
+			(x[SP_W] - x[SINK_C_W])/pk->r_sp_per_x +
+			(x[SINK_W] - x[SINK_C_W])/(pk->r_hs2_x + pk->r_hs);
+	dv[nl*nr*nc + SINK_C_W] = psum / (pk->c_hs_c_per_x + pk->c_amb_c_per_x);
+
+	psum = 0.0;
+	for(i=0; i < nr; i++)
+		psum += (A3D(v,hsidx,i,nc-1,nl,nr,nc) - x[SINK_C_E]);
+	psum /= (l[hsidx].rx / 2.0 + nr * pk->r_hs1_x);
+	psum += (c->ambient - x[SINK_C_E])/(pk->r_hs_c_per_x + pk->r_amb_c_per_x) + 
+			(x[SP_E] - x[SINK_C_E])/pk->r_sp_per_x +
+			(x[SINK_E] - x[SINK_C_E])/(pk->r_hs2_x + pk->r_hs);
+	dv[nl*nr*nc + SINK_C_E] = psum / (pk->c_hs_c_per_x + pk->c_amb_c_per_x);
+
+	/* spreader north/south	*/
+	/* partition r_sp1_y among all the nc grid cells. edge cell has half the ry	*/
+	psum = 0.0;
+	for(j=0; j < nc; j++)
+		psum += (A3D(v,spidx,0,j,nl,nr,nc) - x[SP_N]);
+	psum /= (l[spidx].ry / 2.0 + nc * pk->r_sp1_y);
+	psum += (x[SINK_C_N] - x[SP_N])/pk->r_sp_per_y;
+	dv[nl*nr*nc + SP_N] = psum / pk->c_sp_per_y;
+
+	psum = 0.0;
+	for(j=0; j < nc; j++)
+		psum += (A3D(v,spidx,nr-1,j,nl,nr,nc) - x[SP_S]);
+	psum /= (l[spidx].ry / 2.0 + nc * pk->r_sp1_y);
+	psum += (x[SINK_C_S] - x[SP_S])/pk->r_sp_per_y;
+	dv[nl*nr*nc + SP_S] = psum / pk->c_sp_per_y;
+
+	/* spreader west/east	*/
+	/* partition r_sp1_x among all the nr grid cells. edge cell has half the rx	*/
+	psum = 0.0;
+	for(i=0; i < nr; i++)
+		psum += (A3D(v,spidx,i,0,nl,nr,nc) - x[SP_W]);
+	psum /= (l[spidx].rx / 2.0 + nr * pk->r_sp1_x);
+	psum += (x[SINK_C_W] - x[SP_W])/pk->r_sp_per_x;
+	dv[nl*nr*nc + SP_W] = psum / pk->c_sp_per_x;
+
+	psum = 0.0;
+	for(i=0; i < nr; i++)
+		psum += (A3D(v,spidx,i,nc-1,nl,nr,nc) - x[SP_E]);
+	psum /= (l[spidx].rx / 2.0 + nr * pk->r_sp1_x);
+	psum += (x[SINK_C_E] - x[SP_E])/pk->r_sp_per_x;
+	dv[nl*nr*nc + SP_E] = psum / pk->c_sp_per_x;
+	
+	if (model->config.model_secondary) {
+		/* PCB outer north/south	*/
+		psum = (c->ambient - x[PCB_N])/(pk->r_amb_sec_per) + 
+			   (x[PCB_C_N] - x[PCB_N])/(pk->r_pcb2_y + pk->r_pcb);
+		dv[nl*nr*nc + PCB_N] = psum / (pk->c_pcb_per + pk->c_amb_sec_per);
+		psum = (c->ambient - x[PCB_S])/(pk->r_amb_sec_per) + 
+			   (x[PCB_C_S] - x[PCB_S])/(pk->r_pcb2_y + pk->r_pcb);
+		dv[nl*nr*nc + PCB_S] = psum / (pk->c_pcb_per + pk->c_amb_sec_per);
+  	
+		/* PCB outer west/east	*/
+		psum = (c->ambient - x[PCB_W])/(pk->r_amb_sec_per) + 
+			   (x[PCB_C_W] - x[PCB_W])/(pk->r_pcb2_x + pk->r_pcb);
+		dv[nl*nr*nc + PCB_W] = psum / (pk->c_pcb_per + pk->c_amb_sec_per);
+		psum = (c->ambient - x[PCB_E])/(pk->r_amb_sec_per) + 
+			   (x[PCB_C_E] - x[PCB_E])/(pk->r_pcb2_x + pk->r_pcb);
+		dv[nl*nr*nc + PCB_E] = psum / (pk->c_pcb_per + pk->c_amb_sec_per);
+  	
+		/* PCB inner north/south	*/
+		/* partition r_pcb1_y among all the nc grid cells. edge cell has half the ry	*/
+		psum = 0.0;
+		for(j=0; j < nc; j++)
+			psum += (A3D(v,pcbidx,0,j,nl,nr,nc) - x[PCB_C_N]);
+		psum /= (l[pcbidx].ry / 2.0 + nc * pk->r_pcb1_y);
+		psum += (c->ambient - x[PCB_C_N])/(pk->r_amb_sec_c_per_y) + 
+				(x[SOLDER_N] - x[PCB_C_N])/pk->r_pcb_c_per_y +
+				(x[PCB_N] - x[PCB_C_N])/(pk->r_pcb2_y + pk->r_pcb);
+		dv[nl*nr*nc + PCB_C_N] = psum / (pk->c_pcb_c_per_y + pk->c_amb_sec_c_per_y);
+  	
+		psum = 0.0;
+		for(j=0; j < nc; j++)
+			psum += (A3D(v,pcbidx,nr-1,j,nl,nr,nc) - x[PCB_C_S]);
+		psum /= (l[pcbidx].ry / 2.0 + nc * pk->r_pcb1_y);
+		psum += (c->ambient - x[PCB_C_S])/(pk->r_amb_sec_c_per_y) + 
+				(x[SOLDER_S] - x[PCB_C_S])/pk->r_pcb_c_per_y +
+				(x[PCB_S] - x[PCB_C_S])/(pk->r_pcb2_y + pk->r_pcb);
+		dv[nl*nr*nc + PCB_C_S] = psum / (pk->c_pcb_c_per_y + pk->c_amb_sec_c_per_y);
+  	
+  	/* PCB inner west/east	*/
+		/* partition r_pcb1_x among all the nr grid cells. edge cell has half the rx	*/
+		psum = 0.0;
+		for(i=0; i < nr; i++)
+			psum += (A3D(v,pcbidx,i,0,nl,nr,nc) - x[PCB_C_W]);
+		psum /= (l[pcbidx].rx / 2.0 + nr * pk->r_pcb1_x);
+		psum += (c->ambient - x[PCB_C_W])/(pk->r_amb_sec_c_per_x) + 
+				(x[SOLDER_W] - x[PCB_C_W])/pk->r_pcb_c_per_x +
+				(x[PCB_W] - x[PCB_C_W])/(pk->r_pcb2_x + pk->r_pcb);
+		dv[nl*nr*nc + PCB_C_W] = psum / (pk->c_pcb_c_per_x + pk->c_amb_sec_c_per_x);
+  	
+		psum = 0.0;
+		for(i=0; i < nr; i++)
+			psum += (A3D(v,pcbidx,i,nc-1,nl,nr,nc) - x[PCB_C_E]);
+		psum /= (l[pcbidx].rx / 2.0 + nr * pk->r_pcb1_x);
+		psum += (c->ambient - x[PCB_C_E])/(pk->r_amb_sec_c_per_x) + 
+				(x[SOLDER_E] - x[PCB_C_E])/pk->r_pcb_c_per_x +
+				(x[PCB_E] - x[PCB_C_E])/(pk->r_pcb2_x + pk->r_pcb);
+		dv[nl*nr*nc + PCB_C_E] = psum / (pk->c_pcb_c_per_x + pk->c_amb_sec_c_per_x);
+  	
+		/* solder ball north/south	*/
+		/* partition r_solder1_y among all the nc grid cells. edge cell has half the ry	*/
+		psum = 0.0;
+		for(j=0; j < nc; j++)
+			psum += (A3D(v,solderidx,0,j,nl,nr,nc) - x[SOLDER_N]);
+		psum /= (l[solderidx].ry / 2.0 + nc * pk->r_solder1_y);
+		psum += (x[PCB_C_N] - x[SOLDER_N])/pk->r_pcb_c_per_y;
+		dv[nl*nr*nc + SOLDER_N] = psum / pk->c_solder_per_y;
+  	
+		psum = 0.0;
+		for(j=0; j < nc; j++)
+			psum += (A3D(v,solderidx,nr-1,j,nl,nr,nc) - x[SOLDER_S]);
+		psum /= (l[solderidx].ry / 2.0 + nc * pk->r_solder1_y);
+		psum += (x[PCB_C_S] - x[SOLDER_S])/pk->r_pcb_c_per_y;
+		dv[nl*nr*nc + SOLDER_S] = psum / pk->c_solder_per_y;
+  	
+		/* solder ball west/east	*/
+		/* partition r_solder1_x among all the nr grid cells. edge cell has half the rx	*/
+		psum = 0.0;
+		for(i=0; i < nr; i++)
+			psum += (A3D(v,solderidx,i,0,nl,nr,nc) - x[SOLDER_W]);
+		psum /= (l[solderidx].rx / 2.0 + nr * pk->r_solder1_x);
+		psum += (x[PCB_C_W] - x[SOLDER_W])/pk->r_pcb_c_per_x;
+		dv[nl*nr*nc + SOLDER_W] = psum / pk->c_solder_per_x;
+  	
+		psum = 0.0;
+		for(i=0; i < nr; i++)
+			psum += (A3D(v,solderidx,i,nc-1,nl,nr,nc) - x[SOLDER_E]);
+		psum /= (l[solderidx].rx / 2.0 + nr * pk->r_solder1_x);
+		psum += (x[PCB_C_E] - x[SOLDER_E])/pk->r_pcb_c_per_x;
+		dv[nl*nr*nc + SOLDER_E] = psum / pk->c_solder_per_x;
+		
+		/* package substrate north/south	*/
+		/* partition r_sub1_y among all the nc grid cells. edge cell has half the ry	*/
+		psum = 0.0;
+		for(j=0; j < nc; j++)
+			psum += (A3D(v,subidx,0,j,nl,nr,nc) - x[SUB_N]);
+		psum /= (l[subidx].ry / 2.0 + nc * pk->r_sub1_y);
+		psum += (x[SOLDER_N] - x[SUB_N])/pk->r_solder_per_y;
+		dv[nl*nr*nc + SUB_N] = psum / pk->c_sub_per_y;
+  	
+		psum = 0.0;
+		for(j=0; j < nc; j++)
+			psum += (A3D(v,subidx,nr-1,j,nl,nr,nc) - x[SUB_S]);
+		psum /= (l[subidx].ry / 2.0 + nc * pk->r_sub1_y);
+		psum += (x[SOLDER_S] - x[SUB_S])/pk->r_solder_per_y;
+		dv[nl*nr*nc + SUB_S] = psum / pk->c_sub_per_y;
+  	
+		/* sub ball west/east	*/
+		/* partition r_sub1_x among all the nr grid cells. edge cell has half the rx	*/
+		psum = 0.0;
+		for(i=0; i < nr; i++)
+			psum += (A3D(v,subidx,i,0,nl,nr,nc) - x[SUB_W]);
+		psum /= (l[subidx].rx / 2.0 + nr * pk->r_sub1_x);
+		psum += (x[SOLDER_W] - x[SUB_W])/pk->r_solder_per_x;
+		dv[nl*nr*nc + SUB_W] = psum / pk->c_sub_per_x;
+  	
+		psum = 0.0;
+		for(i=0; i < nr; i++)
+			psum += (A3D(v,subidx,i,nc-1,nl,nr,nc) - x[SUB_E]);
+		psum /= (l[subidx].rx / 2.0 + nr * pk->r_sub1_x);
+		psum += (x[SOLDER_E] - x[SUB_E])/pk->r_solder_per_x;
+		dv[nl*nr*nc + SUB_E] = psum / pk->c_sub_per_x;
+	}
+}
+
+/* macros for calculating currents(power values)	*/
+/* current(power) from the next cell north. zero if on northern boundary	*/
+# define NP(l,v,n,i,j,nl,nr,nc)		((i > 0) ? ((A3D(v,n,i-1,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].ry) : 0.0)
+/* current(power) from the next cell south. zero if on southern boundary	*/
+# define SP(l,v,n,i,j,nl,nr,nc)		((i < nr-1) ? ((A3D(v,n,i+1,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].ry) : 0.0)
+/* current(power) from the next cell east. zero if on eastern boundary	*/
+# define EP(l,v,n,i,j,nl,nr,nc)		((j < nc-1) ? ((A3D(v,n,i,j+1,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].rx) : 0.0)
+/* current(power) from the next cell west. zero if on western boundary	*/
+# define WP(l,v,n,i,j,nl,nr,nc)		((j > 0) ? ((A3D(v,n,i,j-1,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].rx) : 0.0)
+/* current(power) from the next cell below. zero if on bottom face		*/
+# define BP(l,v,n,i,j,nl,nr,nc)		((n < nl-1) ? ((A3D(v,n+1,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].rz) : 0.0)
+/* current(power) from the next cell above. zero if on top face			*/
+# define AP(l,v,n,i,j,nl,nr,nc)		((n > 0) ? ((A3D(v,n-1,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n-1].rz) : 0.0)
+
+/* compute the slope vector for the grid cells. the transient
+ * equation is CdV + sum{(T - Ti)/Ri} = P 
+ * so, slope = dV = [P + sum{(Ti-T)/Ri}]/C
+ */
+void slope_fn_grid(grid_model_t *model, double *v, grid_model_vector_t *p, double *dv)
+{
+	int n, i, j;
+	/* sum of the currents(power values)	*/
+	double psum;
+	
+	/* shortcuts for cell width(cw) and cell height(ch)	*/
+	double cw = model->width / model->cols;
+	double ch = model->height / model->rows;
+
+	/* shortcuts	*/
+	thermal_config_t *c = &model->config;
+	layer_t *l = model->layers;
+	int nl = model->n_layers;
+	int nr = model->rows;
+	int nc = model->cols;
+	int spidx = 0, hsidx = 0, metalidx = 0, c4idx = 0, subidx = 0, solderidx = 0, pcbidx = 0;
+	int model_secondary = model->config.model_secondary;
+	
+	/* pointer to the starting address of the extra nodes	*/
+	double *x = v + nl*nr*nc;
+	
+	if (!model->config.model_secondary) {
+		spidx = nl - DEFAULT_PACK_LAYERS + LAYER_SP;
+		hsidx = nl - DEFAULT_PACK_LAYERS + LAYER_SINK;
+	} else {
+		spidx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SP;
+		hsidx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS + LAYER_SINK;
+		metalidx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS - SEC_CHIP_LAYERS + LAYER_METAL;
+		c4idx = nl - DEFAULT_PACK_LAYERS - SEC_PACK_LAYERS - SEC_CHIP_LAYERS + LAYER_C4;
+		subidx = nl - SEC_PACK_LAYERS + LAYER_SUB;
+		solderidx = nl - SEC_PACK_LAYERS + LAYER_SOLDER;
+		pcbidx = nl - SEC_PACK_LAYERS + LAYER_PCB;		
+	}
+	
+	/* for each grid cell	*/
+	for(n=0; n < nl; n++)
+		for(i=0; i < nr; i++)
+			for(j=0; j < nc; j++) {
+				if (n==LAYER_SI && model_secondary) { //top silicon layer
+					psum = NP(l,v,n,i,j,nl,nr,nc) + SP(l,v,n,i,j,nl,nr,nc) + 
+					   EP(l,v,n,i,j,nl,nr,nc) + WP(l,v,n,i,j,nl,nr,nc) + 
+					   ((A3D(v,metalidx,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[metalidx].rz) +
+					   ((A3D(v,n+1,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].rz);
+				} else if (n==spidx && model_secondary) { //spreader layer
+					psum = NP(l,v,n,i,j,nl,nr,nc) + SP(l,v,n,i,j,nl,nr,nc) + 
+					   EP(l,v,n,i,j,nl,nr,nc) + WP(l,v,n,i,j,nl,nr,nc) + 
+					   ((A3D(v,metalidx-1,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[metalidx-1].rz) +
+					   ((A3D(v,hsidx,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].rz);
+				} else if (n==metalidx && model_secondary) { //metal layer
+					psum = NP(l,v,n,i,j,nl,nr,nc) + SP(l,v,n,i,j,nl,nr,nc) + 
+					   EP(l,v,n,i,j,nl,nr,nc) + WP(l,v,n,i,j,nl,nr,nc) + 
+					   ((A3D(v,c4idx,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[c4idx].rz) +
+					   ((A3D(v,LAYER_SI,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].rz);
+				} else if (n==metalidx-1 && model_secondary) { // TIM layer
+					psum = NP(l,v,n,i,j,nl,nr,nc) + SP(l,v,n,i,j,nl,nr,nc) + 
+					   EP(l,v,n,i,j,nl,nr,nc) + WP(l,v,n,i,j,nl,nr,nc) + 
+					   ((A3D(v,metalidx-2,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[metalidx-2].rz) +
+					   ((A3D(v,spidx,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].rz);
+				} else if (n==c4idx && model_secondary) { //C4 layer
+					psum = NP(l,v,n,i,j,nl,nr,nc) + SP(l,v,n,i,j,nl,nr,nc) + 
+					   EP(l,v,n,i,j,nl,nr,nc) + WP(l,v,n,i,j,nl,nr,nc) + 
+					   ((A3D(v,subidx,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[subidx].rz) +
+					   ((A3D(v,metalidx,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].rz);
+				} else if (n==subidx && model_secondary) { //Substrate layer
+					psum = NP(l,v,n,i,j,nl,nr,nc) + SP(l,v,n,i,j,nl,nr,nc) + 
+					   EP(l,v,n,i,j,nl,nr,nc) + WP(l,v,n,i,j,nl,nr,nc) + 
+					   ((A3D(v,solderidx,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[solderidx].rz) +
+					   ((A3D(v,c4idx,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].rz);
+				} else if (n==pcbidx && model_secondary) { //PCB layer
+					psum = NP(l,v,n,i,j,nl,nr,nc) + SP(l,v,n,i,j,nl,nr,nc) + 
+					   EP(l,v,n,i,j,nl,nr,nc) + WP(l,v,n,i,j,nl,nr,nc) + 
+					   ((A3D(v,solderidx,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].rz);
+				} else if (n==hsidx && model_secondary) { // heatsink layer
+					psum = NP(l,v,n,i,j,nl,nr,nc) + SP(l,v,n,i,j,nl,nr,nc) + 
+					   EP(l,v,n,i,j,nl,nr,nc) + WP(l,v,n,i,j,nl,nr,nc) + 
+					   ((A3D(v,spidx,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[spidx].rz);
+				} else {
+					/* sum the currents(power values) to cells north, south, 
+				 	* east, west, above and below
+				 	*/
+					psum = NP(l,v,n,i,j,nl,nr,nc) + SP(l,v,n,i,j,nl,nr,nc) + 
+					   EP(l,v,n,i,j,nl,nr,nc) + WP(l,v,n,i,j,nl,nr,nc) + 
+					   AP(l,v,n,i,j,nl,nr,nc) + BP(l,v,n,i,j,nl,nr,nc);
+				}
+
+				/* spreader core is connected to its periphery	*/
+				if (n == spidx) {
+					/* northern boundary - edge cell has half the ry	*/
+					if (i == 0)
+						psum += (x[SP_N] - A3D(v,n,i,j,nl,nr,nc))/(l[n].ry/2.0 + nc*model->pack.r_sp1_y); 
+					/* southern boundary - edge cell has half the ry	*/
+					if (i == nr-1)
+						psum += (x[SP_S] - A3D(v,n,i,j,nl,nr,nc))/(l[n].ry/2.0 + nc*model->pack.r_sp1_y); 
+					/* eastern boundary	 - edge cell has half the rx	*/
+					if (j == nc-1)
+						psum += (x[SP_E] - A3D(v,n,i,j,nl,nr,nc))/(l[n].rx/2.0 + nr*model->pack.r_sp1_x); 
+					/* western boundary	 - edge cell has half the rx	*/
+					if (j == 0)
+						psum += (x[SP_W] - A3D(v,n,i,j,nl,nr,nc))/(l[n].rx/2.0 + nr*model->pack.r_sp1_x); 
+				/* heatsink core is connected to its inner periphery and ambient	*/
+				} else if (n == hsidx) {
+					/* all nodes are connected to the ambient	*/
+					psum += (c->ambient - A3D(v,n,i,j,nl,nr,nc))/l[n].rz;
+					/* northern boundary - edge cell has half the ry	*/
+					if (i == 0)
+						psum += (x[SINK_C_N] - A3D(v,n,i,j,nl,nr,nc))/(l[n].ry/2.0 + nc*model->pack.r_hs1_y); 
+					/* southern boundary - edge cell has half the ry	*/
+					if (i == nr-1)
+						psum += (x[SINK_C_S] - A3D(v,n,i,j,nl,nr,nc))/(l[n].ry/2.0 + nc*model->pack.r_hs1_y); 
+					/* eastern boundary	 - edge cell has half the rx	*/
+					if (j == nc-1)
+						psum += (x[SINK_C_E] - A3D(v,n,i,j,nl,nr,nc))/(l[n].rx/2.0 + nr*model->pack.r_hs1_x); 
+					/* western boundary	 - edge cell has half the rx	*/
+					if (j == 0)
+						psum += (x[SINK_C_W] - A3D(v,n,i,j,nl,nr,nc))/(l[n].rx/2.0 + nr*model->pack.r_hs1_x); 
+				}	else if (n == pcbidx && model->config.model_secondary) {
+					/* all nodes are connected to the ambient	*/
+					psum += (c->ambient - A3D(v,n,i,j,nl,nr,nc))/(model->config.r_convec_sec * 
+								   (model->config.s_pcb * model->config.s_pcb) / (cw * ch));
+					/* northern boundary - edge cell has half the ry	*/
+					if (i == 0)
+						psum += (x[PCB_C_N] - A3D(v,n,i,j,nl,nr,nc))/(l[n].ry/2.0 + nc*model->pack.r_pcb1_y); 
+					/* southern boundary - edge cell has half the ry	*/
+					if (i == nr-1)
+						psum += (x[PCB_C_S] - A3D(v,n,i,j,nl,nr,nc))/(l[n].ry/2.0 + nc*model->pack.r_pcb1_y); 
+					/* eastern boundary	 - edge cell has half the rx	*/
+					if (j == nc-1)
+						psum += (x[PCB_C_E] - A3D(v,n,i,j,nl,nr,nc))/(l[n].rx/2.0 + nr*model->pack.r_pcb1_x); 
+					/* western boundary	 - edge cell has half the rx	*/
+					if (j == 0)
+						psum += (x[PCB_C_W] - A3D(v,n,i,j,nl,nr,nc))/(l[n].rx/2.0 + nr*model->pack.r_pcb1_x); 
+				}	else if (n == subidx && model->config.model_secondary) {
+					/* northern boundary - edge cell has half the ry	*/
+					if (i == 0)
+						psum += (x[SUB_N] - A3D(v,n,i,j,nl,nr,nc))/(l[n].ry/2.0 + nc*model->pack.r_sub1_y); 
+					/* southern boundary - edge cell has half the ry	*/
+					if (i == nr-1)
+						psum += (x[SUB_S] - A3D(v,n,i,j,nl,nr,nc))/(l[n].ry/2.0 + nc*model->pack.r_sub1_y); 
+					/* eastern boundary	 - edge cell has half the rx	*/
+					if (j == nc-1)
+						psum += (x[SUB_E] - A3D(v,n,i,j,nl,nr,nc))/(l[n].rx/2.0 + nr*model->pack.r_sub1_x); 
+					/* western boundary	 - edge cell has half the rx	*/
+					if (j == 0)
+						psum += (x[SUB_W] - A3D(v,n,i,j,nl,nr,nc))/(l[n].rx/2.0 + nr*model->pack.r_sub1_x); 
+				}	else if (n == solderidx && model->config.model_secondary) {
+					/* northern boundary - edge cell has half the ry	*/
+					if (i == 0)
+						psum += (x[SOLDER_N] - A3D(v,n,i,j,nl,nr,nc))/(l[n].ry/2.0 + nc*model->pack.r_solder1_y); 
+					/* southern boundary - edge cell has half the ry	*/
+					if (i == nr-1)
+						psum += (x[SOLDER_S] - A3D(v,n,i,j,nl,nr,nc))/(l[n].ry/2.0 + nc*model->pack.r_solder1_y); 
+					/* eastern boundary	 - edge cell has half the rx	*/
+					if (j == nc-1)
+						psum += (x[SOLDER_E] - A3D(v,n,i,j,nl,nr,nc))/(l[n].rx/2.0 + nr*model->pack.r_solder1_x); 
+					/* western boundary	 - edge cell has half the rx	*/
+					if (j == 0)
+						psum += (x[SOLDER_W] - A3D(v,n,i,j,nl,nr,nc))/(l[n].rx/2.0 + nr*model->pack.r_solder1_x); 
+				}
+
+				/* update the current cell's temperature	*/	   
+				A3D(dv,n,i,j,nl,nr,nc) = (p->cuboid[n][i][j] + psum) / l[n].c;
+			}
+	slope_fn_pack(model, v, p, dv);
+}
+
+void compute_temp_grid(grid_model_t *model, double *power, double *temp, double time_elapsed)
+{
+	double t, h, new_h;
+	int extra_nodes;
+	grid_model_vector_t *p;
+	#if VERBOSE > 1
+	//unsigned int i = 0;
+	#endif
+	
+	if (model->config.model_secondary)
+		extra_nodes = EXTRA + EXTRA_SEC;
+	else
+		extra_nodes = EXTRA;
+	
+	if (!model->r_ready || !model->c_ready)
+		fatal((char*)"grid model not ready\n");
+
+	p = new_grid_model_vector(model);
+
+	/* package nodes' power numbers	*/
+	set_internal_power_grid(model, power);
+
+	/* map the block power/temp numbers to the grid	*/
+	xlate_vector_b2g(model, power, p, V_POWER);
+
+	/* if temp is NULL, re-use the temperature from the
+	 * last call. otherwise, translate afresh and remember 
+	 * the grid and block temperature arrays for future use
+	 */
+	if (temp != NULL) {
+		xlate_vector_b2g(model, temp, model->last_trans, V_TEMP);
+		model->last_temp = temp;
+	}	
+
+	/* Obtain temp at time (t+time_elapsed). 
+	 * Instead of getting the temperature at t+time_elapsed directly, we
+	 * do it in multiple steps with the correct step size at each time 
+	 * provided by rk4. 
+	 */
+	for (t = 0, new_h = MIN_STEP; t < time_elapsed && new_h >= MIN_STEP*DELTA; t+=h) {
+		h = new_h;
+		/* pass the entire grid and the tail of package nodes 
+		 * as a 1-d array
+		 */
+		new_h = rk4(model, model->last_trans->cuboid[0][0],  p, 
+				 /* array size = grid size + EXTRA	*/
+				 model->rows * model->cols * model->n_layers + extra_nodes, &h,
+				 model->last_trans->cuboid[0][0], 
+				 /* the slope function callback is typecast accordingly */
+				 (slope_fn_ptr) slope_fn_grid);
+		new_h = MIN(new_h, time_elapsed-t-h);
+		#if VERBOSE > 1
+			//i++;
+		#endif	
+	}
+
+	#if VERBOSE > 1
+	//fprintf(stdout, "no. of rk4 calls during compute_temp: %d\n", i+1);
+	#endif
+
+	/* map the temperature numbers back	*/
+	xlate_temp_g2b(model, model->last_temp, model->last_trans);
+
+	free_grid_model_vector(p);
+}
+
+/* debug print	*/
+void debug_print_blist(blist_t *head, flp_t *flp)
+{
+	blist_t *ptr;
+	fprintf(stdout, "printing blist information...\n");
+	for(ptr = head; ptr; ptr = ptr->next) {
+		fprintf(stdout, "unit: %s\n", flp->units[ptr->idx].name);
+		fprintf(stdout, "occupancy: %f\n", ptr->occupancy);
+	}
+}
+
+void debug_print_glist(glist_t *array, flp_t *flp)
+{
+	int i;
+	fprintf(stdout, "printing glist information...\n");
+	for(i=0; i < flp->n_units; i++)
+		fprintf(stdout, "unit: %s\tstartx: %d\tendx: %d\tstarty: %d\tendy: %d\n",
+				flp->units[i].name, array[i].j1, array[i].j2, array[i].i1, array[i].i2);
+}
+
+void debug_print_layer(grid_model_t *model, layer_t *layer)
+{
+	int i, j;
+	fprintf(stdout, "printing layer information...\n");
+	fprintf(stdout, "no: %d\n", layer->no);
+	fprintf(stdout, "has_lateral: %d\n", layer->has_lateral);
+	fprintf(stdout, "has_power: %d\n", layer->has_power);
+	fprintf(stdout, "k: %f\n", layer->k);
+	fprintf(stdout, "thickness: %f\n", layer->thickness);
+	fprintf(stdout, "sp: %f\n", layer->sp);
+	fprintf(stdout, "rx: %f\try: %f\trz: %f\tc: %f\n", 
+			layer->rx, layer->ry, layer->rz, layer->c);
+
+	fprintf(stdout, "printing b2gmap information...\n");
+	for(i=0; i < model->rows; i++)
+		for(j=0; j < model->cols; j++) {
+			fprintf(stdout, "row: %d, col: %d\n", i, j);
+			debug_print_blist(layer->b2gmap[i][j], layer->flp);
+		}
+
+	fprintf(stdout, "printing g2bmap information...\n");
+	debug_print_glist(layer->g2bmap, layer->flp);
+}
+
+void debug_print_grid_model_vector(grid_model_t *model, grid_model_vector_t *v, int nl, int nr, int nc)
+{
+	int n;
+	int extra_nodes;
+	
+	if (model->config.model_secondary)
+		extra_nodes = EXTRA + EXTRA_SEC;
+	else
+		extra_nodes = EXTRA;
+
+	fprintf(stdout, "printing cuboid information...\n");
+	for(n=0; n < nl; n++)
+		dump_dmatrix(v->cuboid[n], nr, nc);
+	fprintf(stdout, "printing extra information...\n");
+	dump_dvector(v->extra, extra_nodes);
+}
+
+void debug_print_grid(grid_model_t *model)
+{
+	int i;
+	int extra_nodes;
+	
+	if (model->config.model_secondary)
+		extra_nodes = EXTRA + EXTRA_SEC;
+	else
+		extra_nodes = EXTRA;
+		
+	fprintf(stdout, "printing grid model information...\n");
+	fprintf(stdout, "rows: %d\n", model->rows);
+	fprintf(stdout, "cols: %d\n", model->cols);
+	fprintf(stdout, "width: %f\n", model->width);
+	fprintf(stdout, "height: %f\n", model->height);
+
+	debug_print_package_RC(&model->pack);
+
+	fprintf(stdout, "total_n_blocks: %d\n", model->total_n_blocks);
+	fprintf(stdout, "map_mode: %d\n", model->map_mode);
+	fprintf(stdout, "r_ready: %d\n", model->r_ready);
+	fprintf(stdout, "c_ready: %d\n", model->c_ready);
+	fprintf(stdout, "has_lcf: %d\n", model->has_lcf);
+
+	fprintf(stdout, "printing last_steady information...\n");
+	debug_print_grid_model_vector(model, model->last_steady, model->n_layers, 
+								  model->rows, model->cols);
+
+	fprintf(stdout, "printing last_trans information...\n");
+	debug_print_grid_model_vector(model, model->last_trans, model->n_layers,
+								  model->rows, model->cols);
+
+	fprintf(stdout, "printing last_temp information...\n");
+	if (model->last_temp)
+		dump_dvector(model->last_temp, model->total_n_blocks + extra_nodes);
+	else
+		fprintf(stdout, "(null)\n");
+
+	for(i=0; i < model->n_layers; i++)
+		debug_print_layer(model, &model->layers[i]);
+
+	fprintf(stdout, "base_n_units: %d\n", model->base_n_units);
+}
+
diff -Naur temp/temperature_mobile.c HotSpot/temperature_mobile.c
--- temp/temperature_mobile.c	2017-11-20 10:04:24.521682846 +0100
+++ HotSpot/temperature_mobile.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1643 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#ifdef _MSC_VER
-#define strcasecmp    _stricmp
-#define strncasecmp   _strnicmp
-#else
-#include <strings.h>
-#endif
-#include <math.h>
-
-#include "temperature_mobile.h"
-#include "flp.h"
-#include "util.h"
-
-/* constructors	*/
-blist_t *new_blist(int idx, double occupancy)
-{
-	blist_t *ptr = (blist_t *) calloc (1, sizeof(blist_t));
-	if (!ptr)
-		fatal("memory allocation error\n");
-	ptr->idx = idx;
-	ptr->occupancy = occupancy;
-	ptr->next = NULL;
-	return ptr;
-}
-
-blist_t ***new_b2gmap(int rows, int cols)
-{
-	int i;
-	blist_t ***b2gmap;
-
-	b2gmap = (blist_t ***) calloc (rows, sizeof(blist_t **));
-	b2gmap[0] = (blist_t **) calloc (rows * cols, sizeof(blist_t *));
-	if (!b2gmap || !b2gmap[0])
-		fatal("memory allocation error\n");
-
-	for(i=1; i < rows; i++) 
-		b2gmap[i] = b2gmap[0] + cols * i;
-
-	return b2gmap;	
-}
-
-/* destructor	*/
-void delete_b2gmap(blist_t ***b2gmap, int rows, int cols)
-{
-	int i, j;
-	blist_t *ptr, *temp;
-
-	/* free the linked list	*/
-	for(i=0; i < rows; i++)
-		for(j=0; j < cols; j++) {
-			ptr = b2gmap[i][j];
-			while(ptr) {
-				temp = ptr->next;
-				free(ptr);
-				ptr = temp;
-			}
-		}
-
-	/* free the array space	*/
-	free(b2gmap[0]);
-	free(b2gmap);
-}
-
-/* re-initialize */
-void reset_b2gmap(grid_model_t *model, layer_t *layer)
-{
-	int i, j;
-	blist_t *ptr, *temp;
-
-	/* free the linked list	*/
-	for(i=0; i < model->rows; i++)
-		for(j=0; j < model->cols; j++) {
-			ptr = layer->b2gmap[i][j];
-			while(ptr) {
-				temp = ptr->next;
-				free(ptr);
-				ptr = temp;
-			}
-			layer->b2gmap[i][j] = NULL;
-		}
-}
-
-/* create a linked list node and append it at the end	*/
-void blist_append(blist_t *head, int idx, double occupancy)
-{
-	blist_t *tail = NULL;
-	
-	if(!head)
-		fatal("blist_append called with empty list\n");
-
-	/* traverse till the end	*/
-	for(; head; head = head->next)
-		tail = head;
-
-	/* append */
-	tail->next =  new_blist(idx, occupancy);
-}
-
-/* compute the power/temperature average weighted by occupancies	*/
-double blist_avg(blist_t *ptr, flp_t *flp, double *v, int type)
-{
-	double  val = 0.0;
-	
-	for(; ptr; ptr = ptr->next) {
-		if (type == V_POWER)
-			val += ptr->occupancy * v[ptr->idx] / (flp->units[ptr->idx].width * 
-				   flp->units[ptr->idx].height);
-		else if (type == V_TEMP)		   
-			val += ptr->occupancy * v[ptr->idx];
-		else
-			fatal("unknown vector type\n");
-	}		
-
-	return val;		   
-}
-
-void debug_print_blist(blist_t *head, flp_t *flp);
-/* test the block-grid map data structure	*/
-void test_b2gmap(grid_model_t *model, layer_t *layer)
-{
-	int i, j;
-	blist_t *ptr;
-	double sum;
-
-	/* a correctly formed b2gmap should have the 
-	 * sum of occupancies in each linked list
-	 * to be equal to 1.0
-	 */
-	for (i=0; i < model->rows; i++)
-		for(j=0; j < model->cols; j++) {
-			sum = 0.0;
-			for(ptr = layer->b2gmap[i][j]; ptr; ptr = ptr->next)
-				sum += ptr->occupancy;
-			if (!eq(floor(sum*1e5 + 0.5)/1e5, 1.0)) {
-				fprintf(stdout, "i: %d\tj: %d\n", i, j);
-				debug_print_blist(layer->b2gmap[i][j], layer->flp);
-				fatal("erroneous b2gmap data structure. invalid floorplan?\n");
-			}	
-		}
-}
-
-/* setup the block and grid mapping data structures	*/
-void set_bgmap(grid_model_t *model, layer_t *layer)
-{
-	/* i1, i2, j1 and j2 are indices of the boundary grid cells	*/
-	int i, j, u, i1, i2, j1, j2;
-
-	/* shortcuts for cell width(cw) and cell height(ch)	*/
-	double cw = model->width / model->cols;
-	double ch = model->height / model->rows;
-
-	/* initialize	*/
-	reset_b2gmap(model, layer);
-
-	/* for each functional unit	*/
-	for(u=0; u < layer->flp->n_units; u++) {
-		/* shortcuts for unit boundaries	*/
-		double lu = layer->flp->units[u].leftx;
-		double ru = lu + layer->flp->units[u].width;
-		double bu = layer->flp->units[u].bottomy;
-		double tu = bu + layer->flp->units[u].height;
-
-		/* top index (lesser row) = rows - ceil (topy / cell height)	*/
-		i1 = model->rows - tolerant_ceil(tu/ch);
-		/* bottom index (greater row) = rows - floor (bottomy / cell height)	*/
-		i2 = model->rows - tolerant_floor(bu/ch);
-		/* left index = floor (leftx / cell width)	*/
-		j1 = tolerant_floor(lu/cw);
-		/* right index = ceil (rightx / cell width)	*/
-		j2 = tolerant_ceil(ru/cw);
-		/* sanity check	*/
-		if((i1 < 0) || (j1 < 0))
-			fatal("negative grid cell start index!\n");
-		if((i2 > model->rows) || (j2 > model->cols))
-			fatal("grid cell end index out of bounds!\n");
-		if((i1 >= i2) || (j1 >= j2))
-			fatal("invalid floorplan spec or grid resolution\n");
-
-		/* setup g2bmap	*/
-		layer->g2bmap[u].i1 = i1;
-		layer->g2bmap[u].i2 = i2;
-		layer->g2bmap[u].j1 = j1;
-		layer->g2bmap[u].j2 = j2;
-
-		/* setup b2gmap	*/
-		/* for each grid cell in this unit	*/
-		for(i=i1; i < i2; i++)
-			for(j=j1; j < j2; j++)
-				/* grid cells fully overlapped by this unit	*/
-				if ((i > i1) && (i < i2-1) && (j > j1) && (j < j2-1)) {
-					/* first unit in the list	*/
-					if (!layer->b2gmap[i][j])
-						layer->b2gmap[i][j] = new_blist(u, 1.0);
-					else {
-					/* this should not occur since the grid cell is 
-					 * fully covered and hence, no other unit should 
-					 * be sharing it
-					 */
-						blist_append(layer->b2gmap[i][j], u, 1.0);
-						warning("overlap of functional blocks?\n");
-					}
-				/* boundary grid cells partially overlapped by this unit	*/
-				} else {
-					/* shortcuts for cell boundaries	*/
-					double lc = j * cw, rc = (j+1) * cw;
-					double tc = model->height - i * ch;
-					double bc = model->height - (i+1) * ch;
-					
-					/* shortcuts for overlap width and height	*/
-					double oh = (MIN(tu, tc) - MAX(bu, bc));
-					double ow = (MIN(ru, rc) - MAX(lu, lc));
-					double occupancy;
-			
-					/* overlap tolerance	*/
-					if (eq(oh/ch, 0))
-						oh = 0;
-					else if (eq(oh/ch, 1))
-						oh = ch;
-
-					if (eq(ow/cw, 0))
-						ow = 0;
-					else if (eq(ow/cw, 1))
-						ow = cw;
-
-					occupancy = (oh * ow) / (ch * cw);
-					if (oh < 0 || ow < 0)
-						fatal("negative overlap!\n");
-
-					/* first unit in the list	*/
-					if (!layer->b2gmap[i][j])
-						layer->b2gmap[i][j] = new_blist(u, occupancy);
-					else
-					/* append at the end	*/
-						blist_append(layer->b2gmap[i][j], u, occupancy);
-				}
-	}
-
-	/* 
-	 * sanity check	
-	test_b2gmap(model, layer);
-	 */
-}
-
-/* populate default set of layers	*/ 
-void populate_default_layers(grid_model_t *model, flp_t *flp_default)
-{
-	/* silicon	*/
-	model->layers[LAYER_SI].no = LAYER_SI;
-	model->layers[LAYER_SI].has_lateral = TRUE;
-	model->layers[LAYER_SI].has_power = TRUE;
-	model->layers[LAYER_SI].k = model->config.k_chip;
-	model->layers[LAYER_SI].thickness = model->config.t_chip;
-	model->layers[LAYER_SI].sp = model->config.p_chip;
-	model->layers[LAYER_SI].flp = flp_default;
-	model->layers[LAYER_SI].b2gmap = new_b2gmap(model->rows, model->cols);
-	model->layers[LAYER_SI].g2bmap = (glist_t *) calloc(flp_default->n_units, sizeof(glist_t));
-	if (!model->layers[LAYER_SI].g2bmap)
-		fatal("memory allocation error\n");
-
-	/* interface material	*/
-	model->layers[LAYER_INT].no = LAYER_INT;
-	model->layers[LAYER_INT].has_lateral = TRUE;
-	model->layers[LAYER_INT].has_power = FALSE;
-	model->layers[LAYER_INT].k = model->config.k_interface;
-	model->layers[LAYER_INT].thickness = model->config.t_interface;
-	model->layers[LAYER_INT].sp = model->config.p_interface;
-	model->layers[LAYER_INT].flp = flp_default;
-	model->layers[LAYER_INT].b2gmap = model->layers[LAYER_SI].b2gmap;
-	model->layers[LAYER_INT].g2bmap = model->layers[LAYER_SI].g2bmap;
-}
-
-/* parse the layer file open for reading	*/
-void parse_layer_file(grid_model_t *model, FILE *fp)
-{
-	char line[LINE_SIZE], *ptr, cval;
-	int count, i = 0, field = LCF_SNO, ival;
-	double dval;
-
-	fseek(fp, 0, SEEK_SET);
-	count = 0;
-	while (!feof(fp) && count < (model->n_layers * LCF_NPARAMS)) {
-		fgets(line, LINE_SIZE, fp);
-		if (feof(fp))
-			break;
-
-		/* ignore comments and empty lines	*/
-		ptr = strtok(line, " \r\t\n");
-		if (!ptr || ptr[0] == '#')
-			continue;
-			
-		switch (field) 
-		{
-			case LCF_SNO:
-						if (sscanf(ptr, "%d", &ival) != 1)
-							fatal("invalid layer number\n");
-						if(ival >= model->n_layers || ival < 0)
-							fatal("layer number must be >= 0 and < no. of layers\n");
-						if (model->layers[ival].no != 0)
-							fatal("layer numbers must be unique\n");
-						i = ival;
-						model->layers[i].no = ival;
-						break;
-			case LCF_LATERAL:
-						if (sscanf(ptr, "%c", &cval) != 1)
-							fatal("invalid layer heat flow indicator\n");
-						if (cval == 'Y' || cval == 'y')
-							model->layers[i].has_lateral = TRUE;
-						else if (cval == 'N' || cval == 'n')			
-							model->layers[i].has_lateral = FALSE;
-						else			
-							fatal("invalid layer heat flow indicator\n");
-						break;
-			case LCF_POWER:
-						if (sscanf(ptr, "%c", &cval) != 1)
-							fatal("invalid layer power dissipation indicator\n");
-						if (cval == 'Y' || cval == 'y')
-							model->layers[i].has_power = TRUE;
-						else if (cval == 'N' || cval == 'n')			
-							model->layers[i].has_power = FALSE;
-						else			
-							fatal("invalid layer power dissipation indicator\n");
-						break;
-			case LCF_SP:
-						if (sscanf(ptr, "%lf", &dval) != 1)
-							fatal("invalid specific heat\n");
-						model->layers[i].sp = dval;
-						break;
-			case LCF_RHO:
-						if (sscanf(ptr, "%lf", &dval) != 1)
-							fatal("invalid resistivity\n");
-						model->layers[i].k = 1.0 / dval;
-						break;
-			case LCF_THICK:
-						if (sscanf(ptr, "%lf", &dval) != 1)
-							fatal("invalid thickness\n");
-						model->layers[i].thickness = dval;
-						break;
-			case LCF_FLP:
-						model->layers[i].flp = read_flp(ptr, FALSE);
-						/* first layer	*/
-						if (count < LCF_NPARAMS) {
-							model->width = get_total_width(model->layers[i].flp);
-							model->height = get_total_height(model->layers[i].flp);
-						} else if(!eq(model->width, get_total_width(model->layers[i].flp)) || 
-								  !eq(model->height, get_total_height(model->layers[i].flp)))
-							fatal("width and height differ across layers\n");
-						break;
-			default:
-						fatal("invalid field id\n");
-						break;
-		}
-		field = (field + 1) % LCF_NPARAMS;
-		count++;
-	}
-
-	/* allocate the block-grid maps */
-	for(i=0; i < model->n_layers; i++) {
-		model->layers[i].b2gmap = new_b2gmap(model->rows, model->cols);
-		model->layers[i].g2bmap = (glist_t *) calloc(model->layers[i].flp->n_units, 
-								   sizeof(glist_t));
-		if (!model->layers[i].g2bmap)
-			fatal("memory allocation error\n");
-	}
-}
-
-/* populate layer info either from the default floorplan or from
- * the layer configuration file (lcf)
- */
-void populate_layers_grid(grid_model_t *model, flp_t *flp_default)
-{
-	char str[STR_SIZE];
-	FILE *fp = NULL;
-
-	/* lcf file specified	*/
-	if (model->has_lcf) {
-		if (!strcasecmp(model->config.grid_layer_file, "stdin"))
-			fp = stdin;
-		else
-			fp = fopen (model->config.grid_layer_file, "r");
-		if (!fp) {
-			sprintf(str, "error opening file %s\n", model->config.grid_layer_file);
-			fatal(str);
-		}
-	}
-
-	/* compute the no. of layers	*/
-	if (model->has_lcf) {
-		model->n_layers = count_significant_lines(fp);
-		if (model->n_layers % LCF_NPARAMS)
-			fatal("wrong no. of lines in layer file\n");
-		model->n_layers /= LCF_NPARAMS;
-	/* default no. of layers when lcf file is not specified	*/	
-	} else
-		model->n_layers = DEFAULT_CHIP_LAYERS;
-
-	/* allocate initial memory */
-	model->layers = (layer_t *) calloc (model->n_layers, sizeof(layer_t));
-	if (!model->layers)
-		fatal("memory allocation error\n");
-
-	/* read in values from the lcf when specified	*/
-	if (model->has_lcf) {
-		parse_layer_file(model, fp);
-		warning("layer configuration file specified. overriding default floorplan with those in lcf file\n");
-	/* default set of layers	*/
-	} else
-		populate_default_layers(model, flp_default);
-	
-	if (model->has_lcf && fp != stdin)
-		fclose(fp);
-}
-
-/* constructor	*/ 
-grid_model_t *alloc_grid_model(thermal_config_t *config, flp_t *flp_default)
-{
-	int i;
-	grid_model_t *model;
-
-	if (config->grid_rows & (config->grid_rows-1) ||
-		config->grid_cols & (config->grid_cols-1))
-		fatal("grid rows and columns should both be powers of two\n");
-
-	model = (grid_model_t *) calloc (1, sizeof(grid_model_t));
-	if (!model)
-		fatal("memory allocation error\n");
-	model->config = *config;
-	model->rows = config->grid_rows;
-	model->cols = config->grid_cols;
-
-	if(!strcasecmp(model->config.grid_map_mode, GRID_AVG_STR))
-		model->map_mode = GRID_AVG;
-	else if(!strcasecmp(model->config.grid_map_mode, GRID_MIN_STR))
-		model->map_mode = GRID_MIN;
-	else if(!strcasecmp(model->config.grid_map_mode, GRID_MAX_STR))
-		model->map_mode = GRID_MAX;
-	else if(!strcasecmp(model->config.grid_map_mode, GRID_CENTER_STR))
-		model->map_mode = GRID_CENTER;
-	else
-		fatal("unknown mapping mode\n");
-
-	/* layer configuration file specified?	*/
-	if(strcmp(model->config.grid_layer_file, NULLFILE))
-		model->has_lcf = TRUE;
-	else {
-		model->has_lcf = FALSE;
-		model->base_n_units = flp_default->n_units;
-	}
-
-	/* get layer information	*/
-	populate_layers_grid(model, flp_default);
-
-	/* count the total no. of blocks */
-	model->total_n_blocks = 0;
-	for(i=0; i < model->n_layers; i++)
-		model->total_n_blocks += model->layers[i].flp->n_units;
-
-	/* allocate internal state	*/
-	model->last_steady = new_grid_model_vector(model);
-	model->last_trans = new_grid_model_vector(model);
-
-	return model;
-}
-
-void populate_R_model_grid(grid_model_t *model, flp_t *flp)
-{
-	int i;
-	double cw, ch;
-
-	/* setup the block-grid maps; flp parameter is ignored */
-	if (model->has_lcf)
-		for(i=0; i < model->n_layers; i++)
-			set_bgmap(model, &model->layers[i]);
-	/* only the silicon layer has allocated space for the maps. 
-	 * all the rest just point to it. so it is sufficient to
-	 * setup the block-grid map for the silicon layer alone.
-	 * further, for default layer configuration, the `flp' 
-	 * parameter should be the same as that of the silicon 
-	 * layer. finally, the chip width and height information 
-	 * need to be populated for default layer configuration
-	 */
-	else {
-		if (flp != model->layers[LAYER_SI].flp)
-			fatal("mismatch between the floorplan and the thermal model\n");
-		model->width = get_total_width(flp);
-		model->height = get_total_height(flp);
-		set_bgmap(model, &model->layers[LAYER_SI]);
-	}
-
-	/* shortcuts for cell width(cw) and cell height(ch)	*/
-	cw = model->width / model->cols;
-	ch = model->height / model->rows;
-
-	/* layer specific resistances	*/
-	for(i=0; i < model->n_layers; i++) {
-		if (model->layers[i].has_lateral) {
-			model->layers[i].rx =  getr(model->layers[i].k, cw, ch * model->layers[i].thickness);
-			model->layers[i].ry =  getr(model->layers[i].k, ch, cw * model->layers[i].thickness);
-		} else {
-			/* positive infinity	*/
-			model->layers[i].rx = LARGENUM;
-			model->layers[i].ry = LARGENUM;
-		}
-		model->layers[i].rz =  getr(model->layers[i].k, model->layers[i].thickness, cw * ch);
-		/* last layer is connected to ambient. divide r_convec proportional to cell area */
-		if (i == model->n_layers - 1)
-			model->layers[i].rz += model->config.r_convec * 
-								   (model->width * model->height) / (cw * ch);
-	}
-
-	/* done	*/
-	model->r_ready = TRUE;
-}
-
-void populate_C_model_grid(grid_model_t *model, flp_t *flp)
-{
-	int i;
-
-	/* shortcuts for cell width(cw) and cell height(ch)	*/
-	double cw = model->width / model->cols;
-	double ch = model->height / model->rows;
-
-	if (!model->r_ready)
-		fatal("R model not ready\n");
-	if (!model->has_lcf && flp != model->layers[LAYER_SI].flp)
-		fatal("different floorplans for R and C models!\n");
-
-	/* layer specific capacitances	*/
-	for(i=0; i < model->n_layers; i++)
-		model->layers[i].c =  getcap(model->layers[i].sp, model->layers[i].thickness, cw * ch);
-
-	/* last layer is connected to the ambient. 
-	 * divide c_convec proportional to cell area 
-	 */
-	model->layers[model->n_layers-1].c += C_FACTOR * model->config.c_convec * (cw * ch) /
-										  (model->width * model->height);
-
-	/* done	*/	
-	model->c_ready = TRUE;
-}
-
-/* destructor	*/
-void delete_grid_model(grid_model_t *model)
-{
-	int i;
-
-	if (model->has_lcf) 
-		for(i=0; i < model->n_layers; i++) {
-			delete_b2gmap(model->layers[i].b2gmap, model->rows, model->cols);
-			free(model->layers[i].g2bmap);
-			free_flp(model->layers[i].flp, FALSE);
-		}
-	/* only the silicon layer has allocated space for the maps. 
-	 * all the rest just point to it. also, its floorplan was
-	 * allocated elsewhere. so, we don't need to deallocate those.
-	 */
-	else {
-		delete_b2gmap(model->layers[LAYER_SI].b2gmap, model->rows, model->cols);
-		free(model->layers[LAYER_SI].g2bmap);
-	}
-	
-	free_grid_model_vector(model->last_steady);
-	free_grid_model_vector(model->last_trans);
-	free(model->layers);
-	free(model);
-}
-
-/* differs from 'dvector()' in that memory for internal nodes is also allocated	*/
-double *hotspot_vector_grid(grid_model_t *model)
-{
-	if (model->total_n_blocks <= 0)
-		fatal("total_n_blocks is not greater than zero\n");
-	return dvector(model->total_n_blocks);
-}
-
-/* copy 'src' to 'dst' except for a window of 'size'
- * elements starting at 'at'. useful in floorplan
- * compaction. can be used only with default layer
- * configuration as all layers should have the same
- * floorplan. incompatible with layer configuration
- * file.
- */
-void trim_hotspot_vector_grid(grid_model_t *model, double *dst, double *src, 
-						 	  int at, int size)
-{
-	int i;
-	if (model->has_lcf)
-		fatal("trim_hotspot_vector_grid called with lcf file\n");
-	for (i=0; i < at && i < model->total_n_blocks; i++)
-		dst[i] = src[i];
-	for(i=at+size; i < model->total_n_blocks; i++)
-		dst[i-size] = src[i];
-}
-
-/* update the model corresponding to floorplan compaction	*/						 
-void resize_thermal_model_grid(grid_model_t *model, int n_units)
-{
-	int i;
-
-	if (model->has_lcf)
-		fatal("resize_thermal_model_grid called with lcf file\n");
-	if (n_units > model->base_n_units)
-		fatal("resizing grid model to more than the allocated space\n");
-
-	/* count the total no. of blocks again */
-	model->total_n_blocks = 0;
-	for(i=0; i < model->n_layers; i++)
-		model->total_n_blocks += model->layers[i].flp->n_units;
-
-	/* nothing more needs to be done because the only data structure
-	 * that is dependent on flp->n_units is g2bmap (others are
-	 * dependent on 'grid size' which does not change because
-	 * of resizing). g2bmap is a 1-d array and needs no reallocation
-	 */
-}
-
-/* sets the temperature of a vector 'temp' allocated using 'hotspot_vector'	*/
-void set_temp_grid(grid_model_t *model, double *temp, double val)
-{
-	int i;
-	if (model->total_n_blocks <= 0)
-		fatal("total_n_blocks is not greater than zero\n");
-	for(i=0; i < model->total_n_blocks; i++)
-		temp[i] = val;
-}
-
-/* dump the top layer grid temperatures of 'temp' onto 'file'	*/
-void dump_top_layer_temp_grid(grid_model_t *model, char *file, 
-							  grid_model_vector_t *temp)
-{
-	int i, j;
-	char str[STR_SIZE];
-	FILE *fp;
-
-	if (!model->r_ready)
-		fatal("R model not ready\n");
-
-	if (!strcasecmp(file, "stdout"))
-		fp = stdout;
-	else if (!strcasecmp(file, "stderr"))
-		fp = stderr;
-	else 	
-		fp = fopen (file, "w");
-
-	if (!fp) {
-		sprintf (str,"error: %s could not be opened for writing\n", file);
-		fatal(str);
-	}
-
-	for(i=0;  i < model->rows; i++)
-		for(j=0;  j < model->cols; j++)
-			fprintf(fp, "%d\t%.2f\n", i*model->cols+j, temp->cuboid[0][i][j]); 
-		
-	if(fp != stdout && fp != stderr)
-		fclose(fp);	
-}
-
-/* dump the steady state grid temperatures of the top layer onto 'file'	*/
-void dump_steady_temp_grid (grid_model_t *model, char *file)
-{
-	/* top layer of the most-recently computed steady state temperature	*/
-	dump_top_layer_temp_grid(model, file, model->last_steady);
-}
-
-/* dump temperature vector alloced using 'hotspot_vector' to 'file' */ 
-void dump_temp_grid(grid_model_t *model, double *temp, char *file)
-{
-	int i, n, base = 0;
-	char str[STR_SIZE];
-	FILE *fp;
-
-	if (!strcasecmp(file, "stdout"))
-		fp = stdout;
-	else if (!strcasecmp(file, "stderr"))
-		fp = stderr;
-	else 	
-		fp = fopen (file, "w");
-
-	if (!fp) {
-		sprintf (str,"error: %s could not be opened for writing\n", file);
-		fatal(str);
-	}
-
-	/* layer temperatures	*/
-	for(n=0; n < model->n_layers; n++) {
-		/* default set of layers	*/
-		if (!model->has_lcf) {
-			switch(n)
-			{
-				case LAYER_SI:
-						strcpy(str,"");
-						break;
-				case LAYER_INT:
-						strcpy(str,"iface_");
-						break;
-				default:
-						fatal("unknown layer\n");
-						break;
-			}
-		/* layer configuration file	*/
-		} else {
-			sprintf(str,"layer_%d_", n);
-		}
-
-		for(i=0; i < model->layers[n].flp->n_units; i++)
-			fprintf(fp, "%s%s\t%.2f\n", str, 
-					model->layers[n].flp->units[i].name, temp[base+i]);
-		base += model->layers[n].flp->n_units;	
-	}
-
-	if (base != model->total_n_blocks)
-		fatal("total_n_blocks failed to tally\n");
-
-	if(fp != stdout && fp != stderr)
-		fclose(fp);	
-}
-
-void copy_temp_grid(grid_model_t *model, double *dst, double *src)
-{
-	copy_dvector(dst, src, model->total_n_blocks);
-}
-
-/* 
- * read temperature vector alloced using 'hotspot_vector' from 'file'
- * which was dumped using 'dump_temp'. values are clipped to thermal
- * threshold based on 'clip'
- */ 
-void read_temp_grid(grid_model_t *model, double *temp, char *file, int clip)
-{
-	int i, n, idx, base = 0;
-	double max=0, val;
-	char *ptr, str1[LINE_SIZE], str2[LINE_SIZE];
-	char name[STR_SIZE], format[STR_SIZE];
-	FILE *fp;
-
-	if (!strcasecmp(file, "stdin"))
-		fp = stdin;
-	else
-		fp = fopen (file, "r");
-
-	if (!fp) {
-		sprintf (str1,"error: %s could not be opened for reading\n", file);
-		fatal(str1);
-	}	
-
-	/* temperatures of the different layers	*/
-	for (n=0; n < model->n_layers; n++) {
-		/* default set of layers	*/
-		if (!model->has_lcf) {
-			switch(n)
-			{
-				case LAYER_SI:
-						strcpy(format,"%s%lf");
-						break;
-				case LAYER_INT:
-						strcpy(format,"iface_%s%lf");
-						break;
-				default:
-						fatal("unknown layer\n");
-						break;
-			}
-		/* layer configuration file	*/
-		} else {
-			sprintf(format,"layer_%d_%%s%%lf", n);
-		}
-
-		for (i=0; i < model->layers[n].flp->n_units; i++) {
-			fgets(str1, LINE_SIZE, fp);
-			if (feof(fp))
-				fatal("not enough lines in temperature file\n");
-			strcpy(str2, str1);
-			/* ignore comments and empty lines	*/
-			ptr = strtok(str1, " \r\t\n");
-			if (!ptr || ptr[0] == '#') {
-				i--;
-				continue;
-			}
-			if (sscanf(str2, format, name, &val) != 2)
-				fatal("invalid temperature file format\n");
-			idx = get_blk_index(model->layers[n].flp, name);
-			if (idx >= 0)
-				temp[base+idx] = val;
-			else	/* since get_blk_index calls fatal, the line below cannot be reached	*/
-				fatal ("unit in temperature file not found in floorplan\n");
-
-			/* find max temp on the top layer 
-			 * (silicon for the default set of layers)
-			 */
-			if (n == 0 && temp[idx] > max)
-				max = temp[idx];
-		}
-		base += model->layers[n].flp->n_units;
-	}
-
-	if (base != model->total_n_blocks)
-		fatal("total_n_blocks failed to tally\n");
-
-	fgets(str1, LINE_SIZE, fp);
-	if (!feof(fp))
-		fatal("too many lines in temperature file\n");
-
-	if(fp != stdin)
-		fclose(fp);	
-
-	/* clipping	*/
-	if (clip && (max > model->config.thermal_threshold)) {
-		/* if max has to be brought down to thermal_threshold, 
-		 * (w.r.t the ambient) what is the scale down factor?
-		 */
-		double factor = (model->config.thermal_threshold - model->config.ambient) / 
-						(max - model->config.ambient);
-	
-		/* scale down all temperature differences (from ambient) by the same factor	*/
-		for (i=0; i < model->total_n_blocks; i++)
-			temp[i] = (temp[i]-model->config.ambient)*factor + model->config.ambient;
-	}
-}
-
-/* dump power numbers to file	*/
-void dump_power_grid(grid_model_t *model, double *power, char *file)
-{
-	int i, n, base = 0;
-	char str[STR_SIZE];
-	FILE *fp;
-
-	if (!strcasecmp(file, "stdout"))
-		fp = stdout;
-	else if (!strcasecmp(file, "stderr"))
-		fp = stderr;
-	else 	
-		fp = fopen (file, "w");
-	if (!fp) {
-		sprintf (str,"error: %s could not be opened for writing\n", file);
-		fatal(str);
-	}
-
-	/* dump values only for the layers dissipating power	*/
-	for(n=0; n < model->n_layers; n++) {
-		if (model->layers[n].has_power) {
-			for(i=0; i < model->layers[n].flp->n_units; i++)
-				if (model->has_lcf)
-					fprintf(fp, "layer_%d_%s\t%.3f\n", n, 
-							model->layers[n].flp->units[i].name, power[base+i]);
-				else 
-					fprintf(fp, "%s\t%.3f\n", 
-							model->layers[n].flp->units[i].name, power[base+i]);
-		}				
-		base += model->layers[n].flp->n_units;		
-	}
-
-	if(fp != stdout && fp != stderr)
-		fclose(fp);	
-}
-
-/* 
- * read power vector alloced using 'hotspot_vector' from 'file'
- * which was dumped using 'dump_power'. 
- */ 
-void read_power_grid (grid_model_t *model, double *power, char *file)
-{
-	int i, idx, n, base = 0;
-	double val;
-	char *ptr, str1[LINE_SIZE], str2[LINE_SIZE]; 
-	char name[STR_SIZE], format[STR_SIZE];
-	FILE *fp;
-
-	if (!strcasecmp(file, "stdin"))
-		fp = stdin;
-	else
-		fp = fopen (file, "r");
-	if (!fp) {
-		sprintf (str1,"error: %s could not be opened for reading\n", file);
-		fatal(str1);
-	}
-
-	/* lcf file could potentially specify more than one power dissipating 
-	 * layer. hence, units with zero power within a layer cannot be left
-	 * out in the power file.
-	 */
-	if (model->has_lcf) {
-		for(n=0; n < model->n_layers; n++) {
-			if (model->layers[n].has_power)
-				for(i=0; i < model->layers[n].flp->n_units; i++) {
-					fgets(str1, LINE_SIZE, fp);
-					if (feof(fp))
-						fatal("not enough lines in power file\n");
-					strcpy(str2, str1);
-
-					/* ignore comments and empty lines	*/
-					ptr = strtok(str1, " \r\t\n");
-					if (!ptr || ptr[0] == '#') {
-						i--;
-						continue;
-					}
-
-					sprintf(format, "layer_%d_%%s%%lf", n);
-		  			if (sscanf(str2, format, name, &val) != 2)
-						fatal("invalid power file format\n");
-		  			idx = get_blk_index(model->layers[n].flp, name);
-		  			if (idx >= 0)
-						power[base+idx] = val;
-					/* since get_blk_index calls fatal, the line below cannot be reached	*/
-		  			else
-						fatal ("unit in power file not found in floorplan\n");
-				}
-			base += model->layers[n].flp->n_units;	
-		}
-		fgets(str1, LINE_SIZE, fp);
-		if (!feof(fp))
-			fatal("too many lines in power file\n");
-	/* default layer configuration. so only one layer
-	 * has power dissipation. units with zero power 
-	 * can be omitted in the power file
-	 */
-	} else {
-		while(!feof(fp)) {
-			fgets(str1, LINE_SIZE, fp);
-			if (feof(fp))
-				break;
-			strcpy(str2, str1);
-	
-			/* ignore comments and empty lines	*/
-			ptr = strtok(str1, " \r\t\n");
-			if (!ptr || ptr[0] == '#')
-				continue;
-	
-			if (sscanf(str2, "%s%lf", name, &val) != 2)
-				fatal("invalid power file format\n");
-			idx = get_blk_index(model->layers[LAYER_SI].flp, name);
-			if (idx >= 0)
-				power[idx] = val;
-			else	/* since get_blk_index calls fatal, the line below cannot be reached	*/
-				fatal ("unit in power file not found in floorplan\n");
-		}
-	}
-
-	if(fp != stdin)
-		fclose(fp);
-}
-
-double find_max_temp_grid(grid_model_t *model, double *temp)
-{
-	int i;
-	double max = 0.0;
-	/* max temperature occurs on the top-most layer	*/
-	for(i=0; i < model->layers[0].flp->n_units; i++) {
-		if (temp[i] < 0)
-			fatal("negative temperature!\n");
-		else if (max < temp[i])
-			max = temp[i];
-	}
-
-	return max;
-}
-
-double find_avg_temp_grid(grid_model_t *model, double *temp)
-{
-	int i, n, base = 0, count = 0; 
-	double sum = 0.0;
-	/* average temperature of all the power dissipating blocks	*/
-	for(n=0; n < model->n_layers; n++) {
-		if (model->layers[n].has_power) {
-			for(i=0; i < model->layers[n].flp->n_units; i++) {
-				if (temp[base+i] < 0)
-					fatal("negative temperature!\n");
-				else 
-					sum += temp[base+i];
-			}
-			count += model->layers[n].flp->n_units;
-		}	
-		base += model->layers[n].flp->n_units;
-	}
-
-	if (!count)
-		fatal("no power dissipating units?!\n");
-	return (sum / count);
-}
-
-/* grid_model_vector routines	*/
-
-/* constructor	*/
-grid_model_vector_t *new_grid_model_vector(grid_model_t *model)
-{
-	grid_model_vector_t *v;
-
-	v = (grid_model_vector_t *) calloc (1, sizeof(grid_model_vector_t));
-	if (!v)
-		fatal("memory allocation error\n");
-
-	v->cuboid = dcuboid_tail(model->rows, model->cols, model->n_layers, 0);
-	return v;
-}
-
-/* destructor	*/
-void free_grid_model_vector(grid_model_vector_t *v)
-{
-	free_dcuboid(v->cuboid);
-	free(v);
-}
-
-/* translate power/temperature between block and grid vectors	*/
-void xlate_vector_b2g(grid_model_t *model, double *b, grid_model_vector_t *g, int type)
-{
-	int i, j, n, base = 0;
-	double area;
-
-	/* area of a single grid cell	*/
-	area = (model->width * model->height) / (model->cols * model->rows);
-
-	for(n=0; n < model->n_layers; n++) {
-		for(i=0; i < model->rows; i++)
-			for(j=0; j < model->cols; j++) {
-				/* for each grid cell, the power density / temperature are 
-				 * the average of the power densities / temperatures of the 
-				 * blocks in it weighted by their occupancies
-				 */
-				/* convert power density to power	*/ 
-				if (type == V_POWER)
-					g->cuboid[n][i][j] = blist_avg(model->layers[n].b2gmap[i][j], 
-										 model->layers[n].flp, &b[base], type) * area;
-				/* no conversion necessary for temperature	*/ 
-				else if (type == V_TEMP)
-					g->cuboid[n][i][j] = blist_avg(model->layers[n].b2gmap[i][j], 
-										 model->layers[n].flp, &b[base], type);
-				else
-					fatal("unknown vector type\n");
-			}
-		/* keep track of the beginning address of this layer in the 
-		 * block power vector
-		 */
-		base += model->layers[n].flp->n_units;							 
-	}
-
-}
-
-/* translate temperature between grid and block vectors	*/
-void xlate_temp_g2b(grid_model_t *model, double *b, grid_model_vector_t *g)
-{
-	int i, j, n, u, base = 0, count;
-	int i1, j1, i2, j2, ci1, cj1, ci2, cj2;
-	double min, max, avg;
-
-	for(n=0; n < model->n_layers; n++) {
-		for(u=0; u < model->layers[n].flp->n_units; u++) {
-			/* extent of this unit in grid cell units	*/
-			i1 = model->layers[n].g2bmap[u].i1;
-			j1 = model->layers[n].g2bmap[u].j1;
-			i2 = model->layers[n].g2bmap[u].i2;
-			j2 = model->layers[n].g2bmap[u].j2;
-
-			/* map the center grid cell's temperature to the block	*/
-			if (model->map_mode == GRID_CENTER) {
-				/* center co-ordinates	*/	
-				ci1 = (i1 + i2) / 2;
-				cj1 = (j1 + j2) / 2;
-				/* in case of even no. of cells, center 
-				 * is the average of two central cells
-				 */
-				/* ci2 = ci1-1 when even, ci1 otherwise	*/  
-				ci2 = ci1 - !((i2-i1) % 2);
-				/* cj2 = cj1-1 when even, cj1 otherwise	*/  
-				cj2 = cj1 - !((j2-j1) % 2);
-
-				b[base+u] = (g->cuboid[n][ci1][cj1] + g->cuboid[n][ci2][cj1] + 
-						    g->cuboid[n][ci1][cj2] + g->cuboid[n][ci2][cj2]) / 4;
-				continue;
-			}
-		
-			/* find the min/max/avg temperatures of the 
-			 * grid cells in this block
-			 */
-			avg = 0.0;
-			count = 0;
-			min = max = g->cuboid[n][i1][j1];
-			for(i=i1; i < i2; i++)
-				for(j=j1; j < j2; j++) {
-					avg += g->cuboid[n][i][j];
-					if (g->cuboid[n][i][j] < min)
-						min = g->cuboid[n][i][j];
-					if (g->cuboid[n][i][j] > max)
-						max = g->cuboid[n][i][j];
-					count++;
-				}
-
-			/* map to output accordingly	*/
-			switch (model->map_mode)
-			{
-				case GRID_AVG:
-					b[base+u] = avg / count;
-					break;
-				case GRID_MIN:
-					b[base+u] = min;
-					break;
-				case GRID_MAX:
-					b[base+u] = max;
-					break;
-				/* taken care of already	*/	
-				case GRID_CENTER:
-					break;
-				default:
-					fatal("unknown mapping mode\n");
-					break;
-			}
-		}
-		/* keep track of the beginning address of this layer in the 
-		 * block power vector
-		 */
-		base += model->layers[n].flp->n_units;							 
-	}
-
-}
-
-/* set up initial temperatures for the steady state solution
- * heuristically (ignoring the lateral resistances)
- */
-void set_heuristic_temp(grid_model_t *model, grid_model_vector_t *power, 
-						grid_model_vector_t *temp)
-{
-	int n, i, j, nl, nr, nc;
-	double **sum;
-
-	/* shortcuts	*/
-	nl = model->n_layers;
-	nr = model->rows;
-	nc = model->cols;
-
-	/* layer temperatures	*/
-	/* add up power for each grid cell across all layers */
-	sum = dmatrix(nr, nc);
-	for(n=0; n < nl; n++)
-		scaleadd_dvector(sum[0], sum[0], power->cuboid[n][0], nr*nc, 1.0);
-
-	/* last layer	*/
-	for(i=0; i < nr; i++)
-		for(j=0; j < nc; j++)
-			temp->cuboid[nl-1][i][j] = model->config.ambient + sum[i][j] * 
-									 model->layers[nl-1].rz;
-	/* subtract away the layer's power	*/			
-	scaleadd_dvector(sum[0], sum[0], power->cuboid[nl-1][0], nr*nc, -1.0);
-			
-	/* go from last-1 to first	*/
-	for(n=nl-2; n >= 0; n--) {
-		/* nth layer temp is n+1th temp + cumul_power * rz of the nth layer	*/
-		scaleadd_dvector(temp->cuboid[n][0], temp->cuboid[n+1][0], sum[0], 
-						 nr*nc, model->layers[n].rz);
-		/* subtract away the layer's power	*/			
-		scaleadd_dvector(sum[0], sum[0], power->cuboid[n][0], nr*nc, -1.0);
-	}
-	
-	free_dmatrix(sum);
-}
-
-/* macros for calculating conductances	*/
-/* conductance to the next cell north. zero if on northern boundary	*/
-# define NC(l,n,i,j,nl,nr,nc)		((i > 0) ? (1.0/l[n].ry) : 0.0)
-/* conductance to the next cell south. zero if on southern boundary	*/
-# define SC(l,n,i,j,nl,nr,nc)		((i < nr-1) ? (1.0/l[n].ry) : 0.0)
-/* conductance to the next cell east. zero if on eastern boundary	*/
-# define EC(l,n,i,j,nl,nr,nc)		((j < nc-1) ? (1.0/l[n].rx) : 0.0)
-/* conductance to the next cell west. zero if on western boundary	*/
-# define WC(l,n,i,j,nl,nr,nc)		((j > 0) ? (1.0/l[n].rx) : 0.0)
-/* conductance to the next cell below. zero if on bottom face		*/
-# define BC(l,n,i,j,nl,nr,nc)		((n < nl-1) ? (1.0/l[n].rz) : 0.0)
-/* conductance to the next cell above. zero if on top face			*/
-# define AC(l,n,i,j,nl,nr,nc)		((n > 0) ? (1.0/l[n-1].rz) : 0.0)
-
-/* macros for calculating weighted temperatures	*/
-/* weighted T of the next cell north. zero if on northern boundary	*/
-# define NT(l,v,n,i,j,nl,nr,nc)		((i > 0) ? (v[n][i-1][j]/l[n].ry) : 0.0)
-/* weighted T of the next cell south. zero if on southern boundary	*/
-# define ST(l,v,n,i,j,nl,nr,nc)		((i < nr-1) ? (v[n][i+1][j]/l[n].ry) : 0.0)
-/* weighted T of the next cell east. zero if on eastern boundary	*/
-# define ET(l,v,n,i,j,nl,nr,nc)		((j < nc-1) ? (v[n][i][j+1]/l[n].rx) : 0.0)
-/* weighted T of the next cell west. zero if on western boundary	*/
-# define WT(l,v,n,i,j,nl,nr,nc)		((j > 0) ? (v[n][i][j-1]/l[n].rx) : 0.0)
-/* weighted T of the next cell below. zero if on bottom face		*/
-# define BT(l,v,n,i,j,nl,nr,nc)		((n < nl-1) ? (v[n+1][i][j]/l[n].rz) : 0.0)
-/* weighted T of the next cell above. zero if on top face			*/
-# define AT(l,v,n,i,j,nl,nr,nc)		((n > 0) ? (v[n-1][i][j]/l[n-1].rz) : 0.0)
-
-/* single steady state iteration of grid solver - silicon part */
-double single_iteration_steady_grid(grid_model_t *model, grid_model_vector_t *power,
-									grid_model_vector_t *temp)
-{
-	int n, i, j;
-	double prev, delta, max = 0;
-	/* sum of the conductances	*/
-	double csum;
-	/* weighted sum of temperatures	*/
-	double wsum;
-
-	/* shortcuts	*/
-	double ***v = temp->cuboid;
-	thermal_config_t *c = &model->config;
-	layer_t *l = model->layers;
-	int nl = model->n_layers;
-	int nr = model->rows;
-	int nc = model->cols;
-
-	/* for each grid cell	*/
-	for(n=0; n < nl; n++)
-		for(i=0; i < nr; i++)
-			for(j=0; j < nc; j++) {
-				/* sum the conductances to cells north, south, 
-				 * east, west, above and below
-				 */
-				csum = NC(l,n,i,j,nl,nr,nc) + SC(l,n,i,j,nl,nr,nc) + 
-					   EC(l,n,i,j,nl,nr,nc) + WC(l,n,i,j,nl,nr,nc) + 
-					   AC(l,n,i,j,nl,nr,nc) + BC(l,n,i,j,nl,nr,nc);
-
-				/* sum of the weighted temperatures of all the neighbours	*/
-				wsum = NT(l,v,n,i,j,nl,nr,nc) + ST(l,v,n,i,j,nl,nr,nc) + 
-					   ET(l,v,n,i,j,nl,nr,nc) + WT(l,v,n,i,j,nl,nr,nc) + 
-					   AT(l,v,n,i,j,nl,nr,nc) + BT(l,v,n,i,j,nl,nr,nc);
-
-				/* last layer */
-				if (n == nl-1) {
-					/* all nodes are connected to the ambient	*/
-					csum += 1.0/l[n].rz;
-					wsum += c->ambient/l[n].rz;
-				}
-
-				/* update the current cell's temperature	*/	   
-				prev = v[n][i][j];
-				v[n][i][j] = (power->cuboid[n][i][j] + wsum) / csum;
-
-				/* compute maximum delta	*/
-				delta =  fabs(prev - v[n][i][j]);
-				if (delta > max)
-					max = delta;
-			}
-	return max;
-}
-
-/* restriction operator for multigrid solver. given a power vector
- * corresponding to a fine grid, outputs a vector corresponding
- * to one level coarser grid (half the no. of rows and cols)
- * NOTE: model->rows and model->cols denote the size of the
- * coarser grid
- */
-void multigrid_restrict_power(grid_model_t *model, grid_model_vector_t *dst, 
-							  grid_model_vector_t *src)
-{
-	/* coarse grid indices	*/
-	int n, i, j;
-
-	/* grid cells - add the four nearest neighbours	*/
-	for(n=0; n < model->n_layers; n++)
-		for(i=0; i < model->rows; i++)
-			for(j=0; j < model->cols; j++)
-			{
-				dst->cuboid[n][i][j] = (src->cuboid[n][2*i][2*j] +
-										src->cuboid[n][2*i+1][2*j] +
-										src->cuboid[n][2*i][2*j+1] +
-										src->cuboid[n][2*i+1][2*j+1]);
-			}
-}
-
-/* prolongation(interpolation) operator for multigrid solver. 
- * given a temperature vector corresponding to a coarse grid,
- * outputs a (bi)linearly interpolated vector corresponding 
- * to one level finer grid (twice the no. of rows and cols)
- * NOTE: model->rows and model->cols denote the size of the
- * coarser grid
- */
-void multigrid_prolong_temp(grid_model_t *model, grid_model_vector_t *dst, 
-							grid_model_vector_t *src)
-{
-	/* coarse grid indices	*/
-	int n, i, j;
-
-	/* shortcuts	*/
-	int nr = model->rows;
-	int nc = model->cols;
-	double ***d = dst->cuboid;
-	double ***s = src->cuboid;
-
-	/* For the fine grid cells not on the boundary,
-	 * we want to linearly interpolate in the region 
-	 * surrounded by the coarse grid cells (i,j),
-	 * (i+1,j) (i,j+1) and (i+1, j+1). The fine
-	 * grid cells in that region are (2i+1, 2j+1),
-	 * (2i+2, 2j+1), (2i+1, 2j+2) and (2i+2, 2j+2).
-	 * To interpolate bilinearly, we first interpolate
-	 * along one axis and then along the other. In
-	 * each axis, due to the proximity of the fine
-	 * grid cell co-ordinates to one of the coarse
-	 * grid cells, the weights are 3/4 and 1/4 (not
-	 * 1/2 and 1/2) So, repeating them along the  
-	 * other axis also results in weights of 9/16,
-	 * 3/16, 3/16 and 1/16
-	 */ 
-	for(n=0; n < model->n_layers; n++)
-		for(i=0; i < nr-1; i++)
-			for(j=0; j < nc-1; j++) {
-				d[n][2*i+1][2*j+1] = 9.0/16.0 * s[n][i][j] +
-									 3.0/16.0 * s[n][i+1][j] +
-									 1.0/16.0 * s[n][i+1][j+1] +
-									 3.0/16.0 * s[n][i][j+1];
-				d[n][2*i+2][2*j+1] = 3.0/16.0 * s[n][i][j] +
-									 9.0/16.0 * s[n][i+1][j] +
-									 3.0/16.0 * s[n][i+1][j+1] +
-									 1.0/16.0 * s[n][i][j+1];
-				d[n][2*i+2][2*j+2] = 1.0/16.0 * s[n][i][j] +
-									 3.0/16.0 * s[n][i+1][j] +
-									 9.0/16.0 * s[n][i+1][j+1] +
-									 3.0/16.0 * s[n][i][j+1];
-				d[n][2*i+1][2*j+2] = 3.0/16.0 * s[n][i][j] +
-									 1.0/16.0 * s[n][i+1][j] +
-									 3.0/16.0 * s[n][i+1][j+1] +
-									 9.0/16.0 * s[n][i][j+1];
-			}
-
-	/* for the cells on the boundary, we perform
-	 * a zeroth order interpolation. i.e., copy
-	 * the nearest coarse grid cell's value
-	 * as it is
-	 */
-	for(n=0; n < model->n_layers; n++) {
-		for(i=0; i < nr; i++) {
-			d[n][2*i][0] = d[n][2*i+1][0] = s[n][i][0];
-			d[n][2*i][2*nc-1] = d[n][2*i+1][2*nc-1] = s[n][i][nc-1];
-		}	
-		for(j=0; j < nc; j++) {
-			d[n][0][2*j] = d[n][0][2*j+1] = s[n][0][j];
-			d[n][2*nr-1][2*j] = d[n][2*nr-1][2*j+1] = s[n][nr-1][j];
-		}
-	}
-}
-
-/* recursive multigrid solver. it uses the Gauss-Seidel (GS) iterative 
- * solver to solve at a particular grid granularity. Although GS removes
- * high frequency errors in a solution estimate pretty quickly, it 
- * takes a lot of time to eliminate the low frequency ones. These 
- * low frequency errors can be eliminated easily by coarsifying the
- * grid. This is the core principle of mulrigrid solvers. The version here
- * is called "nested iteration". It solves the problem (iteratively using GS)
- * first in the coarsest granularity and then utilizes that solution to 
- * estimate the solution in the next finer grid. This is repeated until
- * the solution is found in the finest desired grid. For details, take 
- * a look at Numerical Recipes in C (2nd edition), sections 19.5 and 19.6
- * (http://www.nrbook.com/a/bookcpdf/c19-5.pdf and
- * http://www.nrbook.com/a/bookcpdf/c19-6.pdf). Also refer to Prof.
- * Jayathi Murthy's ME 608 notes from Purdue - Chapter 8, sections 8.7-8.9.
- * (http://meweb.ecn.purdue.edu/~jmurthy/me608/main.pdf - pg. 175-192)
- */ 
-void recursive_multigrid(grid_model_t *model, grid_model_vector_t *power,
-						 grid_model_vector_t *temp)
-{
-	double delta;
-	#if VERBOSE > 1
-	unsigned int i = 0;
-	#endif
-	grid_model_vector_t *coarse_power, *coarse_temp;
-	int n;
-
-	/* setup heuristic initial temperatures	at the coarsest level*/
-	if (model->rows <= 1 || model->cols <= 1) {
-		set_heuristic_temp(model, power, temp);
-	
-	/* for finer grids. use coarser solutions as estimates	*/
-	} else {
-		/* make the grid coarser	*/
-		model->rows /= 2;
-		model->cols /= 2;
-		for(n=0; n < model->n_layers; n++) {
-			/* only rz's and c's change. rx's and 
-			 * ry's remain the same	
-			 */
-			model->layers[n].rz /= 4;
-			if (model->c_ready)
-				model->layers[n].c *= 4;
-		}
-
-		/* vectors for the coarse grid	*/
-		coarse_power = new_grid_model_vector(model);
-		coarse_temp = new_grid_model_vector(model);
-
-		/* coarsen the power vector	*/
-		multigrid_restrict_power(model, coarse_power, power);
-
-		/* solve recursively	*/
-		recursive_multigrid(model, coarse_power, coarse_temp);
-
-		/* interpolate the solution to the current fine grid	*/
-		multigrid_prolong_temp(model, temp, coarse_temp);
-
-		/* cleanup	*/
-		free_grid_model_vector(coarse_power);
-		free_grid_model_vector(coarse_temp);
-		
-		/* restore the grid */
-		model->rows *= 2;
-		model->cols *= 2;
-		for(n=0; n < model->n_layers; n++) {
-			model->layers[n].rz *= 4;
-			if (model->c_ready)
-				model->layers[n].c /= 4;
-		}
-	}
-	/* refine solution iteratively till convergence	*/
-	do {
-		delta = single_iteration_steady_grid(model, power, temp);
-		#if VERBOSE > 1
-			i++;
-		#endif
-	} while (!eq(delta, 0));
-	#if VERBOSE > 1
-	fprintf(stdout, "no. of iterations for steady state convergence (%d x %d grid): %d\n", 
-					model->rows, model->cols, i);
-	#endif
-}
-
-void steady_state_temp_grid(grid_model_t *model, double *power, double *temp)
-{
-	grid_model_vector_t *p;
-
-	if (!model->r_ready)
-		fatal("R model not ready\n");
-
-	p = new_grid_model_vector(model);
-
-	/* map the block power numbers to the grid	*/
-	xlate_vector_b2g(model, power, p, V_POWER);
-
-	/* solve recursively. use grid model's internal 
-	 * state vector to store the grid temperatures
-	 */ 
-	recursive_multigrid(model, p, model->last_steady);
-
-	/* map the temperature numbers back	*/
-	xlate_temp_g2b(model, temp, model->last_steady);
-
-	free_grid_model_vector(p);
-}
-
-/* function to access a 1-d array as a 3-d matrix	*/
-#define A3D(array,n,i,j,nl,nr,nc)		(array[(n)*(nr)*(nc) + (i)*(nc) + (j)])
-
-/* macros for calculating currents(power values)	*/
-/* current(power) from the next cell north. zero if on northern boundary	*/
-# define NP(l,v,n,i,j,nl,nr,nc)		((i > 0) ? ((A3D(v,n,i-1,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].ry) : 0.0)
-/* current(power) from the next cell south. zero if on southern boundary	*/
-# define SP(l,v,n,i,j,nl,nr,nc)		((i < nr-1) ? ((A3D(v,n,i+1,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].ry) : 0.0)
-/* current(power) from the next cell east. zero if on eastern boundary	*/
-# define EP(l,v,n,i,j,nl,nr,nc)		((j < nc-1) ? ((A3D(v,n,i,j+1,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].rx) : 0.0)
-/* current(power) from the next cell west. zero if on western boundary	*/
-# define WP(l,v,n,i,j,nl,nr,nc)		((j > 0) ? ((A3D(v,n,i,j-1,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].rx) : 0.0)
-/* current(power) from the next cell below. zero if on bottom face		*/
-# define BP(l,v,n,i,j,nl,nr,nc)		((n < nl-1) ? ((A3D(v,n+1,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n].rz) : 0.0)
-/* current(power) from the next cell above. zero if on top face			*/
-# define AP(l,v,n,i,j,nl,nr,nc)		((n > 0) ? ((A3D(v,n-1,i,j,nl,nr,nc)-A3D(v,n,i,j,nl,nr,nc))/l[n-1].rz) : 0.0)
-
-/* compute the slope vector for the grid cells. the transient
- * equation is CdV + sum{(T - Ti)/Ri} = P 
- * so, slope = dV = [P + sum{(Ti-T)/Ri}]/C
- */
-void slope_fn_grid(grid_model_t *model, double *v, grid_model_vector_t *p, double *dv)
-{
-	int n, i, j;
-	/* sum of the currents(power values)	*/
-	double psum;
-
-	/* shortcuts	*/
-	thermal_config_t *c = &model->config;
-	layer_t *l = model->layers;
-	int nl = model->n_layers;
-	int nr = model->rows;
-	int nc = model->cols;
-
-	/* for each grid cell	*/
-	for(n=0; n < nl; n++)
-		for(i=0; i < nr; i++)
-			for(j=0; j < nc; j++) {
-				/* sum the currents(power values) to cells north, south, 
-				 * east, west, above and below
-				 */
-				psum = NP(l,v,n,i,j,nl,nr,nc) + SP(l,v,n,i,j,nl,nr,nc) + 
-					   EP(l,v,n,i,j,nl,nr,nc) + WP(l,v,n,i,j,nl,nr,nc) + 
-					   AP(l,v,n,i,j,nl,nr,nc) + BP(l,v,n,i,j,nl,nr,nc);
-
-				/* last layer	*/
-				if (n == nl-1) {
-					/* all nodes are connected to the ambient	*/
-					psum += (c->ambient - A3D(v,n,i,j,nl,nr,nc))/l[n].rz;
-				}
-
-				/* update the current cell's temperature	*/	   
-				A3D(dv,n,i,j,nl,nr,nc) = (p->cuboid[n][i][j] + psum) / l[n].c;
-			}
-}
-
-void compute_temp_grid(grid_model_t *model, double *power, double *temp, double time_elapsed)
-{
-	double t, h, new_h;
-	grid_model_vector_t *p;
-	#if VERBOSE > 1
-	unsigned int i = 0;
-	#endif
-	
-	if (!model->r_ready || !model->c_ready)
-		fatal("grid model not ready\n");
-
-	p = new_grid_model_vector(model);
-
-	/* map the block power/temp numbers to the grid	*/
-	xlate_vector_b2g(model, power, p, V_POWER);
-
-	/* if temp is NULL, re-use the temperature from the
-	 * last call. otherwise, translate afresh and remember 
-	 * the grid and block temperature arrays for future use
-	 */
-	if (temp != NULL) {
-		xlate_vector_b2g(model, temp, model->last_trans, V_TEMP);
-		model->last_temp = temp;
-	}	
-
-	/* Obtain temp at time (t+time_elapsed). 
-	 * Instead of getting the temperature at t+time_elapsed directly, we
-	 * do it in multiple steps with the correct step size at each time 
-	 * provided by rk4. 
-	 */
-	for (t = 0, new_h = MIN_STEP; t + new_h <= time_elapsed; t+=h) {
-		h = new_h;
-		/* pass the entire grid as a 1-d array */
-		new_h = rk4(model, model->last_trans->cuboid[0][0],  p, 
-				 /* array size	*/
-				 model->rows * model->cols * model->n_layers, h,
-				 model->last_trans->cuboid[0][0], 
-				 /* the slope function callback is typecast accordingly */
-				 (slope_fn_ptr) slope_fn_grid);
-		#if VERBOSE > 1
-			i++;
-		#endif	
-	}
-
-	/* remainder	*/
-	if (time_elapsed > t)
-		rk4(model, model->last_trans->cuboid[0][0],  p, 
-			model->rows * model->cols * model->n_layers,
-			/* the slope function callback is typecast accordingly */
-			time_elapsed - t, model->last_trans->cuboid[0][0], 
-			(slope_fn_ptr) slope_fn_grid);
-
-	#if VERBOSE > 1
-	fprintf(stdout, "no. of rk4 calls during compute_temp: %d\n", i+1);
-	#endif
-
-	/* map the temperature numbers back	*/
-	xlate_temp_g2b(model, model->last_temp, model->last_trans);
-
-	free_grid_model_vector(p);
-}
-
-/* debug print	*/
-void debug_print_blist(blist_t *head, flp_t *flp)
-{
-	blist_t *ptr;
-	fprintf(stdout, "printing blist information...\n");
-	for(ptr = head; ptr; ptr = ptr->next) {
-		fprintf(stdout, "unit: %s\n", flp->units[ptr->idx].name);
-		fprintf(stdout, "occupancy: %f\n", ptr->occupancy);
-	}
-}
-
-void debug_print_glist(glist_t *array, flp_t *flp)
-{
-	int i;
-	fprintf(stdout, "printing glist information...\n");
-	for(i=0; i < flp->n_units; i++)
-		fprintf(stdout, "unit: %s\tstartx: %d\tendx: %d\tstarty: %d\tendy: %d\n",
-				flp->units[i].name, array[i].j1, array[i].j2, array[i].i1, array[i].i2);
-}
-
-void debug_print_layer(grid_model_t *model, layer_t *layer)
-{
-	int i, j;
-	fprintf(stdout, "printing layer information...\n");
-	fprintf(stdout, "no: %d\n", layer->no);
-	fprintf(stdout, "has_lateral: %d\n", layer->has_lateral);
-	fprintf(stdout, "has_power: %d\n", layer->has_power);
-	fprintf(stdout, "k: %f\n", layer->k);
-	fprintf(stdout, "thickness: %f\n", layer->thickness);
-	fprintf(stdout, "sp: %f\n", layer->sp);
-	fprintf(stdout, "rx: %f\try: %f\trz: %f\tc: %f\n", 
-			layer->rx, layer->ry, layer->rz, layer->c);
-
-	fprintf(stdout, "printing b2gmap information...\n");
-	for(i=0; i < model->rows; i++)
-		for(j=0; j < model->cols; j++) {
-			fprintf(stdout, "row: %d, col: %d\n", i, j);
-			debug_print_blist(layer->b2gmap[i][j], layer->flp);
-		}
-
-	fprintf(stdout, "printing g2bmap information...\n");
-	debug_print_glist(layer->g2bmap, layer->flp);
-}
-
-void debug_print_grid_model_vector(grid_model_vector_t *v, int nl, int nr, int nc)
-{
-	int n;
-
-	fprintf(stdout, "printing cuboid information...\n");
-	for(n=0; n < nl; n++)
-		dump_dmatrix(v->cuboid[n], nr, nc);
-}
-
-void debug_print_grid(grid_model_t *model)
-{
-	int i;
-	fprintf(stdout, "printing grid model information...\n");
-	fprintf(stdout, "rows: %d\n", model->rows);
-	fprintf(stdout, "cols: %d\n", model->cols);
-	fprintf(stdout, "width: %f\n", model->width);
-	fprintf(stdout, "height: %f\n", model->height);
-
-	fprintf(stdout, "total_n_blocks: %d\n", model->total_n_blocks);
-	fprintf(stdout, "map_mode: %d\n", model->map_mode);
-	fprintf(stdout, "r_ready: %d\n", model->r_ready);
-	fprintf(stdout, "c_ready: %d\n", model->c_ready);
-	fprintf(stdout, "has_lcf: %d\n", model->has_lcf);
-
-	fprintf(stdout, "printing last_steady information...\n");
-	debug_print_grid_model_vector(model->last_steady, model->n_layers, 
-								  model->rows, model->cols);
-
-	fprintf(stdout, "printing last_trans information...\n");
-	debug_print_grid_model_vector(model->last_trans, model->n_layers,
-								  model->rows, model->cols);
-
-	fprintf(stdout, "printing last_temp information...\n");
-	if (model->last_temp)
-		dump_dvector(model->last_temp, model->total_n_blocks);
-	else
-		fprintf(stdout, "(null)\n");
-
-	for(i=0; i < model->n_layers; i++)
-		debug_print_layer(model, &model->layers[i]);
-
-	fprintf(stdout, "base_n_units: %d\n", model->base_n_units);
-}
-
diff -Naur temp/util.c HotSpot/util.c
--- temp/util.c	2017-11-20 10:04:24.521682846 +0100
+++ HotSpot/util.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,536 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-#include <string.h>
-#ifdef _MSC_VER
-#define strcasecmp    _stricmp
-#define strncasecmp   _strnicmp
-#else
-#include <strings.h>
-#endif
-#include <assert.h>
-
-#include "util.h"
-
-int eq(double x, double y)
-{
-	return (fabs(x-y) <  DELTA);
-}
-
-int le(double x, double y)
-{
-	return ((x < y) || eq(x,y));
-}
-
-int ge(double x, double y)
-{
-	return ((x > y) || eq(x,y));
-}
-
-void fatal(char *s)
-{
-	fprintf(stderr, "error: %s", s);
-	exit(1);
-}
-
-void warning(char *s)
-{
-	fprintf(stderr, "warning: %s", s);
-}
-
-void swap_ival (int *a, int *b)
-{
-	int t = *a;
-	*a = *b;
-	*b = t;
-}
-
-void swap_dval (double *a, double *b)
-{
-	double t = *a;
-	*a = *b;
-	*b = t;
-}
-
-int tolerant_ceil(double val)
-{
-	double nearest = floor(val+0.5);
-	/* numbers close to integers	*/
-	if (eq(val, nearest))
-		return ((int) nearest);
-	/* all others	*/	
-	else 
-		return ((int) ceil(val));
-}
-
-int tolerant_floor(double val)
-{
-	double nearest = floor(val+0.5);
-	/* numbers close to integers	*/
-	if (eq(val, nearest))
-		return ((int) nearest);
-	/* all others	*/	
-	else 
-		return ((int) floor(val));
-}
-
-double *dvector(int n)
-{
-	double *v;
-   
-	v=(double *)calloc(n, sizeof(double));
-	if (!v) fatal("allocation failure in dvector()\n");
-
-	return v;
-}
-
-void free_dvector(double *v)
-{
-	free(v);
-}
-
-void dump_dvector (double *v, int n)
-{
-	int i;
-	for (i=0; i < n; i++)
-		fprintf(stdout, "%.5f\t", v[i]);
-	fprintf(stdout, "\n");
-}	
-
-void copy_dvector (double *dst, double *src, int n)
-{
-	memmove(dst, src, sizeof(double) * n);
-}
-
-void zero_dvector (double *v, int n)
-{
-	memset(v, 0, sizeof(double) * n);
-}
-
-/* sum of the elements	*/
-double sum_dvector (double *v, int n)
-{
-	double sum = 0;
-	int i;
-	for(i=0; i < n; i++)
-		sum += v[i];
-	return sum;	
-}
-
-int *ivector(int n)
-{
-	int *v;
-   
-	v = (int *)calloc(n, sizeof(int));
-	if (!v) fatal("allocation failure in ivector()\n");
-
-	return v;
-}
-
-void free_ivector(int *v)
-{
-	free(v);
-}
-
-void dump_ivector (int *v, int n)
-{
-	int i;
-	for (i=0; i < n; i++)
-		fprintf(stdout, "%d\t", v[i]);
-	fprintf(stdout, "\n\n");
-}
-
-void copy_ivector (int *dst, int *src, int n)
-{
-	memmove(dst, src, sizeof(int) * n);
-}
-
-void zero_ivector (int *v, int n)
-{
-	memset(v, 0, sizeof(int) * n);
-}
-
-/* 
- * Thanks to Greg Link from Penn State University 
- * for these memory allocators/deallocators	
- */
-double **dmatrix(int nr, int nc)
-{
-	int i;
-	double **m;
-
-	m = (double **) calloc (nr, sizeof(double *));
-	assert(m != NULL);
-	m[0] = (double *) calloc (nr * nc, sizeof(double));
-	assert(m[0] != NULL);
-
-	for (i = 1; i < nr; i++)
-    	m[i] =  m[0] + nc * i;
-
-	return m;
-}
-
-void free_dmatrix(double **m)
-{
-	free(m[0]);
-	free(m);
-}
-
-int **imatrix(int nr, int nc)
-{
-	int i;
-	int **m;
-
-	m = (int **) calloc (nr, sizeof(int *));
-	assert(m != NULL);
-	m[0] = (int *) calloc (nr * nc, sizeof(int));
-	assert(m[0] != NULL);
-
-	for (i = 1; i < nr; i++)
-		m[i] = m[0] + nc * i;
-
-	return m;
-}
-
-void free_imatrix(int **m)
-{
-	free(m[0]);
-	free(m);
-}
-
-void dump_dmatrix (double **m, int nr, int nc)
-{
-	int i;
-	for (i=0; i < nr; i++)
-		dump_dvector(m[i], nc);
-	fprintf(stdout, "\n");
-}	
-
-void copy_dmatrix (double **dst, double **src, int nr, int nc)
-{
-	memmove(dst[0], src[0], sizeof(double) * nr * nc);
-}
-
-void zero_dmatrix(double **m, int nr, int nc)
-{
-	memset(m[0], 0, sizeof(double) * nr * nc);
-}
-
-void resize_dmatrix(double **m, int nr, int nc)
-{
-	int i;
-	for (i = 1; i < nr; i++)
-		m[i] = m[0] + nc * i;
-}
-
-/* allocate 3-d matrix with 'nr' rows, 'nc' cols, 
- * 'nl' layers	and a tail of 'xtra' elements 
- */
-double ***dcuboid_tail(int nr, int nc, int nl, int xtra)
-{
-	int i, j;
-	double ***m;
-
-	/* 1-d array of pointers to the rows of the 2-d array below	*/
-	m = (double ***) calloc (nl, sizeof(double **));
-	assert(m != NULL);
-	/* 2-d array of pointers denoting (layer, row)	*/
-	m[0] = (double **) calloc (nl * nr, sizeof(double *));
-	assert(m[0] != NULL);
-	/* the actual 3-d data array	*/
-	m[0][0] = (double *) calloc (nl * nr * nc + xtra, sizeof(double));
-	assert(m[0][0] != NULL);
-
-	/* remaining pointers of the 1-d pointer array	*/
-	for (i = 1; i < nl; i++)
-    	m[i] =  m[0] + nr * i;
-
-	/* remaining pointers of the 2-d pointer array	*/
-	for (i = 0; i < nl; i++)
-		for (j = 0; j < nr; j++)
-			/* to reach the jth row in the ith layer, 
-			 * one has to cross i layers i.e., i*(nr*nc)
-			 * values first and then j rows i.e., j*nc 
-			 * values next
-			 */
-    		m[i][j] =  m[0][0] + (nr * nc) * i + nc * j;
-
-	return m;
-}
-
-void free_dcuboid(double ***m)
-{
-	free(m[0][0]);
-	free(m[0]);
-	free(m);
-}
-
-/* mirror the lower triangle to make 'm' fully symmetric	*/
-void mirror_dmatrix(double **m, int n)
-{
-	int i, j;
-	for(i=0; i < n; i++)
-		for(j=0; j < i; j++)
-			m[j][i] = m[i][j];
-}
-
-void dump_imatrix (int **m, int nr, int nc)
-{
-	int i;
-	for (i=0; i < nr; i++)
-		dump_ivector(m[i], nc);
-	fprintf(stdout, "\n");
-}	
-
-void copy_imatrix (int **dst, int **src, int nr, int nc)
-{
-	memmove(dst[0], src[0], sizeof(int) * nr * nc);
-}
-
-void resize_imatrix(int **m, int nr, int nc)
-{
-	int i;
-	for (i = 1; i < nr; i++)
-		m[i] = m[0] + nc * i;
-}
-
-/* initialize random number generator	*/
-void init_rand(void)
-{
-	srand(RAND_SEED);
-}
-
-/* random number within the range [0, max-1]	*/
-int rand_upto(int max)
-{
-	return (int) (max * (double) rand() / (RAND_MAX+1.0));
-}
-
-/* random number in the range [0, 1)	*/
-double rand_fraction(void)
-{
-	return ((double) rand() / (RAND_MAX+1.0));
-}
-
-/* 
- * reads tab-separated name-value pairs from file into
- * a table of size max_entries and returns the number 
- * of entries read successfully
- */
-int read_str_pairs(str_pair *table, int max_entries, char *file)
-{
-	int i=0;
-	char str[LINE_SIZE], copy[LINE_SIZE];
-	char name[STR_SIZE];
-	char *ptr;
-	FILE *fp = fopen (file, "r");
-	if (!fp) {
-		sprintf (str,"error: %s could not be opened for reading\n", file);
-		fatal(str);
-	}
-	while(i < max_entries) {
-		fgets(str, LINE_SIZE, fp);
-		if (feof(fp))
-			break;
-		strcpy(copy, str);
-
-		/* ignore comments and empty lines  */
-		ptr = strtok(str, " \r\t\n");
-		if (!ptr || ptr[0] == '#') 
-			continue;
-
-		if ((sscanf(copy, "%s%s", name, table[i].value) != 2) || (name[0] != '-'))
-			fatal("invalid file format\n");
-		/* ignore the leading "-"	*/
-		strcpy(table[i].name, &name[1]);
-		i++;
-	}
-	fclose(fp);
-	return i;
-}
-
-/* 
- * same as above but from command line instead of a file. the command
- * line is of the form <prog_name> <name-value pairs> where
- * <name-value pairs> is of the form -<variable> <value>
- */
-int parse_cmdline(str_pair *table, int max_entries, int argc, char **argv)
-{
-	int i, count;
-	for (i=1, count=0; i < argc && count < max_entries; i++) {
-		if (i % 2) {	/* variable name	*/
-			if (argv[i][0] != '-')
-				fatal("invalid command line. check usage\n");
-			/* ignore the leading "-"	*/	
-			strncpy(table[count].name, &argv[i][1], STR_SIZE-1);
-			table[count].name[STR_SIZE-1] = '\0';
-		} else {		/* value	*/
-			strncpy(table[count].value, argv[i], STR_SIZE-1);
-			table[count].value[STR_SIZE-1] = '\0';
-			count++;
-		}
-	}
-	return count;
-}
-
-/* append the table onto a file	*/
-void dump_str_pairs(str_pair *table, int size, char *file, char *prefix)
-{
-	int i; 
-	char str[STR_SIZE];
-	FILE *fp = fopen (file, "w");
-	if (!fp) {
-		sprintf (str,"error: %s could not be opened for writing\n", file);
-		fatal(str);
-	}
-	for(i=0; i < size; i++)
-		fprintf(fp, "%s%s\t%s\n", prefix, table[i].name, table[i].value);
-	fclose(fp);	
-}
-
-/* table lookup	for a name */
-int get_str_index(str_pair *table, int size, char *str)
-{
-	int i;
-
-	if (!table)
-		fatal("null pointer in get_str_index\n");
-
-	for (i = 0; i < size; i++) 
-		if (!strcasecmp(str, table[i].name)) 
-			return i;
-	return -1;
-}
-
-/* delete entry at 'at'	*/
-void delete_entry(str_pair *table, int size, int at)
-{
-	int i;
-	/* 
-	 * overwrite this entry using the next and 
-	 * shift all later entries once
-	 */
-	for (i=at+1; i < size; i++) {
-		strcpy(table[i-1].name, table[i].name);
-		strcpy(table[i-1].value, table[i].value);
-	}
-}
-
-/* 
- * remove duplicate names in the table - the entries later 
- * in the table are discarded. returns the new size of the
- * table
- */
-int str_pairs_remove_duplicates(str_pair *table, int size)
-{
-	int i, j;
-
-	for(i=0; i < size-1; i++)
-		for(j=i+1; j < size; j++)
-			if (!strcasecmp(table[i].name, table[j].name)) {
-				delete_entry(table, size, j);
-				size--;
-				j--;
-			}
-	return size;
-}
-
-/* debug	*/
-void print_str_pairs(str_pair *table, int size)
-{
-	int i;
-	fprintf(stdout, "printing string table\n");
-	for (i=0; i < size; i++)
-		fprintf(stdout, "%s\t%s\n", table[i].name, table[i].value);
-}
-
-/* 
- * binary search a sorted double array 'arr' of size 'n'. if found,
- * the 'loc' pointer has the address of 'ele' and the return 
- * value is TRUE. otherwise, the return value is FALSE and 'loc' 
- * points to the 'should have been' location
- */
-int bsearch_double(double *arr, int n, double ele, double **loc)
-{
-	if(n < 0)
-		fatal("wrong index in binary search\n");
-
-	if(n == 0) {
-		*loc = arr;
-		return FALSE;
-	}
-
-	if(eq(arr[n/2], ele)) {
-		*loc = &arr[n/2];
-		return TRUE;
-	} else if (arr[n/2] < ele) {
-		return bsearch_double(&arr[n/2+1], (n-1)/2, ele, loc);
-	} else
-		return bsearch_double(arr, n/2, ele, loc);
-
-}
-
-/* 
- * binary search and insert an element into a partially sorted
- * double array if not already present. returns FALSE if present
- */
-int bsearch_insert_double(double *arr, int n, double ele)
-{
-	double *loc;
-	int i;
-
-	/* element found - nothing more left to do	*/
-	if (bsearch_double(arr, n, ele, &loc))
-		return FALSE;
-	else {
-		for(i=n-1; i >= (loc-arr); i--)
-			arr[i+1] = arr[i];
-		arr[loc-arr] = ele;	
-	}
-	return TRUE;
-}
-
-/* 
- * population count of an 8-bit integer - using pointers from 
- * http://aggregate.org/MAGIC/
- */
-unsigned int ones8(register unsigned char n)
-{
-	/* group the bits in two and compute the no. of 1's within a group
-	 * this works because 00->00, 01->01, 10->01, 11->10 or 
-	 * n = n - (n >> 1). the 0x55 masking prevents bits flowing across
-	 * group boundary
-	 */
-	n -= ((n >> 1) & 0x55);
-	/* add the 2-bit sums into nibbles */
-	n = ((n & 0x33) + ((n >> 2) & 0x33));
-	/* add both the nibbles */
-	n = ((n + (n >> 4)) & 0x0F);
-	return n;
-}
-
-/* 
- * find the number of non-empty, non-comment lines
- * in a file open for reading
- */
-int count_significant_lines(FILE *fp)
-{
-    char str[LINE_SIZE], *ptr;
-    int count = 0;
-
-	fseek(fp, 0, SEEK_SET);
-	while(!feof(fp)) {
-		fgets(str, LINE_SIZE, fp);
-		if (feof(fp))
-			break;
-
-		/* ignore comments and empty lines	*/
-		ptr = strtok(str, " \r\t\n");
-		if (!ptr || ptr[0] == '#')
-			continue;
-
-		count++;
-	}
-	return count;
-}
-
diff -Naur temp/util.cc HotSpot/util.cc
--- temp/util.cc	1970-01-01 01:00:00.000000000 +0100
+++ HotSpot/util.cc	2017-11-20 09:59:35.316820635 +0100
@@ -0,0 +1,536 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include <string.h>
+#ifdef _MSC_VER
+#define strcasecmp    _stricmp
+#define strncasecmp   _strnicmp
+#else
+#include <strings.h>
+#endif
+#include <assert.h>
+
+#include "util.h"
+
+int eq(double x, double y)
+{
+	return (fabs(x-y) <  DELTA);
+}
+
+int le(double x, double y)
+{
+	return ((x < y) || eq(x,y));
+}
+
+int ge(double x, double y)
+{
+	return ((x > y) || eq(x,y));
+}
+
+void fatal(char *s)
+{
+	fprintf(stderr, "error: %s", s);
+	exit(1);
+}
+
+void warning(char *s)
+{
+	fprintf(stderr, "warning: %s", s);
+}
+
+void swap_ival (int *a, int *b)
+{
+	int t = *a;
+	*a = *b;
+	*b = t;
+}
+
+void swap_dval (double *a, double *b)
+{
+	double t = *a;
+	*a = *b;
+	*b = t;
+}
+
+int tolerant_ceil(double val)
+{
+	double nearest = floor(val+0.5);
+	/* numbers close to integers	*/
+	if (eq(val, nearest))
+		return ((int) nearest);
+	/* all others	*/	
+	else 
+		return ((int) ceil(val));
+}
+
+int tolerant_floor(double val)
+{
+	double nearest = floor(val+0.5);
+	/* numbers close to integers	*/
+	if (eq(val, nearest))
+		return ((int) nearest);
+	/* all others	*/	
+	else 
+		return ((int) floor(val));
+}
+
+double *dvector(int n)
+{
+	double *v;
+   
+	v=(double *)calloc(n, sizeof(double));
+	if (!v) fatal((char*)"allocation failure in dvector()\n");
+
+	return v;
+}
+
+void free_dvector(double *v)
+{
+	free(v);
+}
+
+void dump_dvector (double *v, int n)
+{
+	int i;
+	for (i=0; i < n; i++)
+		fprintf(stdout, "%.5f\t", v[i]);
+	fprintf(stdout, "\n");
+}	
+
+void copy_dvector (double *dst, double *src, int n)
+{
+	memmove(dst, src, sizeof(double) * n);
+}
+
+void zero_dvector (double *v, int n)
+{
+	memset(v, 0, sizeof(double) * n);
+}
+
+/* sum of the elements	*/
+double sum_dvector (double *v, int n)
+{
+	double sum = 0;
+	int i;
+	for(i=0; i < n; i++)
+		sum += v[i];
+	return sum;	
+}
+
+int *ivector(int n)
+{
+	int *v;
+   
+	v = (int *)calloc(n, sizeof(int));
+	if (!v) fatal((char*)"allocation failure in ivector()\n");
+
+	return v;
+}
+
+void free_ivector(int *v)
+{
+	free(v);
+}
+
+void dump_ivector (int *v, int n)
+{
+	int i;
+	for (i=0; i < n; i++)
+		fprintf(stdout, "%d\t", v[i]);
+	fprintf(stdout, "\n\n");
+}
+
+void copy_ivector (int *dst, int *src, int n)
+{
+	memmove(dst, src, sizeof(int) * n);
+}
+
+void zero_ivector (int *v, int n)
+{
+	memset(v, 0, sizeof(int) * n);
+}
+
+/* 
+ * Thanks to Greg Link from Penn State University 
+ * for these memory allocators/deallocators	
+ */
+double **dmatrix(int nr, int nc)
+{
+	int i;
+	double **m;
+
+	m = (double **) calloc (nr, sizeof(double *));
+	assert(m != NULL);
+	m[0] = (double *) calloc (nr * nc, sizeof(double));
+	assert(m[0] != NULL);
+
+	for (i = 1; i < nr; i++)
+    	m[i] =  m[0] + nc * i;
+
+	return m;
+}
+
+void free_dmatrix(double **m)
+{
+	free(m[0]);
+	free(m);
+}
+
+int **imatrix(int nr, int nc)
+{
+	int i;
+	int **m;
+
+	m = (int **) calloc (nr, sizeof(int *));
+	assert(m != NULL);
+	m[0] = (int *) calloc (nr * nc, sizeof(int));
+	assert(m[0] != NULL);
+
+	for (i = 1; i < nr; i++)
+		m[i] = m[0] + nc * i;
+
+	return m;
+}
+
+void free_imatrix(int **m)
+{
+	free(m[0]);
+	free(m);
+}
+
+void dump_dmatrix (double **m, int nr, int nc)
+{
+	int i;
+	for (i=0; i < nr; i++)
+		dump_dvector(m[i], nc);
+	fprintf(stdout, "\n");
+}	
+
+void copy_dmatrix (double **dst, double **src, int nr, int nc)
+{
+	memmove(dst[0], src[0], sizeof(double) * nr * nc);
+}
+
+void zero_dmatrix(double **m, int nr, int nc)
+{
+	memset(m[0], 0, sizeof(double) * nr * nc);
+}
+
+void resize_dmatrix(double **m, int nr, int nc)
+{
+	int i;
+	for (i = 1; i < nr; i++)
+		m[i] = m[0] + nc * i;
+}
+
+/* allocate 3-d matrix with 'nr' rows, 'nc' cols, 
+ * 'nl' layers	and a tail of 'xtra' elements 
+ */
+double ***dcuboid_tail(int nr, int nc, int nl, int xtra)
+{
+	int i, j;
+	double ***m;
+
+	/* 1-d array of pointers to the rows of the 2-d array below	*/
+	m = (double ***) calloc (nl, sizeof(double **));
+	assert(m != NULL);
+	/* 2-d array of pointers denoting (layer, row)	*/
+	m[0] = (double **) calloc (nl * nr, sizeof(double *));
+	assert(m[0] != NULL);
+	/* the actual 3-d data array	*/
+	m[0][0] = (double *) calloc (nl * nr * nc + xtra, sizeof(double));
+	assert(m[0][0] != NULL);
+
+	/* remaining pointers of the 1-d pointer array	*/
+	for (i = 1; i < nl; i++)
+    	m[i] =  m[0] + nr * i;
+
+	/* remaining pointers of the 2-d pointer array	*/
+	for (i = 0; i < nl; i++)
+		for (j = 0; j < nr; j++)
+			/* to reach the jth row in the ith layer, 
+			 * one has to cross i layers i.e., i*(nr*nc)
+			 * values first and then j rows i.e., j*nc 
+			 * values next
+			 */
+    		m[i][j] =  m[0][0] + (nr * nc) * i + nc * j;
+
+	return m;
+}
+
+void free_dcuboid(double ***m)
+{
+	free(m[0][0]);
+	free(m[0]);
+	free(m);
+}
+
+/* mirror the lower triangle to make 'm' fully symmetric	*/
+void mirror_dmatrix(double **m, int n)
+{
+	int i, j;
+	for(i=0; i < n; i++)
+		for(j=0; j < i; j++)
+			m[j][i] = m[i][j];
+}
+
+void dump_imatrix (int **m, int nr, int nc)
+{
+	int i;
+	for (i=0; i < nr; i++)
+		dump_ivector(m[i], nc);
+	fprintf(stdout, "\n");
+}	
+
+void copy_imatrix (int **dst, int **src, int nr, int nc)
+{
+	memmove(dst[0], src[0], sizeof(int) * nr * nc);
+}
+
+void resize_imatrix(int **m, int nr, int nc)
+{
+	int i;
+	for (i = 1; i < nr; i++)
+		m[i] = m[0] + nc * i;
+}
+
+/* initialize random number generator	*/
+void init_rand(void)
+{
+	srand(RAND_SEED);
+}
+
+/* random number within the range [0, max-1]	*/
+int rand_upto(int max)
+{
+	return (int) (max * (double) rand() / (RAND_MAX+1.0));
+}
+
+/* random number in the range [0, 1)	*/
+double rand_fraction(void)
+{
+	return ((double) rand() / (RAND_MAX+1.0));
+}
+
+/* 
+ * reads tab-separated name-value pairs from file into
+ * a table of size max_entries and returns the number 
+ * of entries read successfully
+ */
+int read_str_pairs(str_pair *table, int max_entries, char *file)
+{
+	int i=0;
+	char str[LINE_SIZE], copy[LINE_SIZE];
+	char name[STR_SIZE];
+	char *ptr;
+	FILE *fp = fopen (file, "r");
+	if (!fp) {
+		sprintf (str,"error: %s could not be opened for reading\n", file);
+		fatal(str);
+	}
+	while(i < max_entries) {
+		fgets(str, LINE_SIZE, fp);
+		if (feof(fp))
+			break;
+		strcpy(copy, str);
+
+		/* ignore comments and empty lines  */
+		ptr = strtok(str, " \r\t\n");
+		if (!ptr || ptr[0] == '#') 
+			continue;
+
+		if ((sscanf(copy, "%s%s", name, table[i].value) != 2) || (name[0] != '-'))
+			fatal((char*)"invalid file format\n");
+		/* ignore the leading "-"	*/
+		strcpy(table[i].name, &name[1]);
+		i++;
+	}
+	fclose(fp);
+	return i;
+}
+
+/* 
+ * same as above but from command line instead of a file. the command
+ * line is of the form <prog_name> <name-value pairs> where
+ * <name-value pairs> is of the form -<variable> <value>
+ */
+int parse_cmdline(str_pair *table, int max_entries, int argc, char **argv)
+{
+	int i, count;
+	for (i=1, count=0; i < argc && count < max_entries; i++) {
+		if (i % 2) {	/* variable name	*/
+			if (argv[i][0] != '-')
+				fatal((char*)"invalid command line. check usage\n");
+			/* ignore the leading "-"	*/	
+			strncpy(table[count].name, &argv[i][1], STR_SIZE-1);
+			table[count].name[STR_SIZE-1] = '\0';
+		} else {		/* value	*/
+			strncpy(table[count].value, argv[i], STR_SIZE-1);
+			table[count].value[STR_SIZE-1] = '\0';
+			count++;
+		}
+	}
+	return count;
+}
+
+/* append the table onto a file	*/
+void dump_str_pairs(str_pair *table, int size, char *file, char *prefix)
+{
+	int i; 
+	char str[STR_SIZE];
+	FILE *fp = fopen (file, "w");
+	if (!fp) {
+		sprintf (str,"error: %s could not be opened for writing\n", file);
+		fatal(str);
+	}
+	for(i=0; i < size; i++)
+		fprintf(fp, "%s%s\t%s\n", prefix, table[i].name, table[i].value);
+	fclose(fp);	
+}
+
+/* table lookup	for a name */
+int get_str_index(str_pair *table, int size, char *str)
+{
+	int i;
+
+	if (!table)
+		fatal((char*)"null pointer in get_str_index\n");
+
+	for (i = 0; i < size; i++) 
+		if (!strcasecmp(str, table[i].name)) 
+			return i;
+	return -1;
+}
+
+/* delete entry at 'at'	*/
+void delete_entry(str_pair *table, int size, int at)
+{
+	int i;
+	/* 
+	 * overwrite this entry using the next and 
+	 * shift all later entries once
+	 */
+	for (i=at+1; i < size; i++) {
+		strcpy(table[i-1].name, table[i].name);
+		strcpy(table[i-1].value, table[i].value);
+	}
+}
+
+/* 
+ * remove duplicate names in the table - the entries later 
+ * in the table are discarded. returns the new size of the
+ * table
+ */
+int str_pairs_remove_duplicates(str_pair *table, int size)
+{
+	int i, j;
+
+	for(i=0; i < size-1; i++)
+		for(j=i+1; j < size; j++)
+			if (!strcasecmp(table[i].name, table[j].name)) {
+				delete_entry(table, size, j);
+				size--;
+				j--;
+			}
+	return size;
+}
+
+/* debug	*/
+void print_str_pairs(str_pair *table, int size)
+{
+	int i;
+	fprintf(stdout, "printing string table\n");
+	for (i=0; i < size; i++)
+		fprintf(stdout, "%s\t%s\n", table[i].name, table[i].value);
+}
+
+/* 
+ * binary search a sorted double array 'arr' of size 'n'. if found,
+ * the 'loc' pointer has the address of 'ele' and the return 
+ * value is TRUE. otherwise, the return value is FALSE and 'loc' 
+ * points to the 'should have been' location
+ */
+int bsearch_double(double *arr, int n, double ele, double **loc)
+{
+	if(n < 0)
+		fatal((char*)"wrong index in binary search\n");
+
+	if(n == 0) {
+		*loc = arr;
+		return FALSE;
+	}
+
+	if(eq(arr[n/2], ele)) {
+		*loc = &arr[n/2];
+		return TRUE;
+	} else if (arr[n/2] < ele) {
+		return bsearch_double(&arr[n/2+1], (n-1)/2, ele, loc);
+	} else
+		return bsearch_double(arr, n/2, ele, loc);
+
+}
+
+/* 
+ * binary search and insert an element into a partially sorted
+ * double array if not already present. returns FALSE if present
+ */
+int bsearch_insert_double(double *arr, int n, double ele)
+{
+	double *loc;
+	int i;
+
+	/* element found - nothing more left to do	*/
+	if (bsearch_double(arr, n, ele, &loc))
+		return FALSE;
+	else {
+		for(i=n-1; i >= (loc-arr); i--)
+			arr[i+1] = arr[i];
+		arr[loc-arr] = ele;	
+	}
+	return TRUE;
+}
+
+/* 
+ * population count of an 8-bit integer - using pointers from 
+ * http://aggregate.org/MAGIC/
+ */
+unsigned int ones8(register unsigned char n)
+{
+	/* group the bits in two and compute the no. of 1's within a group
+	 * this works because 00->00, 01->01, 10->01, 11->10 or 
+	 * n = n - (n >> 1). the 0x55 masking prevents bits flowing across
+	 * group boundary
+	 */
+	n -= ((n >> 1) & 0x55);
+	/* add the 2-bit sums into nibbles */
+	n = ((n & 0x33) + ((n >> 2) & 0x33));
+	/* add both the nibbles */
+	n = ((n + (n >> 4)) & 0x0F);
+	return n;
+}
+
+/* 
+ * find the number of non-empty, non-comment lines
+ * in a file open for reading
+ */
+int count_significant_lines(FILE *fp)
+{
+    char str[LINE_SIZE], *ptr;
+    int count = 0;
+
+	fseek(fp, 0, SEEK_SET);
+	while(!feof(fp)) {
+		fgets(str, LINE_SIZE, fp);
+		if (feof(fp))
+			break;
+
+		/* ignore comments and empty lines	*/
+		ptr = strtok(str, " \r\t\n");
+		if (!ptr || ptr[0] == '#')
+			continue;
+
+		count++;
+	}
+	return count;
+}
+
diff -Naur temp/wire.c HotSpot/wire.c
--- temp/wire.c	2017-11-20 10:04:24.521682846 +0100
+++ HotSpot/wire.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,19 +0,0 @@
-#include "wire.h"
-#include "util.h"
-
-/* 
- * function for wire-length to wire-delay conversion.
- * WIRE_DELAY_G and WIRE_DELAY_I are delay values
- * per unit length. see wire.h for the details of the
- * wire model and the computation of these constants
- */
-double wire_length2delay(double length, int layer)
-{
-	if (layer == WIRE_GLOBAL)
-		return WIRE_DELAY_G * length;
-	else if (layer == WIRE_INTER)
-		return WIRE_DELAY_I * length;
-	else
-		fatal("unknown metal layer\n");
-	return 0.0;	
-}
diff -Naur temp/wire.cc HotSpot/wire.cc
--- temp/wire.cc	1970-01-01 01:00:00.000000000 +0100
+++ HotSpot/wire.cc	2017-11-20 09:59:35.316820635 +0100
@@ -0,0 +1,19 @@
+#include "wire.h"
+#include "util.h"
+
+/* 
+ * function for wire-length to wire-delay conversion.
+ * WIRE_DELAY_G and WIRE_DELAY_I are delay values
+ * per unit length. see wire.h for the details of the
+ * wire model and the computation of these constants
+ */
+double wire_length2delay(double length, int layer)
+{
+	if (layer == WIRE_GLOBAL)
+		return WIRE_DELAY_G * length;
+	else if (layer == WIRE_INTER)
+		return WIRE_DELAY_I * length;
+	else
+		fatal((char*)"unknown metal layer\n");
+	return 0.0;	
+}
